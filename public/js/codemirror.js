/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/js/codemirror.js":
/*!************************************!*\
  !*** ./resources/js/codemirror.js ***!
  \************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n// This is CodeMirror (https://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function () {\n  'use strict'; // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge && /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge && /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n  var ios = safari && (/Mobile\\/\\w+/.test(userAgent) || navigator.maxTouchPoints > 2);\n  var android = /Android/.test(userAgent); // This is woefully incomplete. Suggestions for alternative methods welcome.\n\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n\n  if (presto_version) {\n    presto_version = Number(presto_version[1]);\n  }\n\n  if (presto_version && presto_version >= 15) {\n    presto = false;\n    webkit = true;\n  } // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n\n\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || ie && ie_version >= 9;\n\n  function classTest(cls) {\n    return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\");\n  }\n\n  var rmClass = function rmClass(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count) {\n      e.removeChild(e.firstChild);\n    }\n\n    return e;\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e);\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n\n    if (className) {\n      e.className = className;\n    }\n\n    if (style) {\n      e.style.cssText = style;\n    }\n\n    if (typeof content == \"string\") {\n      e.appendChild(document.createTextNode(content));\n    } else if (content) {\n      for (var i = 0; i < content.length; ++i) {\n        e.appendChild(content[i]);\n      }\n    }\n\n    return e;\n  } // wrapper for elt, which removes the elt from the accessibility tree\n\n\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute(\"role\", \"presentation\");\n    return e;\n  }\n\n  var range;\n\n  if (document.createRange) {\n    range = function range(node, start, end, endNode) {\n      var r = document.createRange();\n      r.setEnd(endNode || node, end);\n      r.setStart(node, start);\n      return r;\n    };\n  } else {\n    range = function range(node, start, end) {\n      var r = document.body.createTextRange();\n\n      try {\n        r.moveToElementText(node.parentNode);\n      } catch (e) {\n        return r;\n      }\n\n      r.collapse(true);\n      r.moveEnd(\"character\", end);\n      r.moveStart(\"character\", start);\n      return r;\n    };\n  }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      {\n        child = child.parentNode;\n      }\n\n    if (parent.contains) {\n      return parent.contains(child);\n    }\n\n    do {\n      if (child.nodeType == 11) {\n        child = child.host;\n      }\n\n      if (child == parent) {\n        return true;\n      }\n    } while (child = child.parentNode);\n  }\n\n  function activeElt() {\n    // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n    // IE < 10 will throw when accessed while the page is loading or in an iframe.\n    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var activeElement;\n\n    try {\n      activeElement = document.activeElement;\n    } catch (e) {\n      activeElement = document.body || null;\n    }\n\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {\n      activeElement = activeElement.shadowRoot.activeElement;\n    }\n\n    return activeElement;\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n\n    if (!classTest(cls).test(current)) {\n      node.className += (current ? \" \" : \"\") + cls;\n    }\n  }\n\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n\n    for (var i = 0; i < as.length; i++) {\n      if (as[i] && !classTest(as[i]).test(b)) {\n        b += \" \" + as[i];\n      }\n    }\n\n    return b;\n  }\n\n  var selectInput = function selectInput(node) {\n    node.select();\n  };\n\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    {\n      selectInput = function selectInput(node) {\n        node.selectionStart = 0;\n        node.selectionEnd = node.value.length;\n      };\n    } else if (ie) // Suppress mysterious IE10 errors\n    {\n      selectInput = function selectInput(node) {\n        try {\n          node.select();\n        } catch (_e) {}\n      };\n    }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function () {\n      return f.apply(null, args);\n    };\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) {\n      target = {};\n    }\n\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop))) {\n        target[prop] = obj[prop];\n      }\n    }\n\n    return target;\n  } // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n\n\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n\n      if (end == -1) {\n        end = string.length;\n      }\n    }\n\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n\n      if (nextTab < 0 || nextTab >= end) {\n        return n + (end - i);\n      }\n\n      n += nextTab - i;\n      n += tabSize - n % tabSize;\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function Delayed() {\n    this.id = null;\n    this.f = null;\n    this.time = 0;\n    this.handler = bind(this.onTimeout, this);\n  };\n\n  Delayed.prototype.onTimeout = function (self) {\n    self.id = 0;\n\n    if (self.time <= +new Date()) {\n      self.f();\n    } else {\n      setTimeout(self.handler, self.time - +new Date());\n    }\n  };\n\n  Delayed.prototype.set = function (ms, f) {\n    this.f = f;\n    var time = +new Date() + ms;\n\n    if (!this.id || time < this.time) {\n      clearTimeout(this.id);\n      this.id = setTimeout(this.handler, ms);\n      this.time = time;\n    }\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i) {\n      if (array[i] == elt) {\n        return i;\n      }\n    }\n\n    return -1;\n  } // Number of pixels added to scroller and sizer to hide scrollbar\n\n\n  var scrollerGap = 50; // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n\n  var Pass = {\n    toString: function toString() {\n      return \"CodeMirror.Pass\";\n    }\n  }; // Reused option objects for setSelection & friends\n\n  var sel_dontScroll = {\n    scroll: false\n  },\n      sel_mouse = {\n    origin: \"*mouse\"\n  },\n      sel_move = {\n    origin: \"+move\"\n  }; // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n\n      if (nextTab == -1) {\n        nextTab = string.length;\n      }\n\n      var skipped = nextTab - pos;\n\n      if (nextTab == string.length || col + skipped >= goal) {\n        return pos + Math.min(skipped, goal - col);\n      }\n\n      col += nextTab - pos;\n      col += tabSize - col % tabSize;\n      pos = nextTab + 1;\n\n      if (col >= goal) {\n        return pos;\n      }\n    }\n  }\n\n  var spaceStrs = [\"\"];\n\n  function spaceStr(n) {\n    while (spaceStrs.length <= n) {\n      spaceStrs.push(lst(spaceStrs) + \" \");\n    }\n\n    return spaceStrs[n];\n  }\n\n  function lst(arr) {\n    return arr[arr.length - 1];\n  }\n\n  function map(array, f) {\n    var out = [];\n\n    for (var i = 0; i < array.length; i++) {\n      out[i] = f(array[i], i);\n    }\n\n    return out;\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0,\n        priority = score(value);\n\n    while (pos < array.length && score(array[pos]) <= priority) {\n      pos++;\n    }\n\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n\n    if (props) {\n      copyObj(props, inst);\n    }\n\n    return inst;\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\n  }\n\n  function isWordChar(ch, helper) {\n    if (!helper) {\n      return isWordCharBasic(ch);\n    }\n\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) {\n      return true;\n    }\n\n    return helper.test(ch);\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) {\n      if (obj.hasOwnProperty(n) && obj[n]) {\n        return false;\n      }\n    }\n\n    return true;\n  } // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n\n\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n\n  function isExtendingChar(ch) {\n    return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n  } // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n\n\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {\n      pos += dir;\n    }\n\n    return pos;\n  } // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n\n\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don't know\n    // whether `from` does.\n    var dir = from > to ? -1 : 1;\n\n    for (;;) {\n      if (from == to) {\n        return from;\n      }\n\n      var midF = (from + to) / 2,\n          mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n\n      if (mid == from) {\n        return pred(mid) ? from : to;\n      }\n\n      if (pred(mid)) {\n        to = mid;\n      } else {\n        from = mid + dir;\n      }\n    }\n  } // BIDI HELPERS\n\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) {\n      return f(from, to, \"ltr\", 0);\n    }\n\n    var found = false;\n\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n        found = true;\n      }\n    }\n\n    if (!found) {\n      f(from, to, \"ltr\");\n    }\n  }\n\n  var bidiOther = null;\n\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n\n    for (var i = 0; i < order.length; ++i) {\n      var cur = order[i];\n\n      if (cur.from < ch && cur.to > ch) {\n        return i;\n      }\n\n      if (cur.to == ch) {\n        if (cur.from != cur.to && sticky == \"before\") {\n          found = i;\n        } else {\n          bidiOther = i;\n        }\n      }\n\n      if (cur.from == ch) {\n        if (cur.from != cur.to && sticky != \"before\") {\n          found = i;\n        } else {\n          bidiOther = i;\n        }\n      }\n    }\n\n    return found != null ? found : bidiOther;\n  } // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n\n\n  var bidiOrdering = function () {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\"; // Character types for codepoints 0x600 to 0x6f9\n\n    var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n\n    function charType(code) {\n      if (code <= 0xf7) {\n        return lowTypes.charAt(code);\n      } else if (0x590 <= code && code <= 0x5f4) {\n        return \"R\";\n      } else if (0x600 <= code && code <= 0x6f9) {\n        return arabicTypes.charAt(code - 0x600);\n      } else if (0x6ee <= code && code <= 0x8ac) {\n        return \"r\";\n      } else if (0x2000 <= code && code <= 0x200b) {\n        return \"w\";\n      } else if (code == 0x200c) {\n        return \"b\";\n      } else {\n        return \"L\";\n      }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/,\n        isStrong = /[LRr]/,\n        countsAsLeft = /[Lb1n]/,\n        countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from;\n      this.to = to;\n    }\n\n    return function (str, direction) {\n      var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n      if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) {\n        return false;\n      }\n\n      var len = str.length,\n          types = [];\n\n      for (var i = 0; i < len; ++i) {\n        types.push(charType(str.charCodeAt(i)));\n      } // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n\n\n      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n        var type = types[i$1];\n\n        if (type == \"m\") {\n          types[i$1] = prev;\n        } else {\n          prev = type;\n        }\n      } // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n\n\n      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n        var type$1 = types[i$2];\n\n        if (type$1 == \"1\" && cur == \"r\") {\n          types[i$2] = \"n\";\n        } else if (isStrong.test(type$1)) {\n          cur = type$1;\n\n          if (type$1 == \"r\") {\n            types[i$2] = \"R\";\n          }\n        }\n      } // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n\n\n      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n        var type$2 = types[i$3];\n\n        if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3 + 1] == \"1\") {\n          types[i$3] = \"1\";\n        } else if (type$2 == \",\" && prev$1 == types[i$3 + 1] && (prev$1 == \"1\" || prev$1 == \"n\")) {\n          types[i$3] = prev$1;\n        }\n\n        prev$1 = type$2;\n      } // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n\n\n      for (var i$4 = 0; i$4 < len; ++i$4) {\n        var type$3 = types[i$4];\n\n        if (type$3 == \",\") {\n          types[i$4] = \"N\";\n        } else if (type$3 == \"%\") {\n          var end = void 0;\n\n          for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n\n          var replace = i$4 && types[i$4 - 1] == \"!\" || end < len && types[end] == \"1\" ? \"1\" : \"N\";\n\n          for (var j = i$4; j < end; ++j) {\n            types[j] = replace;\n          }\n\n          i$4 = end - 1;\n        }\n      } // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n\n\n      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n        var type$4 = types[i$5];\n\n        if (cur$1 == \"L\" && type$4 == \"1\") {\n          types[i$5] = \"L\";\n        } else if (isStrong.test(type$4)) {\n          cur$1 = type$4;\n        }\n      } // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n\n\n      for (var i$6 = 0; i$6 < len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = void 0;\n\n          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n\n          var before = (i$6 ? types[i$6 - 1] : outerType) == \"L\";\n          var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n          var replace$1 = before == after ? before ? \"L\" : \"R\" : outerType;\n\n          for (var j$1 = i$6; j$1 < end$1; ++j$1) {\n            types[j$1] = replace$1;\n          }\n\n          i$6 = end$1 - 1;\n        }\n      } // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n\n\n      var order = [],\n          m;\n\n      for (var i$7 = 0; i$7 < len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n\n          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7,\n              at = order.length,\n              isRTL = direction == \"rtl\" ? 1 : 0;\n\n          for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n\n          for (var j$2 = pos; j$2 < i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos < j$2) {\n                order.splice(at, 0, new BidiSpan(1, pos, j$2));\n                at += isRTL;\n              }\n\n              var nstart = j$2;\n\n              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              at += isRTL;\n              pos = j$2;\n            } else {\n              ++j$2;\n            }\n          }\n\n          if (pos < i$7) {\n            order.splice(at, 0, new BidiSpan(1, pos, i$7));\n          }\n        }\n      }\n\n      if (direction == \"ltr\") {\n        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n\n        if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == \"rtl\" ? order.reverse() : order;\n    };\n  }(); // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n\n\n  function getOrder(line, direction) {\n    var order = line.order;\n\n    if (order == null) {\n      order = line.order = bidiOrdering(line.text, direction);\n    }\n\n    return order;\n  } // EVENT HANDLING\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n\n  var noHandlers = [];\n\n  var on = function on(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers || (emitter._handlers = {});\n      map[type] = (map[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers && emitter._handlers[type] || noHandlers;\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent(\"on\" + type, f);\n    } else {\n      var map = emitter._handlers,\n          arr = map && map[type];\n\n      if (arr) {\n        var index = indexOf(arr, f);\n\n        if (index > -1) {\n          map[type] = arr.slice(0, index).concat(arr.slice(index + 1));\n        }\n      }\n    }\n  }\n\n  function signal(emitter, type\n  /*, values...*/\n  ) {\n    var handlers = getHandlers(emitter, type);\n\n    if (!handlers.length) {\n      return;\n    }\n\n    var args = Array.prototype.slice.call(arguments, 2);\n\n    for (var i = 0; i < handlers.length; ++i) {\n      handlers[i].apply(null, args);\n    }\n  } // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n\n\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\") {\n      e = {\n        type: e,\n        preventDefault: function preventDefault() {\n          this.defaultPrevented = true;\n        }\n      };\n    }\n\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n\n    if (!arr) {\n      return;\n    }\n\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n\n    for (var i = 0; i < arr.length; ++i) {\n      if (indexOf(set, arr[i]) == -1) {\n        set.push(arr[i]);\n      }\n    }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0;\n  } // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n\n\n  function eventMixin(ctor) {\n    ctor.prototype.on = function (type, f) {\n      on(this, type, f);\n    };\n\n    ctor.prototype.off = function (type, f) {\n      off(this, type, f);\n    };\n  } // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n    } else {\n      e.returnValue = false;\n    }\n  }\n\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else {\n      e.cancelBubble = true;\n    }\n  }\n\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\n  }\n\n  function e_stop(e) {\n    e_preventDefault(e);\n    e_stopPropagation(e);\n  }\n\n  function e_target(e) {\n    return e.target || e.srcElement;\n  }\n\n  function e_button(e) {\n    var b = e.which;\n\n    if (b == null) {\n      if (e.button & 1) {\n        b = 1;\n      } else if (e.button & 2) {\n        b = 3;\n      } else if (e.button & 4) {\n        b = 2;\n      }\n    }\n\n    if (mac && e.ctrlKey && b == 1) {\n      b = 3;\n    }\n\n    return b;\n  } // Detect drag-and-drop\n\n\n  var dragAndDrop = function () {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) {\n      return false;\n    }\n\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div;\n  }();\n\n  var zwspSupported;\n\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200B\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n\n      if (measure.firstChild.offsetHeight != 0) {\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\n      }\n    }\n\n    var node = zwspSupported ? elt(\"span\", \"\\u200B\") : elt(\"span\", \"\\xA0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node;\n  } // Feature-detect IE's crummy client rect reporting for bidi text\n\n\n  var badBidiRects;\n\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) {\n      return badBidiRects;\n    }\n\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062EA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n\n    if (!r0 || r0.left == r0.right) {\n      return false;\n    } // Safari returns null in some cases (#2780)\n\n\n    return badBidiRects = r1.right - r0.right < 3;\n  } // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n\n\n  var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0,\n        result = [],\n        l = string.length;\n\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n\n      if (nl == -1) {\n        nl = string.length;\n      }\n\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n\n    return result;\n  } : function (string) {\n    return string.split(/\\r\\n?|\\n/);\n  };\n  var hasSelection = window.getSelection ? function (te) {\n    try {\n      return te.selectionStart != te.selectionEnd;\n    } catch (e) {\n      return false;\n    }\n  } : function (te) {\n    var range;\n\n    try {\n      range = te.ownerDocument.selection.createRange();\n    } catch (e) {}\n\n    if (!range || range.parentElement() != te) {\n      return false;\n    }\n\n    return range.compareEndPoints(\"StartToEnd\", range) != 0;\n  };\n\n  var hasCopyEvent = function () {\n    var e = elt(\"div\");\n\n    if (\"oncopy\" in e) {\n      return true;\n    }\n\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\";\n  }();\n\n  var badZoomedRects = null;\n\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) {\n      return badZoomedRects;\n    }\n\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\n  } // Known modes, by name and by MIME\n\n\n  var modes = {},\n      mimeModes = {}; // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n\n  function defineMode(name, mode) {\n    if (arguments.length > 2) {\n      mode.dependencies = Array.prototype.slice.call(arguments, 2);\n    }\n\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  } // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n\n\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n\n      if (typeof found == \"string\") {\n        found = {\n          name: found\n        };\n      }\n\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\");\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\");\n    }\n\n    if (typeof spec == \"string\") {\n      return {\n        name: spec\n      };\n    } else {\n      return spec || {\n        name: \"null\"\n      };\n    }\n  } // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n\n\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n\n    if (!mfactory) {\n      return getMode(options, \"text/plain\");\n    }\n\n    var modeObj = mfactory(options, spec);\n\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) {\n          continue;\n        }\n\n        if (modeObj.hasOwnProperty(prop)) {\n          modeObj[\"_\" + prop] = modeObj[prop];\n        }\n\n        modeObj[prop] = exts[prop];\n      }\n    }\n\n    modeObj.name = spec.name;\n\n    if (spec.helperType) {\n      modeObj.helperType = spec.helperType;\n    }\n\n    if (spec.modeProps) {\n      for (var prop$1 in spec.modeProps) {\n        modeObj[prop$1] = spec.modeProps[prop$1];\n      }\n    }\n\n    return modeObj;\n  } // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n\n\n  var modeExtensions = {};\n\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) {\n      return state;\n    }\n\n    if (mode.copyState) {\n      return mode.copyState(state);\n    }\n\n    var nstate = {};\n\n    for (var n in state) {\n      var val = state[n];\n\n      if (val instanceof Array) {\n        val = val.concat([]);\n      }\n\n      nstate[n] = val;\n    }\n\n    return nstate;\n  } // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n\n\n  function innerMode(mode, state) {\n    var info;\n\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n\n      if (!info || info.mode == mode) {\n        break;\n      }\n\n      state = info.state;\n      mode = info.mode;\n    }\n\n    return info || {\n      mode: mode,\n      state: state\n    };\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true;\n  } // STRING STREAM\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n\n  var StringStream = function StringStream(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {\n    return this.pos >= this.string.length;\n  };\n\n  StringStream.prototype.sol = function () {\n    return this.pos == this.lineStart;\n  };\n\n  StringStream.prototype.peek = function () {\n    return this.string.charAt(this.pos) || undefined;\n  };\n\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length) {\n      return this.string.charAt(this.pos++);\n    }\n  };\n\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n\n    if (typeof match == \"string\") {\n      ok = ch == match;\n    } else {\n      ok = ch && (match.test ? match.test(ch) : match(ch));\n    }\n\n    if (ok) {\n      ++this.pos;\n      return ch;\n    }\n  };\n\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n\n    while (this.eat(match)) {}\n\n    return this.pos > start;\n  };\n\n  StringStream.prototype.eatSpace = function () {\n    var start = this.pos;\n\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) {\n      ++this.pos;\n    }\n\n    return this.pos > start;\n  };\n\n  StringStream.prototype.skipToEnd = function () {\n    this.pos = this.string.length;\n  };\n\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n\n    if (found > -1) {\n      this.pos = found;\n      return true;\n    }\n  };\n\n  StringStream.prototype.backUp = function (n) {\n    this.pos -= n;\n  };\n\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n  };\n\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\n  };\n\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function cased(str) {\n        return caseInsensitive ? str.toLowerCase() : str;\n      };\n\n      var substr = this.string.substr(this.pos, pattern.length);\n\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) {\n          this.pos += pattern.length;\n        }\n\n        return true;\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n\n      if (match && match.index > 0) {\n        return null;\n      }\n\n      if (match && consume !== false) {\n        this.pos += match[0].length;\n      }\n\n      return match;\n    }\n  };\n\n  StringStream.prototype.current = function () {\n    return this.string.slice(this.start, this.pos);\n  };\n\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n\n    try {\n      return inner();\n    } finally {\n      this.lineStart -= n;\n    }\n  };\n\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n);\n  };\n\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos);\n  }; // Find the line object corresponding to the given line number.\n\n\n  function getLine(doc, n) {\n    n -= doc.first;\n\n    if (n < 0 || n >= doc.size) {\n      throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\");\n    }\n\n    var chunk = doc;\n\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i],\n            sz = child.chunkSize();\n\n        if (n < sz) {\n          chunk = child;\n          break;\n        }\n\n        n -= sz;\n      }\n    }\n\n    return chunk.lines[n];\n  } // Get the part of a document between two positions, as an array of\n  // strings.\n\n\n  function getBetween(doc, start, end) {\n    var out = [],\n        n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n\n      if (n == end.line) {\n        text = text.slice(0, end.ch);\n      }\n\n      if (n == start.line) {\n        text = text.slice(start.ch);\n      }\n\n      out.push(text);\n      ++n;\n    });\n    return out;\n  } // Get the lines between from and to, as array of strings.\n\n\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) {\n      out.push(line.text);\n    }); // iter aborts when callback returns truthy value\n\n    return out;\n  } // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n\n\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n\n    if (diff) {\n      for (var n = line; n; n = n.parent) {\n        n.height += diff;\n      }\n    }\n  } // Given a line object, find its line number by walking up through\n  // its parent links.\n\n\n  function lineNo(line) {\n    if (line.parent == null) {\n      return null;\n    }\n\n    var cur = line.parent,\n        no = indexOf(cur.lines, line);\n\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) {\n          break;\n        }\n\n        no += chunk.children[i].chunkSize();\n      }\n    }\n\n    return no + cur.first;\n  } // Find the line at the given vertical position, using the height\n  // information in the document tree.\n\n\n  function _lineAtHeight(chunk, h) {\n    var n = chunk.first;\n\n    outer: do {\n      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1],\n            ch = child.height;\n\n        if (h < ch) {\n          chunk = child;\n          continue outer;\n        }\n\n        h -= ch;\n        n += child.chunkSize();\n      }\n\n      return n;\n    } while (!chunk.lines);\n\n    var i = 0;\n\n    for (; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i],\n          lh = line.height;\n\n      if (h < lh) {\n        break;\n      }\n\n      h -= lh;\n    }\n\n    return n + i;\n  }\n\n  function isLine(doc, l) {\n    return l >= doc.first && l < doc.first + doc.size;\n  }\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\n  } // A Pos instance represents a position within the text.\n\n\n  function Pos(line, ch, sticky) {\n    if (sticky === void 0) sticky = null;\n\n    if (!(this instanceof Pos)) {\n      return new Pos(line, ch, sticky);\n    }\n\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  } // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n\n\n  function cmp(a, b) {\n    return a.line - b.line || a.ch - b.ch;\n  }\n\n  function equalCursorPos(a, b) {\n    return a.sticky == b.sticky && cmp(a, b) == 0;\n  }\n\n  function copyPos(x) {\n    return Pos(x.line, x.ch);\n  }\n\n  function maxPos(a, b) {\n    return cmp(a, b) < 0 ? b : a;\n  }\n\n  function minPos(a, b) {\n    return cmp(a, b) < 0 ? a : b;\n  } // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n\n\n  function clipLine(doc, n) {\n    return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));\n  }\n\n  function _clipPos(doc, pos) {\n    if (pos.line < doc.first) {\n      return Pos(doc.first, 0);\n    }\n\n    var last = doc.first + doc.size - 1;\n\n    if (pos.line > last) {\n      return Pos(last, getLine(doc, last).text.length);\n    }\n\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\n  }\n\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n\n    if (ch == null || ch > linelen) {\n      return Pos(pos.line, linelen);\n    } else if (ch < 0) {\n      return Pos(pos.line, 0);\n    } else {\n      return pos;\n    }\n  }\n\n  function clipPosArray(doc, array) {\n    var out = [];\n\n    for (var i = 0; i < array.length; i++) {\n      out[i] = _clipPos(doc, array[i]);\n    }\n\n    return out;\n  }\n\n  var SavedContext = function SavedContext(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function Context(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n\n    if (line != null && n > this.maxLookAhead) {\n      this.maxLookAhead = n;\n    }\n\n    return line;\n  };\n\n  Context.prototype.baseToken = function (n) {\n    if (!this.baseTokens) {\n      return null;\n    }\n\n    while (this.baseTokens[this.baseTokenPos] <= n) {\n      this.baseTokenPos += 2;\n    }\n\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {\n      type: type && type.replace(/( |^)overlay .*/, \"\"),\n      size: this.baseTokens[this.baseTokenPos] - n\n    };\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n\n    if (this.maxLookAhead > 0) {\n      this.maxLookAhead--;\n    }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext) {\n      return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);\n    } else {\n      return new Context(doc, copyState(doc.mode, saved), line);\n    }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;\n  }; // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n\n\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen],\n        lineClasses = {}; // Compute the base array of styles\n\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) {\n      return st.push(end, style);\n    }, lineClasses, forceToEnd);\n    var state = context.state; // Run overlays, adjust style array.\n\n    var loop = function loop(o) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o],\n          i = 1,\n          at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i; // Ensure there's a token end at the current position, and that i points at it\n\n        while (at < end) {\n          var i_end = st[i];\n\n          if (i_end > end) {\n            st.splice(i, 1, end, st[i + 1], i_end);\n          }\n\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n\n        if (!style) {\n          return;\n        }\n\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start + 1];\n            st[start + 1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\n      loop(o);\n    }\n\n    return {\n      styles: st,\n      classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null\n    };\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n\n      if (resetState) {\n        context.state = resetState;\n      }\n\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n\n      if (result.classes) {\n        line.styleClasses = result.classes;\n      } else if (line.styleClasses) {\n        line.styleClasses = null;\n      }\n\n      if (updateFrontier === cm.doc.highlightFrontier) {\n        cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);\n      }\n    }\n\n    return line.styles;\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc,\n        display = cm.display;\n\n    if (!doc.mode.startState) {\n      return new Context(doc, true, n);\n    }\n\n    var start = findStartLine(cm, n, precise);\n    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n\n    if (precise) {\n      doc.modeFrontier = context.line;\n    }\n\n    return context;\n  } // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n\n\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n\n    if (text == \"\") {\n      callBlankLine(mode, context.state);\n    }\n\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) {\n      return mode.blankLine(state);\n    }\n\n    if (!mode.innerMode) {\n      return;\n    }\n\n    var inner = innerMode(mode, state);\n\n    if (inner.mode.blankLine) {\n      return inner.mode.blankLine(inner.state);\n    }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) {\n        inner[0] = innerMode(mode, state).mode;\n      }\n\n      var style = mode.token(stream, state);\n\n      if (stream.pos > stream.start) {\n        return style;\n      }\n    }\n\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\");\n  }\n\n  var Token = function Token(stream, type, state) {\n    this.start = stream.start;\n    this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  }; // Utility for getTokenAt and getLineTokens\n\n\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc,\n        mode = doc.mode,\n        style;\n    pos = _clipPos(doc, pos);\n    var line = getLine(doc, pos.line),\n        context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context),\n        tokens;\n\n    if (asArray) {\n      tokens = [];\n    }\n\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n\n      if (asArray) {\n        tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));\n      }\n    }\n\n    return asArray ? tokens : new Token(stream, style, context.state);\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) {\n      for (;;) {\n        var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n\n        if (!lineClass) {\n          break;\n        }\n\n        type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n        var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n\n        if (output[prop] == null) {\n          output[prop] = lineClass[2];\n        } else if (!new RegExp(\"(?:^|\\\\s)\" + lineClass[2] + \"(?:$|\\\\s)\").test(output[prop])) {\n          output[prop] += \" \" + lineClass[2];\n        }\n      }\n    }\n\n    return type;\n  } // Run the given mode's parser over a line, calling f for each token.\n\n\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n\n    if (flattenSpans == null) {\n      flattenSpans = cm.options.flattenSpans;\n    }\n\n    var curStart = 0,\n        curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context),\n        style;\n    var inner = cm.options.addModeClass && [null];\n\n    if (text == \"\") {\n      extractLineClasses(callBlankLine(mode, context.state), lineClasses);\n    }\n\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n\n        if (forceToEnd) {\n          processLine(cm, text, context, stream.pos);\n        }\n\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n\n      if (inner) {\n        var mName = inner[0].name;\n\n        if (mName) {\n          style = \"m-\" + (style ? mName + \" \" + style : mName);\n        }\n      }\n\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n\n        curStyle = style;\n      }\n\n      stream.start = stream.pos;\n    }\n\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  } // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n\n\n  function findStartLine(cm, n, precise) {\n    var minindent,\n        minline,\n        doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) {\n        return doc.first;\n      }\n\n      var line = getLine(doc, search - 1),\n          after = line.stateAfter;\n\n      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {\n        return search;\n      }\n\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n\n    return minline;\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n\n    if (doc.highlightFrontier < n - 10) {\n      return;\n    }\n\n    var start = doc.first;\n\n    for (var line = n - 1; line > start; line--) {\n      var saved = getLine(doc, line).stateAfter; // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 < 3 should cover this\n\n      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n        start = line + 1;\n        break;\n      }\n    }\n\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  } // Optimize some code when these features are not used.\n\n\n  var sawReadOnlySpans = false,\n      sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  } // TEXTMARKER SPANS\n\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from;\n    this.to = to;\n  } // Search an array of spans for a span matching the given marker.\n\n\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) {\n      for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n\n        if (span.marker == marker) {\n          return span;\n        }\n      }\n    }\n  } // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n\n\n  function removeMarkedSpan(spans, span) {\n    var r;\n\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i] != span) {\n        (r || (r = [])).push(spans[i]);\n      }\n    }\n\n    return r;\n  } // Add a span to a line.\n\n\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  } // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n\n\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n\n    if (old) {\n      for (var i = 0; i < old.length; ++i) {\n        var span = old[i],\n            marker = span.marker;\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n\n        if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n          var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\n          (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n        }\n      }\n    }\n\n    return nw;\n  }\n\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n\n    if (old) {\n      for (var i = 0; i < old.length; ++i) {\n        var span = old[i],\n            marker = span.marker;\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n\n        if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n          var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\n          (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));\n        }\n      }\n    }\n\n    return nw;\n  } // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n\n\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) {\n      return null;\n    }\n\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n\n    if (!oldFirst && !oldLast) {\n      return null;\n    }\n\n    var startCh = change.from.ch,\n        endCh = change.to.ch,\n        isInsert = cmp(change.from, change.to) == 0; // Get the spans that 'stick out' on both sides\n\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert); // Next, merge those two ends\n\n    var sameLine = change.text.length == 1,\n        offset = lst(change.text).length + (sameLine ? startCh : 0);\n\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n\n          if (!found) {\n            span.to = startCh;\n          } else if (sameLine) {\n            span.to = found.to == null ? null : found.to + offset;\n          }\n        }\n      }\n    }\n\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 < last.length; ++i$1) {\n        var span$1 = last[i$1];\n\n        if (span$1.to != null) {\n          span$1.to += offset;\n        }\n\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n\n          if (!found$1) {\n            span$1.from = offset;\n\n            if (sameLine) {\n              (first || (first = [])).push(span$1);\n            }\n          }\n        } else {\n          span$1.from += offset;\n\n          if (sameLine) {\n            (first || (first = [])).push(span$1);\n          }\n        }\n      }\n    } // Make sure we didn't create any zero-length spans\n\n\n    if (first) {\n      first = clearEmptySpans(first);\n    }\n\n    if (last && last != first) {\n      last = clearEmptySpans(last);\n    }\n\n    var newMarkers = [first];\n\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2,\n          gapMarkers;\n\n      if (gap > 0 && first) {\n        for (var i$2 = 0; i$2 < first.length; ++i$2) {\n          if (first[i$2].to == null) {\n            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));\n          }\n        }\n      }\n\n      for (var i$3 = 0; i$3 < gap; ++i$3) {\n        newMarkers.push(gapMarkers);\n      }\n\n      newMarkers.push(last);\n    }\n\n    return newMarkers;\n  } // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n\n\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {\n        spans.splice(i--, 1);\n      }\n    }\n\n    if (!spans.length) {\n      return null;\n    }\n\n    return spans;\n  } // Used to 'clip' out readOnly ranges when making a change.\n\n\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) {\n        for (var i = 0; i < line.markedSpans.length; ++i) {\n          var mark = line.markedSpans[i].marker;\n\n          if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {\n            (markers || (markers = [])).push(mark);\n          }\n        }\n      }\n    });\n\n    if (!markers) {\n      return null;\n    }\n\n    var parts = [{\n      from: from,\n      to: to\n    }];\n\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i],\n          m = mk.find(0);\n\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) {\n          continue;\n        }\n\n        var newParts = [j, 1],\n            dfrom = cmp(p.from, m.from),\n            dto = cmp(p.to, m.to);\n\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {\n          newParts.push({\n            from: p.from,\n            to: m.from\n          });\n        }\n\n        if (dto > 0 || !mk.inclusiveRight && !dto) {\n          newParts.push({\n            from: m.to,\n            to: p.to\n          });\n        }\n\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n\n    return parts;\n  } // Connect or disconnect spans from a line.\n\n\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n\n    if (!spans) {\n      return;\n    }\n\n    for (var i = 0; i < spans.length; ++i) {\n      spans[i].marker.detachLine(line);\n    }\n\n    line.markedSpans = null;\n  }\n\n  function attachMarkedSpans(line, spans) {\n    if (!spans) {\n      return;\n    }\n\n    for (var i = 0; i < spans.length; ++i) {\n      spans[i].marker.attachLine(line);\n    }\n\n    line.markedSpans = spans;\n  } // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n\n\n  function extraLeft(marker) {\n    return marker.inclusiveLeft ? -1 : 0;\n  }\n\n  function extraRight(marker) {\n    return marker.inclusiveRight ? 1 : 0;\n  } // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n\n\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n\n    if (lenDiff != 0) {\n      return lenDiff;\n    }\n\n    var aPos = a.find(),\n        bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n\n    if (fromCmp) {\n      return -fromCmp;\n    }\n\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n\n    if (toCmp) {\n      return toCmp;\n    }\n\n    return b.id - a.id;\n  } // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n\n\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans,\n        found;\n\n    if (sps) {\n      for (var sp = void 0, i = 0; i < sps.length; ++i) {\n        sp = sps[i];\n\n        if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n          found = sp.marker;\n        }\n      }\n    }\n\n    return found;\n  }\n\n  function collapsedSpanAtStart(line) {\n    return collapsedSpanAtSide(line, true);\n  }\n\n  function collapsedSpanAtEnd(line) {\n    return collapsedSpanAtSide(line, false);\n  }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans,\n        found;\n\n    if (sps) {\n      for (var i = 0; i < sps.length; ++i) {\n        var sp = sps[i];\n\n        if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {\n          found = sp.marker;\n        }\n      }\n    }\n\n    return found;\n  } // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n\n\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\n    var line = getLine(doc, lineNo);\n    var sps = sawCollapsedSpans && line.markedSpans;\n\n    if (sps) {\n      for (var i = 0; i < sps.length; ++i) {\n        var sp = sps[i];\n\n        if (!sp.marker.collapsed) {\n          continue;\n        }\n\n        var found = sp.marker.find(0);\n        var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n        var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n\n        if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {\n          continue;\n        }\n\n        if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {\n          return true;\n        }\n      }\n    }\n  } // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n\n\n  function visualLine(line) {\n    var merged;\n\n    while (merged = collapsedSpanAtStart(line)) {\n      line = merged.find(-1, true).line;\n    }\n\n    return line;\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n    }\n\n    return line;\n  } // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n\n\n  function visualLineContinued(line) {\n    var merged, lines;\n\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n      (lines || (lines = [])).push(line);\n    }\n\n    return lines;\n  } // Get the line number of the start of the visual line that the\n  // given line number is part of.\n\n\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN),\n        vis = visualLine(line);\n\n    if (line == vis) {\n      return lineN;\n    }\n\n    return lineNo(vis);\n  } // Get the line number of the start of the next visual line after\n  // the given line.\n\n\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) {\n      return lineN;\n    }\n\n    var line = getLine(doc, lineN),\n        merged;\n\n    if (!lineIsHidden(doc, line)) {\n      return lineN;\n    }\n\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line;\n    }\n\n    return lineNo(line) + 1;\n  } // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n\n\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n\n    if (sps) {\n      for (var sp = void 0, i = 0; i < sps.length; ++i) {\n        sp = sps[i];\n\n        if (!sp.marker.collapsed) {\n          continue;\n        }\n\n        if (sp.from == null) {\n          return true;\n        }\n\n        if (sp.marker.widgetNode) {\n          continue;\n        }\n\n        if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {\n          return true;\n        }\n      }\n    }\n  }\n\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\n    }\n\n    if (span.marker.inclusiveRight && span.to == line.text.length) {\n      return true;\n    }\n\n    for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {\n        return true;\n      }\n    }\n  } // Find the height above the given line.\n\n\n  function _heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n    var h = 0,\n        chunk = lineObj.parent;\n\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n\n      if (line == lineObj) {\n        break;\n      } else {\n        h += line.height;\n      }\n    }\n\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n\n        if (cur == chunk) {\n          break;\n        } else {\n          h += cur.height;\n        }\n      }\n    }\n\n    return h;\n  } // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n\n\n  function lineLength(line) {\n    if (line.height == 0) {\n      return 0;\n    }\n\n    var len = line.text.length,\n        merged,\n        cur = line;\n\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n\n    cur = line;\n\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n\n    return len;\n  } // Find the longest line in the document.\n\n\n  function findMaxLine(cm) {\n    var d = cm.display,\n        doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  } // LINE DATA STRUCTURE\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n\n\n  var Line = function Line(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () {\n    return lineNo(this);\n  };\n\n  eventMixin(Line); // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n\n    if (line.stateAfter) {\n      line.stateAfter = null;\n    }\n\n    if (line.styles) {\n      line.styles = null;\n    }\n\n    if (line.order != null) {\n      line.order = null;\n    }\n\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n\n    if (estHeight != line.height) {\n      updateLineHeight(line, estHeight);\n    }\n  } // Detach a line from the document tree and its markers.\n\n\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  } // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n\n\n  var styleToClassCache = {},\n      styleToClassCacheWithMode = {};\n\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) {\n      return null;\n    }\n\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] || (cache[style] = style.replace(/\\S+/g, \"cm-$&\"));\n  } // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n\n\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {\n      pre: eltP(\"pre\", [content], \"CodeMirror-line\"),\n      content: content,\n      col: 0,\n      pos: 0,\n      cm: cm,\n      trailingSpace: false,\n      splitSpaces: cm.getOption(\"lineWrapping\")\n    };\n    lineView.measure = {}; // Iterate over the logical lines that make up this visual line.\n\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line,\n          order = void 0;\n      builder.pos = 0;\n      builder.addToken = buildToken; // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\n      }\n\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass) {\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\");\n        }\n\n        if (line.styleClasses.textClass) {\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\");\n        }\n      } // Ensure at least a single node is present, for measuring.\n\n\n      if (builder.map.length == 0) {\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\n      } // Store the map and a cache object for the current logical line\n\n\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    } // See issue #2901\n\n\n    if (webkit) {\n      var last = builder.content.lastChild;\n\n      if (/\\bcm-tab\\b/.test(last.className) || last.querySelector && last.querySelector(\".cm-tab\")) {\n        builder.content.className = \"cm-tab-wrap-hack\";\n      }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n\n    if (builder.pre.className) {\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\");\n    }\n\n    return builder;\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token;\n  } // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n\n\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) {\n      return;\n    }\n\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars,\n        mustWrap = false;\n    var content;\n\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n\n      if (ie && ie_version < 9) {\n        mustWrap = true;\n      }\n\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n\n          if (ie && ie_version < 9) {\n            content.appendChild(elt(\"span\", [txt]));\n          } else {\n            content.appendChild(txt);\n          }\n\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n\n        if (!m) {\n          break;\n        }\n\n        pos += skipped + 1;\n        var txt$1 = void 0;\n\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize,\n              tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt$1.setAttribute(\"role\", \"presentation\");\n          txt$1.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240D\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute(\"cm-text\", m[0]);\n\n          if (ie && ie_version < 9) {\n            content.appendChild(elt(\"span\", [txt$1]));\n          } else {\n            content.appendChild(txt$1);\n          }\n\n          builder.col += 1;\n        }\n\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n\n    if (style || startStyle || endStyle || mustWrap || css || attributes) {\n      var fullStyle = style || \"\";\n\n      if (startStyle) {\n        fullStyle += startStyle;\n      }\n\n      if (endStyle) {\n        fullStyle += endStyle;\n      }\n\n      var token = elt(\"span\", [content], fullStyle, css);\n\n      if (attributes) {\n        for (var attr in attributes) {\n          if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\") {\n            token.setAttribute(attr, attributes[attr]);\n          }\n        }\n      }\n\n      return builder.content.appendChild(token);\n    }\n\n    builder.content.appendChild(content);\n  } // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n\n\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) {\n      return text;\n    }\n\n    var spaceBefore = trailingBefore,\n        result = \"\";\n\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i);\n\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32)) {\n        ch = \"\\xA0\";\n      }\n\n      result += ch;\n      spaceBefore = ch == \" \";\n    }\n\n    return result;\n  } // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n\n\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos,\n          end = start + text.length;\n\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = void 0;\n\n        for (var i = 0; i < order.length; i++) {\n          part = order[i];\n\n          if (part.to > start && part.from <= start) {\n            break;\n          }\n        }\n\n        if (part.to >= end) {\n          return inner(builder, text, style, startStyle, endStyle, css, attributes);\n        }\n\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    };\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n\n    if (widget) {\n      builder.map.push(builder.pos, builder.pos + size, widget);\n    }\n\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget) {\n        widget = builder.content.appendChild(document.createElement(\"span\"));\n      }\n\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n\n    builder.pos += size;\n    builder.trailingSpace = false;\n  } // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n\n\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans,\n        allText = line.text,\n        at = 0;\n\n    if (!spans) {\n      for (var i$1 = 1; i$1 < styles.length; i$1 += 2) {\n        builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options));\n      }\n\n      return;\n    }\n\n    var len = allText.length,\n        pos = 0,\n        i = 1,\n        text = \"\",\n        style,\n        css;\n    var nextChange = 0,\n        spanStyle,\n        spanEndStyle,\n        spanStartStyle,\n        collapsed,\n        attributes;\n\n    for (;;) {\n      if (nextChange == pos) {\n        // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n        attributes = null;\n        collapsed = null;\n        nextChange = Infinity;\n        var foundBookmarks = [],\n            endStyles = void 0;\n\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j],\n              m = sp.marker;\n\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n\n            if (m.className) {\n              spanStyle += \" \" + m.className;\n            }\n\n            if (m.css) {\n              css = (css ? css + \";\" : \"\") + m.css;\n            }\n\n            if (m.startStyle && sp.from == pos) {\n              spanStartStyle += \" \" + m.startStyle;\n            }\n\n            if (m.endStyle && sp.to == nextChange) {\n              (endStyles || (endStyles = [])).push(m.endStyle, sp.to);\n            } // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n\n\n            if (m.title) {\n              (attributes || (attributes = {})).title = m.title;\n            }\n\n            if (m.attributes) {\n              for (var attr in m.attributes) {\n                (attributes || (attributes = {}))[attr] = m.attributes[attr];\n              }\n            }\n\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {\n              collapsed = sp;\n            }\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n\n        if (endStyles) {\n          for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {\n            if (endStyles[j$1 + 1] == nextChange) {\n              spanEndStyle += \" \" + endStyles[j$1];\n            }\n          }\n        }\n\n        if (!collapsed || collapsed.from == pos) {\n          for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {\n            buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);\n          }\n        }\n\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);\n\n          if (collapsed.to == null) {\n            return;\n          }\n\n          if (collapsed.to == pos) {\n            collapsed = false;\n          }\n        }\n      }\n\n      if (pos >= len) {\n        break;\n      }\n\n      var upto = Math.min(len, nextChange);\n\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n          }\n\n          if (end >= upto) {\n            text = text.slice(upto - pos);\n            pos = upto;\n            break;\n          }\n\n          pos = end;\n          spanStartStyle = \"\";\n        }\n\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  } // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n\n\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line; // Continuing lines, if any\n\n    this.rest = visualLineContinued(line); // Number of logical lines in this visual line\n\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  } // Create a range of LineView objects for the given lines.\n\n\n  function buildViewArray(cm, from, to) {\n    var array = [],\n        nextPos;\n\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n\n    return array;\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks,\n        i = 0;\n\n    do {\n      for (; i < callbacks.length; i++) {\n        callbacks[i].call(null);\n      }\n\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n\n        if (op.cursorActivityHandlers) {\n          while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {\n            op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);\n          }\n        }\n      }\n    } while (i < callbacks.length);\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n\n    if (!group) {\n      return;\n    }\n\n    try {\n      fireCallbacksForOps(group);\n    } finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null; // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n\n  function signalLater(emitter, type\n  /*, values...*/\n  ) {\n    var arr = getHandlers(emitter, type);\n\n    if (!arr.length) {\n      return;\n    }\n\n    var args = Array.prototype.slice.call(arguments, 2),\n        list;\n\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n\n    var loop = function loop(i) {\n      list.push(function () {\n        return arr[i].apply(null, args);\n      });\n    };\n\n    for (var i = 0; i < arr.length; ++i) {\n      loop(i);\n    }\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n\n    for (var i = 0; i < delayed.length; ++i) {\n      delayed[i]();\n    }\n  } // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n\n\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n\n      if (type == \"text\") {\n        updateLineText(cm, lineView);\n      } else if (type == \"gutter\") {\n        updateLineGutter(cm, lineView, lineN, dims);\n      } else if (type == \"class\") {\n        updateLineClasses(cm, lineView);\n      } else if (type == \"widget\") {\n        updateLineWidgets(cm, lineView, dims);\n      }\n    }\n\n    lineView.changes = null;\n  } // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n\n\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n\n      if (lineView.text.parentNode) {\n        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\n      }\n\n      lineView.node.appendChild(lineView.text);\n\n      if (ie && ie_version < 8) {\n        lineView.node.style.zIndex = 2;\n      }\n    }\n\n    return lineView.node;\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n\n    if (cls) {\n      cls += \" CodeMirror-linebackground\";\n    }\n\n    if (lineView.background) {\n      if (cls) {\n        lineView.background.className = cls;\n      } else {\n        lineView.background.parentNode.removeChild(lineView.background);\n        lineView.background = null;\n      }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  } // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n\n\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built;\n    }\n\n    return buildLineContent(cm, lineView);\n  } // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n\n\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n\n    if (lineView.text == lineView.node) {\n      lineView.node = built.pre;\n    }\n\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n\n    if (lineView.line.wrapClass) {\n      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\n    } else if (lineView.node != lineView.text) {\n      lineView.node.className = \"\";\n    }\n\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass, \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + dims.gutterTotalWidth + \"px\");\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n\n    var markers = lineView.line.gutterMarkers;\n\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", \"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\");\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n\n      if (lineView.line.gutterClass) {\n        gutterWrap.className += \" \" + lineView.line.gutterClass;\n      }\n\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"])) {\n        lineView.lineNumber = gutterWrap.appendChild(elt(\"div\", lineNumberFor(cm.options, lineN), \"CodeMirror-linenumber CodeMirror-gutter-elt\", \"left: \" + dims.gutterLeft[\"CodeMirror-linenumbers\"] + \"px; width: \" + cm.display.lineNumInnerWidth + \"px\"));\n      }\n\n      if (markers) {\n        for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {\n          var id = cm.display.gutterSpecs[k].className,\n              found = markers.hasOwnProperty(id) && markers[id];\n\n          if (found) {\n            gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\", \"left: \" + dims.gutterLeft[id] + \"px; width: \" + dims.gutterWidth[id] + \"px\"));\n          }\n        }\n      }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) {\n      lineView.alignable = null;\n    }\n\n    var isWidget = classTest(\"CodeMirror-linewidget\");\n\n    for (var node = lineView.node.firstChild, next = void 0; node; node = next) {\n      next = node.nextSibling;\n\n      if (isWidget.test(node.className)) {\n        lineView.node.removeChild(node);\n      }\n    }\n\n    insertLineWidgets(cm, lineView, dims);\n  } // Build a line's DOM representation from scratch\n\n\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n\n    if (built.bgClass) {\n      lineView.bgClass = built.bgClass;\n    }\n\n    if (built.textClass) {\n      lineView.textClass = built.textClass;\n    }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node;\n  } // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n\n\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n\n    if (lineView.rest) {\n      for (var i = 0; i < lineView.rest.length; i++) {\n        insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false);\n      }\n    }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) {\n      return;\n    }\n\n    var wrap = ensureLineWrapped(lineView);\n\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i],\n          node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\" + (widget.className ? \" \" + widget.className : \"\"));\n\n      if (!widget.handleMouseEvents) {\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n      }\n\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n\n      if (allowAbove && widget.above) {\n        wrap.insertBefore(node, lineView.gutter || lineView.text);\n      } else {\n        wrap.appendChild(node);\n      }\n\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n      (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n\n      node.style.width = width + \"px\";\n    }\n\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n\n      if (!widget.noHScroll) {\n        node.style.marginLeft = -dims.gutterTotalWidth + \"px\";\n      }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) {\n      return widget.height;\n    }\n\n    var cm = widget.doc.cm;\n\n    if (!cm) {\n      return 0;\n    }\n\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n\n      if (widget.coverGutter) {\n        parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\";\n      }\n\n      if (widget.noHScroll) {\n        parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\";\n      }\n\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n\n    return widget.height = widget.node.parentNode.offsetHeight;\n  } // Return true when the given mouse event happened in a widget\n\n\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\" || n.parentNode == display.sizer && n != display.mover) {\n        return true;\n      }\n    }\n  } // POSITION MEASUREMENT\n\n\n  function paddingTop(display) {\n    return display.lineSpace.offsetTop;\n  }\n\n  function paddingVert(display) {\n    return display.mover.offsetHeight - display.lineSpace.offsetHeight;\n  }\n\n  function paddingH(display) {\n    if (display.cachedPaddingH) {\n      return display.cachedPaddingH;\n    }\n\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\", \"CodeMirror-line-like\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {\n      left: parseInt(style.paddingLeft),\n      right: parseInt(style.paddingRight)\n    };\n\n    if (!isNaN(data.left) && !isNaN(data.right)) {\n      display.cachedPaddingH = data;\n    }\n\n    return data;\n  }\n\n  function scrollGap(cm) {\n    return scrollerGap - cm.display.nativeBarWidth;\n  }\n\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;\n  }\n\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;\n  } // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n\n\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i],\n              next = rects[i + 1];\n\n          if (Math.abs(cur.bottom - next.bottom) > 2) {\n            heights.push((cur.bottom + next.top) / 2 - rect.top);\n          }\n        }\n      }\n\n      heights.push(rect.bottom - rect.top);\n    }\n  } // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n\n\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line) {\n      return {\n        map: lineView.measure.map,\n        cache: lineView.measure.cache\n      };\n    }\n\n    for (var i = 0; i < lineView.rest.length; i++) {\n      if (lineView.rest[i] == line) {\n        return {\n          map: lineView.measure.maps[i],\n          cache: lineView.measure.caches[i]\n        };\n      }\n    }\n\n    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++) {\n      if (lineNo(lineView.rest[i$1]) > lineN) {\n        return {\n          map: lineView.measure.maps[i$1],\n          cache: lineView.measure.caches[i$1],\n          before: true\n        };\n      }\n    }\n  } // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n\n\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view;\n  } // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n\n\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\n  } // Find a line view that corresponds to the given line number.\n\n\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {\n      return cm.display.view[findViewIndex(cm, lineN)];\n    }\n\n    var ext = cm.display.externalMeasured;\n\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {\n      return ext;\n    }\n  } // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n\n\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n\n    if (!view) {\n      view = updateExternalMeasurement(cm, line);\n    }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line,\n      view: view,\n      rect: null,\n      map: info.map,\n      cache: info.cache,\n      before: info.before,\n      hasHeights: false\n    };\n  } // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n\n\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) {\n      ch = -1;\n    }\n\n    var key = ch + (bias || \"\"),\n        found;\n\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect) {\n        prepared.rect = prepared.view.text.getBoundingClientRect();\n      }\n\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n\n      found = measureCharInner(cm, prepared, ch, bias);\n\n      if (!found.bogus) {\n        prepared.cache[key] = found;\n      }\n    }\n\n    return {\n      left: found.left,\n      right: found.right,\n      top: varHeight ? found.rtop : found.top,\n      bottom: varHeight ? found.rbottom : found.bottom\n    };\n  }\n\n  var nullRect = {\n    left: 0,\n    right: 0,\n    top: 0,\n    bottom: 0\n  };\n\n  function nodeAndOffsetInLineMap(map, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd; // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n\n    for (var i = 0; i < map.length; i += 3) {\n      mStart = map[i];\n      mEnd = map[i + 1];\n\n      if (ch < mStart) {\n        start = 0;\n        end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n\n        if (ch >= mEnd) {\n          collapse = \"right\";\n        }\n      }\n\n      if (start != null) {\n        node = map[i + 2];\n\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\")) {\n          collapse = bias;\n        }\n\n        if (bias == \"left\" && start == 0) {\n          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\n            node = map[(i -= 3) + 2];\n            collapse = \"left\";\n          }\n        }\n\n        if (bias == \"right\" && start == mEnd - mStart) {\n          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\n            node = map[(i += 3) + 2];\n            collapse = \"right\";\n          }\n        }\n\n        break;\n      }\n    }\n\n    return {\n      node: node,\n      start: start,\n      end: end,\n      collapse: collapse,\n      coverStart: mStart,\n      coverEnd: mEnd\n    };\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n\n    if (bias == \"left\") {\n      for (var i = 0; i < rects.length; i++) {\n        if ((rect = rects[i]).left != rect.right) {\n          break;\n        }\n      }\n    } else {\n      for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n        if ((rect = rects[i$1]).left != rect.right) {\n          break;\n        }\n      }\n    }\n\n    return rect;\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node,\n        start = place.start,\n        end = place.end,\n        collapse = place.collapse;\n    var rect;\n\n    if (node.nodeType == 3) {\n      // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 < 4; i$1++) {\n        // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {\n          --start;\n        }\n\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {\n          ++end;\n        }\n\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {\n          rect = node.parentNode.getBoundingClientRect();\n        } else {\n          rect = getUsefulRect(range(node, start, end).getClientRects(), bias);\n        }\n\n        if (rect.left || rect.right || start == 0) {\n          break;\n        }\n\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n\n      if (ie && ie_version < 11) {\n        rect = maybeUpdateRectForZooming(cm.display.measure, rect);\n      }\n    } else {\n      // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) {\n        collapse = bias = \"right\";\n      }\n\n      var rects;\n\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {\n        rect = rects[bias == \"right\" ? rects.length - 1 : 0];\n      } else {\n        rect = node.getBoundingClientRect();\n      }\n    }\n\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n\n      if (rSpan) {\n        rect = {\n          left: rSpan.left,\n          right: rSpan.left + charWidth(cm.display),\n          top: rSpan.top,\n          bottom: rSpan.bottom\n        };\n      } else {\n        rect = nullRect;\n      }\n    }\n\n    var rtop = rect.top - prepared.rect.top,\n        rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n\n    for (; i < heights.length - 1; i++) {\n      if (mid < heights[i]) {\n        break;\n      }\n    }\n\n    var top = i ? heights[i - 1] : 0,\n        bot = heights[i];\n    var result = {\n      left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n      right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n      top: top,\n      bottom: bot\n    };\n\n    if (!rect.left && !rect.right) {\n      result.bogus = true;\n    }\n\n    if (!cm.options.singleCursorHeightPerLine) {\n      result.rtop = rtop;\n      result.rbottom = rbot;\n    }\n\n    return result;\n  } // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n\n\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {\n      return rect;\n    }\n\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {\n      left: rect.left * scaleX,\n      right: rect.right * scaleX,\n      top: rect.top * scaleY,\n      bottom: rect.bottom * scaleY\n    };\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n\n      if (lineView.rest) {\n        for (var i = 0; i < lineView.rest.length; i++) {\n          lineView.measure.caches[i] = {};\n        }\n      }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n\n    for (var i = 0; i < cm.display.view.length; i++) {\n      clearLineMeasurementCacheFor(cm.display.view[i]);\n    }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n\n    if (!cm.options.lineWrapping) {\n      cm.display.maxLineChanged = true;\n    }\n\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome && android) {\n      return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));\n    }\n\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft;\n  }\n\n  function pageScrollY() {\n    if (chrome && android) {\n      return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));\n    }\n\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop;\n  }\n\n  function widgetTopHeight(lineObj) {\n    var height = 0;\n\n    if (lineObj.widgets) {\n      for (var i = 0; i < lineObj.widgets.length; ++i) {\n        if (lineObj.widgets[i].above) {\n          height += widgetHeight(lineObj.widgets[i]);\n        }\n      }\n    }\n\n    return height;\n  } // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n  // or \"page\".\n\n\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height;\n      rect.bottom += height;\n    }\n\n    if (context == \"line\") {\n      return rect;\n    }\n\n    if (!context) {\n      context = \"local\";\n    }\n\n    var yOff = _heightAtLine(lineObj);\n\n    if (context == \"local\") {\n      yOff += paddingTop(cm.display);\n    } else {\n      yOff -= cm.display.viewOffset;\n    }\n\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff;\n      rect.right += xOff;\n    }\n\n    rect.top += yOff;\n    rect.bottom += yOff;\n    return rect;\n  } // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n\n\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") {\n      return coords;\n    }\n\n    var left = coords.left,\n        top = coords.top; // First move into \"page\" coordinate system\n\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {\n      left: left - lineSpaceBox.left,\n      top: top - lineSpaceBox.top\n    };\n  }\n\n  function _charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) {\n      lineObj = getLine(cm.doc, pos.line);\n    }\n\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\n  } // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n\n\n  function _cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n\n    if (!preparedMeasure) {\n      preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    }\n\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n\n      if (right) {\n        m.left = m.right;\n      } else {\n        m.right = m.left;\n      }\n\n      return intoCoordSystem(cm, lineObj, m, context);\n    }\n\n    var order = getOrder(lineObj, cm.doc.direction),\n        ch = pos.ch,\n        sticky = pos.sticky;\n\n    if (ch >= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = \"before\";\n    } else if (ch <= 0) {\n      ch = 0;\n      sticky = \"after\";\n    }\n\n    if (!order) {\n      return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\");\n    }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos],\n          right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert);\n    }\n\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == \"before\");\n\n    if (other != null) {\n      val.other = getBidi(ch, other, sticky != \"before\");\n    }\n\n    return val;\n  } // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n\n\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = _clipPos(cm.doc, pos);\n\n    if (!cm.options.lineWrapping) {\n      left = charWidth(cm.display) * pos.ch;\n    }\n\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = _heightAtLine(lineObj) + paddingTop(cm.display);\n    return {\n      left: left,\n      right: left,\n      top: top,\n      bottom: top + lineObj.height\n    };\n  } // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n\n\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n\n    if (outside) {\n      pos.outside = outside;\n    }\n\n    return pos;\n  } // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n\n\n  function _coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n\n    if (y < 0) {\n      return PosWithInfo(doc.first, 0, null, -1, -1);\n    }\n\n    var lineN = _lineAtHeight(doc, y),\n        last = doc.first + doc.size - 1;\n\n    if (lineN > last) {\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);\n    }\n\n    if (x < 0) {\n      x = 0;\n    }\n\n    var lineObj = getLine(doc, lineN);\n\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));\n\n      if (!collapsed) {\n        return found;\n      }\n\n      var rangeEnd = collapsed.find(1);\n\n      if (rangeEnd.line == lineN) {\n        return rangeEnd;\n      }\n\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) {\n      return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;\n    }, end, 0);\n    end = findFirst(function (ch) {\n      return measureCharPrepared(cm, preparedMeasure, ch).top > y;\n    }, begin, end);\n    return {\n      begin: begin,\n      end: end\n    };\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) {\n      preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    }\n\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);\n  } // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n\n\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\n    // Move y into line-local coordinate space\n    y -= _heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj); // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n\n    var widgetHeight = widgetTopHeight(lineObj);\n    var begin = 0,\n        end = lineObj.text.length,\n        ltr = true;\n    var order = getOrder(lineObj, cm.doc.direction); // If the line isn't plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo, preparedMeasure, order, x, y);\n      ltr = part.level != 1; // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part's range\n\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    } // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n\n\n    var chAround = null,\n        boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight;\n      box.bottom += widgetHeight;\n\n      if (!boxIsAfter(box, x, y, false)) {\n        return false;\n      }\n\n      if (box.top <= y && box.left <= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n\n      return true;\n    }, begin, end);\n    var baseX,\n        sticky,\n        outside = false; // If a box around the coordinates was found, use that\n\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left < boxAround.right - x,\n          atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? \"after\" : \"before\";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr && (ch == end || ch == begin)) {\n        ch++;\n      } // To determine which side to associate with, get the box to the\n      // left of the character and compare it's vertical position to the\n      // coordinates\n\n\n      sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y == ltr ? \"after\" : \"before\"; // Now get accurate coordinates for this place, in order to get a\n      // base X position\n\n      var coords = _cursorCoords(cm, Pos(lineNo, ch, sticky), \"line\", lineObj, preparedMeasure);\n\n      baseX = coords.left;\n      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX);\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i],\n          ltr = part.level != 1;\n      return boxIsAfter(_cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"), \"line\", lineObj, preparedMeasure), x, y, true);\n    }, 0, order.length - 1);\n    var part = order[index]; // If this isn't the first part, the part's start is also after\n    // the coordinates, and the coordinates aren't on the same line as\n    // that start, move one part back.\n\n    if (index > 0) {\n      var ltr = part.level != 1;\n\n      var start = _cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"), \"line\", lineObj, preparedMeasure);\n\n      if (boxIsAfter(start, x, y, true) && start.top > y) {\n        part = order[index - 1];\n      }\n    }\n\n    return part;\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don't correspond to the ordering in our `order` array at\n    // all, so a binary search doesn't work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren't on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) {\n      end--;\n    }\n\n    var part = null,\n        closestDist = null;\n\n    for (var i = 0; i < order.length; i++) {\n      var p = order[i];\n\n      if (p.from >= end || p.to <= begin) {\n        continue;\n      }\n\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right; // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n\n      var dist = endX < x ? x - endX + 1e9 : endX - x;\n\n      if (!part || closestDist > dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n\n    if (!part) {\n      part = order[order.length - 1];\n    } // Clip the part to the wrapped line.\n\n\n    if (part.from < begin) {\n      part = {\n        from: begin,\n        to: part.to,\n        level: part.level\n      };\n    }\n\n    if (part.to > end) {\n      part = {\n        from: part.from,\n        to: end,\n        level: part.level\n      };\n    }\n\n    return part;\n  }\n\n  var measureText; // Compute the default text height.\n\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) {\n      return display.cachedTextHeight;\n    }\n\n    if (measureText == null) {\n      measureText = elt(\"pre\", null, \"CodeMirror-line-like\"); // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n\n    if (height > 3) {\n      display.cachedTextHeight = height;\n    }\n\n    removeChildren(display.measure);\n    return height || 1;\n  } // Compute the default character width.\n\n\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) {\n      return display.cachedCharWidth;\n    }\n\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor], \"CodeMirror-line-like\");\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(),\n        width = (rect.right - rect.left) / 10;\n\n    if (width > 2) {\n      display.cachedCharWidth = width;\n    }\n\n    return width || 10;\n  } // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n\n\n  function getDimensions(cm) {\n    var d = cm.display,\n        left = {},\n        width = {};\n    var gutterLeft = d.gutters.clientLeft;\n\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      var id = cm.display.gutterSpecs[i].className;\n      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[id] = n.clientWidth;\n    }\n\n    return {\n      fixedPos: compensateForHScroll(d),\n      gutterTotalWidth: d.gutters.offsetWidth,\n      gutterLeft: left,\n      gutterWidth: width,\n      wrapperWidth: d.wrapper.clientWidth\n    };\n  } // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n\n\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\n  } // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n\n\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display),\n        wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) {\n        return 0;\n      }\n\n      var widgetsHeight = 0;\n\n      if (line.widgets) {\n        for (var i = 0; i < line.widgets.length; i++) {\n          if (line.widgets[i].height) {\n            widgetsHeight += line.widgets[i].height;\n          }\n        }\n      }\n\n      if (wrapping) {\n        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\n      } else {\n        return widgetsHeight + th;\n      }\n    };\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc,\n        est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n\n      if (estHeight != line.height) {\n        updateLineHeight(line, estHeight);\n      }\n    });\n  } // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n\n\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") {\n      return null;\n    }\n\n    var x,\n        y,\n        space = display.lineSpace.getBoundingClientRect(); // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n\n    try {\n      x = e.clientX - space.left;\n      y = e.clientY - space.top;\n    } catch (e$1) {\n      return null;\n    }\n\n    var coords = _coordsChar(cm, x, y),\n        line;\n\n    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n\n    return coords;\n  } // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n\n\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) {\n      return null;\n    }\n\n    n -= cm.display.viewFrom;\n\n    if (n < 0) {\n      return null;\n    }\n\n    var view = cm.display.view;\n\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n\n      if (n < 0) {\n        return i;\n      }\n    }\n  } // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n\n\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) {\n      from = cm.doc.first;\n    }\n\n    if (to == null) {\n      to = cm.doc.first + cm.doc.size;\n    }\n\n    if (!lendiff) {\n      lendiff = 0;\n    }\n\n    var display = cm.display;\n\n    if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {\n      display.updateLineNumbers = from;\n    }\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) {\n      // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {\n        resetView(cm);\n      }\n    } else if (to <= display.viewFrom) {\n      // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) {\n      // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) {\n      // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) {\n      // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else {\n      // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n\n    if (ext) {\n      if (to < ext.lineN) {\n        ext.lineN += lendiff;\n      } else if (from < ext.lineN + ext.size) {\n        display.externalMeasured = null;\n      }\n    }\n  } // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n\n\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display,\n        ext = cm.display.externalMeasured;\n\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {\n      display.externalMeasured = null;\n    }\n\n    if (line < display.viewFrom || line >= display.viewTo) {\n      return;\n    }\n\n    var lineView = display.view[findViewIndex(cm, line)];\n\n    if (lineView.node == null) {\n      return;\n    }\n\n    var arr = lineView.changes || (lineView.changes = []);\n\n    if (indexOf(arr, type) == -1) {\n      arr.push(type);\n    }\n  } // Clear the view.\n\n\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN),\n        diff,\n        view = cm.display.view;\n\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {\n      return {\n        index: index,\n        lineN: newN\n      };\n    }\n\n    var n = cm.display.viewFrom;\n\n    for (var i = 0; i < index; i++) {\n      n += view[i].size;\n    }\n\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) {\n          return null;\n        }\n\n        diff = n + view[index].size - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n\n      oldN += diff;\n      newN += diff;\n    }\n\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) {\n        return null;\n      }\n\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n\n    return {\n      index: index,\n      lineN: newN\n    };\n  } // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n\n\n  function adjustView(cm, from, to) {\n    var display = cm.display,\n        view = display.view;\n\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from) {\n        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\n      } else if (display.viewFrom < from) {\n        display.view = display.view.slice(findViewIndex(cm, from));\n      }\n\n      display.viewFrom = from;\n\n      if (display.viewTo < to) {\n        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\n      } else if (display.viewTo > to) {\n        display.view = display.view.slice(0, findViewIndex(cm, to));\n      }\n    }\n\n    display.viewTo = to;\n  } // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n\n\n  function countDirtyView(cm) {\n    var view = cm.display.view,\n        dirty = 0;\n\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) {\n        ++dirty;\n      }\n    }\n\n    return dirty;\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if (primary === void 0) primary = true;\n    var doc = cm.doc,\n        result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (!primary && i == doc.sel.primIndex) {\n        continue;\n      }\n\n      var range = doc.sel.ranges[i];\n\n      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) {\n        continue;\n      }\n\n      var collapsed = range.empty();\n\n      if (collapsed || cm.options.showCursorWhenSelecting) {\n        drawSelectionCursor(cm, range.head, curFragment);\n      }\n\n      if (!collapsed) {\n        drawSelectionRange(cm, range, selFragment);\n      }\n    }\n\n    return result;\n  } // Draws a cursor for the given range\n\n\n  function drawSelectionCursor(cm, head, output) {\n    var pos = _cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\xA0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\xA0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  function cmpCoords(a, b) {\n    return a.top - b.top || a.left - b.left;\n  } // Draws the given range as a highlighted selection\n\n\n  function drawSelectionRange(cm, range, output) {\n    var display = cm.display,\n        doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display),\n        leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == \"ltr\";\n\n    function add(left, top, width, bottom) {\n      if (top < 0) {\n        top = 0;\n      }\n\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", \"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\"));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n\n      function coords(ch, bias) {\n        return _charCoords(cm, Pos(line, ch), \"div\", lineObj, bias);\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = dir == \"ltr\" == (side == \"after\") ? \"left\" : \"right\";\n        var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop];\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == \"ltr\";\n        var fromPos = coords(from, ltr ? \"left\" : \"right\");\n        var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n        var openStart = fromArg == null && from == 0,\n            openEnd = toArg == null && to == lineLen;\n        var first = i == 0,\n            last = !order || i == order.length - 1;\n\n        if (toPos.top - fromPos.top <= 3) {\n          // Single line\n          var openLeft = (docLTR ? openStart : openEnd) && first;\n          var openRight = (docLTR ? openEnd : openStart) && last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else {\n          // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n\n          if (ltr) {\n            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n            botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n          }\n\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n\n          if (fromPos.bottom < toPos.top) {\n            add(leftSide, fromPos.bottom, null, toPos.top);\n          }\n\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) < 0) {\n          start = fromPos;\n        }\n\n        if (cmpCoords(toPos, start) < 0) {\n          start = toPos;\n        }\n\n        if (!end || cmpCoords(fromPos, end) < 0) {\n          end = fromPos;\n        }\n\n        if (cmpCoords(toPos, end) < 0) {\n          end = toPos;\n        }\n      });\n      return {\n        start: start,\n        end: end\n      };\n    }\n\n    var sFrom = range.from(),\n        sTo = range.to();\n\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line),\n          toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n\n      if (leftEnd.bottom < rightStart.top) {\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\n      }\n    }\n\n    output.appendChild(fragment);\n  } // Cursor-blinking\n\n\n  function restartBlink(cm) {\n    if (!cm.state.focused) {\n      return;\n    }\n\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n\n    if (cm.options.cursorBlinkRate > 0) {\n      display.blinker = setInterval(function () {\n        if (!cm.hasFocus()) {\n          onBlur(cm);\n        }\n\n        display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\";\n      }, cm.options.cursorBlinkRate);\n    } else if (cm.options.cursorBlinkRate < 0) {\n      display.cursorDiv.style.visibility = \"hidden\";\n    }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.hasFocus()) {\n      cm.display.input.focus();\n\n      if (!cm.state.focused) {\n        onFocus(cm);\n      }\n    }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () {\n      if (cm.state.delayingBlurEvent) {\n        cm.state.delayingBlurEvent = false;\n\n        if (cm.state.focused) {\n          onBlur(cm);\n        }\n      }\n    }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent && !cm.state.draggingText) {\n      cm.state.delayingBlurEvent = false;\n    }\n\n    if (cm.options.readOnly == \"nocursor\") {\n      return;\n    }\n\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\"); // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n\n        if (webkit) {\n          setTimeout(function () {\n            return cm.display.input.reset(true);\n          }, 20);\n        } // Issue #1730\n\n      }\n\n      cm.display.input.receivedFocus();\n    }\n\n    restartBlink(cm);\n  }\n\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) {\n      return;\n    }\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n\n    clearInterval(cm.display.blinker);\n    setTimeout(function () {\n      if (!cm.state.focused) {\n        cm.display.shift = false;\n      }\n    }, 150);\n  } // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n\n\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i],\n          wrapping = cm.options.lineWrapping;\n      var height = void 0,\n          width = 0;\n\n      if (cur.hidden) {\n        continue;\n      }\n\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top; // Check that lines don't extend past the right of the current\n        // editor width\n\n        if (!wrapping && cur.text.firstChild) {\n          width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;\n        }\n      }\n\n      var diff = cur.line.height - height;\n\n      if (diff > .005 || diff < -.005) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n\n        if (cur.rest) {\n          for (var j = 0; j < cur.rest.length; j++) {\n            updateWidgetHeight(cur.rest[j]);\n          }\n        }\n      }\n\n      if (width > cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n\n        if (chWidth > cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n  } // Read and store the height of line widgets associated with the\n  // given line.\n\n\n  function updateWidgetHeight(line) {\n    if (line.widgets) {\n      for (var i = 0; i < line.widgets.length; ++i) {\n        var w = line.widgets[i],\n            parent = w.node.parentNode;\n\n        if (parent) {\n          w.height = parent.offsetHeight;\n        }\n      }\n    }\n  } // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n\n\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = _lineAtHeight(doc, top),\n        to = _lineAtHeight(doc, bottom); // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n\n\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line,\n          ensureTo = viewport.ensure.to.line;\n\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n\n    return {\n      from: from,\n      to: Math.max(to, from + 1)\n    };\n  } // SCROLLING THINGS INTO VIEW\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n\n\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) {\n      return;\n    }\n\n    var display = cm.display,\n        box = display.sizer.getBoundingClientRect(),\n        doScroll = null;\n\n    if (rect.top + box.top < 0) {\n      doScroll = true;\n    } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {\n      doScroll = false;\n    }\n\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200B\", null, \"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + rect.left + \"px; width: \" + Math.max(2, rect.right - rect.left) + \"px;\");\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  } // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n\n\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) {\n      margin = 0;\n    }\n\n    var rect;\n\n    if (!cm.options.lineWrapping && pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n      pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n      end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n    }\n\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false;\n\n      var coords = _cursorCoords(cm, pos);\n\n      var endCoords = !end || end == pos ? coords : _cursorCoords(cm, end);\n      rect = {\n        left: Math.min(coords.left, endCoords.left),\n        top: Math.min(coords.top, endCoords.top) - margin,\n        right: Math.max(coords.left, endCoords.left),\n        bottom: Math.max(coords.bottom, endCoords.bottom) + margin\n      };\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop,\n          startLeft = cm.doc.scrollLeft;\n\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) {\n          changed = true;\n        }\n      }\n\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {\n          changed = true;\n        }\n      }\n\n      if (!changed) {\n        break;\n      }\n    }\n\n    return rect;\n  } // Scroll a given set of coordinates into view (immediately).\n\n\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n\n    if (scrollPos.scrollTop != null) {\n      updateScrollTop(cm, scrollPos.scrollTop);\n    }\n\n    if (scrollPos.scrollLeft != null) {\n      setScrollLeft(cm, scrollPos.scrollLeft);\n    }\n  } // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n\n\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display,\n        snapMargin = textHeight(cm.display);\n\n    if (rect.top < 0) {\n      rect.top = 0;\n    }\n\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm),\n        result = {};\n\n    if (rect.bottom - rect.top > screen) {\n      rect.bottom = rect.top + screen;\n    }\n\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top < snapMargin,\n        atBottom = rect.bottom > docBottom - snapMargin;\n\n    if (rect.top < screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom > screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n\n      if (newTop != screentop) {\n        result.scrollTop = newTop;\n      }\n    }\n\n    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;\n    var screenw = displayWidth(cm) - display.gutters.offsetWidth;\n    var tooWide = rect.right - rect.left > screenw;\n\n    if (tooWide) {\n      rect.right = rect.left + screenw;\n    }\n\n    if (rect.left < 10) {\n      result.scrollLeft = 0;\n    } else if (rect.left < screenleft) {\n      result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));\n    } else if (rect.right > screenw + screenleft - 3) {\n      result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;\n    }\n\n    return result;\n  } // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n\n\n  function addToScrollTop(cm, top) {\n    if (top == null) {\n      return;\n    }\n\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  } // Make sure that at the end of the operation the current cursor is\n  // shown.\n\n\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {\n      from: cur,\n      to: cur,\n      margin: cm.options.cursorScrollMargin\n    };\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) {\n      resolveScrollToPos(cm);\n    }\n\n    if (x != null) {\n      cm.curOp.scrollLeft = x;\n    }\n\n    if (y != null) {\n      cm.curOp.scrollTop = y;\n    }\n  }\n\n  function scrollToRange(cm, range) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range;\n  } // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n\n\n  function resolveScrollToPos(cm) {\n    var range = cm.curOp.scrollToPos;\n\n    if (range) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range.from),\n          to = estimateCoords(cm, range.to);\n      scrollToCoordsRange(cm, from, to, range.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  } // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n\n\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) {\n      return;\n    }\n\n    if (!gecko) {\n      updateDisplaySimple(cm, {\n        top: val\n      });\n    }\n\n    setScrollTop(cm, val, true);\n\n    if (gecko) {\n      updateDisplaySimple(cm);\n    }\n\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));\n\n    if (cm.display.scroller.scrollTop == val && !forceScroll) {\n      return;\n    }\n\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n\n    if (cm.display.scroller.scrollTop != val) {\n      cm.display.scroller.scrollTop = val;\n    }\n  } // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n\n\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));\n\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {\n      return;\n    }\n\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n\n    if (cm.display.scroller.scrollLeft != val) {\n      cm.display.scroller.scrollLeft = val;\n    }\n\n    cm.display.scrollbars.setScrollLeft(val);\n  } // SCROLLBARS\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n\n\n  function measureForScrollbars(cm) {\n    var d = cm.display,\n        gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth,\n      clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    };\n  }\n\n  var NativeScrollbars = function NativeScrollbars(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert);\n    place(horiz);\n    on(vert, \"scroll\", function () {\n      if (vert.clientHeight) {\n        scroll(vert.scrollTop, \"vertical\");\n      }\n    });\n    on(horiz, \"scroll\", function () {\n      if (horiz.clientWidth) {\n        scroll(horiz.scrollLeft, \"horizontal\");\n      }\n    });\n    this.checkedZeroWidth = false; // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n\n    if (ie && ie_version < 8) {\n      this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\";\n    }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = \"block\";\n      this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0); // A bug in IE8 can cause this value to be negative, so guard it.\n\n      this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n    } else {\n      this.vert.style.display = \"\";\n      this.vert.firstChild.style.height = \"0\";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = \"block\";\n      this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n      this.horiz.style.left = measure.barLeft + \"px\";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n    } else {\n      this.horiz.style.display = \"\";\n      this.horiz.firstChild.style.width = \"0\";\n    }\n\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n      if (sWidth == 0) {\n        this.zeroWidthHack();\n      }\n\n      this.checkedZeroWidth = true;\n    }\n\n    return {\n      right: needsV ? sWidth : 0,\n      bottom: needsH ? sWidth : 0\n    };\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) {\n      this.horiz.scrollLeft = pos;\n    }\n\n    if (this.disableHoriz) {\n      this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\");\n    }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) {\n      this.vert.scrollTop = pos;\n    }\n\n    if (this.disableVert) {\n      this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\");\n    }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n    this.disableHoriz = new Delayed();\n    this.disableVert = new Delayed();\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.pointerEvents = \"auto\";\n\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it's hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n\n      if (elt != bar) {\n        bar.style.pointerEvents = \"none\";\n      } else {\n        delay.set(1000, maybeDisable);\n      }\n    }\n\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function NullScrollbars() {};\n\n  NullScrollbars.prototype.update = function () {\n    return {\n      bottom: 0,\n      right: 0\n    };\n  };\n\n  NullScrollbars.prototype.setScrollLeft = function () {};\n\n  NullScrollbars.prototype.setScrollTop = function () {};\n\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) {\n      measure = measureForScrollbars(cm);\n    }\n\n    var startWidth = cm.display.barWidth,\n        startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {\n        updateHeightsInViewport(cm);\n      }\n\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth;\n      startHeight = cm.display.barHeight;\n    }\n  } // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n\n\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else {\n      d.scrollbarFiller.style.display = \"\";\n    }\n\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else {\n      d.gutterFiller.style.display = \"\";\n    }\n  }\n\n  var scrollbarModel = {\n    \"native\": NativeScrollbars,\n    \"null\": NullScrollbars\n  };\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n\n      if (cm.display.scrollbars.addClass) {\n        rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n      }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller); // Prevent clicks in the scrollbars from killing focus\n\n      on(node, \"mousedown\", function () {\n        if (cm.state.focused) {\n          setTimeout(function () {\n            return cm.display.input.focus();\n          }, 0);\n        }\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function (pos, axis) {\n      if (axis == \"horizontal\") {\n        setScrollLeft(cm, pos);\n      } else {\n        updateScrollTop(cm, pos);\n      }\n    }, cm);\n\n    if (cm.display.scrollbars.addClass) {\n      addClass(cm.display.wrapper, cm.display.scrollbars.addClass);\n    }\n  } // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n\n  var nextOpId = 0; // Start a new operation.\n\n  function _startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,\n      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height,\n      // Used to detect need to update scrollbar\n      forceUpdate: false,\n      // Used to force a redraw\n      updateInput: 0,\n      // Whether to reset the input textarea\n      typing: false,\n      // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,\n      // Accumulated changes, for firing change events\n      cursorActivityHandlers: null,\n      // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0,\n      // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false,\n      // Whether the selection needs to be redrawn\n      updateMaxLine: false,\n      // Set when the widest line needs to be determined anew\n      scrollLeft: null,\n      scrollTop: null,\n      // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,\n      // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId // Unique ID\n\n    };\n    pushOperation(cm.curOp);\n  } // Finish an operation, updating the display and signalling delayed events\n\n\n  function _endOperation(cm) {\n    var op = cm.curOp;\n\n    if (op) {\n      finishOperation(op, function (group) {\n        for (var i = 0; i < group.ops.length; i++) {\n          group.ops[i].cm.curOp = null;\n        }\n\n        endOperations(group);\n      });\n    }\n  } // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n\n\n  function endOperations(group) {\n    var ops = group.ops;\n\n    for (var i = 0; i < ops.length; i++) // Read DOM\n    {\n      endOperation_R1(ops[i]);\n    }\n\n    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n    {\n      endOperation_W1(ops[i$1]);\n    }\n\n    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n    {\n      endOperation_R2(ops[i$2]);\n    }\n\n    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n    {\n      endOperation_W2(ops[i$3]);\n    }\n\n    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n    {\n      endOperation_finish(ops[i$4]);\n    }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm,\n        display = cm.display;\n    maybeClipScrollbars(cm);\n\n    if (op.updateMaxLine) {\n      findMaxLine(cm);\n    }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {\n      top: op.scrollTop,\n      ensure: op.scrollToPos\n    }, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm,\n        display = cm.display;\n\n    if (op.updatedDisplay) {\n      updateHeightsInViewport(cm);\n    }\n\n    op.barMeasure = measureForScrollbars(cm); // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged) {\n      op.preparedSelection = display.input.prepareSelection();\n    }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n\n      if (op.maxScrollLeft < cm.doc.scrollLeft) {\n        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\n      }\n\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt();\n\n    if (op.preparedSelection) {\n      cm.display.input.showSelection(op.preparedSelection, takeFocus);\n    }\n\n    if (op.updatedDisplay || op.startHeight != cm.doc.height) {\n      updateScrollbars(cm, op.barMeasure);\n    }\n\n    if (op.updatedDisplay) {\n      setDocumentHeight(cm, op.barMeasure);\n    }\n\n    if (op.selectionChanged) {\n      restartBlink(cm);\n    }\n\n    if (cm.state.focused && op.updateInput) {\n      cm.display.input.reset(op.typing);\n    }\n\n    if (takeFocus) {\n      ensureFocus(op.cm);\n    }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm,\n        display = cm.display,\n        doc = cm.doc;\n\n    if (op.updatedDisplay) {\n      postUpdateDisplay(cm, op.update);\n    } // Abort mouse wheel delta measurement, when scrolling explicitly\n\n\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {\n      display.wheelStartX = display.wheelStartY = null;\n    } // Propagate the scroll position to the actual DOM scroller\n\n\n    if (op.scrollTop != null) {\n      setScrollTop(cm, op.scrollTop, op.forceScroll);\n    }\n\n    if (op.scrollLeft != null) {\n      setScrollLeft(cm, op.scrollLeft, true, true);\n    } // If we need to scroll a specific position into view, do so.\n\n\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, _clipPos(doc, op.scrollToPos.from), _clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    } // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n\n\n    var hidden = op.maybeHiddenMarkers,\n        unhidden = op.maybeUnhiddenMarkers;\n\n    if (hidden) {\n      for (var i = 0; i < hidden.length; ++i) {\n        if (!hidden[i].lines.length) {\n          signal(hidden[i], \"hide\");\n        }\n      }\n    }\n\n    if (unhidden) {\n      for (var i$1 = 0; i$1 < unhidden.length; ++i$1) {\n        if (unhidden[i$1].lines.length) {\n          signal(unhidden[i$1], \"unhide\");\n        }\n      }\n    }\n\n    if (display.wrapper.offsetHeight) {\n      doc.scrollTop = cm.display.scroller.scrollTop;\n    } // Fire change events, and delayed event handlers\n\n\n    if (op.changeObjs) {\n      signal(cm, \"changes\", cm, op.changeObjs);\n    }\n\n    if (op.update) {\n      op.update.finish();\n    }\n  } // Run the given function in an operation\n\n\n  function runInOp(cm, f) {\n    if (cm.curOp) {\n      return f();\n    }\n\n    _startOperation(cm);\n\n    try {\n      return f();\n    } finally {\n      _endOperation(cm);\n    }\n  } // Wraps a function in an operation. Returns the wrapped function.\n\n\n  function operation(cm, f) {\n    return function () {\n      if (cm.curOp) {\n        return f.apply(cm, arguments);\n      }\n\n      _startOperation(cm);\n\n      try {\n        return f.apply(cm, arguments);\n      } finally {\n        _endOperation(cm);\n      }\n    };\n  } // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n\n\n  function methodOp(f) {\n    return function () {\n      if (this.curOp) {\n        return f.apply(this, arguments);\n      }\n\n      _startOperation(this);\n\n      try {\n        return f.apply(this, arguments);\n      } finally {\n        _endOperation(this);\n      }\n    };\n  }\n\n  function docMethodOp(f) {\n    return function () {\n      var cm = this.cm;\n\n      if (!cm || cm.curOp) {\n        return f.apply(this, arguments);\n      }\n\n      _startOperation(cm);\n\n      try {\n        return f.apply(this, arguments);\n      } finally {\n        _endOperation(cm);\n      }\n    };\n  } // HIGHLIGHT WORKER\n\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier < cm.display.viewTo) {\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\n    }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n\n    if (doc.highlightFrontier >= cm.display.viewTo) {\n      return;\n    }\n\n    var end = +new Date() + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line >= cm.display.viewFrom) {\n        // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n\n        if (resetState) {\n          context.state = resetState;\n        }\n\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses,\n            newCls = highlighted.classes;\n\n        if (newCls) {\n          line.styleClasses = newCls;\n        } else if (oldCls) {\n          line.styleClasses = null;\n        }\n\n        var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) {\n          ischange = oldStyles[i] != line.styles[i];\n        }\n\n        if (ischange) {\n          changedLines.push(context.line);\n        }\n\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength) {\n          processLine(cm, line.text, context);\n        }\n\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n\n      if (+new Date() > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true;\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n\n    if (changedLines.length) {\n      runInOp(cm, function () {\n        for (var i = 0; i < changedLines.length; i++) {\n          regLineChange(cm, changedLines[i], \"text\");\n        }\n      });\n    }\n  } // DISPLAY DRAWING\n\n\n  var DisplayUpdate = function DisplayUpdate(cm, viewport, force) {\n    var display = cm.display;\n    this.viewport = viewport; // Store some values that we'll need later (but don't want to force a relayout for)\n\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type)) {\n      this.events.push(arguments);\n    }\n  };\n\n  DisplayUpdate.prototype.finish = function () {\n    for (var i = 0; i < this.events.length; i++) {\n      signal.apply(null, this.events[i]);\n    }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) {\n      return null;\n    }\n\n    var active = activeElt();\n\n    if (!active || !contains(cm.display.lineDiv, active)) {\n      return null;\n    }\n\n    var result = {\n      activeElt: active\n    };\n\n    if (window.getSelection) {\n      var sel = window.getSelection();\n\n      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n\n    return result;\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {\n      return;\n    }\n\n    snapshot.activeElt.focus();\n\n    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n      var sel = window.getSelection(),\n          range = document.createRange();\n      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  } // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n\n\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display,\n        doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false;\n    } // Bail out if the visible area is already rendered and nothing changed.\n\n\n    if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {\n      return false;\n    }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    } // Compute a suitable new viewport (from & to)\n\n\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n\n    if (display.viewFrom < from && from - display.viewFrom < 20) {\n      from = Math.max(doc.first, display.viewFrom);\n    }\n\n    if (display.viewTo > to && display.viewTo - to < 20) {\n      to = Math.min(end, display.viewTo);\n    }\n\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n    display.viewOffset = _heightAtLine(getLine(cm.doc, display.viewFrom)); // Position the mover div to align with the current scroll position\n\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n    var toUpdate = countDirtyView(cm);\n\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {\n      return false;\n    } // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n\n\n    var selSnapshot = selectionSnapshot(cm);\n\n    if (toUpdate > 4) {\n      display.lineDiv.style.display = \"none\";\n    }\n\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n\n    if (toUpdate > 4) {\n      display.lineDiv.style.display = \"\";\n    }\n\n    display.renderedView = display.view; // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n\n    restoreSelection(selSnapshot); // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n    return true;\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null) {\n          viewport = {\n            top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)\n          };\n        } // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n\n\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {\n          break;\n        }\n      } else if (first) {\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n      }\n\n      if (!updateDisplayIfNeeded(cm, update)) {\n        break;\n      }\n\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, \"update\", cm);\n\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom;\n      cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  } // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n\n\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display,\n        lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv,\n        cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling; // Works around a throw-scroll bug in OS X Webkit\n\n      if (webkit && mac && cm.display.currentWheelTarget == node) {\n        node.style.display = \"none\";\n      } else {\n        node.parentNode.removeChild(node);\n      }\n\n      return next;\n    }\n\n    var view = display.view,\n        lineN = display.viewFrom; // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ;else if (!lineView.node || lineView.node.parentNode != container) {\n        // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else {\n        // Already drawn\n        while (cur != lineView.node) {\n          cur = rm(cur);\n        }\n\n        var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;\n\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) {\n            updateNumber = false;\n          }\n\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n\n    while (cur) {\n      cur = rm(cur);\n    }\n  }\n\n  function updateGutterSpace(display) {\n    var width = display.gutters.offsetWidth;\n    display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + \"px\";\n  } // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n\n\n  function alignHorizontally(cm) {\n    var display = cm.display,\n        view = display.view;\n\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {\n      return;\n    }\n\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth,\n        left = comp + \"px\";\n\n    for (var i = 0; i < view.length; i++) {\n      if (!view[i].hidden) {\n        if (cm.options.fixedGutter) {\n          if (view[i].gutter) {\n            view[i].gutter.style.left = left;\n          }\n\n          if (view[i].gutterBackground) {\n            view[i].gutterBackground.style.left = left;\n          }\n        }\n\n        var align = view[i].alignable;\n\n        if (align) {\n          for (var j = 0; j < align.length; j++) {\n            align[j].style.left = left;\n          }\n        }\n      }\n    }\n\n    if (cm.options.fixedGutter) {\n      display.gutters.style.left = comp + gutterW + \"px\";\n    }\n  } // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n\n\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) {\n      return false;\n    }\n\n    var doc = cm.doc,\n        last = lineNumberFor(cm.options, doc.first + doc.size - 1),\n        display = cm.display;\n\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)], \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth,\n          padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm.display);\n      return true;\n    }\n\n    return false;\n  }\n\n  function getGutters(gutters, lineNumbers) {\n    var result = [],\n        sawLineNumbers = false;\n\n    for (var i = 0; i < gutters.length; i++) {\n      var name = gutters[i],\n          style = null;\n\n      if (typeof name != \"string\") {\n        style = name.style;\n        name = name.className;\n      }\n\n      if (name == \"CodeMirror-linenumbers\") {\n        if (!lineNumbers) {\n          continue;\n        } else {\n          sawLineNumbers = true;\n        }\n      }\n\n      result.push({\n        className: name,\n        style: style\n      });\n    }\n\n    if (lineNumbers && !sawLineNumbers) {\n      result.push({\n        className: \"CodeMirror-linenumbers\",\n        style: null\n      });\n    }\n\n    return result;\n  } // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n\n\n  function renderGutters(display) {\n    var gutters = display.gutters,\n        specs = display.gutterSpecs;\n    removeChildren(gutters);\n    display.lineGutter = null;\n\n    for (var i = 0; i < specs.length; ++i) {\n      var ref = specs[i];\n      var className = ref.className;\n      var style = ref.style;\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + className));\n\n      if (style) {\n        gElt.style.cssText = style;\n      }\n\n      if (className == \"CodeMirror-linenumbers\") {\n        display.lineGutter = gElt;\n        gElt.style.width = (display.lineNumWidth || 1) + \"px\";\n      }\n    }\n\n    gutters.style.display = specs.length ? \"\" : \"none\";\n    updateGutterSpace(display);\n  }\n\n  function updateGutters(cm) {\n    renderGutters(cm.display);\n    regChange(cm);\n    alignHorizontally(cm);\n  } // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n\n  function Display(place, doc, input, options) {\n    var d = this;\n    this.input = input; // Covers bottom-right square when both scrollbars are present.\n\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\"); // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\"); // Will contain the actual code, positioned to cover the viewport.\n\n    d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\"); // Elements are added to these to represent selection and cursors.\n\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\"); // A visibility: hidden element used to find the size of things.\n\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\"); // When lines outside of the viewport are measured, they are drawn in this.\n\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\"); // Wraps everything that needs to exist inside the vertically-padded coordinate system\n\n    d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, \"position: relative; outline: none\");\n    var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\"); // Moved around its parent to cover visible view.\n\n    d.mover = elt(\"div\", [lines], null, \"position: relative\"); // Set to the height of the document, allowing scrolling.\n\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null; // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\"); // Will contain the gutters, if any.\n\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null; // Actual scrollable element.\n\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\"); // The element in which the editor lives.\n\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\"); // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n\n    if (ie && ie_version < 8) {\n      d.gutters.style.zIndex = -1;\n      d.scroller.style.paddingRight = 0;\n    }\n\n    if (!webkit && !(gecko && mobile)) {\n      d.scroller.draggable = true;\n    }\n\n    if (place) {\n      if (place.appendChild) {\n        place.appendChild(d.wrapper);\n      } else {\n        place(d.wrapper);\n      }\n    } // Current rendered range (may be bigger than the view window).\n\n\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first; // Information about the rendered lines.\n\n    d.view = [];\n    d.renderedView = null; // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n\n    d.externalMeasured = null; // Empty space (in pixels) above the view\n\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false; // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null; // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n\n    d.alignWidgets = false;\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null; // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false; // Used for measuring wheel scrolling granularity\n\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null; // True when shift is held down.\n\n    d.shift = false; // Used to track whether anything happened since the context menu\n    // was opened.\n\n    d.selForContextMenu = null;\n    d.activeTouch = null;\n    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);\n    renderGutters(d);\n    input.init(d);\n  } // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n\n  var wheelSamples = 0,\n      wheelPixelsPerUnit = null; // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n\n  if (ie) {\n    wheelPixelsPerUnit = -.53;\n  } else if (gecko) {\n    wheelPixelsPerUnit = 15;\n  } else if (chrome) {\n    wheelPixelsPerUnit = -.7;\n  } else if (safari) {\n    wheelPixelsPerUnit = -1 / 3;\n  }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX,\n        dy = e.wheelDeltaY;\n\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {\n      dx = e.detail;\n    }\n\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {\n      dy = e.detail;\n    } else if (dy == null) {\n      dy = e.wheelDelta;\n    }\n\n    return {\n      x: dx,\n      y: dy\n    };\n  }\n\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta;\n  }\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e),\n        dx = delta.x,\n        dy = delta.y;\n    var display = cm.display,\n        scroll = display.scroller; // Quit if there's nothing to scroll here\n\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n\n    if (!(dx && canScrollX || dy && canScrollY)) {\n      return;\n    } // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n\n\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer;\n          }\n        }\n      }\n    } // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n\n\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY) {\n        updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit));\n      }\n\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit)); // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n\n      if (!dy || dy && canScrollY) {\n        e_preventDefault(e);\n      }\n\n      display.wheelStartX = null; // Abort measurement, if in progress\n\n      return;\n    } // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n\n\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop,\n          bot = top + display.wrapper.clientHeight;\n\n      if (pixels < 0) {\n        top = Math.max(0, top + pixels - 50);\n      } else {\n        bot = Math.min(cm.doc.height, bot + pixels + 50);\n      }\n\n      updateDisplaySimple(cm, {\n        top: top,\n        bottom: bot\n      });\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft;\n        display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx;\n        display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) {\n            return;\n          }\n\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;\n          display.wheelStartX = display.wheelStartY = null;\n\n          if (!sample) {\n            return;\n          }\n\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx;\n        display.wheelDY += dy;\n      }\n    }\n  } // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n\n\n  var Selection = function Selection(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () {\n    return this.ranges[this.primIndex];\n  };\n\n  Selection.prototype.equals = function (other) {\n    if (other == this) {\n      return true;\n    }\n\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {\n      return false;\n    }\n\n    for (var i = 0; i < this.ranges.length; i++) {\n      var here = this.ranges[i],\n          there = other.ranges[i];\n\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Selection.prototype.deepCopy = function () {\n    var out = [];\n\n    for (var i = 0; i < this.ranges.length; i++) {\n      out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\n    }\n\n    return new Selection(out, this.primIndex);\n  };\n\n  Selection.prototype.somethingSelected = function () {\n    for (var i = 0; i < this.ranges.length; i++) {\n      if (!this.ranges[i].empty()) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n    if (!end) {\n      end = pos;\n    }\n\n    for (var i = 0; i < this.ranges.length; i++) {\n      var range = this.ranges[i];\n\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) {\n        return i;\n      }\n    }\n\n    return -1;\n  };\n\n  var Range = function Range(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  };\n\n  Range.prototype.from = function () {\n    return minPos(this.anchor, this.head);\n  };\n\n  Range.prototype.to = function () {\n    return maxPos(this.anchor, this.head);\n  };\n\n  Range.prototype.empty = function () {\n    return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\n  }; // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n\n\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm && cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) {\n      return cmp(a.from(), b.from());\n    });\n    primIndex = indexOf(ranges, prim);\n\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i],\n          prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n\n      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n        var from = minPos(prev.from(), cur.from()),\n            to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n\n        if (i <= primIndex) {\n          --primIndex;\n        }\n\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n\n    return new Selection(ranges, primIndex);\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0);\n  } // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n\n\n  function changeEnd(change) {\n    if (!change.text) {\n      return change.to;\n    }\n\n    return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\n  } // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n\n\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) {\n      return pos;\n    }\n\n    if (cmp(pos, change.to) <= 0) {\n      return changeEnd(change);\n    }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,\n        ch = pos.ch;\n\n    if (pos.line == change.to.line) {\n      ch += changeEnd(change).ch - change.to.ch;\n    }\n\n    return Pos(line, ch);\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)));\n    }\n\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex);\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line) {\n      return Pos(nw.line, pos.ch - old.ch + nw.ch);\n    } else {\n      return Pos(nw.line + (pos.line - old.line), pos.ch);\n    }\n  } // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n\n\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0),\n        newPrev = oldPrev;\n\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i],\n            inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n\n    return new Selection(out, doc.sel.primIndex);\n  } // Used to get the editor into a consistent state again when options change.\n\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) {\n        line.stateAfter = null;\n      }\n\n      if (line.styles) {\n        line.styles = null;\n      }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n\n    if (cm.curOp) {\n      regChange(cm);\n    }\n  } // DOCUMENT DATA STRUCTURE\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n\n\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\n  } // Perform a change on the document data structure.\n\n\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\n    function spansFor(n) {\n      return markedSpans ? markedSpans[n] : null;\n    }\n\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight);\n      signalLater(line, \"change\", line, change);\n    }\n\n    function linesFor(start, end) {\n      var result = [];\n\n      for (var i = start; i < end; ++i) {\n        result.push(new Line(text[i], spansFor(i), estimateHeight));\n      }\n\n      return result;\n    }\n\n    var from = change.from,\n        to = change.to,\n        text = change.text;\n    var firstLine = getLine(doc, from.line),\n        lastLine = getLine(doc, to.line);\n    var lastText = lst(text),\n        lastSpans = spansFor(text.length - 1),\n        nlines = to.line - from.line; // Adjust the line structure\n\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n\n      if (nlines) {\n        doc.remove(from.line, nlines);\n      }\n\n      if (added.length) {\n        doc.insert(from.line, added);\n      }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n\n      if (nlines > 1) {\n        doc.remove(from.line + 1, nlines - 1);\n      }\n\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  } // Call f for all linked documents.\n\n\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) {\n        for (var i = 0; i < doc.linked.length; ++i) {\n          var rel = doc.linked[i];\n\n          if (rel.doc == skip) {\n            continue;\n          }\n\n          var shared = sharedHist && rel.sharedHist;\n\n          if (sharedHistOnly && !shared) {\n            continue;\n          }\n\n          f(rel.doc, shared);\n          propagate(rel.doc, doc, shared);\n        }\n      }\n    }\n\n    propagate(doc, null, true);\n  } // Attach a document to an editor.\n\n\n  function attachDoc(cm, doc) {\n    if (doc.cm) {\n      throw new Error(\"This document is already in use.\");\n    }\n\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n\n    if (!cm.options.lineWrapping) {\n      findMaxLine(cm);\n    }\n\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n    (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = [];\n    this.undone = [];\n    this.undoDepth = Infinity; // Used to track when changes can be merged into a single undo\n    // event\n\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null; // Used by the isClean() method\n\n    this.generation = this.maxGeneration = startGen || 1;\n  } // Create a history change event from an updateDoc-style change\n  // object.\n\n\n  function historyChangeFromChange(doc, change) {\n    var histChange = {\n      from: copyPos(change.from),\n      to: changeEnd(change),\n      text: getBetween(doc, change.from, change.to)\n    };\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) {\n      return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    }, true);\n    return histChange;\n  } // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n\n\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n\n      if (last.ranges) {\n        array.pop();\n      } else {\n        break;\n      }\n    }\n  } // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n\n\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done);\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done);\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done);\n    }\n  } // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n\n\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date(),\n        cur;\n    var last;\n\n    if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == \"*\")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n\n      if (!before || !before.ranges) {\n        pushSelectionToHistory(doc.sel, hist.done);\n      }\n\n      cur = {\n        changes: [historyChangeFromChange(doc, change)],\n        generation: hist.generation\n      };\n      hist.done.push(cur);\n\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n\n        if (!hist.done[0].ranges) {\n          hist.done.shift();\n        }\n      }\n    }\n\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) {\n      signal(doc, \"historyAdded\");\n    }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" || ch == \"+\" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\n  } // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n\n\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history,\n        origin = options && options.origin; // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n\n    if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {\n      hist.done[hist.done.length - 1] = sel;\n    } else {\n      pushSelectionToHistory(sel, hist.done);\n    }\n\n    hist.lastSelTime = +new Date();\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n\n    if (options && options.clearRedo !== false) {\n      clearSelectionEvents(hist.undone);\n    }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n\n    if (!(top && top.ranges && top.equals(sel))) {\n      dest.push(sel);\n    }\n  } // Used to store marked span information in the history.\n\n\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id],\n        n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans) {\n        (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans;\n      }\n\n      ++n;\n    });\n  } // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n\n\n  function removeClearedSpans(spans) {\n    if (!spans) {\n      return null;\n    }\n\n    var out;\n\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) {\n        if (!out) {\n          out = spans.slice(0, i);\n        }\n      } else if (out) {\n        out.push(spans[i]);\n      }\n    }\n\n    return !out ? spans : out.length ? out : null;\n  } // Retrieve and filter the old marked spans stored in a change event.\n\n\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n\n    if (!found) {\n      return null;\n    }\n\n    var nw = [];\n\n    for (var i = 0; i < change.text.length; ++i) {\n      nw.push(removeClearedSpans(found[i]));\n    }\n\n    return nw;\n  } // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n\n\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n\n    if (!old) {\n      return stretched;\n    }\n\n    if (!stretched) {\n      return old;\n    }\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i],\n          stretchCur = stretched[i];\n\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n\n          for (var k = 0; k < oldCur.length; ++k) {\n            if (oldCur[k].marker == span.marker) {\n              continue spans;\n            }\n          }\n\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n\n    return old;\n  } // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n\n\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n\n    for (var i = 0; i < events.length; ++i) {\n      var event = events[i];\n\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue;\n      }\n\n      var changes = event.changes,\n          newChanges = [];\n      copy.push({\n        changes: newChanges\n      });\n\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j],\n            m = void 0;\n        newChanges.push({\n          from: change.from,\n          to: change.to,\n          text: change.text\n        });\n\n        if (newGroup) {\n          for (var prop in change) {\n            if (m = prop.match(/^spans_(\\d+)$/)) {\n              if (indexOf(newGroup, Number(m[1])) > -1) {\n                lst(newChanges)[prop] = change[prop];\n                delete change[prop];\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return copy;\n  } // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n\n\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n\n        if (posBefore != cmp(other, anchor) < 0) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != cmp(head, other) < 0) {\n          head = other;\n        }\n      }\n\n      return new Range(anchor, head);\n    } else {\n      return new Range(other || head, head);\n    }\n  } // Extend the primary selection range, discard the rest.\n\n\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) {\n      extend = doc.cm && (doc.cm.display.shift || doc.extend);\n    }\n\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  } // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n\n\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);\n    }\n\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  } // Updates a single range in the selection.\n\n\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  } // Reset the selection to a single range.\n\n\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  } // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n\n\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function update(ranges) {\n        this.ranges = [];\n\n        for (var i = 0; i < ranges.length; i++) {\n          this.ranges[i] = new Range(_clipPos(doc, ranges[i].anchor), _clipPos(doc, ranges[i].head));\n        }\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n\n    if (doc.cm) {\n      signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj);\n    }\n\n    if (obj.ranges != sel.ranges) {\n      return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);\n    } else {\n      return sel;\n    }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done,\n        last = lst(done);\n\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  } // Set a new selection.\n\n\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\")) {\n      sel = filterSelectionChange(doc, sel, options);\n    }\n\n    var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption(\"readOnly\") != \"nocursor\") {\n      ensureCursorVisible(doc.cm);\n    }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) {\n      return;\n    }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n\n    signalLater(doc, \"cursorActivity\", doc);\n  } // Verify that the selection does not partially select any atomic\n  // marked ranges.\n\n\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  } // Return a selection that does not partially select any atomic\n  // ranges.\n\n\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) {\n          out = sel.ranges.slice(0, i);\n        }\n\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n\n    if (line.markedSpans) {\n      for (var i = 0; i < line.markedSpans.length; ++i) {\n        var sp = line.markedSpans[i],\n            m = sp.marker; // Determine if we should prevent the cursor being placed to the left/right of an atomic marker\n        // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it\n        // is with selectLeft/Right\n\n        var preventCursorLeft = \"selectLeft\" in m ? !m.selectLeft : m.inclusiveLeft;\n        var preventCursorRight = \"selectRight\" in m ? !m.selectRight : m.inclusiveRight;\n\n        if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n          if (mayClear) {\n            signal(m, \"beforeCursorEnter\");\n\n            if (m.explicitlyCleared) {\n              if (!line.markedSpans) {\n                break;\n              } else {\n                --i;\n                continue;\n              }\n            }\n          }\n\n          if (!m.atomic) {\n            continue;\n          }\n\n          if (oldPos) {\n            var near = m.find(dir < 0 ? 1 : -1),\n                diff = void 0;\n\n            if (dir < 0 ? preventCursorRight : preventCursorLeft) {\n              near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);\n            }\n\n            if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) {\n              return skipAtomicInner(doc, near, pos, dir, mayClear);\n            }\n          }\n\n          var far = m.find(dir < 0 ? -1 : 1);\n\n          if (dir < 0 ? preventCursorLeft : preventCursorRight) {\n            far = movePos(doc, far, dir, far.line == pos.line ? line : null);\n          }\n\n          return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;\n        }\n      }\n    }\n\n    return pos;\n  } // Ensure a given position is not inside an atomic range.\n\n\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);\n\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0);\n    }\n\n    return found;\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) {\n        return _clipPos(doc, Pos(pos.line - 1));\n      } else {\n        return null;\n      }\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) {\n        return Pos(pos.line + 1, 0);\n      } else {\n        return null;\n      }\n    } else {\n      return new Pos(pos.line, pos.ch + dir);\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  } // UPDATING\n  // Allow \"beforeChange\" event handlers to influence a change\n\n\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function cancel() {\n        return obj.canceled = true;\n      }\n    };\n\n    if (update) {\n      obj.update = function (from, to, text, origin) {\n        if (from) {\n          obj.from = _clipPos(doc, from);\n        }\n\n        if (to) {\n          obj.to = _clipPos(doc, to);\n        }\n\n        if (text) {\n          obj.text = text;\n        }\n\n        if (origin !== undefined) {\n          obj.origin = origin;\n        }\n      };\n    }\n\n    signal(doc, \"beforeChange\", doc, obj);\n\n    if (doc.cm) {\n      signal(doc.cm, \"beforeChange\", doc.cm, obj);\n    }\n\n    if (obj.canceled) {\n      if (doc.cm) {\n        doc.cm.curOp.updateInput = 2;\n      }\n\n      return null;\n    }\n\n    return {\n      from: obj.from,\n      to: obj.to,\n      text: obj.text,\n      origin: obj.origin\n    };\n  } // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n\n\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) {\n        return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\n      }\n\n      if (doc.cm.state.suppressEdits) {\n        return;\n      }\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n\n      if (!change) {\n        return;\n      }\n    } // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n\n\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i) {\n        makeChangeInner(doc, {\n          from: split[i].from,\n          to: split[i].to,\n          text: i ? [\"\"] : change.text,\n          origin: change.origin\n        });\n      }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) {\n      return;\n    }\n\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  } // Revert a change stored in a document's history.\n\n\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm && doc.cm.state.suppressEdits;\n\n    if (suppress && !allowSelectionOnly) {\n      return;\n    }\n\n    var hist = doc.history,\n        event,\n        selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone,\n        dest = type == \"undo\" ? hist.undone : hist.done; // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n\n    var i = 0;\n\n    for (; i < source.length; i++) {\n      event = source[i];\n\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {\n        break;\n      }\n    }\n\n    if (i == source.length) {\n      return;\n    }\n\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {\n            clearRedo: false\n          });\n          return;\n        }\n\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return;\n      } else {\n        break;\n      }\n    } // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n\n\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({\n      changes: antiChanges,\n      generation: hist.generation\n    });\n    hist.generation = event.generation || ++hist.maxGeneration;\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    var loop = function loop(i) {\n      var change = event.changes[i];\n      change.origin = type;\n\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {};\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n\n      if (!i && doc.cm) {\n        doc.cm.scrollIntoView({\n          from: change.from,\n          to: changeEnd(change)\n        });\n      }\n\n      var rebased = []; // Propagate to the linked documents\n\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n      var returned = loop(i$1);\n      if (returned) return returned.v;\n    }\n  } // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n\n\n  function shiftDoc(doc, distance) {\n    if (distance == 0) {\n      return;\n    }\n\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) {\n      return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch));\n    }), doc.sel.primIndex);\n\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {\n        regLineChange(doc.cm, l, \"gutter\");\n      }\n    }\n  } // More lower-level change function, handling only a single document\n  // (not linked ones).\n\n\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp) {\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\n    }\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return;\n    }\n\n    if (change.from.line > doc.lastLine()) {\n      return;\n    } // Clip the change to the size of this doc\n\n\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {\n        from: Pos(doc.first, 0),\n        to: Pos(change.to.line + shift, change.to.ch),\n        text: [lst(change.text)],\n        origin: change.origin\n      };\n    }\n\n    var last = doc.lastLine();\n\n    if (change.to.line > last) {\n      change = {\n        from: change.from,\n        to: Pos(last, getLine(doc, last).text.length),\n        text: [change.text[0]],\n        origin: change.origin\n      };\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) {\n      selAfter = computeSelAfterChange(doc, change);\n    }\n\n    if (doc.cm) {\n      makeChangeSingleDocInEditor(doc.cm, change, spans);\n    } else {\n      updateDoc(doc, change, spans);\n    }\n\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n\n    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {\n      doc.cantEdit = false;\n    }\n  } // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n\n\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc,\n        display = cm.display,\n        from = change.from,\n        to = change.to;\n    var recomputeMaxLength = false,\n        checkWidthStart = from.line;\n\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true;\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1) {\n      signalCursorActivity(cm);\n    }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n\n      if (recomputeMaxLength) {\n        cm.curOp.updateMaxLine = true;\n      }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n    var lendiff = change.text.length - (to.line - from.line) - 1; // Remember that these lines changed, for updating the display\n\n    if (change.full) {\n      regChange(cm);\n    } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {\n      regLineChange(cm, from.line, \"text\");\n    } else {\n      regChange(cm, from.line, to.line + 1, lendiff);\n    }\n\n    var changesHandler = hasHandler(cm, \"changes\"),\n        changeHandler = hasHandler(cm, \"change\");\n\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from,\n        to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n\n      if (changeHandler) {\n        signalLater(cm, \"change\", cm, obj);\n      }\n\n      if (changesHandler) {\n        (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\n      }\n    }\n\n    cm.display.selForContextMenu = null;\n  }\n\n  function _replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) {\n      to = from;\n    }\n\n    if (cmp(to, from) < 0) {\n      assign = [to, from], from = assign[0], to = assign[1];\n    }\n\n    if (typeof code == \"string\") {\n      code = doc.splitLines(code);\n    }\n\n    makeChange(doc, {\n      from: from,\n      to: to,\n      text: code,\n      origin: origin\n    });\n  } // Rebasing/resetting history to deal with externally-sourced changes\n\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  } // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n\n\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i],\n          ok = true;\n\n      if (sub.ranges) {\n        if (!sub.copied) {\n          sub = array[i] = sub.deepCopy();\n          sub.copied = true;\n        }\n\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n\n        continue;\n      }\n\n      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break;\n        }\n      }\n\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line,\n        to = change.to.line,\n        diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  } // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n\n\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle,\n        line = handle;\n\n    if (typeof handle == \"number\") {\n      line = getLine(doc, clipLine(doc, handle));\n    } else {\n      no = lineNo(handle);\n    }\n\n    if (no == null) {\n      return null;\n    }\n\n    if (op(line, no) && doc.cm) {\n      regLineChange(doc.cm, no, changeType);\n    }\n\n    return line;\n  } // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n\n  function LeafChunk(lines) {\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i].parent = this;\n      height += lines[i].height;\n    }\n\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function chunkSize() {\n      return this.lines.length;\n    },\n    // Remove the n lines at offset 'at'.\n    removeInner: function removeInner(at, n) {\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this.lines[i];\n        this.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n\n      this.lines.splice(at, n);\n    },\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function collapse(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function insertInner(at, lines, height) {\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n\n      for (var i = 0; i < lines.length; ++i) {\n        lines[i].parent = this;\n      }\n    },\n    // Used to iterate over a part of the tree.\n    iterN: function iterN(at, n, op) {\n      for (var e = at + n; at < e; ++at) {\n        if (op(this.lines[at])) {\n          return true;\n        }\n      }\n    }\n  };\n\n  function BranchChunk(children) {\n    this.children = children;\n    var size = 0,\n        height = 0;\n\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize();\n      height += ch.height;\n      ch.parent = this;\n    }\n\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function chunkSize() {\n      return this.size;\n    },\n    removeInner: function removeInner(at, n) {\n      this.size -= n;\n\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i],\n            sz = child.chunkSize();\n\n        if (at < sz) {\n          var rm = Math.min(n, sz - at),\n              oldHeight = child.height;\n          child.removeInner(at, rm);\n          this.height -= oldHeight - child.height;\n\n          if (sz == rm) {\n            this.children.splice(i--, 1);\n            child.parent = null;\n          }\n\n          if ((n -= rm) == 0) {\n            break;\n          }\n\n          at = 0;\n        } else {\n          at -= sz;\n        }\n      } // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n\n\n      if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n    collapse: function collapse(lines) {\n      for (var i = 0; i < this.children.length; ++i) {\n        this.children[i].collapse(lines);\n      }\n    },\n    insertInner: function insertInner(at, lines, height) {\n      this.size += lines.length;\n      this.height += height;\n\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i],\n            sz = child.chunkSize();\n\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this.children.splice(++i, 0, leaf);\n              leaf.parent = this;\n            }\n\n            child.lines = child.lines.slice(0, remaining);\n            this.maybeSpill();\n          }\n\n          break;\n        }\n\n        at -= sz;\n      }\n    },\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function maybeSpill() {\n      if (this.children.length <= 10) {\n        return;\n      }\n\n      var me = this;\n\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n\n        if (!me.parent) {\n          // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n        } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n\n        sibling.parent = me.parent;\n      } while (me.children.length > 10);\n\n      me.parent.maybeSpill();\n    },\n    iterN: function iterN(at, n, op) {\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this.children[i],\n            sz = child.chunkSize();\n\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n\n          if (child.iterN(at, used, op)) {\n            return true;\n          }\n\n          if ((n -= used) == 0) {\n            break;\n          }\n\n          at = 0;\n        } else {\n          at -= sz;\n        }\n      }\n    }\n  }; // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function LineWidget(doc, node, options) {\n    if (options) {\n      for (var opt in options) {\n        if (options.hasOwnProperty(opt)) {\n          this[opt] = options[opt];\n        }\n      }\n    }\n\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n    var cm = this.doc.cm,\n        ws = this.line.widgets,\n        line = this.line,\n        no = lineNo(line);\n\n    if (no == null || !ws) {\n      return;\n    }\n\n    for (var i = 0; i < ws.length; ++i) {\n      if (ws[i] == this) {\n        ws.splice(i--, 1);\n      }\n    }\n\n    if (!ws.length) {\n      line.widgets = null;\n    }\n\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, \"widget\");\n      });\n      signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n    var this$1 = this;\n    var oldH = this.height,\n        cm = this.doc.cm,\n        line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n\n    if (!diff) {\n      return;\n    }\n\n    if (!lineIsHidden(this.doc, line)) {\n      updateLineHeight(line, line.height + diff);\n    }\n\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n      });\n    }\n  };\n\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (_heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {\n      addToScrollTop(cm, diff);\n    }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n\n    if (cm && widget.noHScroll) {\n      cm.display.alignWidgets = true;\n    }\n\n    changeLine(doc, handle, \"widget\", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n\n      if (widget.insertAt == null) {\n        widgets.push(widget);\n      } else {\n        widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);\n      }\n\n      widget.line = line;\n\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = _heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n\n        if (aboveVisible) {\n          addToScrollTop(cm, widget.height);\n        }\n\n        cm.curOp.forceUpdate = true;\n      }\n\n      return true;\n    });\n\n    if (cm) {\n      signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle));\n    }\n\n    return widget;\n  } // TEXTMARKERS\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n\n\n  var nextMarkerId = 0;\n\n  var TextMarker = function TextMarker(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  }; // Clear the marker.\n\n\n  TextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) {\n      return;\n    }\n\n    var cm = this.doc.cm,\n        withOp = cm && !cm.curOp;\n\n    if (withOp) {\n      _startOperation(cm);\n    }\n\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n\n      if (found) {\n        signalLater(this, \"clear\", found.from, found.to);\n      }\n    }\n\n    var min = null,\n        max = null;\n\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n\n      if (cm && !this.collapsed) {\n        regLineChange(cm, lineNo(line), \"text\");\n      } else if (cm) {\n        if (span.to != null) {\n          max = lineNo(line);\n        }\n\n        if (span.from != null) {\n          min = lineNo(line);\n        }\n      }\n\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {\n        updateLineHeight(line, textHeight(cm.display));\n      }\n    }\n\n    if (cm && this.collapsed && !cm.options.lineWrapping) {\n      for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n        var visual = visualLine(this.lines[i$1]),\n            len = lineLength(visual);\n\n        if (len > cm.display.maxLineLength) {\n          cm.display.maxLine = visual;\n          cm.display.maxLineLength = len;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n\n    if (min != null && cm && this.collapsed) {\n      regChange(cm, min, max + 1);\n    }\n\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n\n      if (cm) {\n        reCheckSelection(cm.doc);\n      }\n    }\n\n    if (cm) {\n      signalLater(cm, \"markerCleared\", cm, this, min, max);\n    }\n\n    if (withOp) {\n      _endOperation(cm);\n    }\n\n    if (this.parent) {\n      this.parent.clear();\n    }\n  }; // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n\n\n  TextMarker.prototype.find = function (side, lineObj) {\n    if (side == null && this.type == \"bookmark\") {\n      side = 1;\n    }\n\n    var from, to;\n\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this);\n\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n\n        if (side == -1) {\n          return from;\n        }\n      }\n\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n\n        if (side == 1) {\n          return to;\n        }\n      }\n    }\n\n    return from && {\n      from: from,\n      to: to\n    };\n  }; // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n\n\n  TextMarker.prototype.changed = function () {\n    var this$1 = this;\n    var pos = this.find(-1, true),\n        widget = this,\n        cm = this.doc.cm;\n\n    if (!pos || !cm) {\n      return;\n    }\n\n    runInOp(cm, function () {\n      var line = pos.line,\n          lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n\n      cm.curOp.updateMaxLine = true;\n\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n\n        if (dHeight) {\n          updateLineHeight(line, line.height + dHeight);\n        }\n      }\n\n      signalLater(cm, \"markerChanged\", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\n      }\n    }\n\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n\n  eventMixin(TextMarker); // Create a marker, wire it up to the right lines, and\n\n  function _markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) {\n      return markTextShared(doc, from, to, options, type);\n    } // Ensure we are in an operation.\n\n\n    if (doc.cm && !doc.cm.curOp) {\n      return operation(doc.cm, _markText)(doc, from, to, options, type);\n    }\n\n    var marker = new TextMarker(doc, type),\n        diff = cmp(from, to);\n\n    if (options) {\n      copyObj(options, marker, false);\n    } // Don't connect empty markers unless clearWhenEmpty is false\n\n\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false) {\n      return marker;\n    }\n\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n\n      if (!options.handleMouseEvents) {\n        marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\");\n      }\n\n      if (options.insertLeft) {\n        marker.widgetNode.insertLeft = true;\n      }\n    }\n\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {\n        throw new Error(\"Inserting collapsed marker partially overlapping an existing one\");\n      }\n\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory) {\n      addChangeToHistory(doc, {\n        from: from,\n        to: to,\n        origin: \"markText\"\n      }, doc.sel, NaN);\n    }\n\n    var curLine = from.line,\n        cm = doc.cm,\n        updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {\n        updateMaxLine = true;\n      }\n\n      if (marker.collapsed && curLine != from.line) {\n        updateLineHeight(line, 0);\n      }\n\n      addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null));\n      ++curLine;\n    }); // lineIsHidden depends on the presence of the spans, so needs a second pass\n\n    if (marker.collapsed) {\n      doc.iter(from.line, to.line + 1, function (line) {\n        if (lineIsHidden(doc, line)) {\n          updateLineHeight(line, 0);\n        }\n      });\n    }\n\n    if (marker.clearOnEnter) {\n      on(marker, \"beforeCursorEnter\", function () {\n        return marker.clear();\n      });\n    }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n\n      if (doc.history.done.length || doc.history.undone.length) {\n        doc.clearHistory();\n      }\n    }\n\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) {\n        cm.curOp.updateMaxLine = true;\n      }\n\n      if (marker.collapsed) {\n        regChange(cm, from.line, to.line + 1);\n      } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {\n        for (var i = from.line; i <= to.line; i++) {\n          regLineChange(cm, i, \"text\");\n        }\n      }\n\n      if (marker.atomic) {\n        reCheckSelection(cm.doc);\n      }\n\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n\n    return marker;\n  } // SHARED TEXTMARKERS\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n\n\n  var SharedTextMarker = function SharedTextMarker(markers, primary) {\n    this.markers = markers;\n    this.primary = primary;\n\n    for (var i = 0; i < markers.length; ++i) {\n      markers[i].parent = this;\n    }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n    if (this.explicitlyCleared) {\n      return;\n    }\n\n    this.explicitlyCleared = true;\n\n    for (var i = 0; i < this.markers.length; ++i) {\n      this.markers[i].clear();\n    }\n\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj);\n  };\n\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [_markText(doc, from, to, options, type)],\n        primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) {\n        options.widgetNode = widget.cloneNode(true);\n      }\n\n      markers.push(_markText(doc, _clipPos(doc, from), _clipPos(doc, to), options, type));\n\n      for (var i = 0; i < doc.linked.length; ++i) {\n        if (doc.linked[i].isParent) {\n          return;\n        }\n      }\n\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary);\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) {\n      return m.parent;\n    });\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i],\n          pos = marker.find();\n      var mFrom = doc.clipPos(pos.from),\n          mTo = doc.clipPos(pos.to);\n\n      if (cmp(mFrom, mTo)) {\n        var subMark = _markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function loop(i) {\n      var marker = markers[i],\n          linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) {\n        return linked.push(d);\n      });\n\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i < markers.length; i++) {\n      loop(i);\n    }\n  }\n\n  var nextDocId = 0;\n\n  var Doc = function Doc(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) {\n      return new Doc(text, mode, firstLine, lineSep, direction);\n    }\n\n    if (firstLine == null) {\n      firstLine = 0;\n    }\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = direction == \"rtl\" ? \"rtl\" : \"ltr\";\n    this.extend = false;\n\n    if (typeof text == \"string\") {\n      text = this.splitLines(text);\n    }\n\n    updateDoc(this, {\n      from: start,\n      to: start,\n      text: text\n    });\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function iter(from, to, op) {\n      if (op) {\n        this.iterN(from - this.first, to - from, op);\n      } else {\n        this.iterN(this.first, this.first + this.size, from);\n      }\n    },\n    // Non-public interface for adding and removing lines.\n    insert: function insert(at, lines) {\n      var height = 0;\n\n      for (var i = 0; i < lines.length; ++i) {\n        height += lines[i].height;\n      }\n\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function remove(at, n) {\n      this.removeInner(at - this.first, n);\n    },\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n    getValue: function getValue(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n\n      if (lineSep === false) {\n        return lines;\n      }\n\n      return lines.join(lineSep || this.lineSeparator());\n    },\n    setValue: docMethodOp(function (code) {\n      var top = Pos(this.first, 0),\n          last = this.first + this.size - 1;\n      makeChange(this, {\n        from: top,\n        to: Pos(last, getLine(this, last).text.length),\n        text: this.splitLines(code),\n        origin: \"setValue\",\n        full: true\n      }, true);\n\n      if (this.cm) {\n        scrollToCoords(this.cm, 0, 0);\n      }\n\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function replaceRange(code, from, to, origin) {\n      from = _clipPos(this, from);\n      to = to ? _clipPos(this, to) : from;\n\n      _replaceRange(this, code, from, to, origin);\n    },\n    getRange: function getRange(from, to, lineSep) {\n      var lines = getBetween(this, _clipPos(this, from), _clipPos(this, to));\n\n      if (lineSep === false) {\n        return lines;\n      }\n\n      return lines.join(lineSep || this.lineSeparator());\n    },\n    getLine: function getLine(line) {\n      var l = this.getLineHandle(line);\n      return l && l.text;\n    },\n    getLineHandle: function getLineHandle(line) {\n      if (isLine(this, line)) {\n        return getLine(this, line);\n      }\n    },\n    getLineNumber: function getLineNumber(line) {\n      return lineNo(line);\n    },\n    getLineHandleVisualStart: function getLineHandleVisualStart(line) {\n      if (typeof line == \"number\") {\n        line = getLine(this, line);\n      }\n\n      return visualLine(line);\n    },\n    lineCount: function lineCount() {\n      return this.size;\n    },\n    firstLine: function firstLine() {\n      return this.first;\n    },\n    lastLine: function lastLine() {\n      return this.first + this.size - 1;\n    },\n    clipPos: function clipPos(pos) {\n      return _clipPos(this, pos);\n    },\n    getCursor: function getCursor(start) {\n      var range = this.sel.primary(),\n          pos;\n\n      if (start == null || start == \"head\") {\n        pos = range.head;\n      } else if (start == \"anchor\") {\n        pos = range.anchor;\n      } else if (start == \"end\" || start == \"to\" || start === false) {\n        pos = range.to();\n      } else {\n        pos = range.from();\n      }\n\n      return pos;\n    },\n    listSelections: function listSelections() {\n      return this.sel.ranges;\n    },\n    somethingSelected: function somethingSelected() {\n      return this.sel.somethingSelected();\n    },\n    setCursor: docMethodOp(function (line, ch, options) {\n      setSimpleSelection(this, _clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function (anchor, head, options) {\n      setSimpleSelection(this, _clipPos(this, anchor), _clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function (head, other, options) {\n      extendSelection(this, _clipPos(this, head), other && _clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function (heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function (f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function (ranges, primary, options) {\n      if (!ranges.length) {\n        return;\n      }\n\n      var out = [];\n\n      for (var i = 0; i < ranges.length; i++) {\n        out[i] = new Range(_clipPos(this, ranges[i].anchor), _clipPos(this, ranges[i].head));\n      }\n\n      if (primary == null) {\n        primary = Math.min(ranges.length - 1, this.sel.primIndex);\n      }\n\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function (anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(_clipPos(this, anchor), _clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n    getSelection: function getSelection(lineSep) {\n      var ranges = this.sel.ranges,\n          lines;\n\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n\n      if (lineSep === false) {\n        return lines;\n      } else {\n        return lines.join(lineSep || this.lineSeparator());\n      }\n    },\n    getSelections: function getSelections(lineSep) {\n      var parts = [],\n          ranges = this.sel.ranges;\n\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\n\n        if (lineSep !== false) {\n          sel = sel.join(lineSep || this.lineSeparator());\n        }\n\n        parts[i] = sel;\n      }\n\n      return parts;\n    },\n    replaceSelection: function replaceSelection(code, collapse, origin) {\n      var dup = [];\n\n      for (var i = 0; i < this.sel.ranges.length; i++) {\n        dup[i] = code;\n      }\n\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function (code, collapse, origin) {\n      var changes = [],\n          sel = this.sel;\n\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range = sel.ranges[i];\n        changes[i] = {\n          from: range.from(),\n          to: range.to(),\n          text: this.splitLines(code[i]),\n          origin: origin\n        };\n      }\n\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n\n      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--) {\n        makeChange(this, changes[i$1]);\n      }\n\n      if (newSel) {\n        setSelectionReplaceHistory(this, newSel);\n      } else if (this.cm) {\n        ensureCursorVisible(this.cm);\n      }\n    }),\n    undo: docMethodOp(function () {\n      makeChangeFromHistory(this, \"undo\");\n    }),\n    redo: docMethodOp(function () {\n      makeChangeFromHistory(this, \"redo\");\n    }),\n    undoSelection: docMethodOp(function () {\n      makeChangeFromHistory(this, \"undo\", true);\n    }),\n    redoSelection: docMethodOp(function () {\n      makeChangeFromHistory(this, \"redo\", true);\n    }),\n    setExtending: function setExtending(val) {\n      this.extend = val;\n    },\n    getExtending: function getExtending() {\n      return this.extend;\n    },\n    historySize: function historySize() {\n      var hist = this.history,\n          done = 0,\n          undone = 0;\n\n      for (var i = 0; i < hist.done.length; i++) {\n        if (!hist.done[i].ranges) {\n          ++done;\n        }\n      }\n\n      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) {\n        if (!hist.undone[i$1].ranges) {\n          ++undone;\n        }\n      }\n\n      return {\n        undo: done,\n        redo: undone\n      };\n    },\n    clearHistory: function clearHistory() {\n      var this$1 = this;\n      this.history = new History(this.history.maxGeneration);\n      linkedDocs(this, function (doc) {\n        return doc.history = this$1.history;\n      }, true);\n    },\n    markClean: function markClean() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function changeGeneration(forceSplit) {\n      if (forceSplit) {\n        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\n      }\n\n      return this.history.generation;\n    },\n    isClean: function isClean(gen) {\n      return this.history.generation == (gen || this.cleanGeneration);\n    },\n    getHistory: function getHistory() {\n      return {\n        done: copyHistoryArray(this.history.done),\n        undone: copyHistoryArray(this.history.undone)\n      };\n    },\n    setHistory: function setHistory(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n    setGutterMarker: docMethodOp(function (line, gutterID, value) {\n      return changeLine(this, line, \"gutter\", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n\n        if (!value && isEmpty(markers)) {\n          line.gutterMarkers = null;\n        }\n\n        return true;\n      });\n    }),\n    clearGutter: docMethodOp(function (gutterID) {\n      var this$1 = this;\n      this.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, \"gutter\", function () {\n            line.gutterMarkers[gutterID] = null;\n\n            if (isEmpty(line.gutterMarkers)) {\n              line.gutterMarkers = null;\n            }\n\n            return true;\n          });\n        }\n      });\n    }),\n    lineInfo: function lineInfo(line) {\n      var n;\n\n      if (typeof line == \"number\") {\n        if (!isLine(this, line)) {\n          return null;\n        }\n\n        n = line;\n        line = getLine(this, line);\n\n        if (!line) {\n          return null;\n        }\n      } else {\n        n = lineNo(line);\n\n        if (n == null) {\n          return null;\n        }\n      }\n\n      return {\n        line: n,\n        handle: line,\n        text: line.text,\n        gutterMarkers: line.gutterMarkers,\n        textClass: line.textClass,\n        bgClass: line.bgClass,\n        wrapClass: line.wrapClass,\n        widgets: line.widgets\n      };\n    },\n    addLineClass: docMethodOp(function (handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n\n        if (!line[prop]) {\n          line[prop] = cls;\n        } else if (classTest(cls).test(line[prop])) {\n          return false;\n        } else {\n          line[prop] += \" \" + cls;\n        }\n\n        return true;\n      });\n    }),\n    removeLineClass: docMethodOp(function (handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\" : where == \"background\" ? \"bgClass\" : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n\n        if (!cur) {\n          return false;\n        } else if (cls == null) {\n          line[prop] = null;\n        } else {\n          var found = cur.match(classTest(cls));\n\n          if (!found) {\n            return false;\n          }\n\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n\n        return true;\n      });\n    }),\n    addLineWidget: docMethodOp(function (handle, node, options) {\n      return addLineWidget(this, handle, node, options);\n    }),\n    removeLineWidget: function removeLineWidget(widget) {\n      widget.clear();\n    },\n    markText: function markText(from, to, options) {\n      return _markText(this, _clipPos(this, from), _clipPos(this, to), options, options && options.type || \"range\");\n    },\n    setBookmark: function setBookmark(pos, options) {\n      var realOpts = {\n        replacedWith: options && (options.nodeType == null ? options.widget : options),\n        insertLeft: options && options.insertLeft,\n        clearWhenEmpty: false,\n        shared: options && options.shared,\n        handleMouseEvents: options && options.handleMouseEvents\n      };\n      pos = _clipPos(this, pos);\n      return _markText(this, pos, pos, realOpts, \"bookmark\");\n    },\n    findMarksAt: function findMarksAt(pos) {\n      pos = _clipPos(this, pos);\n      var markers = [],\n          spans = getLine(this, pos.line).markedSpans;\n\n      if (spans) {\n        for (var i = 0; i < spans.length; ++i) {\n          var span = spans[i];\n\n          if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {\n            markers.push(span.marker.parent || span.marker);\n          }\n        }\n      }\n\n      return markers;\n    },\n    findMarks: function findMarks(from, to, filter) {\n      from = _clipPos(this, from);\n      to = _clipPos(this, to);\n      var found = [],\n          lineNo = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n\n        if (spans) {\n          for (var i = 0; i < spans.length; i++) {\n            var span = spans[i];\n\n            if (!(span.to != null && lineNo == from.line && from.ch >= span.to || span.from == null && lineNo != from.line || span.from != null && lineNo == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {\n              found.push(span.marker.parent || span.marker);\n            }\n          }\n        }\n\n        ++lineNo;\n      });\n      return found;\n    },\n    getAllMarks: function getAllMarks() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n\n        if (sps) {\n          for (var i = 0; i < sps.length; ++i) {\n            if (sps[i].from != null) {\n              markers.push(sps[i].marker);\n            }\n          }\n        }\n      });\n      return markers;\n    },\n    posFromIndex: function posFromIndex(off) {\n      var ch,\n          lineNo = this.first,\n          sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n\n        if (sz > off) {\n          ch = off;\n          return true;\n        }\n\n        off -= sz;\n        ++lineNo;\n      });\n      return _clipPos(this, Pos(lineNo, ch));\n    },\n    indexFromPos: function indexFromPos(coords) {\n      coords = _clipPos(this, coords);\n      var index = coords.ch;\n\n      if (coords.line < this.first || coords.ch < 0) {\n        return 0;\n      }\n\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) {\n        // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index;\n    },\n    copy: function copy(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop;\n      doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n\n      return doc;\n    },\n    linkedDoc: function linkedDoc(options) {\n      if (!options) {\n        options = {};\n      }\n\n      var from = this.first,\n          to = this.first + this.size;\n\n      if (options.from != null && options.from > from) {\n        from = options.from;\n      }\n\n      if (options.to != null && options.to < to) {\n        to = options.to;\n      }\n\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n\n      if (options.sharedHist) {\n        copy.history = this.history;\n      }\n\n      (this.linked || (this.linked = [])).push({\n        doc: copy,\n        sharedHist: options.sharedHist\n      });\n      copy.linked = [{\n        doc: this,\n        isParent: true,\n        sharedHist: options.sharedHist\n      }];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy;\n    },\n    unlinkDoc: function unlinkDoc(other) {\n      if (other instanceof CodeMirror) {\n        other = other.doc;\n      }\n\n      if (this.linked) {\n        for (var i = 0; i < this.linked.length; ++i) {\n          var link = this.linked[i];\n\n          if (link.doc != other) {\n            continue;\n          }\n\n          this.linked.splice(i, 1);\n          other.unlinkDoc(this);\n          detachSharedMarkers(findSharedMarkers(this));\n          break;\n        }\n      } // If the histories were shared, split them again\n\n\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) {\n          return splitIds.push(doc.id);\n        }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function iterLinkedDocs(f) {\n      linkedDocs(this, f);\n    },\n    getMode: function getMode() {\n      return this.mode;\n    },\n    getEditor: function getEditor() {\n      return this.cm;\n    },\n    splitLines: function splitLines(str) {\n      if (this.lineSep) {\n        return str.split(this.lineSep);\n      }\n\n      return splitLinesAuto(str);\n    },\n    lineSeparator: function lineSeparator() {\n      return this.lineSep || \"\\n\";\n    },\n    setDirection: docMethodOp(function (dir) {\n      if (dir != \"rtl\") {\n        dir = \"ltr\";\n      }\n\n      if (dir == this.direction) {\n        return;\n      }\n\n      this.direction = dir;\n      this.iter(function (line) {\n        return line.order = null;\n      });\n\n      if (this.cm) {\n        directionChanged(this.cm);\n      }\n    })\n  }); // Public alias.\n\n  Doc.prototype.eachLine = Doc.prototype.iter; // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n      return;\n    }\n\n    e_preventDefault(e);\n\n    if (ie) {\n      lastDrop = +new Date();\n    }\n\n    var pos = posFromMouse(cm, e, true),\n        files = e.dataTransfer.files;\n\n    if (!pos || cm.isReadOnly()) {\n      return;\n    } // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n\n\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length,\n          text = Array(n),\n          read = 0;\n\n      var markAsReadAndPasteIfAllFilesAreRead = function markAsReadAndPasteIfAllFilesAreRead() {\n        if (++read == n) {\n          operation(cm, function () {\n            pos = _clipPos(cm.doc, pos);\n            var change = {\n              from: pos,\n              to: pos,\n              text: cm.doc.splitLines(text.filter(function (t) {\n                return t != null;\n              }).join(cm.doc.lineSeparator())),\n              origin: \"paste\"\n            };\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(_clipPos(cm.doc, pos), _clipPos(cm.doc, changeEnd(change))));\n          })();\n        }\n      };\n\n      var readTextFromFile = function readTextFromFile(file, i) {\n        if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {\n          markAsReadAndPasteIfAllFilesAreRead();\n          return;\n        }\n\n        var reader = new FileReader();\n\n        reader.onerror = function () {\n          return markAsReadAndPasteIfAllFilesAreRead();\n        };\n\n        reader.onload = function () {\n          var content = reader.result;\n\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) {\n            markAsReadAndPasteIfAllFilesAreRead();\n            return;\n          }\n\n          text[i] = content;\n          markAsReadAndPasteIfAllFilesAreRead();\n        };\n\n        reader.readAsText(file);\n      };\n\n      for (var i = 0; i < files.length; i++) {\n        readTextFromFile(files[i], i);\n      }\n    } else {\n      // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e); // Ensure the editor is re-focused\n\n        setTimeout(function () {\n          return cm.display.input.focus();\n        }, 20);\n        return;\n      }\n\n      try {\n        var text$1 = e.dataTransfer.getData(\"Text\");\n\n        if (text$1) {\n          var selected;\n\n          if (cm.state.draggingText && !cm.state.draggingText.copy) {\n            selected = cm.listSelections();\n          }\n\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n\n          if (selected) {\n            for (var i$1 = 0; i$1 < selected.length; ++i$1) {\n              _replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\");\n            }\n          }\n\n          cm.replaceSelection(text$1, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      } catch (e$1) {}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {\n      e_stop(e);\n      return;\n    }\n\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {\n      return;\n    }\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\"; // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img); // Force a relayout, or Opera won't use our image for some obscure reason\n\n        img._top = img.offsetTop;\n      }\n\n      e.dataTransfer.setDragImage(img, 0, 0);\n\n      if (presto) {\n        img.parentNode.removeChild(img);\n      }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n\n    if (!pos) {\n      return;\n    }\n\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  } // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) {\n      return;\n    }\n\n    var byClass = document.getElementsByClassName(\"CodeMirror\"),\n        editors = [];\n\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n\n      if (cm) {\n        editors.push(cm);\n      }\n    }\n\n    if (editors.length) {\n      editors[0].operation(function () {\n        for (var i = 0; i < editors.length; i++) {\n          f(editors[i]);\n        }\n      });\n    }\n  }\n\n  var globalsRegistered = false;\n\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) {\n      return;\n    }\n\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function () {\n      if (resizeTimer == null) {\n        resizeTimer = setTimeout(function () {\n          resizeTimer = null;\n          forEachCodeMirror(onResize);\n        }, 100);\n      }\n    }); // When the window loses focus, we want to show the editor as blurred\n\n    on(window, \"blur\", function () {\n      return forEachCodeMirror(onBlur);\n    });\n  } // Called when the window resizes\n\n\n  function onResize(cm) {\n    var d = cm.display; // Might be a text scaling operation, clear size caches.\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: \"Pause\",\n    8: \"Backspace\",\n    9: \"Tab\",\n    13: \"Enter\",\n    16: \"Shift\",\n    17: \"Ctrl\",\n    18: \"Alt\",\n    19: \"Pause\",\n    20: \"CapsLock\",\n    27: \"Esc\",\n    32: \"Space\",\n    33: \"PageUp\",\n    34: \"PageDown\",\n    35: \"End\",\n    36: \"Home\",\n    37: \"Left\",\n    38: \"Up\",\n    39: \"Right\",\n    40: \"Down\",\n    44: \"PrintScrn\",\n    45: \"Insert\",\n    46: \"Delete\",\n    59: \";\",\n    61: \"=\",\n    91: \"Mod\",\n    92: \"Mod\",\n    93: \"Mod\",\n    106: \"*\",\n    107: \"=\",\n    109: \"-\",\n    110: \".\",\n    111: \"/\",\n    145: \"ScrollLock\",\n    173: \"-\",\n    186: \";\",\n    187: \"=\",\n    188: \",\",\n    189: \"-\",\n    190: \".\",\n    191: \"/\",\n    192: \"`\",\n    219: \"[\",\n    220: \"\\\\\",\n    221: \"]\",\n    222: \"'\",\n    224: \"Mod\",\n    63232: \"Up\",\n    63233: \"Down\",\n    63234: \"Left\",\n    63235: \"Right\",\n    63272: \"Delete\",\n    63273: \"Home\",\n    63275: \"End\",\n    63276: \"PageUp\",\n    63277: \"PageDown\",\n    63302: \"Insert\"\n  }; // Number keys\n\n  for (var i = 0; i < 10; i++) {\n    keyNames[i + 48] = keyNames[i + 96] = String(i);\n  } // Alphabetic keys\n\n\n  for (var i$1 = 65; i$1 <= 90; i$1++) {\n    keyNames[i$1] = String.fromCharCode(i$1);\n  } // Function keys\n\n\n  for (var i$2 = 1; i$2 <= 12; i$2++) {\n    keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2;\n  }\n\n  var keyMap = {};\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\",\n    \"Right\": \"goCharRight\",\n    \"Up\": \"goLineUp\",\n    \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\",\n    \"Home\": \"goLineStartSmart\",\n    \"PageUp\": \"goPageUp\",\n    \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\",\n    \"Backspace\": \"delCharBefore\",\n    \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\",\n    \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\",\n    \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  }; // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\",\n    \"Ctrl-D\": \"deleteLine\",\n    \"Ctrl-Z\": \"undo\",\n    \"Shift-Ctrl-Z\": \"redo\",\n    \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\",\n    \"Ctrl-End\": \"goDocEnd\",\n    \"Ctrl-Up\": \"goLineUp\",\n    \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\",\n    \"Ctrl-Right\": \"goGroupRight\",\n    \"Alt-Left\": \"goLineStart\",\n    \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Delete\": \"delGroupAfter\",\n    \"Ctrl-S\": \"save\",\n    \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\",\n    \"Shift-Ctrl-G\": \"findPrev\",\n    \"Shift-Ctrl-F\": \"replace\",\n    \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\",\n    \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\",\n    \"Shift-Ctrl-U\": \"redoSelection\",\n    \"Alt-U\": \"redoSelection\",\n    \"fallthrough\": \"basic\"\n  }; // Very basic readline/emacs-style bindings, which are standard on Mac.\n\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\",\n    \"Ctrl-B\": \"goCharLeft\",\n    \"Ctrl-P\": \"goLineUp\",\n    \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\",\n    \"Alt-B\": \"goWordLeft\",\n    \"Ctrl-A\": \"goLineStart\",\n    \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\",\n    \"Shift-Ctrl-V\": \"goPageUp\",\n    \"Ctrl-D\": \"delCharAfter\",\n    \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\",\n    \"Alt-Backspace\": \"delWordBefore\",\n    \"Ctrl-K\": \"killLine\",\n    \"Ctrl-T\": \"transposeChars\",\n    \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\",\n    \"Cmd-D\": \"deleteLine\",\n    \"Cmd-Z\": \"undo\",\n    \"Shift-Cmd-Z\": \"redo\",\n    \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\",\n    \"Cmd-Up\": \"goDocStart\",\n    \"Cmd-End\": \"goDocEnd\",\n    \"Cmd-Down\": \"goDocEnd\",\n    \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\",\n    \"Cmd-Left\": \"goLineLeft\",\n    \"Cmd-Right\": \"goLineRight\",\n    \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\",\n    \"Alt-Delete\": \"delGroupAfter\",\n    \"Cmd-S\": \"save\",\n    \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\",\n    \"Shift-Cmd-G\": \"findPrev\",\n    \"Cmd-Alt-F\": \"replace\",\n    \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\",\n    \"Cmd-]\": \"indentMore\",\n    \"Cmd-Backspace\": \"delWrappedLineLeft\",\n    \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\",\n    \"Shift-Cmd-U\": \"redoSelection\",\n    \"Ctrl-Up\": \"goDocStart\",\n    \"Ctrl-Down\": \"goDocEnd\",\n    \"fallthrough\": [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault; // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n\n      if (/^(cmd|meta|m)$/i.test(mod)) {\n        cmd = true;\n      } else if (/^a(lt)?$/i.test(mod)) {\n        alt = true;\n      } else if (/^(c|ctrl|control)$/i.test(mod)) {\n        ctrl = true;\n      } else if (/^s(hift)?$/i.test(mod)) {\n        shift = true;\n      } else {\n        throw new Error(\"Unrecognized modifier name: \" + mod);\n      }\n    }\n\n    if (alt) {\n      name = \"Alt-\" + name;\n    }\n\n    if (ctrl) {\n      name = \"Ctrl-\" + name;\n    }\n\n    if (cmd) {\n      name = \"Cmd-\" + name;\n    }\n\n    if (shift) {\n      name = \"Shift-\" + name;\n    }\n\n    return name;\n  } // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n\n\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n\n    for (var keyname in keymap) {\n      if (keymap.hasOwnProperty(keyname)) {\n        var value = keymap[keyname];\n\n        if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {\n          continue;\n        }\n\n        if (value == \"...\") {\n          delete keymap[keyname];\n          continue;\n        }\n\n        var keys = map(keyname.split(\" \"), normalizeKeyName);\n\n        for (var i = 0; i < keys.length; i++) {\n          var val = void 0,\n              name = void 0;\n\n          if (i == keys.length - 1) {\n            name = keys.join(\" \");\n            val = value;\n          } else {\n            name = keys.slice(0, i + 1).join(\" \");\n            val = \"...\";\n          }\n\n          var prev = copy[name];\n\n          if (!prev) {\n            copy[name] = val;\n          } else if (prev != val) {\n            throw new Error(\"Inconsistent bindings for \" + name);\n          }\n        }\n\n        delete keymap[keyname];\n      }\n    }\n\n    for (var prop in copy) {\n      keymap[prop] = copy[prop];\n    }\n\n    return keymap;\n  }\n\n  function lookupKey(key, map, handle, context) {\n    map = getKeyMap(map);\n    var found = map.call ? map.call(key, context) : map[key];\n\n    if (found === false) {\n      return \"nothing\";\n    }\n\n    if (found === \"...\") {\n      return \"multi\";\n    }\n\n    if (found != null && handle(found)) {\n      return \"handled\";\n    }\n\n    if (map.fallthrough) {\n      if (Object.prototype.toString.call(map.fallthrough) != \"[object Array]\") {\n        return lookupKey(key, map.fallthrough, handle, context);\n      }\n\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle, context);\n\n        if (result) {\n          return result;\n        }\n      }\n    }\n  } // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n\n\n  function isModifierKey(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\";\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n\n    if (event.altKey && base != \"Alt\") {\n      name = \"Alt-\" + name;\n    }\n\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") {\n      name = \"Ctrl-\" + name;\n    }\n\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Mod\") {\n      name = \"Cmd-\" + name;\n    }\n\n    if (!noShift && event.shiftKey && base != \"Shift\") {\n      name = \"Shift-\" + name;\n    }\n\n    return name;\n  } // Look up the name of a key as indicated by an event object.\n\n\n  function keyName(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) {\n      return false;\n    }\n\n    var name = keyNames[event.keyCode];\n\n    if (name == null || event.altGraphKey) {\n      return false;\n    } // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n\n\n    if (event.keyCode == 3 && event.code) {\n      name = event.code;\n    }\n\n    return addModifierNames(name, event, noShift);\n  }\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val;\n  } // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n\n\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges,\n        kill = []; // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break;\n        }\n      }\n\n      kill.push(toKill);\n    } // Next, remove those actual ranges.\n\n\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i >= 0; i--) {\n        _replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\");\n      }\n\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target < 0 || target > line.text.length ? null : target;\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\");\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      if (cm.doc.direction == \"rtl\") {\n        dir = -dir;\n      }\n\n      var order = getOrder(lineObj, cm.doc.direction);\n\n      if (order) {\n        var part = dir < 0 ? lst(order) : order[0];\n        var moveInStorageOrder = dir < 0 == (part.level == 1);\n        var sticky = moveInStorageOrder ? \"after\" : \"before\";\n        var ch; // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n\n        if (part.level > 0 || cm.doc.direction == \"rtl\") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir < 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) {\n            return measureCharPrepared(cm, prep, ch).top == targetTop;\n          }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);\n\n          if (sticky == \"before\") {\n            ch = moveCharLogically(lineObj, ch, 1);\n          }\n        } else {\n          ch = dir < 0 ? part.to : part.from;\n        }\n\n        return new Pos(lineNo, ch, sticky);\n      }\n    }\n\n    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\");\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n\n    if (!bidi) {\n      return moveLogically(line, start, dir);\n    }\n\n    if (start.ch >= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = \"before\";\n    } else if (start.ch <= 0) {\n      start.ch = 0;\n      start.sticky = \"after\";\n    }\n\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky),\n        part = bidi[partPos];\n\n    if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir);\n    }\n\n    var mv = function mv(pos, dir) {\n      return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir);\n    };\n\n    var prep;\n\n    var getWrappedLineExtent = function getWrappedLineExtent(ch) {\n      if (!cm.options.lineWrapping) {\n        return {\n          begin: 0,\n          end: line.text.length\n        };\n      }\n\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch);\n    };\n\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == \"rtl\" || part.level == 1) {\n      var moveInStorageOrder = part.level == 1 == dir < 0;\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n\n      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? \"before\" : \"after\";\n        return new Pos(start.line, ch, sticky);\n      }\n    } // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n\n    var searchInVisualLine = function searchInVisualLine(partPos, dir, wrappedLineExtent) {\n      var getRes = function getRes(ch, moveInStorageOrder) {\n        return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), \"before\") : new Pos(start.line, ch, \"after\");\n      };\n\n      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = dir > 0 == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n\n        if (part.from <= ch && ch < part.to) {\n          return getRes(ch, moveInStorageOrder);\n        }\n\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n\n        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) {\n          return getRes(ch, moveInStorageOrder);\n        }\n      }\n    }; // Case 3a: Look for other bidi parts on the same visual line\n\n\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n\n    if (res) {\n      return res;\n    } // Case 3b: Look for other bidi parts on the next visual line\n\n\n    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n\n    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n\n      if (res) {\n        return res;\n      }\n    } // Case 4: Nowhere to move\n\n\n    return null;\n  } // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n\n\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function singleSelection(cm) {\n      return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll);\n    },\n    killLine: function killLine(cm) {\n      return deleteNearSelection(cm, function (range) {\n        if (range.empty()) {\n          var len = getLine(cm.doc, range.head.line).text.length;\n\n          if (range.head.ch == len && range.head.line < cm.lastLine()) {\n            return {\n              from: range.head,\n              to: Pos(range.head.line + 1, 0)\n            };\n          } else {\n            return {\n              from: range.head,\n              to: Pos(range.head.line, len)\n            };\n          }\n        } else {\n          return {\n            from: range.from(),\n            to: range.to()\n          };\n        }\n      });\n    },\n    deleteLine: function deleteLine(cm) {\n      return deleteNearSelection(cm, function (range) {\n        return {\n          from: Pos(range.from().line, 0),\n          to: _clipPos(cm.doc, Pos(range.to().line + 1, 0))\n        };\n      });\n    },\n    delLineLeft: function delLineLeft(cm) {\n      return deleteNearSelection(cm, function (range) {\n        return {\n          from: Pos(range.from().line, 0),\n          to: range.from()\n        };\n      });\n    },\n    delWrappedLineLeft: function delWrappedLineLeft(cm) {\n      return deleteNearSelection(cm, function (range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var leftPos = cm.coordsChar({\n          left: 0,\n          top: top\n        }, \"div\");\n        return {\n          from: leftPos,\n          to: range.from()\n        };\n      });\n    },\n    delWrappedLineRight: function delWrappedLineRight(cm) {\n      return deleteNearSelection(cm, function (range) {\n        var top = cm.charCoords(range.head, \"div\").top + 5;\n        var rightPos = cm.coordsChar({\n          left: cm.display.lineDiv.offsetWidth + 100,\n          top: top\n        }, \"div\");\n        return {\n          from: range.from(),\n          to: rightPos\n        };\n      });\n    },\n    undo: function undo(cm) {\n      return cm.undo();\n    },\n    redo: function redo(cm) {\n      return cm.redo();\n    },\n    undoSelection: function undoSelection(cm) {\n      return cm.undoSelection();\n    },\n    redoSelection: function redoSelection(cm) {\n      return cm.redoSelection();\n    },\n    goDocStart: function goDocStart(cm) {\n      return cm.extendSelection(Pos(cm.firstLine(), 0));\n    },\n    goDocEnd: function goDocEnd(cm) {\n      return cm.extendSelection(Pos(cm.lastLine()));\n    },\n    goLineStart: function goLineStart(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        return lineStart(cm, range.head.line);\n      }, {\n        origin: \"+move\",\n        bias: 1\n      });\n    },\n    goLineStartSmart: function goLineStartSmart(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        return lineStartSmart(cm, range.head);\n      }, {\n        origin: \"+move\",\n        bias: 1\n      });\n    },\n    goLineEnd: function goLineEnd(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        return lineEnd(cm, range.head.line);\n      }, {\n        origin: \"+move\",\n        bias: -1\n      });\n    },\n    goLineRight: function goLineRight(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        var top = cm.cursorCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({\n          left: cm.display.lineDiv.offsetWidth + 100,\n          top: top\n        }, \"div\");\n      }, sel_move);\n    },\n    goLineLeft: function goLineLeft(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        var top = cm.cursorCoords(range.head, \"div\").top + 5;\n        return cm.coordsChar({\n          left: 0,\n          top: top\n        }, \"div\");\n      }, sel_move);\n    },\n    goLineLeftSmart: function goLineLeftSmart(cm) {\n      return cm.extendSelectionsBy(function (range) {\n        var top = cm.cursorCoords(range.head, \"div\").top + 5;\n        var pos = cm.coordsChar({\n          left: 0,\n          top: top\n        }, \"div\");\n\n        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) {\n          return lineStartSmart(cm, range.head);\n        }\n\n        return pos;\n      }, sel_move);\n    },\n    goLineUp: function goLineUp(cm) {\n      return cm.moveV(-1, \"line\");\n    },\n    goLineDown: function goLineDown(cm) {\n      return cm.moveV(1, \"line\");\n    },\n    goPageUp: function goPageUp(cm) {\n      return cm.moveV(-1, \"page\");\n    },\n    goPageDown: function goPageDown(cm) {\n      return cm.moveV(1, \"page\");\n    },\n    goCharLeft: function goCharLeft(cm) {\n      return cm.moveH(-1, \"char\");\n    },\n    goCharRight: function goCharRight(cm) {\n      return cm.moveH(1, \"char\");\n    },\n    goColumnLeft: function goColumnLeft(cm) {\n      return cm.moveH(-1, \"column\");\n    },\n    goColumnRight: function goColumnRight(cm) {\n      return cm.moveH(1, \"column\");\n    },\n    goWordLeft: function goWordLeft(cm) {\n      return cm.moveH(-1, \"word\");\n    },\n    goGroupRight: function goGroupRight(cm) {\n      return cm.moveH(1, \"group\");\n    },\n    goGroupLeft: function goGroupLeft(cm) {\n      return cm.moveH(-1, \"group\");\n    },\n    goWordRight: function goWordRight(cm) {\n      return cm.moveH(1, \"word\");\n    },\n    delCharBefore: function delCharBefore(cm) {\n      return cm.deleteH(-1, \"codepoint\");\n    },\n    delCharAfter: function delCharAfter(cm) {\n      return cm.deleteH(1, \"char\");\n    },\n    delWordBefore: function delWordBefore(cm) {\n      return cm.deleteH(-1, \"word\");\n    },\n    delWordAfter: function delWordAfter(cm) {\n      return cm.deleteH(1, \"word\");\n    },\n    delGroupBefore: function delGroupBefore(cm) {\n      return cm.deleteH(-1, \"group\");\n    },\n    delGroupAfter: function delGroupAfter(cm) {\n      return cm.deleteH(1, \"group\");\n    },\n    indentAuto: function indentAuto(cm) {\n      return cm.indentSelection(\"smart\");\n    },\n    indentMore: function indentMore(cm) {\n      return cm.indentSelection(\"add\");\n    },\n    indentLess: function indentLess(cm) {\n      return cm.indentSelection(\"subtract\");\n    },\n    insertTab: function insertTab(cm) {\n      return cm.replaceSelection(\"\\t\");\n    },\n    insertSoftTab: function insertSoftTab(cm) {\n      var spaces = [],\n          ranges = cm.listSelections(),\n          tabSize = cm.options.tabSize;\n\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function defaultTab(cm) {\n      if (cm.somethingSelected()) {\n        cm.indentSelection(\"add\");\n      } else {\n        cm.execCommand(\"insertTab\");\n      }\n    },\n    // Swap the two chars left and right of each selection's head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn't consider line feeds a character.\n    // Doesn't scan more than one line above to find a character.\n    // Doesn't do anything on an empty line.\n    // Doesn't do anything with non-empty selections.\n    transposeChars: function transposeChars(cm) {\n      return runInOp(cm, function () {\n        var ranges = cm.listSelections(),\n            newSel = [];\n\n        for (var i = 0; i < ranges.length; i++) {\n          if (!ranges[i].empty()) {\n            continue;\n          }\n\n          var cur = ranges[i].head,\n              line = getLine(cm.doc, cur.line).text;\n\n          if (line) {\n            if (cur.ch == line.length) {\n              cur = new Pos(cur.line, cur.ch - 1);\n            }\n\n            if (cur.ch > 0) {\n              cur = new Pos(cur.line, cur.ch + 1);\n              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n            } else if (cur.line > cm.doc.first) {\n              var prev = getLine(cm.doc, cur.line - 1).text;\n\n              if (prev) {\n                cur = new Pos(cur.line, 1);\n                cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n              }\n            }\n          }\n\n          newSel.push(new Range(cur, cur));\n        }\n\n        cm.setSelections(newSel);\n      });\n    },\n    newlineAndIndent: function newlineAndIndent(cm) {\n      return runInOp(cm, function () {\n        var sels = cm.listSelections();\n\n        for (var i = sels.length - 1; i >= 0; i--) {\n          cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\");\n        }\n\n        sels = cm.listSelections();\n\n        for (var i$1 = 0; i$1 < sels.length; i$1++) {\n          cm.indentLine(sels[i$1].from().line, null, true);\n        }\n\n        ensureCursorVisible(cm);\n      });\n    },\n    openLine: function openLine(cm) {\n      return cm.replaceSelection(\"\\n\", \"start\");\n    },\n    toggleOverwrite: function toggleOverwrite(cm) {\n      return cm.toggleOverwrite();\n    }\n  };\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n\n    if (visual != line) {\n      lineN = lineNo(visual);\n    }\n\n    return endOfLine(true, cm, visual, lineN, 1);\n  }\n\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n\n    if (visual != line) {\n      lineN = lineNo(visual);\n    }\n\n    return endOfLine(true, cm, line, lineN, -1);\n  }\n\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(start.ch, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);\n    }\n\n    return start;\n  } // Run a handler that was bound to a key.\n\n\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n\n      if (!bound) {\n        return false;\n      }\n    } // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n\n\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift,\n        done = false;\n\n    try {\n      if (cm.isReadOnly()) {\n        cm.state.suppressEdits = true;\n      }\n\n      if (dropShift) {\n        cm.display.shift = false;\n      }\n\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n\n    return done;\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n\n      if (result) {\n        return result;\n      }\n    }\n\n    return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm);\n  } // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n\n  var stopSeq = new Delayed();\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n\n    if (seq) {\n      if (isModifierKey(name)) {\n        return \"handled\";\n      }\n\n      if (/\\'$/.test(name)) {\n        cm.state.keySeq = null;\n      } else {\n        stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        });\n      }\n\n      if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) {\n        return true;\n      }\n    }\n\n    return dispatchKeyInner(cm, name, e, handle);\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\") {\n      cm.state.keySeq = name;\n    }\n\n    if (result == \"handled\") {\n      signalLater(cm, \"keyHandled\", cm, name, e);\n    }\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result;\n  } // Handle a key from the keydown event.\n\n\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n\n    if (!name) {\n      return false;\n    }\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function (b) {\n        return doHandleBinding(cm, b, true);\n      }) || dispatchKey(cm, name, e, function (b) {\n        if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion) {\n          return doHandleBinding(cm, b);\n        }\n      });\n    } else {\n      return dispatchKey(cm, name, e, function (b) {\n        return doHandleBinding(cm, b);\n      });\n    }\n  } // Handle a key from the keypress event\n\n\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) {\n      return doHandleBinding(cm, b, true);\n    });\n  }\n\n  var lastStoppedKey = null;\n\n  function onKeyDown(e) {\n    var cm = this;\n\n    if (e.target && e.target != cm.display.input.getField()) {\n      return;\n    }\n\n    cm.curOp.focus = activeElt();\n\n    if (signalDOMEvent(cm, e)) {\n      return;\n    } // IE does strange things with escape.\n\n\n    if (ie && ie_version < 11 && e.keyCode == 27) {\n      e.returnValue = false;\n    }\n\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n\n    if (presto) {\n      lastStoppedKey = handled ? code : null; // Opera has no cut event... we try to at least catch the key combo\n\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {\n        cm.replaceSelection(\"\", null, \"cut\");\n      }\n    }\n\n    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {\n      document.execCommand(\"cut\");\n    } // Turn mouse into crosshair when Alt is held on Mac.\n\n\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className)) {\n      showCrossHair(cm);\n    }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) {\n      this.doc.sel.shift = false;\n    }\n\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n\n    if (e.target && e.target != cm.display.input.getField()) {\n      return;\n    }\n\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {\n      return;\n    }\n\n    var keyCode = e.keyCode,\n        charCode = e.charCode;\n\n    if (presto && keyCode == lastStoppedKey) {\n      lastStoppedKey = null;\n      e_preventDefault(e);\n      return;\n    }\n\n    if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {\n      return;\n    }\n\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode); // Some browsers fire keypress events for backspace\n\n    if (ch == \"\\x08\") {\n      return;\n    }\n\n    if (handleCharBinding(cm, e, ch)) {\n      return;\n    }\n\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function PastClick(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;\n  };\n\n  var lastClick, lastDoubleClick;\n\n  function clickRepeat(pos, button) {\n    var now = +new Date();\n\n    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return \"triple\";\n    } else if (lastClick && lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return \"double\";\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return \"single\";\n    }\n  } // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n\n\n  function onMouseDown(e) {\n    var cm = this,\n        display = cm.display;\n\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {\n      return;\n    }\n\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () {\n          return display.scroller.draggable = true;\n        }, 100);\n      }\n\n      return;\n    }\n\n    if (clickInGutter(cm, e)) {\n      return;\n    }\n\n    var pos = posFromMouse(cm, e),\n        button = e_button(e),\n        repeat = pos ? clickRepeat(pos, button) : \"single\";\n    window.focus(); // #3261: make sure, that we're not starting a second selection\n\n    if (button == 1 && cm.state.selectingText) {\n      cm.state.selectingText(e);\n    }\n\n    if (pos && handleMappedButton(cm, button, pos, repeat, e)) {\n      return;\n    }\n\n    if (button == 1) {\n      if (pos) {\n        leftButtonDown(cm, pos, repeat, e);\n      } else if (e_target(e) == display.scroller) {\n        e_preventDefault(e);\n      }\n    } else if (button == 2) {\n      if (pos) {\n        extendSelection(cm.doc, pos);\n      }\n\n      setTimeout(function () {\n        return display.input.focus();\n      }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) {\n        cm.display.input.onContextMenu(e);\n      } else {\n        delayBlurEvent(cm);\n      }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = \"Click\";\n\n    if (repeat == \"double\") {\n      name = \"Double\" + name;\n    } else if (repeat == \"triple\") {\n      name = \"Triple\" + name;\n    }\n\n    name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n    return dispatchKey(cm, addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == \"string\") {\n        bound = commands[bound];\n      }\n\n      if (!bound) {\n        return false;\n      }\n\n      var done = false;\n\n      try {\n        if (cm.isReadOnly()) {\n          cm.state.suppressEdits = true;\n        }\n\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n\n      return done;\n    });\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption(\"configureMouse\");\n    var value = option ? option(cm, repeat, event) : {};\n\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n      value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n    }\n\n    if (value.extend == null || cm.doc.extend) {\n      value.extend = cm.doc.extend || event.shiftKey;\n    }\n\n    if (value.addNew == null) {\n      value.addNew = mac ? event.metaKey : event.ctrlKey;\n    }\n\n    if (value.moveOnDrag == null) {\n      value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);\n    }\n\n    return value;\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) {\n      setTimeout(bind(ensureFocus, cm), 0);\n    } else {\n      cm.curOp.focus = activeElt();\n    }\n\n    var behavior = configureMouse(cm, repeat, event);\n    var sel = cm.doc.sel,\n        contained;\n\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == \"single\" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {\n      leftButtonStartDrag(cm, event, pos, behavior);\n    } else {\n      leftButtonSelect(cm, event, pos, behavior);\n    }\n  } // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n\n\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display,\n        moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) {\n        display.scroller.draggable = false;\n      }\n\n      cm.state.draggingText = false;\n\n      if (cm.state.delayingBlurEvent) {\n        if (cm.hasFocus()) {\n          cm.state.delayingBlurEvent = false;\n        } else {\n          delayBlurEvent(cm);\n        }\n      }\n\n      off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      off(display.scroller, \"dragstart\", dragStart);\n      off(display.scroller, \"drop\", dragEnd);\n\n      if (!moved) {\n        e_preventDefault(e);\n\n        if (!behavior.addNew) {\n          extendSelection(cm.doc, pos, null, null, behavior.extend);\n        } // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n\n\n        if (webkit && !safari || ie && ie_version == 9) {\n          setTimeout(function () {\n            display.wrapper.ownerDocument.body.focus({\n              preventScroll: true\n            });\n            display.input.focus();\n          }, 20);\n        } else {\n          display.input.focus();\n        }\n      }\n    });\n\n    var mouseMove = function mouseMove(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n    };\n\n    var dragStart = function dragStart() {\n      return moved = true;\n    }; // Let the drag handler handle this.\n\n\n    if (webkit) {\n      display.scroller.draggable = true;\n    }\n\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag;\n    on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n    on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n    on(display.scroller, \"dragstart\", dragStart);\n    on(display.scroller, \"drop\", dragEnd);\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () {\n      return display.input.focus();\n    }, 20); // IE's approach to draggable\n\n    if (display.scroller.dragDrop) {\n      display.scroller.dragDrop();\n    }\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == \"char\") {\n      return new Range(pos, pos);\n    }\n\n    if (unit == \"word\") {\n      return cm.findWordAt(pos);\n    }\n\n    if (unit == \"line\") {\n      return new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));\n    }\n\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to);\n  } // Normal selection, as opposed to text dragging.\n\n\n  function leftButtonSelect(cm, event, start, behavior) {\n    if (ie) {\n      delayBlurEvent(cm);\n    }\n\n    var display = cm.display,\n        doc = cm.doc;\n    e_preventDefault(event);\n    var ourRange,\n        ourIndex,\n        startSel = doc.sel,\n        ranges = startSel.ranges;\n\n    if (behavior.addNew && !behavior.extend) {\n      ourIndex = doc.sel.contains(start);\n\n      if (ourIndex > -1) {\n        ourRange = ranges[ourIndex];\n      } else {\n        ourRange = new Range(start, start);\n      }\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (behavior.unit == \"rectangle\") {\n      if (!behavior.addNew) {\n        ourRange = new Range(start, start);\n      }\n\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range = rangeForUnit(cm, start, behavior.unit);\n\n      if (behavior.extend) {\n        ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend);\n      } else {\n        ourRange = range;\n      }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), {\n        scroll: false,\n        origin: \"*mouse\"\n      });\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {\n        scroll: false,\n        origin: \"*mouse\"\n      });\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) {\n        return;\n      }\n\n      lastPos = pos;\n\n      if (behavior.unit == \"rectangle\") {\n        var ranges = [],\n            tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol),\n            right = Math.max(startCol, posCol);\n\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {\n          var text = getLine(doc, line).text,\n              leftPos = findColumn(text, left, tabSize);\n\n          if (left == right) {\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\n          } else if (text.length > leftPos) {\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\n          }\n        }\n\n        if (!ranges.length) {\n          ranges.push(new Range(start, start));\n        }\n\n        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {\n          origin: \"*mouse\",\n          scroll: false\n        });\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor,\n            head;\n\n        if (cmp(range.anchor, anchor) > 0) {\n          head = range.head;\n          anchor = minPos(oldRange.from(), range.anchor);\n        } else {\n          head = range.anchor;\n          anchor = maxPos(oldRange.to(), range.head);\n        }\n\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(_clipPos(doc, anchor), head));\n        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect(); // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n\n      if (!cur) {\n        return;\n      }\n\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n\n        if (cur.line >= visible.to || cur.line < visible.from) {\n          setTimeout(operation(cm, function () {\n            if (counter == curCount) {\n              extend(e);\n            }\n          }), 150);\n        }\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n\n        if (outside) {\n          setTimeout(operation(cm, function () {\n            if (counter != curCount) {\n              return;\n            }\n\n            display.scroller.scrollTop += outside;\n            extend(e);\n          }), 50);\n        }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity; // If e is null or undefined we interpret this as someone trying\n      // to explicitly cancel the selection rather than the user\n      // letting go of the mouse button.\n\n      if (e) {\n        e_preventDefault(e);\n        display.input.focus();\n      }\n\n      off(display.wrapper.ownerDocument, \"mousemove\", move);\n      off(display.wrapper.ownerDocument, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) {\n        done(e);\n      } else {\n        extend(e);\n      }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, \"mousemove\", move);\n    on(display.wrapper.ownerDocument, \"mouseup\", up);\n  } // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n\n\n  function bidiSimplify(cm, range) {\n    var anchor = range.anchor;\n    var head = range.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n\n    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {\n      return range;\n    }\n\n    var order = getOrder(anchorLine);\n\n    if (!order) {\n      return range;\n    }\n\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky),\n        part = order[index];\n\n    if (part.from != anchor.ch && part.to != anchor.ch) {\n      return range;\n    }\n\n    var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);\n\n    if (boundary == 0 || boundary == order.length) {\n      return range;\n    } // Compute the relative visual position of the head compared to the\n    // anchor (<0 is to the left, >0 to the right)\n\n\n    var leftSide;\n\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n\n      if (headIndex == boundary - 1 || headIndex == boundary) {\n        leftSide = dir < 0;\n      } else {\n        leftSide = dir > 0;\n      }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to,\n        sticky = from ? \"after\" : \"before\";\n    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head);\n  } // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n\n\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try {\n        mX = e.clientX;\n        mY = e.clientY;\n      } catch (e$1) {\n        return false;\n      }\n    }\n\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {\n      return false;\n    }\n\n    if (prevent) {\n      e_preventDefault(e);\n    }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) {\n      return e_defaultPrevented(e);\n    }\n\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {\n      var g = display.gutters.childNodes[i];\n\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = _lineAtHeight(cm.doc, mY);\n\n        var gutter = cm.display.gutterSpecs[i];\n        signal(cm, type, cm, line, gutter.className, e);\n        return e_defaultPrevented(e);\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true);\n  } // CONTEXT MENU HANDLING\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n\n\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {\n      return;\n    }\n\n    if (signalDOMEvent(cm, e, \"contextmenu\")) {\n      return;\n    }\n\n    if (!captureRightClick) {\n      cm.display.input.onContextMenu(e);\n    }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) {\n      return false;\n    }\n\n    return gutterEvent(cm, e, \"gutterContextMenu\", false);\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") + cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  var Init = {\n    toString: function toString() {\n      return \"CodeMirror.Init\";\n    }\n  };\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n\n      if (handle) {\n        optionHandlers[name] = notOnInit ? function (cm, val, old) {\n          if (old != Init) {\n            handle(cm, val, old);\n          }\n        } : handle;\n      }\n    }\n\n    CodeMirror.defineOption = option; // Passed to option handlers when there is no old value.\n\n    CodeMirror.Init = Init; // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n\n    option(\"value\", \"\", function (cm, val) {\n      return cm.setValue(val);\n    }, true);\n    option(\"mode\", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n    option(\"indentUnit\", 2, loadMode, true);\n    option(\"indentWithTabs\", false);\n    option(\"smartIndent\", true);\n    option(\"tabSize\", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n    option(\"lineSeparator\", null, function (cm, val) {\n      cm.doc.lineSep = val;\n\n      if (!val) {\n        return;\n      }\n\n      var newBreaks = [],\n          lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n\n          if (found == -1) {\n            break;\n          }\n\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n\n        lineNo++;\n      });\n\n      for (var i = newBreaks.length - 1; i >= 0; i--) {\n        _replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length));\n      }\n    });\n    option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200c\\u200e\\u200f\\u2028\\u2029\\ufeff\\ufff9-\\ufffc]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n\n      if (old != Init) {\n        cm.refresh();\n      }\n    });\n    option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) {\n      return cm.refresh();\n    }, true);\n    option(\"electricChars\", true);\n    option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n      throw new Error(\"inputStyle can not (yet) be changed in a running editor\"); // FIXME\n    }, true);\n    option(\"spellcheck\", false, function (cm, val) {\n      return cm.getInputField().spellcheck = val;\n    }, true);\n    option(\"autocorrect\", false, function (cm, val) {\n      return cm.getInputField().autocorrect = val;\n    }, true);\n    option(\"autocapitalize\", false, function (cm, val) {\n      return cm.getInputField().autocapitalize = val;\n    }, true);\n    option(\"rtlMoveVisually\", !windows);\n    option(\"wholeLineUpdateBefore\", true);\n    option(\"theme\", \"default\", function (cm) {\n      themeChanged(cm);\n      updateGutters(cm);\n    }, true);\n    option(\"keyMap\", \"default\", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init && getKeyMap(old);\n\n      if (prev && prev.detach) {\n        prev.detach(cm, next);\n      }\n\n      if (next.attach) {\n        next.attach(cm, prev || null);\n      }\n    });\n    option(\"extraKeys\", null);\n    option(\"configureMouse\", null);\n    option(\"lineWrapping\", false, wrappingChanged, true);\n    option(\"gutters\", [], function (cm, val) {\n      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);\n      updateGutters(cm);\n    }, true);\n    option(\"fixedGutter\", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n      cm.refresh();\n    }, true);\n    option(\"coverGutterNextToScrollbar\", false, function (cm) {\n      return updateScrollbars(cm);\n    }, true);\n    option(\"scrollbarStyle\", \"native\", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option(\"lineNumbers\", false, function (cm, val) {\n      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);\n      updateGutters(cm);\n    }, true);\n    option(\"firstLineNumber\", 1, updateGutters, true);\n    option(\"lineNumberFormatter\", function (integer) {\n      return integer;\n    }, updateGutters, true);\n    option(\"showCursorWhenSelecting\", false, updateSelection, true);\n    option(\"resetSelectionOnContextMenu\", true);\n    option(\"lineWiseCopyCut\", true);\n    option(\"pasteLinesPerSelection\", true);\n    option(\"selectionsMayTouch\", false);\n    option(\"readOnly\", false, function (cm, val) {\n      if (val == \"nocursor\") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n\n      cm.display.input.readOnlyChanged(val);\n    });\n    option(\"screenReaderLabel\", null, function (cm, val) {\n      val = val === '' ? null : val;\n      cm.display.input.screenReaderLabelChanged(val);\n    });\n    option(\"disableInput\", false, function (cm, val) {\n      if (!val) {\n        cm.display.input.reset();\n      }\n    }, true);\n    option(\"dragDrop\", true, dragDropChanged);\n    option(\"allowDropFileTypes\", null);\n    option(\"cursorBlinkRate\", 530);\n    option(\"cursorScrollMargin\", 0);\n    option(\"cursorHeight\", 1, updateSelection, true);\n    option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n    option(\"workTime\", 100);\n    option(\"workDelay\", 100);\n    option(\"flattenSpans\", true, resetModeState, true);\n    option(\"addModeClass\", false, resetModeState, true);\n    option(\"pollInterval\", 100);\n    option(\"undoDepth\", 200, function (cm, val) {\n      return cm.doc.history.undoDepth = val;\n    });\n    option(\"historyEventDelay\", 1250);\n    option(\"viewportMargin\", 10, function (cm) {\n      return cm.refresh();\n    }, true);\n    option(\"maxHighlightLength\", 10000, resetModeState, true);\n    option(\"moveInputWithCursor\", true, function (cm, val) {\n      if (!val) {\n        cm.display.input.resetPosition();\n      }\n    });\n    option(\"tabindex\", null, function (cm, val) {\n      return cm.display.input.getField().tabIndex = val || \"\";\n    });\n    option(\"autofocus\", null);\n    option(\"direction\", \"ltr\", function (cm, val) {\n      return cm.doc.setDirection(val);\n    }, true);\n    option(\"phrases\", null);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != Init;\n\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () {\n      return updateScrollbars(cm);\n    }, 100);\n  } // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) {\n      return new CodeMirror(place, options);\n    }\n\n    this.options = options = options ? copyObj(options) : {}; // Determine effective options based on given values and defaults.\n\n    copyObj(defaults, options, false);\n    var doc = options.value;\n\n    if (typeof doc == \"string\") {\n      doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);\n    } else if (options.mode) {\n      doc.modeOption = options.mode;\n    }\n\n    this.doc = doc;\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input, options);\n    display.wrapper.CodeMirror = this;\n    themeChanged(this);\n\n    if (options.lineWrapping) {\n      this.display.wrapper.className += \" CodeMirror-wrap\";\n    }\n\n    initScrollbars(this);\n    this.state = {\n      keyMaps: [],\n      // stores maps added by addKeyMap\n      overlays: [],\n      // highlighting overlays, as added by addOverlay\n      modeGen: 0,\n      // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false,\n      // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: -1,\n      cutIncoming: -1,\n      // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(),\n      // stores highlight worker timeout\n      keySeq: null,\n      // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus && !mobile) {\n      display.input.focus();\n    } // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n\n\n    if (ie && ie_version < 11) {\n      setTimeout(function () {\n        return this$1.display.input.reset(true);\n      }, 20);\n    }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    _startOperation(this);\n\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if (options.autofocus && !mobile || this.hasFocus()) {\n      setTimeout(function () {\n        if (this$1.hasFocus() && !this$1.state.focused) {\n          onFocus(this$1);\n        }\n      }, 20);\n    } else {\n      onBlur(this);\n    }\n\n    for (var opt in optionHandlers) {\n      if (optionHandlers.hasOwnProperty(opt)) {\n        optionHandlers[opt](this, options[opt], Init);\n      }\n    }\n\n    maybeUpdateLineNumberWidth(this);\n\n    if (options.finishInit) {\n      options.finishInit(this);\n    }\n\n    for (var i = 0; i < initHooks.length; ++i) {\n      initHooks[i](this);\n    }\n\n    _endOperation(this); // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n\n\n    if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\") {\n      display.lineDiv.style.textRendering = \"auto\";\n    }\n  } // The default configuration options.\n\n\n  CodeMirror.defaults = defaults; // Functions to run when options are changed.\n\n  CodeMirror.optionHandlers = optionHandlers; // Attach the necessary event handlers when initializing the editor\n\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown)); // Older IE's will not fire a second mousedown for a double click\n\n    if (ie && ie_version < 11) {\n      on(d.scroller, \"dblclick\", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) {\n          return;\n        }\n\n        var pos = posFromMouse(cm, e);\n\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {\n          return;\n        }\n\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      }));\n    } else {\n      on(d.scroller, \"dblclick\", function (e) {\n        return signalDOMEvent(cm, e) || e_preventDefault(e);\n      });\n    } // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n\n\n    on(d.scroller, \"contextmenu\", function (e) {\n      return onContextMenu(cm, e);\n    });\n    on(d.input.getField(), \"contextmenu\", function (e) {\n      if (!d.scroller.contains(e.target)) {\n        onContextMenu(cm, e);\n      }\n    }); // Used to suppress mouse event handling when a touch happens\n\n    var touchFinished,\n        prevTouch = {\n      end: 0\n    };\n\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () {\n          return d.activeTouch = null;\n        }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date();\n      }\n    }\n\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) {\n        return false;\n      }\n\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1;\n    }\n\n    function farAway(touch, other) {\n      if (other.left == null) {\n        return true;\n      }\n\n      var dx = other.left - touch.left,\n          dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20;\n    }\n\n    on(d.scroller, \"touchstart\", function (e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date();\n        d.activeTouch = {\n          start: now,\n          moved: false,\n          prev: now - prevTouch.end <= 300 ? prevTouch : null\n        };\n\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function () {\n      if (d.activeTouch) {\n        d.activeTouch.moved = true;\n      }\n    });\n    on(d.scroller, \"touchend\", function (e) {\n      var touch = d.activeTouch;\n\n      if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"),\n            range;\n\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          {\n            range = new Range(pos, pos);\n          } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          {\n            range = cm.findWordAt(pos);\n          } else // Triple tap\n          {\n            range = new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));\n          }\n\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch); // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n\n    on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    }); // Listen to wheel events in order to try and update the viewport on time.\n\n    on(d.scroller, \"mousewheel\", function (e) {\n      return onScrollWheel(cm, e);\n    });\n    on(d.scroller, \"DOMMouseScroll\", function (e) {\n      return onScrollWheel(cm, e);\n    }); // Prevent wrapper from ever scrolling\n\n    on(d.wrapper, \"scroll\", function () {\n      return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;\n    });\n    d.dragFunctions = {\n      enter: function enter(e) {\n        if (!signalDOMEvent(cm, e)) {\n          e_stop(e);\n        }\n      },\n      over: function over(e) {\n        if (!signalDOMEvent(cm, e)) {\n          onDragOver(cm, e);\n          e_stop(e);\n        }\n      },\n      start: function start(e) {\n        return onDragStart(cm, e);\n      },\n      drop: operation(cm, onDrop),\n      leave: function leave(e) {\n        if (!signalDOMEvent(cm, e)) {\n          clearDragCursor(cm);\n        }\n      }\n    };\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function (e) {\n      return onKeyUp.call(cm, e);\n    });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) {\n      return onFocus(cm, e);\n    });\n    on(inp, \"blur\", function (e) {\n      return onBlur(cm, e);\n    });\n  }\n\n  var initHooks = [];\n\n  CodeMirror.defineInitHook = function (f) {\n    return initHooks.push(f);\n  }; // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n\n\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc,\n        state;\n\n    if (how == null) {\n      how = \"add\";\n    }\n\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) {\n        how = \"prev\";\n      } else {\n        state = getContextBefore(cm, n).state;\n      }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n),\n        curSpace = countColumn(line.text, null, tabSize);\n\n    if (line.stateAfter) {\n      line.stateAfter = null;\n    }\n\n    var curSpaceString = line.text.match(/^\\s*/)[0],\n        indentation;\n\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) {\n          return;\n        }\n\n        how = \"prev\";\n      }\n    }\n\n    if (how == \"prev\") {\n      if (n > doc.first) {\n        indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);\n      } else {\n        indentation = 0;\n      }\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n\n    indentation = Math.max(0, indentation);\n    var indentString = \"\",\n        pos = 0;\n\n    if (cm.options.indentWithTabs) {\n      for (var i = Math.floor(indentation / tabSize); i; --i) {\n        pos += tabSize;\n        indentString += \"\\t\";\n      }\n    }\n\n    if (pos < indentation) {\n      indentString += spaceStr(indentation - pos);\n    }\n\n    if (indentString != curSpaceString) {\n      _replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n\n      line.stateAfter = null;\n      return true;\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break;\n        }\n      }\n    }\n  } // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n\n\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n\n    if (!sel) {\n      sel = doc.sel;\n    }\n\n    var recent = +new Date() - 200;\n    var paste = origin == \"paste\" || cm.state.pasteIncoming > recent;\n    var textLines = splitLinesAuto(inserted),\n        multiPaste = null; // When pasting N lines into N selections, insert one line per selection\n\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n\n          for (var i = 0; i < lastCopied.text.length; i++) {\n            multiPaste.push(doc.splitLines(lastCopied.text[i]));\n          }\n        }\n      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) {\n          return [l];\n        });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput; // Normal behavior is to insert the new text into every selection\n\n    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n      var range = sel.ranges[i$1];\n      var from = range.from(),\n          to = range.to();\n\n      if (range.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          {\n            from = Pos(from.line, from.ch - deleted);\n          } else if (cm.state.overwrite && !paste) // Handle overwrite\n          {\n            to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\n          } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == textLines.join(\"\\n\")) {\n          from = to = Pos(from.line, 0);\n        }\n      }\n\n      var changeEvent = {\n        from: from,\n        to: to,\n        text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n        origin: origin || (paste ? \"paste\" : cm.state.cutIncoming > recent ? \"cut\" : \"+input\")\n      };\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n\n    if (inserted && !paste) {\n      triggerElectric(cm, inserted);\n    }\n\n    ensureCursorVisible(cm);\n\n    if (cm.curOp.updateInput < 2) {\n      cm.curOp.updateInput = updateInput;\n    }\n\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n\n    if (pasted) {\n      e.preventDefault();\n\n      if (!cm.isReadOnly() && !cm.options.disableInput) {\n        runInOp(cm, function () {\n          return applyTextInput(cm, pasted, 0, null, \"paste\");\n        });\n      }\n\n      return true;\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) {\n      return;\n    }\n\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range = sel.ranges[i];\n\n      if (range.head.ch > 100 || i && sel.ranges[i - 1].head.line == range.head.line) {\n        continue;\n      }\n\n      var mode = cm.getModeAt(range.head);\n      var indented = false;\n\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++) {\n          if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range.head.line, \"smart\");\n            break;\n          }\n        }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch))) {\n          indented = indentLine(cm, range.head.line, \"smart\");\n        }\n      }\n\n      if (indented) {\n        signalLater(cm, \"electricInput\", cm, range.head.line);\n      }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [],\n        ranges = [];\n\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {\n        anchor: Pos(line, 0),\n        head: Pos(line + 1, 0)\n      };\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n\n    return {\n      text: text,\n      ranges: ranges\n    };\n  }\n\n  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n    field.setAttribute(\"autocorrect\", autocorrect ? \"\" : \"off\");\n    field.setAttribute(\"autocapitalize\", autocapitalize ? \"\" : \"off\");\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\"); // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n\n    if (webkit) {\n      te.style.width = \"1000px\";\n    } else {\n      te.setAttribute(\"wrap\", \"off\");\n    } // If border: 0; -- iOS fails to open keyboard (issue #1287)\n\n\n    if (ios) {\n      te.style.border = \"1px solid black\";\n    }\n\n    disableBrowserMagic(te);\n    return div;\n  } // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n    var helpers = CodeMirror.helpers = {};\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function focus() {\n        window.focus();\n        this.display.input.focus();\n      },\n      setOption: function setOption(option, value) {\n        var options = this.options,\n            old = options[option];\n\n        if (options[option] == value && option != \"mode\") {\n          return;\n        }\n\n        options[option] = value;\n\n        if (optionHandlers.hasOwnProperty(option)) {\n          operation(this, optionHandlers[option])(this, value, old);\n        }\n\n        signal(this, \"optionChange\", this, option);\n      },\n      getOption: function getOption(option) {\n        return this.options[option];\n      },\n      getDoc: function getDoc() {\n        return this.doc;\n      },\n      addKeyMap: function addKeyMap(map, bottom) {\n        this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map));\n      },\n      removeKeyMap: function removeKeyMap(map) {\n        var maps = this.state.keyMaps;\n\n        for (var i = 0; i < maps.length; ++i) {\n          if (maps[i] == map || maps[i].name == map) {\n            maps.splice(i, 1);\n            return true;\n          }\n        }\n      },\n      addOverlay: methodOp(function (spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n\n        if (mode.startState) {\n          throw new Error(\"Overlays may not be stateful.\");\n        }\n\n        insertSorted(this.state.overlays, {\n          mode: mode,\n          modeSpec: spec,\n          opaque: options && options.opaque,\n          priority: options && options.priority || 0\n        }, function (overlay) {\n          return overlay.priority;\n        });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function (spec) {\n        var overlays = this.state.overlays;\n\n        for (var i = 0; i < overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n\n          if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n            overlays.splice(i, 1);\n            this.state.modeGen++;\n            regChange(this);\n            return;\n          }\n        }\n      }),\n      indentLine: methodOp(function (n, dir, aggressive) {\n        if (typeof dir != \"string\" && typeof dir != \"number\") {\n          if (dir == null) {\n            dir = this.options.smartIndent ? \"smart\" : \"prev\";\n          } else {\n            dir = dir ? \"add\" : \"subtract\";\n          }\n        }\n\n        if (isLine(this.doc, n)) {\n          indentLine(this, n, dir, aggressive);\n        }\n      }),\n      indentSelection: methodOp(function (how) {\n        var ranges = this.doc.sel.ranges,\n            end = -1;\n\n        for (var i = 0; i < ranges.length; i++) {\n          var range = ranges[i];\n\n          if (!range.empty()) {\n            var from = range.from(),\n                to = range.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n\n            for (var j = start; j < end; ++j) {\n              indentLine(this, j, how);\n            }\n\n            var newRanges = this.doc.sel.ranges;\n\n            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0) {\n              replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\n            }\n          } else if (range.head.line > end) {\n            indentLine(this, range.head.line, how, true);\n            end = range.head.line;\n\n            if (i == this.doc.sel.primIndex) {\n              ensureCursorVisible(this);\n            }\n          }\n        }\n      }),\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function getTokenAt(pos, precise) {\n        return takeToken(this, pos, precise);\n      },\n      getLineTokens: function getLineTokens(line, precise) {\n        return takeToken(this, Pos(line), precise, true);\n      },\n      getTokenTypeAt: function getTokenTypeAt(pos) {\n        pos = _clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0,\n            after = (styles.length - 1) / 2,\n            ch = pos.ch;\n        var type;\n\n        if (ch == 0) {\n          type = styles[2];\n        } else {\n          for (;;) {\n            var mid = before + after >> 1;\n\n            if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {\n              after = mid;\n            } else if (styles[mid * 2 + 1] < ch) {\n              before = mid + 1;\n            } else {\n              type = styles[mid * 2 + 2];\n              break;\n            }\n          }\n        }\n\n        var cut = type ? type.indexOf(\"overlay \") : -1;\n        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\n      },\n      getModeAt: function getModeAt(pos) {\n        var mode = this.doc.mode;\n\n        if (!mode.innerMode) {\n          return mode;\n        }\n\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\n      },\n      getHelper: function getHelper(pos, type) {\n        return this.getHelpers(pos, type)[0];\n      },\n      getHelpers: function getHelpers(pos, type) {\n        var found = [];\n\n        if (!helpers.hasOwnProperty(type)) {\n          return found;\n        }\n\n        var help = helpers[type],\n            mode = this.getModeAt(pos);\n\n        if (typeof mode[type] == \"string\") {\n          if (help[mode[type]]) {\n            found.push(help[mode[type]]);\n          }\n        } else if (mode[type]) {\n          for (var i = 0; i < mode[type].length; i++) {\n            var val = help[mode[type][i]];\n\n            if (val) {\n              found.push(val);\n            }\n          }\n        } else if (mode.helperType && help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n\n        for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n          var cur = help._global[i$1];\n\n          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {\n            found.push(cur.val);\n          }\n        }\n\n        return found;\n      },\n      getStateAfter: function getStateAfter(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);\n        return getContextBefore(this, line + 1, precise).state;\n      },\n      cursorCoords: function cursorCoords(start, mode) {\n        var pos,\n            range = this.doc.sel.primary();\n\n        if (start == null) {\n          pos = range.head;\n        } else if (_typeof(start) == \"object\") {\n          pos = _clipPos(this.doc, start);\n        } else {\n          pos = start ? range.from() : range.to();\n        }\n\n        return _cursorCoords(this, pos, mode || \"page\");\n      },\n      charCoords: function charCoords(pos, mode) {\n        return _charCoords(this, _clipPos(this.doc, pos), mode || \"page\");\n      },\n      coordsChar: function coordsChar(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || \"page\");\n        return _coordsChar(this, coords.left, coords.top);\n      },\n      lineAtHeight: function lineAtHeight(height, mode) {\n        height = fromCoordSystem(this, {\n          top: height,\n          left: 0\n        }, mode || \"page\").top;\n        return _lineAtHeight(this.doc, height + this.display.viewOffset);\n      },\n      heightAtLine: function heightAtLine(line, mode, includeWidgets) {\n        var end = false,\n            lineObj;\n\n        if (typeof line == \"number\") {\n          var last = this.doc.first + this.doc.size - 1;\n\n          if (line < this.doc.first) {\n            line = this.doc.first;\n          } else if (line > last) {\n            line = last;\n            end = true;\n          }\n\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n\n        return intoCoordSystem(this, lineObj, {\n          top: 0,\n          left: 0\n        }, mode || \"page\", includeWidgets || end).top + (end ? this.doc.height - _heightAtLine(lineObj) : 0);\n      },\n      defaultTextHeight: function defaultTextHeight() {\n        return textHeight(this.display);\n      },\n      defaultCharWidth: function defaultCharWidth() {\n        return charWidth(this.display);\n      },\n      getViewport: function getViewport() {\n        return {\n          from: this.display.viewFrom,\n          to: this.display.viewTo\n        };\n      },\n      addWidget: function addWidget(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = _cursorCoords(this, _clipPos(this.doc, pos));\n        var top = pos.bottom,\n            left = pos.left;\n        node.style.position = \"absolute\";\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n\n        if (vert == \"over\") {\n          top = pos.top;\n        } else if (vert == \"above\" || vert == \"near\") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n              hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth); // Default to positioning above (if specified and possible); otherwise default to positioning below\n\n          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {\n            top = pos.top - node.offsetHeight;\n          } else if (pos.bottom + node.offsetHeight <= vspace) {\n            top = pos.bottom;\n          }\n\n          if (left + node.offsetWidth > hspace) {\n            left = hspace - node.offsetWidth;\n          }\n        }\n\n        node.style.top = top + \"px\";\n        node.style.left = node.style.right = \"\";\n\n        if (horiz == \"right\") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") {\n            left = 0;\n          } else if (horiz == \"middle\") {\n            left = (display.sizer.clientWidth - node.offsetWidth) / 2;\n          }\n\n          node.style.left = left + \"px\";\n        }\n\n        if (scroll) {\n          scrollIntoView(this, {\n            left: left,\n            top: top,\n            right: left + node.offsetWidth,\n            bottom: top + node.offsetHeight\n          });\n        }\n      },\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n      execCommand: function execCommand(cmd) {\n        if (commands.hasOwnProperty(cmd)) {\n          return commands[cmd].call(null, this);\n        }\n      },\n      triggerElectric: methodOp(function (text) {\n        triggerElectric(this, text);\n      }),\n      findPosH: function findPosH(from, amount, unit, visually) {\n        var dir = 1;\n\n        if (amount < 0) {\n          dir = -1;\n          amount = -amount;\n        }\n\n        var cur = _clipPos(this.doc, from);\n\n        for (var i = 0; i < amount; ++i) {\n          cur = _findPosH(this.doc, cur, dir, unit, visually);\n\n          if (cur.hitSide) {\n            break;\n          }\n        }\n\n        return cur;\n      },\n      moveH: methodOp(function (dir, unit) {\n        var this$1 = this;\n        this.extendSelectionsBy(function (range) {\n          if (this$1.display.shift || this$1.doc.extend || range.empty()) {\n            return _findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually);\n          } else {\n            return dir < 0 ? range.from() : range.to();\n          }\n        }, sel_move);\n      }),\n      deleteH: methodOp(function (dir, unit) {\n        var sel = this.doc.sel,\n            doc = this.doc;\n\n        if (sel.somethingSelected()) {\n          doc.replaceSelection(\"\", null, \"+delete\");\n        } else {\n          deleteNearSelection(this, function (range) {\n            var other = _findPosH(doc, range.head, dir, unit, false);\n\n            return dir < 0 ? {\n              from: other,\n              to: range.head\n            } : {\n              from: range.head,\n              to: other\n            };\n          });\n        }\n      }),\n      findPosV: function findPosV(from, amount, unit, goalColumn) {\n        var dir = 1,\n            x = goalColumn;\n\n        if (amount < 0) {\n          dir = -1;\n          amount = -amount;\n        }\n\n        var cur = _clipPos(this.doc, from);\n\n        for (var i = 0; i < amount; ++i) {\n          var coords = _cursorCoords(this, cur, \"div\");\n\n          if (x == null) {\n            x = coords.left;\n          } else {\n            coords.left = x;\n          }\n\n          cur = _findPosV(this, coords, dir, unit);\n\n          if (cur.hitSide) {\n            break;\n          }\n        }\n\n        return cur;\n      },\n      moveV: methodOp(function (dir, unit) {\n        var this$1 = this;\n        var doc = this.doc,\n            goals = [];\n        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range) {\n          if (collapse) {\n            return dir < 0 ? range.from() : range.to();\n          }\n\n          var headPos = _cursorCoords(this$1, range.head, \"div\");\n\n          if (range.goalColumn != null) {\n            headPos.left = range.goalColumn;\n          }\n\n          goals.push(headPos.left);\n\n          var pos = _findPosV(this$1, headPos, dir, unit);\n\n          if (unit == \"page\" && range == doc.sel.primary()) {\n            addToScrollTop(this$1, _charCoords(this$1, pos, \"div\").top - headPos.top);\n          }\n\n          return pos;\n        }, sel_move);\n\n        if (goals.length) {\n          for (var i = 0; i < doc.sel.ranges.length; i++) {\n            doc.sel.ranges[i].goalColumn = goals[i];\n          }\n        }\n      }),\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function findWordAt(pos) {\n        var doc = this.doc,\n            line = getLine(doc, pos.line).text;\n        var start = pos.ch,\n            end = pos.ch;\n\n        if (line) {\n          var helper = this.getHelper(pos, \"wordChars\");\n\n          if ((pos.sticky == \"before\" || end == line.length) && start) {\n            --start;\n          } else {\n            ++end;\n          }\n\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper) ? function (ch) {\n            return isWordChar(ch, helper);\n          } : /\\s/.test(startChar) ? function (ch) {\n            return /\\s/.test(ch);\n          } : function (ch) {\n            return !/\\s/.test(ch) && !isWordChar(ch);\n          };\n\n          while (start > 0 && check(line.charAt(start - 1))) {\n            --start;\n          }\n\n          while (end < line.length && check(line.charAt(end))) {\n            ++end;\n          }\n        }\n\n        return new Range(Pos(pos.line, start), Pos(pos.line, end));\n      },\n      toggleOverwrite: function toggleOverwrite(value) {\n        if (value != null && value == this.state.overwrite) {\n          return;\n        }\n\n        if (this.state.overwrite = !this.state.overwrite) {\n          addClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n        } else {\n          rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\");\n        }\n\n        signal(this, \"overwriteToggle\", this, this.state.overwrite);\n      },\n      hasFocus: function hasFocus() {\n        return this.display.input.getField() == activeElt();\n      },\n      isReadOnly: function isReadOnly() {\n        return !!(this.options.readOnly || this.doc.cantEdit);\n      },\n      scrollTo: methodOp(function (x, y) {\n        scrollToCoords(this, x, y);\n      }),\n      getScrollInfo: function getScrollInfo() {\n        var scroller = this.display.scroller;\n        return {\n          left: scroller.scrollLeft,\n          top: scroller.scrollTop,\n          height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n          width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n          clientHeight: displayHeight(this),\n          clientWidth: displayWidth(this)\n        };\n      },\n      scrollIntoView: methodOp(function (range, margin) {\n        if (range == null) {\n          range = {\n            from: this.doc.sel.primary().head,\n            to: null\n          };\n\n          if (margin == null) {\n            margin = this.options.cursorScrollMargin;\n          }\n        } else if (typeof range == \"number\") {\n          range = {\n            from: Pos(range, 0),\n            to: null\n          };\n        } else if (range.from == null) {\n          range = {\n            from: range,\n            to: null\n          };\n        }\n\n        if (!range.to) {\n          range.to = range.from;\n        }\n\n        range.margin = margin || 0;\n\n        if (range.from.line != null) {\n          scrollToRange(this, range);\n        } else {\n          scrollToCoordsRange(this, range.from, range.to, range.margin);\n        }\n      }),\n      setSize: methodOp(function (width, height) {\n        var this$1 = this;\n\n        var interpret = function interpret(val) {\n          return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val;\n        };\n\n        if (width != null) {\n          this.display.wrapper.style.width = interpret(width);\n        }\n\n        if (height != null) {\n          this.display.wrapper.style.height = interpret(height);\n        }\n\n        if (this.options.lineWrapping) {\n          clearLineMeasurementCache(this);\n        }\n\n        var lineNo = this.display.viewFrom;\n        this.doc.iter(lineNo, this.display.viewTo, function (line) {\n          if (line.widgets) {\n            for (var i = 0; i < line.widgets.length; i++) {\n              if (line.widgets[i].noHScroll) {\n                regLineChange(this$1, lineNo, \"widget\");\n                break;\n              }\n            }\n          }\n\n          ++lineNo;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, \"refresh\", this);\n      }),\n      operation: function operation(f) {\n        return runInOp(this, f);\n      },\n      startOperation: function startOperation() {\n        return _startOperation(this);\n      },\n      endOperation: function endOperation() {\n        return _endOperation(this);\n      },\n      refresh: methodOp(function () {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this.display);\n\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping) {\n          estimateLineHeights(this);\n        }\n\n        signal(this, \"refresh\", this);\n      }),\n      swapDoc: methodOp(function (doc) {\n        var old = this.doc;\n        old.cm = null; // Cancel the current text selection if any (#5821)\n\n        if (this.state.selectingText) {\n          this.state.selectingText();\n        }\n\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, \"swapDoc\", this, old);\n        return old;\n      }),\n      phrase: function phrase(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;\n      },\n      getInputField: function getInputField() {\n        return this.display.input.getField();\n      },\n      getWrapperElement: function getWrapperElement() {\n        return this.display.wrapper;\n      },\n      getScrollerElement: function getScrollerElement() {\n        return this.display.scroller;\n      },\n      getGutterElement: function getGutterElement() {\n        return this.display.gutters;\n      }\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function (type, name, value) {\n      if (!helpers.hasOwnProperty(type)) {\n        helpers[type] = CodeMirror[type] = {\n          _global: []\n        };\n      }\n\n      helpers[type][name] = value;\n    };\n\n    CodeMirror.registerGlobalHelper = function (type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n\n      helpers[type]._global.push({\n        pred: predicate,\n        val: value\n      });\n    };\n  } // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"codepoint\", \"char\", \"column\" (like char, but\n  // doesn't cross line boundaries), \"word\" (across next word), or\n  // \"group\" (to the start of next group of word or\n  // non-word-non-whitespace chars). The visually param controls\n  // whether, in right-to-left text, direction 1 means to move towards\n  // the next index in the string, or towards the character to the right\n  // of the current position. The resulting position will have a\n  // hitSide=true property if it reached the end of the document.\n\n\n  function _findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n    var lineDir = visually && doc.direction == \"rtl\" ? -dir : dir;\n\n    function findNextLine() {\n      var l = pos.line + lineDir;\n\n      if (l < doc.first || l >= doc.first + doc.size) {\n        return false;\n      }\n\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l);\n    }\n\n    function moveOnce(boundToLine) {\n      var next;\n\n      if (unit == \"codepoint\") {\n        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));\n\n        if (isNaN(ch)) {\n          next = null;\n        } else {\n          var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;\n          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);\n        }\n      } else if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n\n      if (next == null) {\n        if (!boundToLine && findNextLine()) {\n          pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);\n        } else {\n          return false;\n        }\n      } else {\n        pos = next;\n      }\n\n      return true;\n    }\n\n    if (unit == \"char\" || unit == \"codepoint\") {\n      moveOnce();\n    } else if (unit == \"column\") {\n      moveOnce(true);\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null,\n          group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) {\n          break;\n        }\n\n        var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\" : group && cur == \"\\n\" ? \"n\" : !group || /\\s/.test(cur) ? null : \"p\";\n\n        if (group && !first && !type) {\n          type = \"s\";\n        }\n\n        if (sawType && sawType != type) {\n          if (dir < 0) {\n            dir = 1;\n            moveOnce();\n            pos.sticky = \"after\";\n          }\n\n          break;\n        }\n\n        if (type) {\n          sawType = type;\n        }\n\n        if (dir > 0 && !moveOnce(!first)) {\n          break;\n        }\n      }\n    }\n\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n\n    if (equalCursorPos(oldPos, result)) {\n      result.hitSide = true;\n    }\n\n    return result;\n  } // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n\n\n  function _findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc,\n        x = pos.left,\n        y;\n\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n\n    var target;\n\n    for (;;) {\n      target = _coordsChar(cm, x, y);\n\n      if (!target.outside) {\n        break;\n      }\n\n      if (dir < 0 ? y <= 0 : y >= doc.height) {\n        target.hitSide = true;\n        break;\n      }\n\n      y += dir * 5;\n    }\n\n    return target;\n  } // CONTENTEDITABLE INPUT STYLE\n\n\n  var ContentEditableInput = function ContentEditableInput(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n    var this$1 = this;\n    var input = this,\n        cm = input.cm;\n    var div = input.div = display.lineDiv;\n    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n\n    function belongsToInput(e) {\n      for (var t = e.target; t; t = t.parentNode) {\n        if (t == div) {\n          return true;\n        }\n\n        if (/\\bCodeMirror-(?:line)?widget\\b/.test(t.className)) {\n          break;\n        }\n      }\n\n      return false;\n    }\n\n    on(div, \"paste\", function (e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n        return;\n      } // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n\n\n      if (ie_version <= 11) {\n        setTimeout(operation(cm, function () {\n          return this$1.updateFromDOM();\n        }), 20);\n      }\n    });\n    on(div, \"compositionstart\", function (e) {\n      this$1.composing = {\n        data: e.data,\n        done: false\n      };\n    });\n    on(div, \"compositionupdate\", function (e) {\n      if (!this$1.composing) {\n        this$1.composing = {\n          data: e.data,\n          done: false\n        };\n      }\n    });\n    on(div, \"compositionend\", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) {\n          this$1.readFromDOMSoon();\n        }\n\n        this$1.composing.done = true;\n      }\n    });\n    on(div, \"touchstart\", function () {\n      return input.forceCompositionEnd();\n    });\n    on(div, \"input\", function () {\n      if (!this$1.composing) {\n        this$1.readFromDOMSoon();\n      }\n    });\n\n    function onCopyCut(e) {\n      if (!belongsToInput(e) || signalDOMEvent(cm, e)) {\n        return;\n      }\n\n      if (cm.somethingSelected()) {\n        setLastCopied({\n          lineWise: false,\n          text: cm.getSelections()\n        });\n\n        if (e.type == \"cut\") {\n          cm.replaceSelection(\"\", null, \"cut\");\n        }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return;\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({\n          lineWise: true,\n          text: ranges.text\n        });\n\n        if (e.type == \"cut\") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection(\"\", null, \"cut\");\n          });\n        }\n      }\n\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join(\"\\n\"); // iOS exposes the clipboard API, but seems to discard content inserted into it\n\n        e.clipboardData.setData(\"Text\", content);\n\n        if (e.clipboardData.getData(\"Text\") == content) {\n          e.preventDefault();\n          return;\n        }\n      } // Old-fashioned briefly-focus-a-textarea hack\n\n\n      var kludge = hiddenTextarea(),\n          te = kludge.firstChild;\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join(\"\\n\");\n      var hadFocus = document.activeElement;\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n\n        if (hadFocus == div) {\n          input.showPrimarySelection();\n        }\n      }, 50);\n    }\n\n    on(div, \"copy\", onCopyCut);\n    on(div, \"cut\", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if (label) {\n      this.div.setAttribute('aria-label', label);\n    } else {\n      this.div.removeAttribute('aria-label');\n    }\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = document.activeElement == this.div;\n    return result;\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) {\n      return;\n    }\n\n    if (info.focus || takeFocus) {\n      this.showPrimarySelection();\n    }\n\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection();\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(),\n        cm = this.cm,\n        prim = cm.doc.sel.primary();\n    var from = prim.from(),\n        to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return;\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {\n      return;\n    }\n\n    var view = cm.display.view;\n    var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {\n      node: view[0].measure.map[2],\n      offset: 0\n    };\n    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {\n        node: map[map.length - 1],\n        offset: map[map.length - 2] - map[map.length - 3]\n      };\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return;\n    }\n\n    var old = sel.rangeCount && sel.getRangeAt(0),\n        rng;\n\n    try {\n      rng = range(start.node, start.offset, end.offset, end.node);\n    } catch (e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n\n\n    if (rng) {\n      if (!gecko && cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n\n      if (old && sel.anchorNode == null) {\n        sel.addRange(old);\n      } else if (gecko) {\n        this.startGracePeriod();\n      }\n    }\n\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n    var this$1 = this;\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n\n      if (this$1.selectionChanged()) {\n        this$1.cm.operation(function () {\n          return this$1.cm.curOp.selectionChanged = true;\n        });\n      }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode;\n    this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode;\n    this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n\n    if (!sel.rangeCount) {\n      return false;\n    }\n\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node);\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\") {\n      if (!this.selectionInEditor() || document.activeElement != this.div) {\n        this.showSelection(this.prepareSelection(), true);\n      }\n\n      this.div.focus();\n    }\n  };\n\n  ContentEditableInput.prototype.blur = function () {\n    this.div.blur();\n  };\n\n  ContentEditableInput.prototype.getField = function () {\n    return this.div;\n  };\n\n  ContentEditableInput.prototype.supportsTouch = function () {\n    return true;\n  };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n    var input = this;\n\n    if (this.selectionInEditor()) {\n      this.pollSelection();\n    } else {\n      runInOp(this.cm, function () {\n        return input.cm.curOp.selectionChanged = true;\n      });\n    }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {\n      return;\n    }\n\n    var sel = this.getSelection(),\n        cm = this.cm; // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it's not editable, hide the virtual keyboard.\n    // Because Android doesn't allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n\n    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({\n        type: \"keydown\",\n        keyCode: 8,\n        preventDefault: Math.abs\n      });\n      this.blur();\n      this.focus();\n      return;\n    }\n\n    if (this.composing) {\n      return;\n    }\n\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n\n    if (anchor && head) {\n      runInOp(cm, function () {\n        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n\n        if (anchor.bad || head.bad) {\n          cm.curOp.selectionChanged = true;\n        }\n      });\n    }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm,\n        display = cm.display,\n        sel = cm.doc.sel.primary();\n    var from = sel.from(),\n        to = sel.to();\n\n    if (from.ch == 0 && from.line > cm.firstLine()) {\n      from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);\n    }\n\n    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {\n      to = Pos(to.line + 1, 0);\n    }\n\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) {\n      return false;\n    }\n\n    var fromIndex, fromLine, fromNode;\n\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) {\n      return false;\n    }\n\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n\n    while (newText.length > 1 && oldText.length > 1) {\n      if (lst(newText) == lst(oldText)) {\n        newText.pop();\n        oldText.pop();\n        toLine--;\n      } else if (newText[0] == oldText[0]) {\n        newText.shift();\n        oldText.shift();\n        fromLine++;\n      } else {\n        break;\n      }\n    }\n\n    var cutFront = 0,\n        cutEnd = 0;\n    var newTop = newText[0],\n        oldTop = oldText[0],\n        maxCutFront = Math.min(newTop.length, oldTop.length);\n\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {\n      ++cutFront;\n    }\n\n    var newBot = lst(newText),\n        oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));\n\n    while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n      ++cutEnd;\n    } // Try to move start of change to start of selection if ambiguous\n\n\n    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n      while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n      _replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n\n      return true;\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) {\n      return;\n    }\n\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n    var this$1 = this;\n\n    if (this.readDOMTimeout != null) {\n      return;\n    }\n\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n\n      if (this$1.composing) {\n        if (this$1.composing.done) {\n          this$1.composing = null;\n        } else {\n          return;\n        }\n      }\n\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n    var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent()) {\n      runInOp(this.cm, function () {\n        return regChange(this$1.cm);\n      });\n    }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = \"false\";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) {\n      return;\n    }\n\n    e.preventDefault();\n\n    if (!this.cm.isReadOnly()) {\n      operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);\n    }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != \"nocursor\");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n\n    if (!view || view.hidden) {\n      return null;\n    }\n\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n    var order = getOrder(line, cm.doc.direction),\n        side = \"left\";\n\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result;\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode) {\n      if (/CodeMirror-gutter-wrapper/.test(scan.className)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function badPos(pos, bad) {\n    if (bad) {\n      pos.bad = true;\n    }\n\n    return pos;\n  }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\",\n        closing = false,\n        lineSep = cm.doc.lineSeparator(),\n        extraLinebreak = false;\n\n    function recognizeMarker(id) {\n      return function (marker) {\n        return marker.id == id;\n      };\n    }\n\n    function close() {\n      if (closing) {\n        text += lineSep;\n\n        if (extraLinebreak) {\n          text += lineSep;\n        }\n\n        closing = extraLinebreak = false;\n      }\n    }\n\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n\n        if (cmText) {\n          addText(cmText);\n          return;\n        }\n\n        var markerID = node.getAttribute(\"cm-marker\"),\n            range;\n\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n\n          if (found.length && (range = found[0].find(0))) {\n            addText(getBetween(cm.doc, range.from, range.to).join(lineSep));\n          }\n\n          return;\n        }\n\n        if (node.getAttribute(\"contenteditable\") == \"false\") {\n          return;\n        }\n\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n\n        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {\n          return;\n        }\n\n        if (isBlock) {\n          close();\n        }\n\n        for (var i = 0; i < node.childNodes.length; i++) {\n          walk(node.childNodes[i]);\n        }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) {\n          extraLinebreak = true;\n        }\n\n        if (isBlock) {\n          closing = true;\n        }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n      }\n    }\n\n    for (;;) {\n      walk(from);\n\n      if (from == to) {\n        break;\n      }\n\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n\n    return text;\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n\n      if (!lineNode) {\n        return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);\n      }\n\n      node = null;\n      offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) {\n          return null;\n        }\n\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {\n          break;\n        }\n      }\n    }\n\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n\n      if (lineView.node == lineNode) {\n        return locateNodeInLineView(lineView, node, offset);\n      }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild,\n        bad = false;\n\n    if (!node || !contains(wrapper, node)) {\n      return badPos(Pos(lineNo(lineView.line), 0), true);\n    }\n\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad);\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null,\n        topNode = node;\n\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n\n      if (offset) {\n        offset = textNode.nodeValue.length;\n      }\n    }\n\n    while (topNode.parentNode != wrapper) {\n      topNode = topNode.parentNode;\n    }\n\n    var measure = lineView.measure,\n        maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map = i < 0 ? measure.map : maps[i];\n\n        for (var j = 0; j < map.length; j += 3) {\n          var curNode = map[j + 2];\n\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map[j] + offset;\n\n            if (offset < 0 || curNode != textNode) {\n              ch = map[j + (offset ? 1 : 0)];\n            }\n\n            return Pos(line, ch);\n          }\n        }\n      }\n    }\n\n    var found = find(textNode, topNode, offset);\n\n    if (found) {\n      return badPos(found, bad);\n    } // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n\n\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n\n      if (found) {\n        return badPos(Pos(found.line, found.ch - dist), bad);\n      } else {\n        dist += after.textContent.length;\n      }\n    }\n\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n\n      if (found) {\n        return badPos(Pos(found.line, found.ch + dist$1), bad);\n      } else {\n        dist$1 += before.textContent.length;\n      }\n    }\n  } // TEXTAREA INPUT STYLE\n\n\n  var TextareaInput = function TextareaInput(cm) {\n    this.cm = cm; // See input.poll and input.reset\n\n    this.prevInput = \"\"; // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n\n    this.pollingFast = false; // Self-resetting timeout for the poller\n\n    this.polling = new Delayed(); // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n    var this$1 = this;\n    var input = this,\n        cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild); // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n\n    if (ios) {\n      te.style.width = \"0px\";\n    }\n\n    on(te, \"input\", function () {\n      if (ie && ie_version >= 9 && this$1.hasSelection) {\n        this$1.hasSelection = null;\n      }\n\n      input.poll();\n    });\n    on(te, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {\n        return;\n      }\n\n      cm.state.pasteIncoming = +new Date();\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) {\n        return;\n      }\n\n      if (cm.somethingSelected()) {\n        setLastCopied({\n          lineWise: false,\n          text: cm.getSelections()\n        });\n      } else if (!cm.options.lineWiseCopyCut) {\n        return;\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({\n          lineWise: true,\n          text: ranges.text\n        });\n\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = \"\";\n          te.value = ranges.text.join(\"\\n\");\n          selectInput(te);\n        }\n      }\n\n      if (e.type == \"cut\") {\n        cm.state.cutIncoming = +new Date();\n      }\n    }\n\n    on(te, \"cut\", prepareCopyCut);\n    on(te, \"copy\", prepareCopyCut);\n    on(display.scroller, \"paste\", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {\n        return;\n      }\n\n      if (!te.dispatchEvent) {\n        cm.state.pasteIncoming = +new Date();\n        input.focus();\n        return;\n      } // Pass the `paste` event to the textarea so it's handled by its event listener.\n\n\n      var event = new Event(\"paste\");\n      event.clipboardData = e.clipboardData;\n      te.dispatchEvent(event);\n    }); // Prevent normal selection in the editor (we handle our own)\n\n    on(display.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(display, e)) {\n        e_preventDefault(e);\n      }\n    });\n    on(te, \"compositionstart\", function () {\n      var start = cm.getCursor(\"from\");\n\n      if (input.composing) {\n        input.composing.range.clear();\n      }\n\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor(\"to\"), {\n          className: \"CodeMirror-composing\"\n        })\n      };\n    });\n    on(te, \"compositionend\", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea(); // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n\n    this.textarea = this.wrapper.firstChild;\n  };\n\n  TextareaInput.prototype.screenReaderLabelChanged = function (label) {\n    // Label for screenreaders, accessibility\n    if (label) {\n      this.textarea.setAttribute('aria-label', label);\n    } else {\n      this.textarea.removeAttribute('aria-label');\n    }\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm,\n        display = cm.display,\n        doc = cm.doc;\n    var result = prepareSelection(cm); // Move the hidden textarea near the cursor to prevent scrolling artifacts\n\n    if (cm.options.moveInputWithCursor) {\n      var headPos = _cursorCoords(cm, doc.sel.primary().head, \"div\");\n\n      var wrapOff = display.wrapper.getBoundingClientRect(),\n          lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result;\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm,\n        display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + \"px\";\n      this.wrapper.style.left = drawn.teLeft + \"px\";\n    }\n  }; // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n\n\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing) {\n      return;\n    }\n\n    var cm = this.cm;\n\n    if (cm.somethingSelected()) {\n      this.prevInput = \"\";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n\n      if (cm.state.focused) {\n        selectInput(this.textarea);\n      }\n\n      if (ie && ie_version >= 9) {\n        this.hasSelection = content;\n      }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = \"\";\n\n      if (ie && ie_version >= 9) {\n        this.hasSelection = null;\n      }\n    }\n  };\n\n  TextareaInput.prototype.getField = function () {\n    return this.textarea;\n  };\n\n  TextareaInput.prototype.supportsTouch = function () {\n    return false;\n  };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n      try {\n        this.textarea.focus();\n      } catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n\n    }\n  };\n\n  TextareaInput.prototype.blur = function () {\n    this.textarea.blur();\n  };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () {\n    this.slowPoll();\n  }; // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n\n\n  TextareaInput.prototype.slowPoll = function () {\n    var this$1 = this;\n\n    if (this.pollingFast) {\n      return;\n    }\n\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n\n      if (this$1.cm.state.focused) {\n        this$1.slowPoll();\n      }\n    });\n  }; // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n\n\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false,\n        input = this;\n    input.pollingFast = true;\n\n    function p() {\n      var changed = input.poll();\n\n      if (!changed && !missed) {\n        missed = true;\n        input.polling.set(60, p);\n      } else {\n        input.pollingFast = false;\n        input.slowPoll();\n      }\n    }\n\n    input.polling.set(20, p);\n  }; // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n\n\n  TextareaInput.prototype.poll = function () {\n    var this$1 = this;\n    var cm = this.cm,\n        input = this.textarea,\n        prevInput = this.prevInput; // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n\n    if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {\n      return false;\n    }\n\n    var text = input.value; // If nothing changed, bail.\n\n    if (text == prevInput && !cm.somethingSelected()) {\n      return false;\n    } // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n\n\n    if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false;\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n\n      if (first == 0x200b && !prevInput) {\n        prevInput = \"\\u200B\";\n      }\n\n      if (first == 0x21da) {\n        this.reset();\n        return this.cm.execCommand(\"undo\");\n      }\n    } // Find the part of the input that is actually new\n\n\n    var same = 0,\n        l = Math.min(prevInput.length, text.length);\n\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) {\n      ++same;\n    }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? \"*compose\" : null); // Don't leave long text in the textarea, since it makes further polling slow\n\n      if (text.length > 1000 || text.indexOf(\"\\n\") > -1) {\n        input.value = this$1.prevInput = \"\";\n      } else {\n        this$1.prevInput = text;\n      }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"), {\n          className: \"CodeMirror-composing\"\n        });\n      }\n    });\n    return true;\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast && this.poll()) {\n      this.pollingFast = false;\n    }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie && ie_version >= 9) {\n      this.hasSelection = null;\n    }\n\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this,\n        cm = input.cm,\n        display = cm.display,\n        te = input.textarea;\n\n    if (input.contextMenuPending) {\n      input.contextMenuPending();\n    }\n\n    var pos = posFromMouse(cm, e),\n        scrollPos = display.scroller.scrollTop;\n\n    if (!pos || presto) {\n      return;\n    } // Opera is difficult.\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n\n\n    var reset = cm.options.resetSelectionOnContextMenu;\n\n    if (reset && cm.doc.sel.contains(pos) == -1) {\n      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\n    }\n\n    var oldCSS = te.style.cssText,\n        oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = \"position: static\";\n    te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    var oldScrollY;\n\n    if (webkit) {\n      oldScrollY = window.scrollY;\n    } // Work around Chrome issue (#2712)\n\n\n    display.input.focus();\n\n    if (webkit) {\n      window.scrollTo(null, oldScrollY);\n    }\n\n    display.input.reset(); // Adds \"Select all\" to context menu in FF\n\n    if (!cm.somethingSelected()) {\n      te.value = input.prevInput = \" \";\n    }\n\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll); // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = \"\\u200B\" + (selected ? te.value : \"\");\n        te.value = \"\\u21DA\"; // Used to catch context-menu undo\n\n        te.value = extval;\n        input.prevInput = selected ? \"\" : \"\\u200B\";\n        te.selectionStart = 1;\n        te.selectionEnd = extval.length; // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n\n    function rehide() {\n      if (input.contextMenuPending != rehide) {\n        return;\n      }\n\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n\n      if (ie && ie_version < 9) {\n        display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);\n      } // Try to detect the user choosing select-all\n\n\n      if (te.selectionStart != null) {\n        if (!ie || ie && ie_version < 9) {\n          prepareSelectAllHack();\n        }\n\n        var i = 0,\n            poll = function poll() {\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == \"\\u200B\") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ < 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) {\n      prepareSelectAllHack();\n    }\n\n    if (captureRightClick) {\n      e_stop(e);\n\n      var mouseup = function mouseup() {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) {\n      this.reset();\n    }\n\n    this.textarea.disabled = val == \"nocursor\";\n    this.textarea.readOnly = !!val;\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n\n    if (!options.tabindex && textarea.tabIndex) {\n      options.tabindex = textarea.tabIndex;\n    }\n\n    if (!options.placeholder && textarea.placeholder) {\n      options.placeholder = textarea.placeholder;\n    } // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n\n\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea || textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {\n      textarea.value = cm.getValue();\n    }\n\n    var realSubmit;\n\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save); // Deplorable hack to make the submit method do the right thing.\n\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch (e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n\n      cm.getTextArea = function () {\n        return textarea;\n      };\n\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n\n          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == \"function\") {\n            textarea.form.submit = realSubmit;\n          }\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) {\n      return textarea.parentNode.insertBefore(node, textarea.nextSibling);\n    }, options);\n    return cm;\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  } // EDITOR CONSTRUCTOR\n\n\n  defineOptions(CodeMirror);\n  addEditorMethods(CodeMirror); // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n\n  for (var prop in Doc.prototype) {\n    if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {\n      CodeMirror.prototype[prop] = function (method) {\n        return function () {\n          return method.apply(this.doc, arguments);\n        };\n      }(Doc.prototype[prop]);\n    }\n  }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {\n    \"textarea\": TextareaInput,\n    \"contenteditable\": ContentEditableInput\n  }; // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n\n  CodeMirror.defineMode = function (name\n  /*, mode, */\n  ) {\n    if (!CodeMirror.defaults.mode && name != \"null\") {\n      CodeMirror.defaults.mode = name;\n    }\n\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME; // Minimal default mode.\n\n  CodeMirror.defineMode(\"null\", function () {\n    return {\n      token: function token(stream) {\n        return stream.skipToEnd();\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"text/plain\", \"null\"); // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n  addLegacyProps(CodeMirror);\n  CodeMirror.version = \"5.59.2\";\n  return CodeMirror;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvanMvY29kZW1pcnJvci5qcz83OTQxIl0sIm5hbWVzIjpbImdsb2JhbCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwidXNlckFnZW50IiwibmF2aWdhdG9yIiwicGxhdGZvcm0iLCJnZWNrbyIsInRlc3QiLCJpZV91cHRvMTAiLCJpZV8xMXVwIiwiZXhlYyIsImVkZ2UiLCJpZSIsImllX3ZlcnNpb24iLCJkb2N1bWVudCIsImRvY3VtZW50TW9kZSIsIndlYmtpdCIsInF0d2Via2l0IiwiY2hyb21lIiwicHJlc3RvIiwic2FmYXJpIiwidmVuZG9yIiwibWFjX2dlTW91bnRhaW5MaW9uIiwicGhhbnRvbSIsImlvcyIsIm1heFRvdWNoUG9pbnRzIiwiYW5kcm9pZCIsIm1vYmlsZSIsIm1hYyIsImNocm9tZU9TIiwid2luZG93cyIsInByZXN0b192ZXJzaW9uIiwibWF0Y2giLCJOdW1iZXIiLCJmbGlwQ3RybENtZCIsImNhcHR1cmVSaWdodENsaWNrIiwiY2xhc3NUZXN0IiwiY2xzIiwiUmVnRXhwIiwicm1DbGFzcyIsIm5vZGUiLCJjdXJyZW50IiwiY2xhc3NOYW1lIiwiYWZ0ZXIiLCJzbGljZSIsImluZGV4IiwibGVuZ3RoIiwicmVtb3ZlQ2hpbGRyZW4iLCJlIiwiY291bnQiLCJjaGlsZE5vZGVzIiwicmVtb3ZlQ2hpbGQiLCJmaXJzdENoaWxkIiwicmVtb3ZlQ2hpbGRyZW5BbmRBZGQiLCJwYXJlbnQiLCJhcHBlbmRDaGlsZCIsImVsdCIsInRhZyIsImNvbnRlbnQiLCJzdHlsZSIsImNyZWF0ZUVsZW1lbnQiLCJjc3NUZXh0IiwiY3JlYXRlVGV4dE5vZGUiLCJpIiwiZWx0UCIsInNldEF0dHJpYnV0ZSIsInJhbmdlIiwiY3JlYXRlUmFuZ2UiLCJzdGFydCIsImVuZCIsImVuZE5vZGUiLCJyIiwic2V0RW5kIiwic2V0U3RhcnQiLCJib2R5IiwiY3JlYXRlVGV4dFJhbmdlIiwibW92ZVRvRWxlbWVudFRleHQiLCJwYXJlbnROb2RlIiwiY29sbGFwc2UiLCJtb3ZlRW5kIiwibW92ZVN0YXJ0IiwiY29udGFpbnMiLCJjaGlsZCIsIm5vZGVUeXBlIiwiaG9zdCIsImFjdGl2ZUVsdCIsImFjdGl2ZUVsZW1lbnQiLCJzaGFkb3dSb290IiwiYWRkQ2xhc3MiLCJqb2luQ2xhc3NlcyIsImEiLCJiIiwiYXMiLCJzcGxpdCIsInNlbGVjdElucHV0Iiwic2VsZWN0Iiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJ2YWx1ZSIsIl9lIiwiYmluZCIsImYiLCJhcmdzIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJjYWxsIiwiYXJndW1lbnRzIiwiYXBwbHkiLCJjb3B5T2JqIiwib2JqIiwidGFyZ2V0Iiwib3ZlcndyaXRlIiwicHJvcCIsImhhc093blByb3BlcnR5IiwiY291bnRDb2x1bW4iLCJzdHJpbmciLCJ0YWJTaXplIiwic3RhcnRJbmRleCIsInN0YXJ0VmFsdWUiLCJzZWFyY2giLCJuIiwibmV4dFRhYiIsImluZGV4T2YiLCJEZWxheWVkIiwiaWQiLCJ0aW1lIiwiaGFuZGxlciIsIm9uVGltZW91dCIsInNlbGYiLCJEYXRlIiwic2V0VGltZW91dCIsInNldCIsIm1zIiwiY2xlYXJUaW1lb3V0IiwiYXJyYXkiLCJzY3JvbGxlckdhcCIsIlBhc3MiLCJ0b1N0cmluZyIsInNlbF9kb250U2Nyb2xsIiwic2Nyb2xsIiwic2VsX21vdXNlIiwib3JpZ2luIiwic2VsX21vdmUiLCJmaW5kQ29sdW1uIiwiZ29hbCIsInBvcyIsImNvbCIsInNraXBwZWQiLCJNYXRoIiwibWluIiwic3BhY2VTdHJzIiwic3BhY2VTdHIiLCJwdXNoIiwibHN0IiwiYXJyIiwibWFwIiwib3V0IiwiaW5zZXJ0U29ydGVkIiwic2NvcmUiLCJwcmlvcml0eSIsInNwbGljZSIsIm5vdGhpbmciLCJjcmVhdGVPYmoiLCJiYXNlIiwicHJvcHMiLCJpbnN0IiwiT2JqZWN0IiwiY3JlYXRlIiwibm9uQVNDSUlTaW5nbGVDYXNlV29yZENoYXIiLCJpc1dvcmRDaGFyQmFzaWMiLCJjaCIsInRvVXBwZXJDYXNlIiwidG9Mb3dlckNhc2UiLCJpc1dvcmRDaGFyIiwiaGVscGVyIiwic291cmNlIiwiaXNFbXB0eSIsImV4dGVuZGluZ0NoYXJzIiwiaXNFeHRlbmRpbmdDaGFyIiwiY2hhckNvZGVBdCIsInNraXBFeHRlbmRpbmdDaGFycyIsInN0ciIsImRpciIsImNoYXJBdCIsImZpbmRGaXJzdCIsInByZWQiLCJmcm9tIiwidG8iLCJtaWRGIiwibWlkIiwiY2VpbCIsImZsb29yIiwiaXRlcmF0ZUJpZGlTZWN0aW9ucyIsIm9yZGVyIiwiZm91bmQiLCJwYXJ0IiwibWF4IiwibGV2ZWwiLCJiaWRpT3RoZXIiLCJnZXRCaWRpUGFydEF0Iiwic3RpY2t5IiwiY3VyIiwiYmlkaU9yZGVyaW5nIiwibG93VHlwZXMiLCJhcmFiaWNUeXBlcyIsImNoYXJUeXBlIiwiY29kZSIsImJpZGlSRSIsImlzTmV1dHJhbCIsImlzU3Ryb25nIiwiY291bnRzQXNMZWZ0IiwiY291bnRzQXNOdW0iLCJCaWRpU3BhbiIsImRpcmVjdGlvbiIsIm91dGVyVHlwZSIsImxlbiIsInR5cGVzIiwiaSQxIiwicHJldiIsInR5cGUiLCJpJDIiLCJ0eXBlJDEiLCJpJDMiLCJwcmV2JDEiLCJ0eXBlJDIiLCJpJDQiLCJ0eXBlJDMiLCJyZXBsYWNlIiwiaiIsImkkNSIsImN1ciQxIiwidHlwZSQ0IiwiaSQ2IiwiZW5kJDEiLCJiZWZvcmUiLCJyZXBsYWNlJDEiLCJqJDEiLCJtIiwiaSQ3IiwiYXQiLCJpc1JUTCIsImokMiIsIm5zdGFydCIsInVuc2hpZnQiLCJyZXZlcnNlIiwiZ2V0T3JkZXIiLCJsaW5lIiwidGV4dCIsIm5vSGFuZGxlcnMiLCJvbiIsImVtaXR0ZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJfaGFuZGxlcnMiLCJjb25jYXQiLCJnZXRIYW5kbGVycyIsIm9mZiIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJkZXRhY2hFdmVudCIsInNpZ25hbCIsImhhbmRsZXJzIiwic2lnbmFsRE9NRXZlbnQiLCJjbSIsIm92ZXJyaWRlIiwicHJldmVudERlZmF1bHQiLCJkZWZhdWx0UHJldmVudGVkIiwiZV9kZWZhdWx0UHJldmVudGVkIiwiY29kZW1pcnJvcklnbm9yZSIsInNpZ25hbEN1cnNvckFjdGl2aXR5IiwiY3Vyc29yQWN0aXZpdHkiLCJjdXJPcCIsImN1cnNvckFjdGl2aXR5SGFuZGxlcnMiLCJoYXNIYW5kbGVyIiwiZXZlbnRNaXhpbiIsImN0b3IiLCJlX3ByZXZlbnREZWZhdWx0IiwicmV0dXJuVmFsdWUiLCJlX3N0b3BQcm9wYWdhdGlvbiIsInN0b3BQcm9wYWdhdGlvbiIsImNhbmNlbEJ1YmJsZSIsImVfc3RvcCIsImVfdGFyZ2V0Iiwic3JjRWxlbWVudCIsImVfYnV0dG9uIiwid2hpY2giLCJidXR0b24iLCJjdHJsS2V5IiwiZHJhZ0FuZERyb3AiLCJkaXYiLCJ6d3NwU3VwcG9ydGVkIiwiemVyb1dpZHRoRWxlbWVudCIsIm1lYXN1cmUiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsImJhZEJpZGlSZWN0cyIsImhhc0JhZEJpZGlSZWN0cyIsInR4dCIsInIwIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicjEiLCJsZWZ0IiwicmlnaHQiLCJzcGxpdExpbmVzQXV0byIsInJlc3VsdCIsImwiLCJubCIsInJ0IiwiaGFzU2VsZWN0aW9uIiwid2luZG93IiwiZ2V0U2VsZWN0aW9uIiwidGUiLCJvd25lckRvY3VtZW50Iiwic2VsZWN0aW9uIiwicGFyZW50RWxlbWVudCIsImNvbXBhcmVFbmRQb2ludHMiLCJoYXNDb3B5RXZlbnQiLCJvbmNvcHkiLCJiYWRab29tZWRSZWN0cyIsImhhc0JhZFpvb21lZFJlY3RzIiwibm9ybWFsIiwiZnJvbVJhbmdlIiwiYWJzIiwibW9kZXMiLCJtaW1lTW9kZXMiLCJkZWZpbmVNb2RlIiwibmFtZSIsIm1vZGUiLCJkZXBlbmRlbmNpZXMiLCJkZWZpbmVNSU1FIiwibWltZSIsInNwZWMiLCJyZXNvbHZlTW9kZSIsImdldE1vZGUiLCJvcHRpb25zIiwibWZhY3RvcnkiLCJtb2RlT2JqIiwibW9kZUV4dGVuc2lvbnMiLCJleHRzIiwiaGVscGVyVHlwZSIsIm1vZGVQcm9wcyIsInByb3AkMSIsImV4dGVuZE1vZGUiLCJwcm9wZXJ0aWVzIiwiY29weVN0YXRlIiwic3RhdGUiLCJuc3RhdGUiLCJ2YWwiLCJpbm5lck1vZGUiLCJpbmZvIiwic3RhcnRTdGF0ZSIsImExIiwiYTIiLCJTdHJpbmdTdHJlYW0iLCJsaW5lT3JhY2xlIiwibGFzdENvbHVtblBvcyIsImxhc3RDb2x1bW5WYWx1ZSIsImxpbmVTdGFydCIsImVvbCIsInNvbCIsInBlZWsiLCJ1bmRlZmluZWQiLCJuZXh0IiwiZWF0Iiwib2siLCJlYXRXaGlsZSIsImVhdFNwYWNlIiwic2tpcFRvRW5kIiwic2tpcFRvIiwiYmFja1VwIiwiY29sdW1uIiwiaW5kZW50YXRpb24iLCJwYXR0ZXJuIiwiY29uc3VtZSIsImNhc2VJbnNlbnNpdGl2ZSIsImNhc2VkIiwic3Vic3RyIiwiaGlkZUZpcnN0Q2hhcnMiLCJpbm5lciIsImxvb2tBaGVhZCIsIm9yYWNsZSIsImJhc2VUb2tlbiIsImdldExpbmUiLCJkb2MiLCJmaXJzdCIsInNpemUiLCJFcnJvciIsImNodW5rIiwibGluZXMiLCJjaGlsZHJlbiIsInN6IiwiY2h1bmtTaXplIiwiZ2V0QmV0d2VlbiIsIml0ZXIiLCJnZXRMaW5lcyIsInVwZGF0ZUxpbmVIZWlnaHQiLCJoZWlnaHQiLCJkaWZmIiwibGluZU5vIiwibm8iLCJsaW5lQXRIZWlnaHQiLCJoIiwib3V0ZXIiLCJsaCIsImlzTGluZSIsImxpbmVOdW1iZXJGb3IiLCJTdHJpbmciLCJsaW5lTnVtYmVyRm9ybWF0dGVyIiwiZmlyc3RMaW5lTnVtYmVyIiwiUG9zIiwiY21wIiwiZXF1YWxDdXJzb3JQb3MiLCJjb3B5UG9zIiwieCIsIm1heFBvcyIsIm1pblBvcyIsImNsaXBMaW5lIiwiY2xpcFBvcyIsImxhc3QiLCJjbGlwVG9MZW4iLCJsaW5lbGVuIiwiY2xpcFBvc0FycmF5IiwiU2F2ZWRDb250ZXh0IiwiQ29udGV4dCIsIm1heExvb2tBaGVhZCIsImJhc2VUb2tlbnMiLCJiYXNlVG9rZW5Qb3MiLCJuZXh0TGluZSIsImZyb21TYXZlZCIsInNhdmVkIiwic2F2ZSIsImNvcHkiLCJoaWdobGlnaHRMaW5lIiwiY29udGV4dCIsImZvcmNlVG9FbmQiLCJzdCIsIm1vZGVHZW4iLCJsaW5lQ2xhc3NlcyIsInJ1bk1vZGUiLCJsb29wIiwibyIsIm92ZXJsYXkiLCJvdmVybGF5cyIsImlfZW5kIiwib3BhcXVlIiwic3R5bGVzIiwiY2xhc3NlcyIsImJnQ2xhc3MiLCJ0ZXh0Q2xhc3MiLCJnZXRMaW5lU3R5bGVzIiwidXBkYXRlRnJvbnRpZXIiLCJnZXRDb250ZXh0QmVmb3JlIiwicmVzZXRTdGF0ZSIsIm1heEhpZ2hsaWdodExlbmd0aCIsInN0YXRlQWZ0ZXIiLCJzdHlsZUNsYXNzZXMiLCJoaWdobGlnaHRGcm9udGllciIsIm1vZGVGcm9udGllciIsInByZWNpc2UiLCJkaXNwbGF5IiwiZmluZFN0YXJ0TGluZSIsInByb2Nlc3NMaW5lIiwidmlld0Zyb20iLCJ2aWV3VG8iLCJzdGFydEF0Iiwic3RyZWFtIiwiY2FsbEJsYW5rTGluZSIsInJlYWRUb2tlbiIsImJsYW5rTGluZSIsInRva2VuIiwiVG9rZW4iLCJ0YWtlVG9rZW4iLCJhc0FycmF5IiwidG9rZW5zIiwiZXh0cmFjdExpbmVDbGFzc2VzIiwib3V0cHV0IiwibGluZUNsYXNzIiwiZmxhdHRlblNwYW5zIiwiY3VyU3RhcnQiLCJjdXJTdHlsZSIsImFkZE1vZGVDbGFzcyIsIm1OYW1lIiwibWluaW5kZW50IiwibWlubGluZSIsImxpbSIsImluZGVudGVkIiwicmV0cmVhdEZyb250aWVyIiwic2F3UmVhZE9ubHlTcGFucyIsInNhd0NvbGxhcHNlZFNwYW5zIiwic2VlUmVhZE9ubHlTcGFucyIsInNlZUNvbGxhcHNlZFNwYW5zIiwiTWFya2VkU3BhbiIsIm1hcmtlciIsImdldE1hcmtlZFNwYW5Gb3IiLCJzcGFucyIsInNwYW4iLCJyZW1vdmVNYXJrZWRTcGFuIiwiYWRkTWFya2VkU3BhbiIsIm1hcmtlZFNwYW5zIiwiYXR0YWNoTGluZSIsIm1hcmtlZFNwYW5zQmVmb3JlIiwib2xkIiwic3RhcnRDaCIsImlzSW5zZXJ0IiwibnciLCJzdGFydHNCZWZvcmUiLCJpbmNsdXNpdmVMZWZ0IiwiaW5zZXJ0TGVmdCIsImVuZHNBZnRlciIsImluY2x1c2l2ZVJpZ2h0IiwibWFya2VkU3BhbnNBZnRlciIsImVuZENoIiwic3RyZXRjaFNwYW5zT3ZlckNoYW5nZSIsImNoYW5nZSIsImZ1bGwiLCJvbGRGaXJzdCIsIm9sZExhc3QiLCJzYW1lTGluZSIsIm9mZnNldCIsInNwYW4kMSIsImZvdW5kJDEiLCJjbGVhckVtcHR5U3BhbnMiLCJuZXdNYXJrZXJzIiwiZ2FwIiwiZ2FwTWFya2VycyIsImNsZWFyV2hlbkVtcHR5IiwicmVtb3ZlUmVhZE9ubHlSYW5nZXMiLCJtYXJrZXJzIiwibWFyayIsInJlYWRPbmx5IiwicGFydHMiLCJtayIsImZpbmQiLCJwIiwibmV3UGFydHMiLCJkZnJvbSIsImR0byIsImRldGFjaE1hcmtlZFNwYW5zIiwiZGV0YWNoTGluZSIsImF0dGFjaE1hcmtlZFNwYW5zIiwiZXh0cmFMZWZ0IiwiZXh0cmFSaWdodCIsImNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzIiwibGVuRGlmZiIsImFQb3MiLCJiUG9zIiwiZnJvbUNtcCIsInRvQ21wIiwiY29sbGFwc2VkU3BhbkF0U2lkZSIsInNwcyIsInNwIiwiY29sbGFwc2VkIiwiY29sbGFwc2VkU3BhbkF0U3RhcnQiLCJjb2xsYXBzZWRTcGFuQXRFbmQiLCJjb2xsYXBzZWRTcGFuQXJvdW5kIiwiY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZSIsInZpc3VhbExpbmUiLCJtZXJnZWQiLCJ2aXN1YWxMaW5lRW5kIiwidmlzdWFsTGluZUNvbnRpbnVlZCIsInZpc3VhbExpbmVObyIsImxpbmVOIiwidmlzIiwidmlzdWFsTGluZUVuZE5vIiwibGFzdExpbmUiLCJsaW5lSXNIaWRkZW4iLCJ3aWRnZXROb2RlIiwibGluZUlzSGlkZGVuSW5uZXIiLCJoZWlnaHRBdExpbmUiLCJsaW5lT2JqIiwibGluZUxlbmd0aCIsImZpbmRNYXhMaW5lIiwiZCIsIm1heExpbmUiLCJtYXhMaW5lTGVuZ3RoIiwibWF4TGluZUNoYW5nZWQiLCJMaW5lIiwiZXN0aW1hdGVIZWlnaHQiLCJ1cGRhdGVMaW5lIiwiZXN0SGVpZ2h0IiwiY2xlYW5VcExpbmUiLCJzdHlsZVRvQ2xhc3NDYWNoZSIsInN0eWxlVG9DbGFzc0NhY2hlV2l0aE1vZGUiLCJpbnRlcnByZXRUb2tlblN0eWxlIiwiY2FjaGUiLCJidWlsZExpbmVDb250ZW50IiwibGluZVZpZXciLCJidWlsZGVyIiwicHJlIiwidHJhaWxpbmdTcGFjZSIsInNwbGl0U3BhY2VzIiwiZ2V0T3B0aW9uIiwicmVzdCIsImFkZFRva2VuIiwiYnVpbGRUb2tlbiIsImJ1aWxkVG9rZW5CYWRCaWRpIiwiYWxsb3dGcm9udGllclVwZGF0ZSIsImV4dGVybmFsTWVhc3VyZWQiLCJpbnNlcnRMaW5lQ29udGVudCIsIm1hcHMiLCJjYWNoZXMiLCJsYXN0Q2hpbGQiLCJxdWVyeVNlbGVjdG9yIiwiZGVmYXVsdFNwZWNpYWxDaGFyUGxhY2Vob2xkZXIiLCJ0aXRsZSIsInN0YXJ0U3R5bGUiLCJlbmRTdHlsZSIsImNzcyIsImF0dHJpYnV0ZXMiLCJkaXNwbGF5VGV4dCIsInNwZWNpYWwiLCJzcGVjaWFsQ2hhcnMiLCJtdXN0V3JhcCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJsYXN0SW5kZXgiLCJ0eHQkMSIsInRhYldpZHRoIiwic3BlY2lhbENoYXJQbGFjZWhvbGRlciIsImZ1bGxTdHlsZSIsImF0dHIiLCJ0cmFpbGluZ0JlZm9yZSIsInNwYWNlQmVmb3JlIiwiYnVpbGRDb2xsYXBzZWRTcGFuIiwiaWdub3JlV2lkZ2V0Iiwid2lkZ2V0IiwiaW5wdXQiLCJuZWVkc0NvbnRlbnRBdHRyaWJ1dGUiLCJzZXRVbmVkaXRhYmxlIiwiYWxsVGV4dCIsIm5leHRDaGFuZ2UiLCJzcGFuU3R5bGUiLCJzcGFuRW5kU3R5bGUiLCJzcGFuU3RhcnRTdHlsZSIsIkluZmluaXR5IiwiZm91bmRCb29rbWFya3MiLCJlbmRTdHlsZXMiLCJ1cHRvIiwidG9rZW5UZXh0IiwiTGluZVZpZXciLCJoaWRkZW4iLCJidWlsZFZpZXdBcnJheSIsIm5leHRQb3MiLCJ2aWV3Iiwib3BlcmF0aW9uR3JvdXAiLCJwdXNoT3BlcmF0aW9uIiwib3AiLCJvcHMiLCJvd25zR3JvdXAiLCJkZWxheWVkQ2FsbGJhY2tzIiwiZmlyZUNhbGxiYWNrc0Zvck9wcyIsImdyb3VwIiwiY2FsbGJhY2tzIiwiY3Vyc29yQWN0aXZpdHlDYWxsZWQiLCJmaW5pc2hPcGVyYXRpb24iLCJlbmRDYiIsIm9ycGhhbkRlbGF5ZWRDYWxsYmFja3MiLCJzaWduYWxMYXRlciIsImxpc3QiLCJmaXJlT3JwaGFuRGVsYXllZCIsImRlbGF5ZWQiLCJ1cGRhdGVMaW5lRm9yQ2hhbmdlcyIsImRpbXMiLCJjaGFuZ2VzIiwidXBkYXRlTGluZVRleHQiLCJ1cGRhdGVMaW5lR3V0dGVyIiwidXBkYXRlTGluZUNsYXNzZXMiLCJ1cGRhdGVMaW5lV2lkZ2V0cyIsImVuc3VyZUxpbmVXcmFwcGVkIiwicmVwbGFjZUNoaWxkIiwiekluZGV4IiwidXBkYXRlTGluZUJhY2tncm91bmQiLCJiYWNrZ3JvdW5kIiwid3JhcCIsImluc2VydEJlZm9yZSIsImdldExpbmVDb250ZW50IiwiZXh0IiwiYnVpbHQiLCJ3cmFwQ2xhc3MiLCJndXR0ZXIiLCJndXR0ZXJCYWNrZ3JvdW5kIiwiZ3V0dGVyQ2xhc3MiLCJmaXhlZEd1dHRlciIsImZpeGVkUG9zIiwiZ3V0dGVyVG90YWxXaWR0aCIsImd1dHRlck1hcmtlcnMiLCJsaW5lTnVtYmVycyIsIndyYXAkMSIsImd1dHRlcldyYXAiLCJsaW5lTnVtYmVyIiwiZ3V0dGVyTGVmdCIsImxpbmVOdW1Jbm5lcldpZHRoIiwiayIsImd1dHRlclNwZWNzIiwiZ3V0dGVyV2lkdGgiLCJhbGlnbmFibGUiLCJpc1dpZGdldCIsIm5leHRTaWJsaW5nIiwiaW5zZXJ0TGluZVdpZGdldHMiLCJidWlsZExpbmVFbGVtZW50IiwiaW5zZXJ0TGluZVdpZGdldHNGb3IiLCJhbGxvd0Fib3ZlIiwid2lkZ2V0cyIsIndzIiwiaGFuZGxlTW91c2VFdmVudHMiLCJwb3NpdGlvbkxpbmVXaWRnZXQiLCJhYm92ZSIsIm5vSFNjcm9sbCIsIndpZHRoIiwid3JhcHBlcldpZHRoIiwiY292ZXJHdXR0ZXIiLCJwYWRkaW5nTGVmdCIsInBvc2l0aW9uIiwibWFyZ2luTGVmdCIsIndpZGdldEhlaWdodCIsInBhcmVudFN0eWxlIiwiZ3V0dGVycyIsIndyYXBwZXIiLCJjbGllbnRXaWR0aCIsImV2ZW50SW5XaWRnZXQiLCJnZXRBdHRyaWJ1dGUiLCJzaXplciIsIm1vdmVyIiwicGFkZGluZ1RvcCIsImxpbmVTcGFjZSIsIm9mZnNldFRvcCIsInBhZGRpbmdWZXJ0IiwicGFkZGluZ0giLCJjYWNoZWRQYWRkaW5nSCIsImdldENvbXB1dGVkU3R5bGUiLCJjdXJyZW50U3R5bGUiLCJkYXRhIiwicGFyc2VJbnQiLCJwYWRkaW5nUmlnaHQiLCJpc05hTiIsInNjcm9sbEdhcCIsIm5hdGl2ZUJhcldpZHRoIiwiZGlzcGxheVdpZHRoIiwic2Nyb2xsZXIiLCJiYXJXaWR0aCIsImRpc3BsYXlIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJiYXJIZWlnaHQiLCJlbnN1cmVMaW5lSGVpZ2h0cyIsInJlY3QiLCJ3cmFwcGluZyIsImxpbmVXcmFwcGluZyIsImN1cldpZHRoIiwiaGVpZ2h0cyIsInJlY3RzIiwiZ2V0Q2xpZW50UmVjdHMiLCJib3R0b20iLCJ0b3AiLCJtYXBGcm9tTGluZVZpZXciLCJ1cGRhdGVFeHRlcm5hbE1lYXN1cmVtZW50IiwibGluZU1lYXN1cmUiLCJtZWFzdXJlQ2hhciIsImJpYXMiLCJtZWFzdXJlQ2hhclByZXBhcmVkIiwicHJlcGFyZU1lYXN1cmVGb3JMaW5lIiwiZmluZFZpZXdGb3JMaW5lIiwiZmluZFZpZXdJbmRleCIsImdldERpbWVuc2lvbnMiLCJmb3JjZVVwZGF0ZSIsImhhc0hlaWdodHMiLCJwcmVwYXJlZCIsInZhckhlaWdodCIsImtleSIsIm1lYXN1cmVDaGFySW5uZXIiLCJib2d1cyIsInJ0b3AiLCJyYm90dG9tIiwibnVsbFJlY3QiLCJub2RlQW5kT2Zmc2V0SW5MaW5lTWFwIiwibVN0YXJ0IiwibUVuZCIsImNvdmVyU3RhcnQiLCJjb3ZlckVuZCIsImdldFVzZWZ1bFJlY3QiLCJwbGFjZSIsIm1heWJlVXBkYXRlUmVjdEZvclpvb21pbmciLCJyU3BhbiIsImNoYXJXaWR0aCIsInJib3QiLCJib3QiLCJzaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lIiwic2NyZWVuIiwibG9naWNhbFhEUEkiLCJkZXZpY2VYRFBJIiwic2NhbGVYIiwic2NhbGVZIiwibG9naWNhbFlEUEkiLCJkZXZpY2VZRFBJIiwiY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvciIsImNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUiLCJleHRlcm5hbE1lYXN1cmUiLCJjbGVhckNhY2hlcyIsImNhY2hlZENoYXJXaWR0aCIsImNhY2hlZFRleHRIZWlnaHQiLCJsaW5lTnVtQ2hhcnMiLCJwYWdlU2Nyb2xsWCIsInBhZ2VYT2Zmc2V0IiwiZG9jdW1lbnRFbGVtZW50Iiwic2Nyb2xsTGVmdCIsInBhZ2VTY3JvbGxZIiwibWFyZ2luVG9wIiwicGFnZVlPZmZzZXQiLCJzY3JvbGxUb3AiLCJ3aWRnZXRUb3BIZWlnaHQiLCJpbnRvQ29vcmRTeXN0ZW0iLCJpbmNsdWRlV2lkZ2V0cyIsInlPZmYiLCJ2aWV3T2Zmc2V0IiwibE9mZiIsInhPZmYiLCJmcm9tQ29vcmRTeXN0ZW0iLCJjb29yZHMiLCJsb2NhbEJveCIsImxpbmVTcGFjZUJveCIsImNoYXJDb29yZHMiLCJjdXJzb3JDb29yZHMiLCJwcmVwYXJlZE1lYXN1cmUiLCJnZXQiLCJnZXRCaWRpIiwicGFydFBvcyIsImludmVydCIsIm90aGVyIiwiZXN0aW1hdGVDb29yZHMiLCJQb3NXaXRoSW5mbyIsIm91dHNpZGUiLCJ4UmVsIiwiY29vcmRzQ2hhciIsInkiLCJjb29yZHNDaGFySW5uZXIiLCJyYW5nZUVuZCIsIndyYXBwZWRMaW5lRXh0ZW50IiwiYmVnaW4iLCJ3cmFwcGVkTGluZUV4dGVudENoYXIiLCJ0YXJnZXRUb3AiLCJib3hJc0FmdGVyIiwiYm94IiwibHRyIiwiY29vcmRzQmlkaVBhcnRXcmFwcGVkIiwiY29vcmRzQmlkaVBhcnQiLCJjaEFyb3VuZCIsImJveEFyb3VuZCIsImJhc2VYIiwiYXRMZWZ0IiwiYXRTdGFydCIsIl9saW5lTm8iLCJyZWYiLCJjbG9zZXN0RGlzdCIsImVuZFgiLCJkaXN0IiwibWVhc3VyZVRleHQiLCJ0ZXh0SGVpZ2h0IiwiYW5jaG9yIiwiY2xpZW50TGVmdCIsIm9mZnNldExlZnQiLCJjb21wZW5zYXRlRm9ySFNjcm9sbCIsInRoIiwicGVyTGluZSIsIndpZGdldHNIZWlnaHQiLCJlc3RpbWF0ZUxpbmVIZWlnaHRzIiwiZXN0IiwicG9zRnJvbU1vdXNlIiwibGliZXJhbCIsImZvclJlY3QiLCJzcGFjZSIsImNsaWVudFgiLCJjbGllbnRZIiwiZSQxIiwiY29sRGlmZiIsInJvdW5kIiwicmVnQ2hhbmdlIiwibGVuZGlmZiIsInVwZGF0ZUxpbmVOdW1iZXJzIiwidmlld0NoYW5nZWQiLCJyZXNldFZpZXciLCJjdXQiLCJ2aWV3Q3V0dGluZ1BvaW50IiwiY3V0JDEiLCJjdXRUb3AiLCJjdXRCb3QiLCJyZWdMaW5lQ2hhbmdlIiwib2xkTiIsIm5ld04iLCJhZGp1c3RWaWV3IiwiY291bnREaXJ0eVZpZXciLCJkaXJ0eSIsInVwZGF0ZVNlbGVjdGlvbiIsInNob3dTZWxlY3Rpb24iLCJwcmVwYXJlU2VsZWN0aW9uIiwicHJpbWFyeSIsImN1ckZyYWdtZW50IiwiY3Vyc29ycyIsInNlbEZyYWdtZW50Iiwic2VsIiwicmFuZ2VzIiwicHJpbUluZGV4IiwiZW1wdHkiLCJzaG93Q3Vyc29yV2hlblNlbGVjdGluZyIsImRyYXdTZWxlY3Rpb25DdXJzb3IiLCJoZWFkIiwiZHJhd1NlbGVjdGlvblJhbmdlIiwiY3Vyc29yIiwiY3Vyc29ySGVpZ2h0Iiwib3RoZXJDdXJzb3IiLCJjbXBDb29yZHMiLCJmcmFnbWVudCIsInBhZGRpbmciLCJsZWZ0U2lkZSIsInJpZ2h0U2lkZSIsInNpemVyV2lkdGgiLCJkb2NMVFIiLCJhZGQiLCJkcmF3Rm9yTGluZSIsImZyb21BcmciLCJ0b0FyZyIsImxpbmVMZW4iLCJ3cmFwWCIsInNpZGUiLCJleHRlbnQiLCJmcm9tUG9zIiwidG9Qb3MiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwib3BlbkxlZnQiLCJvcGVuUmlnaHQiLCJ0b3BMZWZ0IiwidG9wUmlnaHQiLCJib3RMZWZ0IiwiYm90UmlnaHQiLCJzRnJvbSIsInNUbyIsImZyb21MaW5lIiwidG9MaW5lIiwic2luZ2xlVkxpbmUiLCJsZWZ0RW5kIiwicmlnaHRTdGFydCIsInJlc3RhcnRCbGluayIsImZvY3VzZWQiLCJjbGVhckludGVydmFsIiwiYmxpbmtlciIsImN1cnNvckRpdiIsInZpc2liaWxpdHkiLCJjdXJzb3JCbGlua1JhdGUiLCJzZXRJbnRlcnZhbCIsImhhc0ZvY3VzIiwib25CbHVyIiwiZW5zdXJlRm9jdXMiLCJmb2N1cyIsIm9uRm9jdXMiLCJkZWxheUJsdXJFdmVudCIsImRlbGF5aW5nQmx1ckV2ZW50IiwiZHJhZ2dpbmdUZXh0Iiwic2VsRm9yQ29udGV4dE1lbnUiLCJyZXNldCIsInJlY2VpdmVkRm9jdXMiLCJzaGlmdCIsInVwZGF0ZUhlaWdodHNJblZpZXdwb3J0IiwicHJldkJvdHRvbSIsImxpbmVEaXYiLCJ1cGRhdGVXaWRnZXRIZWlnaHQiLCJjaFdpZHRoIiwidyIsInZpc2libGVMaW5lcyIsInZpZXdwb3J0IiwiZW5zdXJlIiwiZW5zdXJlRnJvbSIsImVuc3VyZVRvIiwibWF5YmVTY3JvbGxXaW5kb3ciLCJkb1Njcm9sbCIsImlubmVySGVpZ2h0Iiwic2Nyb2xsTm9kZSIsInNjcm9sbEludG9WaWV3Iiwic2Nyb2xsUG9zSW50b1ZpZXciLCJtYXJnaW4iLCJsaW1pdCIsImNoYW5nZWQiLCJlbmRDb29yZHMiLCJzY3JvbGxQb3MiLCJjYWxjdWxhdGVTY3JvbGxQb3MiLCJzdGFydFRvcCIsInN0YXJ0TGVmdCIsInVwZGF0ZVNjcm9sbFRvcCIsInNldFNjcm9sbExlZnQiLCJzbmFwTWFyZ2luIiwic2NyZWVudG9wIiwiZG9jQm90dG9tIiwiYXRUb3AiLCJhdEJvdHRvbSIsIm5ld1RvcCIsImd1dHRlclNwYWNlIiwic2NyZWVubGVmdCIsInNjcmVlbnciLCJ0b29XaWRlIiwiYWRkVG9TY3JvbGxUb3AiLCJyZXNvbHZlU2Nyb2xsVG9Qb3MiLCJlbnN1cmVDdXJzb3JWaXNpYmxlIiwiZ2V0Q3Vyc29yIiwic2Nyb2xsVG9Qb3MiLCJjdXJzb3JTY3JvbGxNYXJnaW4iLCJzY3JvbGxUb0Nvb3JkcyIsInNjcm9sbFRvUmFuZ2UiLCJzY3JvbGxUb0Nvb3Jkc1JhbmdlIiwic1BvcyIsInVwZGF0ZURpc3BsYXlTaW1wbGUiLCJzZXRTY3JvbGxUb3AiLCJzdGFydFdvcmtlciIsImZvcmNlU2Nyb2xsIiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsYmFycyIsImlzU2Nyb2xsZXIiLCJzY3JvbGxXaWR0aCIsImFsaWduSG9yaXpvbnRhbGx5IiwibWVhc3VyZUZvclNjcm9sbGJhcnMiLCJndXR0ZXJXIiwiZG9jSCIsInZpZXdIZWlnaHQiLCJ2aWV3V2lkdGgiLCJiYXJMZWZ0IiwiZG9jSGVpZ2h0IiwiTmF0aXZlU2Nyb2xsYmFycyIsInZlcnQiLCJob3JpeiIsInRhYkluZGV4IiwiY2hlY2tlZFplcm9XaWR0aCIsIm1pbkhlaWdodCIsIm1pbldpZHRoIiwidXBkYXRlIiwibmVlZHNIIiwibmVlZHNWIiwic1dpZHRoIiwidG90YWxIZWlnaHQiLCJ0b3RhbFdpZHRoIiwiemVyb1dpZHRoSGFjayIsImRpc2FibGVIb3JpeiIsImVuYWJsZVplcm9XaWR0aEJhciIsImRpc2FibGVWZXJ0IiwicG9pbnRlckV2ZW50cyIsImJhciIsImRlbGF5IiwibWF5YmVEaXNhYmxlIiwiZWxlbWVudEZyb21Qb2ludCIsImNsZWFyIiwiTnVsbFNjcm9sbGJhcnMiLCJ1cGRhdGVTY3JvbGxiYXJzIiwic3RhcnRXaWR0aCIsInN0YXJ0SGVpZ2h0IiwidXBkYXRlU2Nyb2xsYmFyc0lubmVyIiwic2l6ZXMiLCJwYWRkaW5nQm90dG9tIiwiaGVpZ2h0Rm9yY2VyIiwiYm9yZGVyQm90dG9tIiwic2Nyb2xsYmFyRmlsbGVyIiwiY292ZXJHdXR0ZXJOZXh0VG9TY3JvbGxiYXIiLCJndXR0ZXJGaWxsZXIiLCJzY3JvbGxiYXJNb2RlbCIsImluaXRTY3JvbGxiYXJzIiwic2Nyb2xsYmFyU3R5bGUiLCJheGlzIiwibmV4dE9wSWQiLCJzdGFydE9wZXJhdGlvbiIsInVwZGF0ZUlucHV0IiwidHlwaW5nIiwiY2hhbmdlT2JqcyIsInNlbGVjdGlvbkNoYW5nZWQiLCJ1cGRhdGVNYXhMaW5lIiwiZW5kT3BlcmF0aW9uIiwiZW5kT3BlcmF0aW9ucyIsImVuZE9wZXJhdGlvbl9SMSIsImVuZE9wZXJhdGlvbl9XMSIsImVuZE9wZXJhdGlvbl9SMiIsImVuZE9wZXJhdGlvbl9XMiIsImVuZE9wZXJhdGlvbl9maW5pc2giLCJtYXliZUNsaXBTY3JvbGxiYXJzIiwibXVzdFVwZGF0ZSIsIkRpc3BsYXlVcGRhdGUiLCJ1cGRhdGVkRGlzcGxheSIsInVwZGF0ZURpc3BsYXlJZk5lZWRlZCIsImJhck1lYXN1cmUiLCJhZGp1c3RXaWR0aFRvIiwibWF4U2Nyb2xsTGVmdCIsInByZXBhcmVkU2VsZWN0aW9uIiwidGFrZUZvY3VzIiwic2V0RG9jdW1lbnRIZWlnaHQiLCJwb3N0VXBkYXRlRGlzcGxheSIsIndoZWVsU3RhcnRYIiwid2hlZWxTdGFydFkiLCJtYXliZUhpZGRlbk1hcmtlcnMiLCJ1bmhpZGRlbiIsIm1heWJlVW5oaWRkZW5NYXJrZXJzIiwiZmluaXNoIiwicnVuSW5PcCIsIm9wZXJhdGlvbiIsIm1ldGhvZE9wIiwiZG9jTWV0aG9kT3AiLCJoaWdobGlnaHQiLCJoaWdobGlnaHRXb3JrZXIiLCJ3b3JrVGltZSIsImNoYW5nZWRMaW5lcyIsIm9sZFN0eWxlcyIsImhpZ2hsaWdodGVkIiwib2xkQ2xzIiwibmV3Q2xzIiwiaXNjaGFuZ2UiLCJ3b3JrRGVsYXkiLCJmb3JjZSIsInZpc2libGUiLCJlZGl0b3JJc0hpZGRlbiIsIndyYXBwZXJIZWlnaHQiLCJvbGREaXNwbGF5V2lkdGgiLCJldmVudHMiLCJzY3JvbGxiYXJzQ2xpcHBlZCIsIm1hcmdpbkJvdHRvbSIsImJvcmRlclJpZ2h0V2lkdGgiLCJzZWxlY3Rpb25TbmFwc2hvdCIsImFjdGl2ZSIsImFuY2hvck5vZGUiLCJleHRlbmQiLCJhbmNob3JPZmZzZXQiLCJmb2N1c05vZGUiLCJmb2N1c09mZnNldCIsInJlc3RvcmVTZWxlY3Rpb24iLCJzbmFwc2hvdCIsIm5vZGVOYW1lIiwicmVtb3ZlQWxsUmFuZ2VzIiwiYWRkUmFuZ2UiLCJyZW5kZXJlZFZpZXciLCJtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aCIsInZpZXdwb3J0TWFyZ2luIiwiZGlmZmVyZW50IiwibGFzdFdyYXBIZWlnaHQiLCJsYXN0V3JhcFdpZHRoIiwidG9VcGRhdGUiLCJzZWxTbmFwc2hvdCIsInBhdGNoRGlzcGxheSIsInNlbGVjdGlvbkRpdiIsInJlcG9ydGVkVmlld0Zyb20iLCJyZXBvcnRlZFZpZXdUbyIsInVwZGF0ZU51bWJlcnNGcm9tIiwiY29udGFpbmVyIiwicm0iLCJjdXJyZW50V2hlZWxUYXJnZXQiLCJ1cGRhdGVOdW1iZXIiLCJ1cGRhdGVHdXR0ZXJTcGFjZSIsImFsaWduV2lkZ2V0cyIsImNvbXAiLCJhbGlnbiIsImlubmVyVyIsImxpbmVHdXR0ZXIiLCJsaW5lTnVtV2lkdGgiLCJnZXRHdXR0ZXJzIiwic2F3TGluZU51bWJlcnMiLCJyZW5kZXJHdXR0ZXJzIiwic3BlY3MiLCJnRWx0IiwidXBkYXRlR3V0dGVycyIsIkRpc3BsYXkiLCJkcmFnZ2FibGUiLCJ3aGVlbERYIiwid2hlZWxEWSIsImFjdGl2ZVRvdWNoIiwiaW5pdCIsIndoZWVsU2FtcGxlcyIsIndoZWVsUGl4ZWxzUGVyVW5pdCIsIndoZWVsRXZlbnREZWx0YSIsImR4Iiwid2hlZWxEZWx0YVgiLCJkeSIsIndoZWVsRGVsdGFZIiwiZGV0YWlsIiwiSE9SSVpPTlRBTF9BWElTIiwiVkVSVElDQUxfQVhJUyIsIndoZWVsRGVsdGEiLCJ3aGVlbEV2ZW50UGl4ZWxzIiwiZGVsdGEiLCJvblNjcm9sbFdoZWVsIiwiY2FuU2Nyb2xsWCIsImNhblNjcm9sbFkiLCJwaXhlbHMiLCJtb3ZlZFgiLCJtb3ZlZFkiLCJzYW1wbGUiLCJTZWxlY3Rpb24iLCJlcXVhbHMiLCJoZXJlIiwidGhlcmUiLCJkZWVwQ29weSIsIlJhbmdlIiwic29tZXRoaW5nU2VsZWN0ZWQiLCJub3JtYWxpemVTZWxlY3Rpb24iLCJtYXlUb3VjaCIsInNlbGVjdGlvbnNNYXlUb3VjaCIsInByaW0iLCJzb3J0IiwiaW52Iiwic2ltcGxlU2VsZWN0aW9uIiwiY2hhbmdlRW5kIiwiYWRqdXN0Rm9yQ2hhbmdlIiwiY29tcHV0ZVNlbEFmdGVyQ2hhbmdlIiwib2Zmc2V0UG9zIiwiY29tcHV0ZVJlcGxhY2VkU2VsIiwiaGludCIsIm9sZFByZXYiLCJuZXdQcmV2IiwibG9hZE1vZGUiLCJtb2RlT3B0aW9uIiwicmVzZXRNb2RlU3RhdGUiLCJpc1dob2xlTGluZVVwZGF0ZSIsIndob2xlTGluZVVwZGF0ZUJlZm9yZSIsInVwZGF0ZURvYyIsInNwYW5zRm9yIiwibGluZXNGb3IiLCJmaXJzdExpbmUiLCJsYXN0VGV4dCIsImxhc3RTcGFucyIsIm5saW5lcyIsImluc2VydCIsInJlbW92ZSIsImFkZGVkIiwiYWRkZWQkMSIsImFkZGVkJDIiLCJsaW5rZWREb2NzIiwic2hhcmVkSGlzdE9ubHkiLCJwcm9wYWdhdGUiLCJza2lwIiwic2hhcmVkSGlzdCIsImxpbmtlZCIsInJlbCIsInNoYXJlZCIsImF0dGFjaERvYyIsInNldERpcmVjdGlvbkNsYXNzIiwiZGlyZWN0aW9uQ2hhbmdlZCIsIkhpc3RvcnkiLCJzdGFydEdlbiIsImRvbmUiLCJ1bmRvbmUiLCJ1bmRvRGVwdGgiLCJsYXN0TW9kVGltZSIsImxhc3RTZWxUaW1lIiwibGFzdE9wIiwibGFzdFNlbE9wIiwibGFzdE9yaWdpbiIsImxhc3RTZWxPcmlnaW4iLCJnZW5lcmF0aW9uIiwibWF4R2VuZXJhdGlvbiIsImhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlIiwiaGlzdENoYW5nZSIsImF0dGFjaExvY2FsU3BhbnMiLCJjbGVhclNlbGVjdGlvbkV2ZW50cyIsInBvcCIsImxhc3RDaGFuZ2VFdmVudCIsImhpc3QiLCJhZGRDaGFuZ2VUb0hpc3RvcnkiLCJzZWxBZnRlciIsIm9wSWQiLCJoaXN0b3J5IiwiaGlzdG9yeUV2ZW50RGVsYXkiLCJwdXNoU2VsZWN0aW9uVG9IaXN0b3J5Iiwic2VsZWN0aW9uRXZlbnRDYW5CZU1lcmdlZCIsImFkZFNlbGVjdGlvblRvSGlzdG9yeSIsImNsZWFyUmVkbyIsImRlc3QiLCJleGlzdGluZyIsInJlbW92ZUNsZWFyZWRTcGFucyIsImV4cGxpY2l0bHlDbGVhcmVkIiwiZ2V0T2xkU3BhbnMiLCJtZXJnZU9sZFNwYW5zIiwic3RyZXRjaGVkIiwib2xkQ3VyIiwic3RyZXRjaEN1ciIsImNvcHlIaXN0b3J5QXJyYXkiLCJuZXdHcm91cCIsImluc3RhbnRpYXRlU2VsIiwiZXZlbnQiLCJuZXdDaGFuZ2VzIiwiZXh0ZW5kUmFuZ2UiLCJwb3NCZWZvcmUiLCJleHRlbmRTZWxlY3Rpb24iLCJzZXRTZWxlY3Rpb24iLCJleHRlbmRTZWxlY3Rpb25zIiwiaGVhZHMiLCJuZXdTZWwiLCJyZXBsYWNlT25lU2VsZWN0aW9uIiwic2V0U2ltcGxlU2VsZWN0aW9uIiwiZmlsdGVyU2VsZWN0aW9uQ2hhbmdlIiwic2V0U2VsZWN0aW9uUmVwbGFjZUhpc3RvcnkiLCJzZXRTZWxlY3Rpb25Ob1VuZG8iLCJOYU4iLCJzZXRTZWxlY3Rpb25Jbm5lciIsInNraXBBdG9taWNJblNlbGVjdGlvbiIsInJlQ2hlY2tTZWxlY3Rpb24iLCJtYXlDbGVhciIsIm5ld0FuY2hvciIsInNraXBBdG9taWMiLCJuZXdIZWFkIiwic2tpcEF0b21pY0lubmVyIiwib2xkUG9zIiwicHJldmVudEN1cnNvckxlZnQiLCJzZWxlY3RMZWZ0IiwicHJldmVudEN1cnNvclJpZ2h0Iiwic2VsZWN0UmlnaHQiLCJhdG9taWMiLCJuZWFyIiwibW92ZVBvcyIsImZhciIsImNhbnRFZGl0Iiwic2VsZWN0QWxsIiwiZmlsdGVyQ2hhbmdlIiwiY2FuY2VsZWQiLCJjYW5jZWwiLCJtYWtlQ2hhbmdlIiwiaWdub3JlUmVhZE9ubHkiLCJzdXBwcmVzc0VkaXRzIiwibWFrZUNoYW5nZUlubmVyIiwibWFrZUNoYW5nZVNpbmdsZURvYyIsInJlYmFzZWQiLCJyZWJhc2VIaXN0IiwibWFrZUNoYW5nZUZyb21IaXN0b3J5IiwiYWxsb3dTZWxlY3Rpb25Pbmx5Iiwic3VwcHJlc3MiLCJhbnRpQ2hhbmdlcyIsImZpbHRlciIsInJldHVybmVkIiwidiIsInNoaWZ0RG9jIiwiZGlzdGFuY2UiLCJyZW1vdmVkIiwibWFrZUNoYW5nZVNpbmdsZURvY0luRWRpdG9yIiwicmVjb21wdXRlTWF4TGVuZ3RoIiwiY2hlY2tXaWR0aFN0YXJ0IiwiY2hhbmdlc0hhbmRsZXIiLCJjaGFuZ2VIYW5kbGVyIiwicmVwbGFjZVJhbmdlIiwiYXNzaWduIiwic3BsaXRMaW5lcyIsInJlYmFzZUhpc3RTZWxTaW5nbGUiLCJyZWJhc2VIaXN0QXJyYXkiLCJzdWIiLCJjb3BpZWQiLCJjaGFuZ2VMaW5lIiwiaGFuZGxlIiwiY2hhbmdlVHlwZSIsIkxlYWZDaHVuayIsInJlbW92ZUlubmVyIiwiaW5zZXJ0SW5uZXIiLCJpdGVyTiIsIkJyYW5jaENodW5rIiwib2xkSGVpZ2h0IiwicmVtYWluaW5nIiwibGVhZiIsIm1heWJlU3BpbGwiLCJtZSIsInNwaWxsZWQiLCJzaWJsaW5nIiwibXlJbmRleCIsInVzZWQiLCJMaW5lV2lkZ2V0Iiwib3B0IiwiYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZSIsInRoaXMkMSIsIm9sZEgiLCJhZGRMaW5lV2lkZ2V0IiwiaW5zZXJ0QXQiLCJhYm92ZVZpc2libGUiLCJuZXh0TWFya2VySWQiLCJUZXh0TWFya2VyIiwid2l0aE9wIiwidmlzdWFsIiwiZEhlaWdodCIsIm1hcmtUZXh0IiwibWFya1RleHRTaGFyZWQiLCJyZXBsYWNlZFdpdGgiLCJhZGRUb0hpc3RvcnkiLCJjdXJMaW5lIiwiY2xlYXJPbkVudGVyIiwiY2xlYXJIaXN0b3J5IiwiU2hhcmVkVGV4dE1hcmtlciIsImNsb25lTm9kZSIsImlzUGFyZW50IiwiZmluZFNoYXJlZE1hcmtlcnMiLCJmaW5kTWFya3MiLCJjb3B5U2hhcmVkTWFya2VycyIsIm1Gcm9tIiwibVRvIiwic3ViTWFyayIsImRldGFjaFNoYXJlZE1hcmtlcnMiLCJzdWJNYXJrZXIiLCJuZXh0RG9jSWQiLCJEb2MiLCJsaW5lU2VwIiwiY2xlYW5HZW5lcmF0aW9uIiwiY29uc3RydWN0b3IiLCJnZXRWYWx1ZSIsImpvaW4iLCJsaW5lU2VwYXJhdG9yIiwic2V0VmFsdWUiLCJnZXRSYW5nZSIsImdldExpbmVIYW5kbGUiLCJnZXRMaW5lTnVtYmVyIiwiZ2V0TGluZUhhbmRsZVZpc3VhbFN0YXJ0IiwibGluZUNvdW50IiwibGlzdFNlbGVjdGlvbnMiLCJzZXRDdXJzb3IiLCJleHRlbmRTZWxlY3Rpb25zQnkiLCJzZXRTZWxlY3Rpb25zIiwiYWRkU2VsZWN0aW9uIiwiZ2V0U2VsZWN0aW9ucyIsInJlcGxhY2VTZWxlY3Rpb24iLCJkdXAiLCJyZXBsYWNlU2VsZWN0aW9ucyIsInVuZG8iLCJyZWRvIiwidW5kb1NlbGVjdGlvbiIsInJlZG9TZWxlY3Rpb24iLCJzZXRFeHRlbmRpbmciLCJnZXRFeHRlbmRpbmciLCJoaXN0b3J5U2l6ZSIsIm1hcmtDbGVhbiIsImNoYW5nZUdlbmVyYXRpb24iLCJmb3JjZVNwbGl0IiwiaXNDbGVhbiIsImdlbiIsImdldEhpc3RvcnkiLCJzZXRIaXN0b3J5IiwiaGlzdERhdGEiLCJzZXRHdXR0ZXJNYXJrZXIiLCJndXR0ZXJJRCIsImNsZWFyR3V0dGVyIiwibGluZUluZm8iLCJhZGRMaW5lQ2xhc3MiLCJ3aGVyZSIsInJlbW92ZUxpbmVDbGFzcyIsInJlbW92ZUxpbmVXaWRnZXQiLCJzZXRCb29rbWFyayIsInJlYWxPcHRzIiwiZmluZE1hcmtzQXQiLCJnZXRBbGxNYXJrcyIsInBvc0Zyb21JbmRleCIsInNlcFNpemUiLCJpbmRleEZyb21Qb3MiLCJjb3B5SGlzdG9yeSIsImxpbmtlZERvYyIsInVubGlua0RvYyIsIkNvZGVNaXJyb3IiLCJsaW5rIiwic3BsaXRJZHMiLCJpdGVyTGlua2VkRG9jcyIsImdldEVkaXRvciIsInNldERpcmVjdGlvbiIsImVhY2hMaW5lIiwibGFzdERyb3AiLCJvbkRyb3AiLCJjbGVhckRyYWdDdXJzb3IiLCJmaWxlcyIsImRhdGFUcmFuc2ZlciIsImlzUmVhZE9ubHkiLCJGaWxlUmVhZGVyIiwiRmlsZSIsInJlYWQiLCJtYXJrQXNSZWFkQW5kUGFzdGVJZkFsbEZpbGVzQXJlUmVhZCIsInQiLCJyZWFkVGV4dEZyb21GaWxlIiwiZmlsZSIsImFsbG93RHJvcEZpbGVUeXBlcyIsInJlYWRlciIsIm9uZXJyb3IiLCJvbmxvYWQiLCJyZWFkQXNUZXh0IiwidGV4dCQxIiwiZ2V0RGF0YSIsInNlbGVjdGVkIiwib25EcmFnU3RhcnQiLCJzZXREYXRhIiwiZWZmZWN0QWxsb3dlZCIsInNldERyYWdJbWFnZSIsImltZyIsInNyYyIsIl90b3AiLCJvbkRyYWdPdmVyIiwiZnJhZyIsImRyYWdDdXJzb3IiLCJmb3JFYWNoQ29kZU1pcnJvciIsImdldEVsZW1lbnRzQnlDbGFzc05hbWUiLCJieUNsYXNzIiwiZWRpdG9ycyIsImdsb2JhbHNSZWdpc3RlcmVkIiwiZW5zdXJlR2xvYmFsSGFuZGxlcnMiLCJyZWdpc3Rlckdsb2JhbEhhbmRsZXJzIiwicmVzaXplVGltZXIiLCJvblJlc2l6ZSIsInNldFNpemUiLCJrZXlOYW1lcyIsImZyb21DaGFyQ29kZSIsImtleU1hcCIsImJhc2ljIiwicGNEZWZhdWx0IiwiZW1hY3N5IiwibWFjRGVmYXVsdCIsIm5vcm1hbGl6ZUtleU5hbWUiLCJhbHQiLCJjdHJsIiwiY21kIiwibW9kIiwibm9ybWFsaXplS2V5TWFwIiwia2V5bWFwIiwia2V5bmFtZSIsImtleXMiLCJsb29rdXBLZXkiLCJnZXRLZXlNYXAiLCJmYWxsdGhyb3VnaCIsImlzTW9kaWZpZXJLZXkiLCJrZXlDb2RlIiwiYWRkTW9kaWZpZXJOYW1lcyIsIm5vU2hpZnQiLCJhbHRLZXkiLCJtZXRhS2V5Iiwic2hpZnRLZXkiLCJrZXlOYW1lIiwiYWx0R3JhcGhLZXkiLCJkZWxldGVOZWFyU2VsZWN0aW9uIiwiY29tcHV0ZSIsImtpbGwiLCJ0b0tpbGwiLCJyZXBsYWNlZCIsIm1vdmVDaGFyTG9naWNhbGx5IiwibW92ZUxvZ2ljYWxseSIsImVuZE9mTGluZSIsInZpc3VhbGx5IiwibW92ZUluU3RvcmFnZU9yZGVyIiwicHJlcCIsIm1vdmVWaXN1YWxseSIsImJpZGkiLCJtdiIsImdldFdyYXBwZWRMaW5lRXh0ZW50Iiwic2VhcmNoSW5WaXN1YWxMaW5lIiwiZ2V0UmVzIiwicmVzIiwibmV4dENoIiwiY29tbWFuZHMiLCJzaW5nbGVTZWxlY3Rpb24iLCJraWxsTGluZSIsImRlbGV0ZUxpbmUiLCJkZWxMaW5lTGVmdCIsImRlbFdyYXBwZWRMaW5lTGVmdCIsImxlZnRQb3MiLCJkZWxXcmFwcGVkTGluZVJpZ2h0IiwicmlnaHRQb3MiLCJnb0RvY1N0YXJ0IiwiZ29Eb2NFbmQiLCJnb0xpbmVTdGFydCIsImdvTGluZVN0YXJ0U21hcnQiLCJsaW5lU3RhcnRTbWFydCIsImdvTGluZUVuZCIsImxpbmVFbmQiLCJnb0xpbmVSaWdodCIsImdvTGluZUxlZnQiLCJnb0xpbmVMZWZ0U21hcnQiLCJnb0xpbmVVcCIsIm1vdmVWIiwiZ29MaW5lRG93biIsImdvUGFnZVVwIiwiZ29QYWdlRG93biIsImdvQ2hhckxlZnQiLCJtb3ZlSCIsImdvQ2hhclJpZ2h0IiwiZ29Db2x1bW5MZWZ0IiwiZ29Db2x1bW5SaWdodCIsImdvV29yZExlZnQiLCJnb0dyb3VwUmlnaHQiLCJnb0dyb3VwTGVmdCIsImdvV29yZFJpZ2h0IiwiZGVsQ2hhckJlZm9yZSIsImRlbGV0ZUgiLCJkZWxDaGFyQWZ0ZXIiLCJkZWxXb3JkQmVmb3JlIiwiZGVsV29yZEFmdGVyIiwiZGVsR3JvdXBCZWZvcmUiLCJkZWxHcm91cEFmdGVyIiwiaW5kZW50QXV0byIsImluZGVudFNlbGVjdGlvbiIsImluZGVudE1vcmUiLCJpbmRlbnRMZXNzIiwiaW5zZXJ0VGFiIiwiaW5zZXJ0U29mdFRhYiIsInNwYWNlcyIsImRlZmF1bHRUYWIiLCJleGVjQ29tbWFuZCIsInRyYW5zcG9zZUNoYXJzIiwibmV3bGluZUFuZEluZGVudCIsInNlbHMiLCJpbmRlbnRMaW5lIiwib3BlbkxpbmUiLCJ0b2dnbGVPdmVyd3JpdGUiLCJmaXJzdE5vbldTIiwiaW5XUyIsImRvSGFuZGxlQmluZGluZyIsImJvdW5kIiwiZHJvcFNoaWZ0IiwiZW5zdXJlUG9sbGVkIiwicHJldlNoaWZ0IiwibG9va3VwS2V5Rm9yRWRpdG9yIiwia2V5TWFwcyIsImV4dHJhS2V5cyIsInN0b3BTZXEiLCJkaXNwYXRjaEtleSIsInNlcSIsImtleVNlcSIsImRpc3BhdGNoS2V5SW5uZXIiLCJoYW5kbGVLZXlCaW5kaW5nIiwibW90aW9uIiwiaGFuZGxlQ2hhckJpbmRpbmciLCJsYXN0U3RvcHBlZEtleSIsIm9uS2V5RG93biIsImdldEZpZWxkIiwiaGFuZGxlZCIsInNob3dDcm9zc0hhaXIiLCJ1cCIsIm9uS2V5VXAiLCJvbktleVByZXNzIiwiY2hhckNvZGUiLCJET1VCTEVDTElDS19ERUxBWSIsIlBhc3RDbGljayIsImNvbXBhcmUiLCJsYXN0Q2xpY2siLCJsYXN0RG91YmxlQ2xpY2siLCJjbGlja1JlcGVhdCIsIm5vdyIsIm9uTW91c2VEb3duIiwic3VwcG9ydHNUb3VjaCIsImNsaWNrSW5HdXR0ZXIiLCJyZXBlYXQiLCJzZWxlY3RpbmdUZXh0IiwiaGFuZGxlTWFwcGVkQnV0dG9uIiwibGVmdEJ1dHRvbkRvd24iLCJvbkNvbnRleHRNZW51IiwiY29uZmlndXJlTW91c2UiLCJvcHRpb24iLCJ1bml0IiwiYWRkTmV3IiwibW92ZU9uRHJhZyIsImJlaGF2aW9yIiwiY29udGFpbmVkIiwiZHJhZ0Ryb3AiLCJsZWZ0QnV0dG9uU3RhcnREcmFnIiwibGVmdEJ1dHRvblNlbGVjdCIsIm1vdmVkIiwiZHJhZ0VuZCIsIm1vdXNlTW92ZSIsImRyYWdTdGFydCIsInByZXZlbnRTY3JvbGwiLCJlMiIsInJhbmdlRm9yVW5pdCIsImZpbmRXb3JkQXQiLCJvdXJSYW5nZSIsIm91ckluZGV4Iiwic3RhcnRTZWwiLCJsYXN0UG9zIiwiZXh0ZW5kVG8iLCJzdGFydENvbCIsInBvc0NvbCIsIm9sZFJhbmdlIiwicmFuZ2VzJDEiLCJiaWRpU2ltcGxpZnkiLCJlZGl0b3JTaXplIiwiY291bnRlciIsImN1ckNvdW50IiwibW92ZSIsImJ1dHRvbnMiLCJhbmNob3JMaW5lIiwiYm91bmRhcnkiLCJoZWFkSW5kZXgiLCJ1c2VQYXJ0IiwiZ3V0dGVyRXZlbnQiLCJwcmV2ZW50IiwibVgiLCJtWSIsInRvdWNoZXMiLCJsaW5lQm94IiwiZyIsImNvbnRleHRNZW51SW5HdXR0ZXIiLCJ0aGVtZUNoYW5nZWQiLCJ0aGVtZSIsIkluaXQiLCJkZWZhdWx0cyIsIm9wdGlvbkhhbmRsZXJzIiwiZGVmaW5lT3B0aW9ucyIsImRlZmx0Iiwibm90T25Jbml0IiwiZGVmaW5lT3B0aW9uIiwibmV3QnJlYWtzIiwicmVmcmVzaCIsImdldElucHV0RmllbGQiLCJzcGVsbGNoZWNrIiwiYXV0b2NvcnJlY3QiLCJhdXRvY2FwaXRhbGl6ZSIsImRldGFjaCIsImF0dGFjaCIsIndyYXBwaW5nQ2hhbmdlZCIsImludGVnZXIiLCJibHVyIiwicmVhZE9ubHlDaGFuZ2VkIiwic2NyZWVuUmVhZGVyTGFiZWxDaGFuZ2VkIiwiZHJhZ0Ryb3BDaGFuZ2VkIiwicmVzZXRQb3NpdGlvbiIsIndhc09uIiwiZnVuY3MiLCJkcmFnRnVuY3Rpb25zIiwidG9nZ2xlIiwiZW50ZXIiLCJvdmVyIiwibGVhdmUiLCJkcm9wIiwiaW5wdXRTdHlsZXMiLCJpbnB1dFN0eWxlIiwicGFzdGVJbmNvbWluZyIsImN1dEluY29taW5nIiwiYXV0b2ZvY3VzIiwicmVnaXN0ZXJFdmVudEhhbmRsZXJzIiwiZmluaXNoSW5pdCIsImluaXRIb29rcyIsInRleHRSZW5kZXJpbmciLCJ3b3JkIiwidG91Y2hGaW5pc2hlZCIsInByZXZUb3VjaCIsImZpbmlzaFRvdWNoIiwiaXNNb3VzZUxpa2VUb3VjaEV2ZW50IiwidG91Y2giLCJyYWRpdXNYIiwicmFkaXVzWSIsImZhckF3YXkiLCJwYWdlWCIsInBhZ2VZIiwiaW5wIiwiZGVmaW5lSW5pdEhvb2siLCJob3ciLCJhZ2dyZXNzaXZlIiwiaW5kZW50IiwiY3VyU3BhY2UiLCJjdXJTcGFjZVN0cmluZyIsImluZGVudFVuaXQiLCJpbmRlbnRTdHJpbmciLCJpbmRlbnRXaXRoVGFicyIsInBvcyQxIiwibGFzdENvcGllZCIsInNldExhc3RDb3BpZWQiLCJuZXdMYXN0Q29waWVkIiwiYXBwbHlUZXh0SW5wdXQiLCJpbnNlcnRlZCIsImRlbGV0ZWQiLCJyZWNlbnQiLCJwYXN0ZSIsInRleHRMaW5lcyIsIm11bHRpUGFzdGUiLCJwYXN0ZUxpbmVzUGVyU2VsZWN0aW9uIiwibGluZVdpc2UiLCJjaGFuZ2VFdmVudCIsInRyaWdnZXJFbGVjdHJpYyIsImhhbmRsZVBhc3RlIiwicGFzdGVkIiwiY2xpcGJvYXJkRGF0YSIsImRpc2FibGVJbnB1dCIsImVsZWN0cmljQ2hhcnMiLCJzbWFydEluZGVudCIsImdldE1vZGVBdCIsImVsZWN0cmljSW5wdXQiLCJjb3B5YWJsZVJhbmdlcyIsImxpbmVSYW5nZSIsImRpc2FibGVCcm93c2VyTWFnaWMiLCJmaWVsZCIsImhpZGRlblRleHRhcmVhIiwiYm9yZGVyIiwiYWRkRWRpdG9yTWV0aG9kcyIsImhlbHBlcnMiLCJzZXRPcHRpb24iLCJnZXREb2MiLCJhZGRLZXlNYXAiLCJyZW1vdmVLZXlNYXAiLCJhZGRPdmVybGF5IiwibW9kZVNwZWMiLCJyZW1vdmVPdmVybGF5IiwibmV3UmFuZ2VzIiwiZ2V0VG9rZW5BdCIsImdldExpbmVUb2tlbnMiLCJnZXRUb2tlblR5cGVBdCIsImdldEhlbHBlciIsImdldEhlbHBlcnMiLCJoZWxwIiwiX2dsb2JhbCIsImdldFN0YXRlQWZ0ZXIiLCJkZWZhdWx0VGV4dEhlaWdodCIsImRlZmF1bHRDaGFyV2lkdGgiLCJnZXRWaWV3cG9ydCIsImFkZFdpZGdldCIsInZzcGFjZSIsImhzcGFjZSIsInRyaWdnZXJPbktleURvd24iLCJ0cmlnZ2VyT25LZXlQcmVzcyIsInRyaWdnZXJPbktleVVwIiwidHJpZ2dlck9uTW91c2VEb3duIiwiZmluZFBvc0giLCJhbW91bnQiLCJoaXRTaWRlIiwicnRsTW92ZVZpc3VhbGx5IiwiZmluZFBvc1YiLCJnb2FsQ29sdW1uIiwiZ29hbHMiLCJoZWFkUG9zIiwic3RhcnRDaGFyIiwiY2hlY2siLCJzY3JvbGxUbyIsImdldFNjcm9sbEluZm8iLCJpbnRlcnByZXQiLCJzd2FwRG9jIiwicGhyYXNlIiwicGhyYXNlVGV4dCIsInBocmFzZXMiLCJnZXRXcmFwcGVyRWxlbWVudCIsImdldFNjcm9sbGVyRWxlbWVudCIsImdldEd1dHRlckVsZW1lbnQiLCJyZWdpc3RlckhlbHBlciIsInJlZ2lzdGVyR2xvYmFsSGVscGVyIiwicHJlZGljYXRlIiwib3JpZ0RpciIsImxpbmVEaXIiLCJmaW5kTmV4dExpbmUiLCJtb3ZlT25jZSIsImJvdW5kVG9MaW5lIiwiYXN0cmFsIiwic2F3VHlwZSIsInBhZ2VTaXplIiwibW92ZUFtb3VudCIsIkNvbnRlbnRFZGl0YWJsZUlucHV0IiwibGFzdEFuY2hvck5vZGUiLCJsYXN0QW5jaG9yT2Zmc2V0IiwibGFzdEZvY3VzTm9kZSIsImxhc3RGb2N1c09mZnNldCIsInBvbGxpbmciLCJjb21wb3NpbmciLCJncmFjZVBlcmlvZCIsInJlYWRET01UaW1lb3V0IiwiYmVsb25nc1RvSW5wdXQiLCJ1cGRhdGVGcm9tRE9NIiwicmVhZEZyb21ET01Tb29uIiwiZm9yY2VDb21wb3NpdGlvbkVuZCIsIm9uQ29weUN1dCIsImxpbmVXaXNlQ29weUN1dCIsImNsZWFyRGF0YSIsImtsdWRnZSIsImhhZEZvY3VzIiwic2hvd1ByaW1hcnlTZWxlY3Rpb24iLCJsYWJlbCIsInJlbW92ZUF0dHJpYnV0ZSIsInNob3dNdWx0aXBsZVNlbGVjdGlvbnMiLCJjdXJBbmNob3IiLCJkb21Ub1BvcyIsImN1ckZvY3VzIiwiYmFkIiwicG9zVG9ET00iLCJyYW5nZUNvdW50IiwiZ2V0UmFuZ2VBdCIsInJuZyIsInN0YXJ0R3JhY2VQZXJpb2QiLCJyZW1lbWJlclNlbGVjdGlvbiIsInNlbGVjdGlvbkluRWRpdG9yIiwiY29tbW9uQW5jZXN0b3JDb250YWluZXIiLCJwb2xsU2VsZWN0aW9uIiwicG9sbCIsInBvbGxJbnRlcnZhbCIsImlzSW5HdXR0ZXIiLCJwb2xsQ29udGVudCIsImZyb21JbmRleCIsImZyb21Ob2RlIiwidG9JbmRleCIsInRvTm9kZSIsInByZXZpb3VzU2libGluZyIsIm5ld1RleHQiLCJkb21UZXh0QmV0d2VlbiIsIm9sZFRleHQiLCJjdXRGcm9udCIsImN1dEVuZCIsIm9sZFRvcCIsIm1heEN1dEZyb250IiwibmV3Qm90Iiwib2xkQm90IiwibWF4Q3V0RW5kIiwiY2hGcm9tIiwiY2hUbyIsImNvbnRlbnRFZGl0YWJsZSIsInNjYW4iLCJiYWRQb3MiLCJjbG9zaW5nIiwiZXh0cmFMaW5lYnJlYWsiLCJyZWNvZ25pemVNYXJrZXIiLCJjbG9zZSIsImFkZFRleHQiLCJ3YWxrIiwiY21UZXh0IiwibWFya2VySUQiLCJpc0Jsb2NrIiwidGV4dENvbnRlbnQiLCJub2RlVmFsdWUiLCJsaW5lTm9kZSIsImxvY2F0ZU5vZGVJbkxpbmVWaWV3IiwidGV4dE5vZGUiLCJ0b3BOb2RlIiwiY3VyTm9kZSIsImRpc3QkMSIsIlRleHRhcmVhSW5wdXQiLCJwcmV2SW5wdXQiLCJwb2xsaW5nRmFzdCIsImNyZWF0ZUZpZWxkIiwidGV4dGFyZWEiLCJmYXN0UG9sbCIsInByZXBhcmVDb3B5Q3V0IiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50IiwiX2Rpc3BsYXkiLCJtb3ZlSW5wdXRXaXRoQ3Vyc29yIiwid3JhcE9mZiIsImxpbmVPZmYiLCJ0ZVRvcCIsInRlTGVmdCIsImRyYXduIiwiY29udGV4dE1lbnVQZW5kaW5nIiwic2xvd1BvbGwiLCJtaXNzZWQiLCJzYW1lIiwicmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51Iiwib2xkQ1NTIiwib2xkV3JhcHBlckNTUyIsIndyYXBwZXJCb3giLCJvZmZzZXRQYXJlbnQiLCJvbGRTY3JvbGxZIiwic2Nyb2xsWSIsInJlaGlkZSIsImRldGVjdGluZ1NlbGVjdEFsbCIsInByZXBhcmVTZWxlY3RBbGxIYWNrIiwiZXh0dmFsIiwibW91c2V1cCIsImRpc2FibGVkIiwiZnJvbVRleHRBcmVhIiwidGFiaW5kZXgiLCJwbGFjZWhvbGRlciIsInJlYWxTdWJtaXQiLCJmb3JtIiwibGVhdmVTdWJtaXRNZXRob2RBbG9uZSIsInN1Ym1pdCIsIndyYXBwZWRTdWJtaXQiLCJnZXRUZXh0QXJlYSIsInRvVGV4dEFyZWEiLCJhZGRMZWdhY3lQcm9wcyIsImNtcFBvcyIsImRvbnREZWxlZ2F0ZSIsIm1ldGhvZCIsImRlZmluZUV4dGVuc2lvbiIsImZ1bmMiLCJkZWZpbmVEb2NFeHRlbnNpb24iLCJ2ZXJzaW9uIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUMsV0FBVUEsTUFBVixFQUFrQkMsT0FBbEIsRUFBMkI7QUFDMUIsd0JBQU9DLE9BQVAsT0FBbUIsUUFBbkIsSUFBK0IsYUFBa0IsV0FBakQsR0FBK0RDLE1BQU0sQ0FBQ0QsT0FBUCxHQUFpQkQsT0FBTyxFQUF2RixHQUNBLFFBQTZDRyxvQ0FBT0gsT0FBRDtBQUFBO0FBQUE7QUFBQTtBQUFBLGtHQUFuRCxJQUNDRCxDQURELENBREE7QUFHRCxDQUpBLEVBSUMsSUFKRCxFQUlRLFlBQVk7QUFBRSxlQUFGLENBRW5CO0FBQ0E7O0FBQ0EsTUFBSUssU0FBUyxHQUFHQyxTQUFTLENBQUNELFNBQTFCO0FBQ0EsTUFBSUUsUUFBUSxHQUFHRCxTQUFTLENBQUNDLFFBQXpCO0FBRUEsTUFBSUMsS0FBSyxHQUFHLGFBQWFDLElBQWIsQ0FBa0JKLFNBQWxCLENBQVo7QUFDQSxNQUFJSyxTQUFTLEdBQUcsVUFBVUQsSUFBVixDQUFlSixTQUFmLENBQWhCO0FBQ0EsTUFBSU0sT0FBTyxHQUFHLHdDQUF3Q0MsSUFBeEMsQ0FBNkNQLFNBQTdDLENBQWQ7QUFDQSxNQUFJUSxJQUFJLEdBQUcsY0FBY0QsSUFBZCxDQUFtQlAsU0FBbkIsQ0FBWDtBQUNBLE1BQUlTLEVBQUUsR0FBR0osU0FBUyxJQUFJQyxPQUFiLElBQXdCRSxJQUFqQztBQUNBLE1BQUlFLFVBQVUsR0FBR0QsRUFBRSxLQUFLSixTQUFTLEdBQUdNLFFBQVEsQ0FBQ0MsWUFBVCxJQUF5QixDQUE1QixHQUFnQyxDQUFDLENBQUNKLElBQUksSUFBSUYsT0FBVCxFQUFrQixDQUFsQixDQUEvQyxDQUFuQjtBQUNBLE1BQUlPLE1BQU0sR0FBRyxDQUFDTCxJQUFELElBQVMsV0FBV0osSUFBWCxDQUFnQkosU0FBaEIsQ0FBdEI7QUFDQSxNQUFJYyxRQUFRLEdBQUdELE1BQU0sSUFBSSxlQUFlVCxJQUFmLENBQW9CSixTQUFwQixDQUF6QjtBQUNBLE1BQUllLE1BQU0sR0FBRyxDQUFDUCxJQUFELElBQVMsV0FBV0osSUFBWCxDQUFnQkosU0FBaEIsQ0FBdEI7QUFDQSxNQUFJZ0IsTUFBTSxHQUFHLFVBQVVaLElBQVYsQ0FBZUosU0FBZixDQUFiO0FBQ0EsTUFBSWlCLE1BQU0sR0FBRyxpQkFBaUJiLElBQWpCLENBQXNCSCxTQUFTLENBQUNpQixNQUFoQyxDQUFiO0FBQ0EsTUFBSUMsa0JBQWtCLEdBQUcsK0JBQStCZixJQUEvQixDQUFvQ0osU0FBcEMsQ0FBekI7QUFDQSxNQUFJb0IsT0FBTyxHQUFHLFlBQVloQixJQUFaLENBQWlCSixTQUFqQixDQUFkO0FBRUEsTUFBSXFCLEdBQUcsR0FBR0osTUFBTSxLQUFLLGNBQWNiLElBQWQsQ0FBbUJKLFNBQW5CLEtBQWlDQyxTQUFTLENBQUNxQixjQUFWLEdBQTJCLENBQWpFLENBQWhCO0FBQ0EsTUFBSUMsT0FBTyxHQUFHLFVBQVVuQixJQUFWLENBQWVKLFNBQWYsQ0FBZCxDQXRCbUIsQ0F1Qm5COztBQUNBLE1BQUl3QixNQUFNLEdBQUdILEdBQUcsSUFBSUUsT0FBUCxJQUFrQixtREFBbURuQixJQUFuRCxDQUF3REosU0FBeEQsQ0FBL0I7QUFDQSxNQUFJeUIsR0FBRyxHQUFHSixHQUFHLElBQUksTUFBTWpCLElBQU4sQ0FBV0YsUUFBWCxDQUFqQjtBQUNBLE1BQUl3QixRQUFRLEdBQUcsV0FBV3RCLElBQVgsQ0FBZ0JKLFNBQWhCLENBQWY7QUFDQSxNQUFJMkIsT0FBTyxHQUFHLE9BQU92QixJQUFQLENBQVlGLFFBQVosQ0FBZDtBQUVBLE1BQUkwQixjQUFjLEdBQUdaLE1BQU0sSUFBSWhCLFNBQVMsQ0FBQzZCLEtBQVYsQ0FBZ0IscUJBQWhCLENBQS9COztBQUNBLE1BQUlELGNBQUosRUFBb0I7QUFBRUEsa0JBQWMsR0FBR0UsTUFBTSxDQUFDRixjQUFjLENBQUMsQ0FBRCxDQUFmLENBQXZCO0FBQTZDOztBQUNuRSxNQUFJQSxjQUFjLElBQUlBLGNBQWMsSUFBSSxFQUF4QyxFQUE0QztBQUFFWixVQUFNLEdBQUcsS0FBVDtBQUFnQkgsVUFBTSxHQUFHLElBQVQ7QUFBZ0IsR0EvQjNELENBZ0NuQjs7O0FBQ0EsTUFBSWtCLFdBQVcsR0FBR04sR0FBRyxLQUFLWCxRQUFRLElBQUlFLE1BQU0sS0FBS1ksY0FBYyxJQUFJLElBQWxCLElBQTBCQSxjQUFjLEdBQUcsS0FBaEQsQ0FBdkIsQ0FBckI7QUFDQSxNQUFJSSxpQkFBaUIsR0FBRzdCLEtBQUssSUFBS00sRUFBRSxJQUFJQyxVQUFVLElBQUksQ0FBdEQ7O0FBRUEsV0FBU3VCLFNBQVQsQ0FBbUJDLEdBQW5CLEVBQXdCO0FBQUUsV0FBTyxJQUFJQyxNQUFKLENBQVcsWUFBWUQsR0FBWixHQUFrQixlQUE3QixDQUFQO0FBQXNEOztBQUVoRixNQUFJRSxPQUFPLEdBQUcsU0FBVkEsT0FBVSxDQUFTQyxJQUFULEVBQWVILEdBQWYsRUFBb0I7QUFDaEMsUUFBSUksT0FBTyxHQUFHRCxJQUFJLENBQUNFLFNBQW5CO0FBQ0EsUUFBSVYsS0FBSyxHQUFHSSxTQUFTLENBQUNDLEdBQUQsQ0FBVCxDQUFlM0IsSUFBZixDQUFvQitCLE9BQXBCLENBQVo7O0FBQ0EsUUFBSVQsS0FBSixFQUFXO0FBQ1QsVUFBSVcsS0FBSyxHQUFHRixPQUFPLENBQUNHLEtBQVIsQ0FBY1osS0FBSyxDQUFDYSxLQUFOLEdBQWNiLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU2MsTUFBckMsQ0FBWjtBQUNBTixVQUFJLENBQUNFLFNBQUwsR0FBaUJELE9BQU8sQ0FBQ0csS0FBUixDQUFjLENBQWQsRUFBaUJaLEtBQUssQ0FBQ2EsS0FBdkIsS0FBaUNGLEtBQUssR0FBR1gsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXVyxLQUFkLEdBQXNCLEVBQTVELENBQWpCO0FBQ0Q7QUFDRixHQVBEOztBQVNBLFdBQVNJLGNBQVQsQ0FBd0JDLENBQXhCLEVBQTJCO0FBQ3pCLFNBQUssSUFBSUMsS0FBSyxHQUFHRCxDQUFDLENBQUNFLFVBQUYsQ0FBYUosTUFBOUIsRUFBc0NHLEtBQUssR0FBRyxDQUE5QyxFQUFpRCxFQUFFQSxLQUFuRCxFQUNFO0FBQUVELE9BQUMsQ0FBQ0csV0FBRixDQUFjSCxDQUFDLENBQUNJLFVBQWhCO0FBQThCOztBQUNsQyxXQUFPSixDQUFQO0FBQ0Q7O0FBRUQsV0FBU0ssb0JBQVQsQ0FBOEJDLE1BQTlCLEVBQXNDTixDQUF0QyxFQUF5QztBQUN2QyxXQUFPRCxjQUFjLENBQUNPLE1BQUQsQ0FBZCxDQUF1QkMsV0FBdkIsQ0FBbUNQLENBQW5DLENBQVA7QUFDRDs7QUFFRCxXQUFTUSxHQUFULENBQWFDLEdBQWIsRUFBa0JDLE9BQWxCLEVBQTJCaEIsU0FBM0IsRUFBc0NpQixLQUF0QyxFQUE2QztBQUMzQyxRQUFJWCxDQUFDLEdBQUdsQyxRQUFRLENBQUM4QyxhQUFULENBQXVCSCxHQUF2QixDQUFSOztBQUNBLFFBQUlmLFNBQUosRUFBZTtBQUFFTSxPQUFDLENBQUNOLFNBQUYsR0FBY0EsU0FBZDtBQUEwQjs7QUFDM0MsUUFBSWlCLEtBQUosRUFBVztBQUFFWCxPQUFDLENBQUNXLEtBQUYsQ0FBUUUsT0FBUixHQUFrQkYsS0FBbEI7QUFBMEI7O0FBQ3ZDLFFBQUksT0FBT0QsT0FBUCxJQUFrQixRQUF0QixFQUFnQztBQUFFVixPQUFDLENBQUNPLFdBQUYsQ0FBY3pDLFFBQVEsQ0FBQ2dELGNBQVQsQ0FBd0JKLE9BQXhCLENBQWQ7QUFBa0QsS0FBcEYsTUFDSyxJQUFJQSxPQUFKLEVBQWE7QUFBRSxXQUFLLElBQUlLLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdMLE9BQU8sQ0FBQ1osTUFBNUIsRUFBb0MsRUFBRWlCLENBQXRDLEVBQXlDO0FBQUVmLFNBQUMsQ0FBQ08sV0FBRixDQUFjRyxPQUFPLENBQUNLLENBQUQsQ0FBckI7QUFBNEI7QUFBRTs7QUFDN0YsV0FBT2YsQ0FBUDtBQUNELEdBaEVrQixDQWlFbkI7OztBQUNBLFdBQVNnQixJQUFULENBQWNQLEdBQWQsRUFBbUJDLE9BQW5CLEVBQTRCaEIsU0FBNUIsRUFBdUNpQixLQUF2QyxFQUE4QztBQUM1QyxRQUFJWCxDQUFDLEdBQUdRLEdBQUcsQ0FBQ0MsR0FBRCxFQUFNQyxPQUFOLEVBQWVoQixTQUFmLEVBQTBCaUIsS0FBMUIsQ0FBWDtBQUNBWCxLQUFDLENBQUNpQixZQUFGLENBQWUsTUFBZixFQUF1QixjQUF2QjtBQUNBLFdBQU9qQixDQUFQO0FBQ0Q7O0FBRUQsTUFBSWtCLEtBQUo7O0FBQ0EsTUFBSXBELFFBQVEsQ0FBQ3FELFdBQWIsRUFBMEI7QUFBRUQsU0FBSyxHQUFHLGVBQVMxQixJQUFULEVBQWU0QixLQUFmLEVBQXNCQyxHQUF0QixFQUEyQkMsT0FBM0IsRUFBb0M7QUFDdEUsVUFBSUMsQ0FBQyxHQUFHekQsUUFBUSxDQUFDcUQsV0FBVCxFQUFSO0FBQ0FJLE9BQUMsQ0FBQ0MsTUFBRixDQUFTRixPQUFPLElBQUk5QixJQUFwQixFQUEwQjZCLEdBQTFCO0FBQ0FFLE9BQUMsQ0FBQ0UsUUFBRixDQUFXakMsSUFBWCxFQUFpQjRCLEtBQWpCO0FBQ0EsYUFBT0csQ0FBUDtBQUNELEtBTDJCO0FBS3hCLEdBTEosTUFNSztBQUFFTCxTQUFLLEdBQUcsZUFBUzFCLElBQVQsRUFBZTRCLEtBQWYsRUFBc0JDLEdBQXRCLEVBQTJCO0FBQ3hDLFVBQUlFLENBQUMsR0FBR3pELFFBQVEsQ0FBQzRELElBQVQsQ0FBY0MsZUFBZCxFQUFSOztBQUNBLFVBQUk7QUFBRUosU0FBQyxDQUFDSyxpQkFBRixDQUFvQnBDLElBQUksQ0FBQ3FDLFVBQXpCO0FBQXVDLE9BQTdDLENBQ0EsT0FBTTdCLENBQU4sRUFBUztBQUFFLGVBQU91QixDQUFQO0FBQVU7O0FBQ3JCQSxPQUFDLENBQUNPLFFBQUYsQ0FBVyxJQUFYO0FBQ0FQLE9BQUMsQ0FBQ1EsT0FBRixDQUFVLFdBQVYsRUFBdUJWLEdBQXZCO0FBQ0FFLE9BQUMsQ0FBQ1MsU0FBRixDQUFZLFdBQVosRUFBeUJaLEtBQXpCO0FBQ0EsYUFBT0csQ0FBUDtBQUNELEtBUk07QUFRSDs7QUFFSixXQUFTVSxRQUFULENBQWtCM0IsTUFBbEIsRUFBMEI0QixLQUExQixFQUFpQztBQUMvQixRQUFJQSxLQUFLLENBQUNDLFFBQU4sSUFBa0IsQ0FBdEIsRUFBeUI7QUFDdkI7QUFBRUQsYUFBSyxHQUFHQSxLQUFLLENBQUNMLFVBQWQ7QUFBMkI7O0FBQy9CLFFBQUl2QixNQUFNLENBQUMyQixRQUFYLEVBQ0U7QUFBRSxhQUFPM0IsTUFBTSxDQUFDMkIsUUFBUCxDQUFnQkMsS0FBaEIsQ0FBUDtBQUErQjs7QUFDbkMsT0FBRztBQUNELFVBQUlBLEtBQUssQ0FBQ0MsUUFBTixJQUFrQixFQUF0QixFQUEwQjtBQUFFRCxhQUFLLEdBQUdBLEtBQUssQ0FBQ0UsSUFBZDtBQUFxQjs7QUFDakQsVUFBSUYsS0FBSyxJQUFJNUIsTUFBYixFQUFxQjtBQUFFLGVBQU8sSUFBUDtBQUFhO0FBQ3JDLEtBSEQsUUFHUzRCLEtBQUssR0FBR0EsS0FBSyxDQUFDTCxVQUh2QjtBQUlEOztBQUVELFdBQVNRLFNBQVQsR0FBcUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsUUFBSUMsYUFBSjs7QUFDQSxRQUFJO0FBQ0ZBLG1CQUFhLEdBQUd4RSxRQUFRLENBQUN3RSxhQUF6QjtBQUNELEtBRkQsQ0FFRSxPQUFNdEMsQ0FBTixFQUFTO0FBQ1RzQyxtQkFBYSxHQUFHeEUsUUFBUSxDQUFDNEQsSUFBVCxJQUFpQixJQUFqQztBQUNEOztBQUNELFdBQU9ZLGFBQWEsSUFBSUEsYUFBYSxDQUFDQyxVQUEvQixJQUE2Q0QsYUFBYSxDQUFDQyxVQUFkLENBQXlCRCxhQUE3RSxFQUNFO0FBQUVBLG1CQUFhLEdBQUdBLGFBQWEsQ0FBQ0MsVUFBZCxDQUF5QkQsYUFBekM7QUFBeUQ7O0FBQzdELFdBQU9BLGFBQVA7QUFDRDs7QUFFRCxXQUFTRSxRQUFULENBQWtCaEQsSUFBbEIsRUFBd0JILEdBQXhCLEVBQTZCO0FBQzNCLFFBQUlJLE9BQU8sR0FBR0QsSUFBSSxDQUFDRSxTQUFuQjs7QUFDQSxRQUFJLENBQUNOLFNBQVMsQ0FBQ0MsR0FBRCxDQUFULENBQWU5QixJQUFmLENBQW9Ca0MsT0FBcEIsQ0FBTCxFQUFtQztBQUFFRCxVQUFJLENBQUNFLFNBQUwsSUFBa0IsQ0FBQ0QsT0FBTyxHQUFHLEdBQUgsR0FBUyxFQUFqQixJQUF1QkosR0FBekM7QUFBK0M7QUFDckY7O0FBQ0QsV0FBU29ELFdBQVQsQ0FBcUJDLENBQXJCLEVBQXdCQyxDQUF4QixFQUEyQjtBQUN6QixRQUFJQyxFQUFFLEdBQUdGLENBQUMsQ0FBQ0csS0FBRixDQUFRLEdBQVIsQ0FBVDs7QUFDQSxTQUFLLElBQUk5QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNkIsRUFBRSxDQUFDOUMsTUFBdkIsRUFBK0JpQixDQUFDLEVBQWhDLEVBQ0U7QUFBRSxVQUFJNkIsRUFBRSxDQUFDN0IsQ0FBRCxDQUFGLElBQVMsQ0FBQzNCLFNBQVMsQ0FBQ3dELEVBQUUsQ0FBQzdCLENBQUQsQ0FBSCxDQUFULENBQWlCeEQsSUFBakIsQ0FBc0JvRixDQUF0QixDQUFkLEVBQXdDO0FBQUVBLFNBQUMsSUFBSSxNQUFNQyxFQUFFLENBQUM3QixDQUFELENBQWI7QUFBbUI7QUFBRTs7QUFDbkUsV0FBTzRCLENBQVA7QUFDRDs7QUFFRCxNQUFJRyxXQUFXLEdBQUcscUJBQVN0RCxJQUFULEVBQWU7QUFBRUEsUUFBSSxDQUFDdUQsTUFBTDtBQUFnQixHQUFuRDs7QUFDQSxNQUFJdkUsR0FBSixFQUFTO0FBQ1A7QUFBRXNFLGlCQUFXLEdBQUcscUJBQVN0RCxJQUFULEVBQWU7QUFBRUEsWUFBSSxDQUFDd0QsY0FBTCxHQUFzQixDQUF0QjtBQUF5QnhELFlBQUksQ0FBQ3lELFlBQUwsR0FBb0J6RCxJQUFJLENBQUMwRCxLQUFMLENBQVdwRCxNQUEvQjtBQUF3QyxPQUFoRztBQUFtRyxLQUR2RyxNQUVLLElBQUlsQyxFQUFKLEVBQVE7QUFDWDtBQUFFa0YsaUJBQVcsR0FBRyxxQkFBU3RELElBQVQsRUFBZTtBQUFFLFlBQUk7QUFBRUEsY0FBSSxDQUFDdUQsTUFBTDtBQUFnQixTQUF0QixDQUF1QixPQUFNSSxFQUFOLEVBQVUsQ0FBRTtBQUFFLE9BQXBFO0FBQXVFOztBQUUzRSxXQUFTQyxJQUFULENBQWNDLENBQWQsRUFBaUI7QUFDZixRQUFJQyxJQUFJLEdBQUdDLEtBQUssQ0FBQ0MsU0FBTixDQUFnQjVELEtBQWhCLENBQXNCNkQsSUFBdEIsQ0FBMkJDLFNBQTNCLEVBQXNDLENBQXRDLENBQVg7QUFDQSxXQUFPLFlBQVU7QUFBQyxhQUFPTCxDQUFDLENBQUNNLEtBQUYsQ0FBUSxJQUFSLEVBQWNMLElBQWQsQ0FBUDtBQUEyQixLQUE3QztBQUNEOztBQUVELFdBQVNNLE9BQVQsQ0FBaUJDLEdBQWpCLEVBQXNCQyxNQUF0QixFQUE4QkMsU0FBOUIsRUFBeUM7QUFDdkMsUUFBSSxDQUFDRCxNQUFMLEVBQWE7QUFBRUEsWUFBTSxHQUFHLEVBQVQ7QUFBYzs7QUFDN0IsU0FBSyxJQUFJRSxJQUFULElBQWlCSCxHQUFqQixFQUNFO0FBQUUsVUFBSUEsR0FBRyxDQUFDSSxjQUFKLENBQW1CRCxJQUFuQixNQUE2QkQsU0FBUyxLQUFLLEtBQWQsSUFBdUIsQ0FBQ0QsTUFBTSxDQUFDRyxjQUFQLENBQXNCRCxJQUF0QixDQUFyRCxDQUFKLEVBQ0E7QUFBRUYsY0FBTSxDQUFDRSxJQUFELENBQU4sR0FBZUgsR0FBRyxDQUFDRyxJQUFELENBQWxCO0FBQTJCO0FBQUU7O0FBQ25DLFdBQU9GLE1BQVA7QUFDRCxHQS9Ja0IsQ0FpSm5CO0FBQ0E7OztBQUNBLFdBQVNJLFdBQVQsQ0FBcUJDLE1BQXJCLEVBQTZCOUMsR0FBN0IsRUFBa0MrQyxPQUFsQyxFQUEyQ0MsVUFBM0MsRUFBdURDLFVBQXZELEVBQW1FO0FBQ2pFLFFBQUlqRCxHQUFHLElBQUksSUFBWCxFQUFpQjtBQUNmQSxTQUFHLEdBQUc4QyxNQUFNLENBQUNJLE1BQVAsQ0FBYyxhQUFkLENBQU47O0FBQ0EsVUFBSWxELEdBQUcsSUFBSSxDQUFDLENBQVosRUFBZTtBQUFFQSxXQUFHLEdBQUc4QyxNQUFNLENBQUNyRSxNQUFiO0FBQXNCO0FBQ3hDOztBQUNELFNBQUssSUFBSWlCLENBQUMsR0FBR3NELFVBQVUsSUFBSSxDQUF0QixFQUF5QkcsQ0FBQyxHQUFHRixVQUFVLElBQUksQ0FBaEQsSUFBcUQ7QUFDbkQsVUFBSUcsT0FBTyxHQUFHTixNQUFNLENBQUNPLE9BQVAsQ0FBZSxJQUFmLEVBQXFCM0QsQ0FBckIsQ0FBZDs7QUFDQSxVQUFJMEQsT0FBTyxHQUFHLENBQVYsSUFBZUEsT0FBTyxJQUFJcEQsR0FBOUIsRUFDRTtBQUFFLGVBQU9tRCxDQUFDLElBQUluRCxHQUFHLEdBQUdOLENBQVYsQ0FBUjtBQUFzQjs7QUFDMUJ5RCxPQUFDLElBQUlDLE9BQU8sR0FBRzFELENBQWY7QUFDQXlELE9BQUMsSUFBSUosT0FBTyxHQUFJSSxDQUFDLEdBQUdKLE9BQXBCO0FBQ0FyRCxPQUFDLEdBQUcwRCxPQUFPLEdBQUcsQ0FBZDtBQUNEO0FBQ0Y7O0FBRUQsTUFBSUUsT0FBTyxHQUFHLFNBQVZBLE9BQVUsR0FBVztBQUN2QixTQUFLQyxFQUFMLEdBQVUsSUFBVjtBQUNBLFNBQUt2QixDQUFMLEdBQVMsSUFBVDtBQUNBLFNBQUt3QixJQUFMLEdBQVksQ0FBWjtBQUNBLFNBQUtDLE9BQUwsR0FBZTFCLElBQUksQ0FBQyxLQUFLMkIsU0FBTixFQUFpQixJQUFqQixDQUFuQjtBQUNELEdBTEQ7O0FBTUFKLFNBQU8sQ0FBQ25CLFNBQVIsQ0FBa0J1QixTQUFsQixHQUE4QixVQUFVQyxJQUFWLEVBQWdCO0FBQzVDQSxRQUFJLENBQUNKLEVBQUwsR0FBVSxDQUFWOztBQUNBLFFBQUlJLElBQUksQ0FBQ0gsSUFBTCxJQUFhLENBQUMsSUFBSUksSUFBSixFQUFsQixFQUE0QjtBQUMxQkQsVUFBSSxDQUFDM0IsQ0FBTDtBQUNELEtBRkQsTUFFTztBQUNMNkIsZ0JBQVUsQ0FBQ0YsSUFBSSxDQUFDRixPQUFOLEVBQWVFLElBQUksQ0FBQ0gsSUFBTCxHQUFZLENBQUMsSUFBSUksSUFBSixFQUE1QixDQUFWO0FBQ0Q7QUFDRixHQVBEOztBQVFBTixTQUFPLENBQUNuQixTQUFSLENBQWtCMkIsR0FBbEIsR0FBd0IsVUFBVUMsRUFBVixFQUFjL0IsQ0FBZCxFQUFpQjtBQUN2QyxTQUFLQSxDQUFMLEdBQVNBLENBQVQ7QUFDQSxRQUFJd0IsSUFBSSxHQUFHLENBQUMsSUFBSUksSUFBSixFQUFELEdBQVlHLEVBQXZCOztBQUNBLFFBQUksQ0FBQyxLQUFLUixFQUFOLElBQVlDLElBQUksR0FBRyxLQUFLQSxJQUE1QixFQUFrQztBQUNoQ1Esa0JBQVksQ0FBQyxLQUFLVCxFQUFOLENBQVo7QUFDQSxXQUFLQSxFQUFMLEdBQVVNLFVBQVUsQ0FBQyxLQUFLSixPQUFOLEVBQWVNLEVBQWYsQ0FBcEI7QUFDQSxXQUFLUCxJQUFMLEdBQVlBLElBQVo7QUFDRDtBQUNGLEdBUkQ7O0FBVUEsV0FBU0gsT0FBVCxDQUFpQlksS0FBakIsRUFBd0I5RSxHQUF4QixFQUE2QjtBQUMzQixTQUFLLElBQUlPLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1RSxLQUFLLENBQUN4RixNQUExQixFQUFrQyxFQUFFaUIsQ0FBcEMsRUFDRTtBQUFFLFVBQUl1RSxLQUFLLENBQUN2RSxDQUFELENBQUwsSUFBWVAsR0FBaEIsRUFBcUI7QUFBRSxlQUFPTyxDQUFQO0FBQVU7QUFBRTs7QUFDdkMsV0FBTyxDQUFDLENBQVI7QUFDRCxHQTlMa0IsQ0FnTW5COzs7QUFDQSxNQUFJd0UsV0FBVyxHQUFHLEVBQWxCLENBak1tQixDQW1NbkI7QUFDQTs7QUFDQSxNQUFJQyxJQUFJLEdBQUc7QUFBQ0MsWUFBUSxFQUFFLG9CQUFVO0FBQUMsYUFBTyxpQkFBUDtBQUF5QjtBQUEvQyxHQUFYLENBck1tQixDQXVNbkI7O0FBQ0EsTUFBSUMsY0FBYyxHQUFHO0FBQUNDLFVBQU0sRUFBRTtBQUFULEdBQXJCO0FBQUEsTUFBc0NDLFNBQVMsR0FBRztBQUFDQyxVQUFNLEVBQUU7QUFBVCxHQUFsRDtBQUFBLE1BQXNFQyxRQUFRLEdBQUc7QUFBQ0QsVUFBTSxFQUFFO0FBQVQsR0FBakYsQ0F4TW1CLENBME1uQjtBQUNBOztBQUNBLFdBQVNFLFVBQVQsQ0FBb0I1QixNQUFwQixFQUE0QjZCLElBQTVCLEVBQWtDNUIsT0FBbEMsRUFBMkM7QUFDekMsU0FBSyxJQUFJNkIsR0FBRyxHQUFHLENBQVYsRUFBYUMsR0FBRyxHQUFHLENBQXhCLElBQTZCO0FBQzNCLFVBQUl6QixPQUFPLEdBQUdOLE1BQU0sQ0FBQ08sT0FBUCxDQUFlLElBQWYsRUFBcUJ1QixHQUFyQixDQUFkOztBQUNBLFVBQUl4QixPQUFPLElBQUksQ0FBQyxDQUFoQixFQUFtQjtBQUFFQSxlQUFPLEdBQUdOLE1BQU0sQ0FBQ3JFLE1BQWpCO0FBQTBCOztBQUMvQyxVQUFJcUcsT0FBTyxHQUFHMUIsT0FBTyxHQUFHd0IsR0FBeEI7O0FBQ0EsVUFBSXhCLE9BQU8sSUFBSU4sTUFBTSxDQUFDckUsTUFBbEIsSUFBNEJvRyxHQUFHLEdBQUdDLE9BQU4sSUFBaUJILElBQWpELEVBQ0U7QUFBRSxlQUFPQyxHQUFHLEdBQUdHLElBQUksQ0FBQ0MsR0FBTCxDQUFTRixPQUFULEVBQWtCSCxJQUFJLEdBQUdFLEdBQXpCLENBQWI7QUFBNEM7O0FBQ2hEQSxTQUFHLElBQUl6QixPQUFPLEdBQUd3QixHQUFqQjtBQUNBQyxTQUFHLElBQUk5QixPQUFPLEdBQUk4QixHQUFHLEdBQUc5QixPQUF4QjtBQUNBNkIsU0FBRyxHQUFHeEIsT0FBTyxHQUFHLENBQWhCOztBQUNBLFVBQUl5QixHQUFHLElBQUlGLElBQVgsRUFBaUI7QUFBRSxlQUFPQyxHQUFQO0FBQVk7QUFDaEM7QUFDRjs7QUFFRCxNQUFJSyxTQUFTLEdBQUcsQ0FBQyxFQUFELENBQWhCOztBQUNBLFdBQVNDLFFBQVQsQ0FBa0IvQixDQUFsQixFQUFxQjtBQUNuQixXQUFPOEIsU0FBUyxDQUFDeEcsTUFBVixJQUFvQjBFLENBQTNCLEVBQ0U7QUFBRThCLGVBQVMsQ0FBQ0UsSUFBVixDQUFlQyxHQUFHLENBQUNILFNBQUQsQ0FBSCxHQUFpQixHQUFoQztBQUF1Qzs7QUFDM0MsV0FBT0EsU0FBUyxDQUFDOUIsQ0FBRCxDQUFoQjtBQUNEOztBQUVELFdBQVNpQyxHQUFULENBQWFDLEdBQWIsRUFBa0I7QUFBRSxXQUFPQSxHQUFHLENBQUNBLEdBQUcsQ0FBQzVHLE1BQUosR0FBVyxDQUFaLENBQVY7QUFBMEI7O0FBRTlDLFdBQVM2RyxHQUFULENBQWFyQixLQUFiLEVBQW9CakMsQ0FBcEIsRUFBdUI7QUFDckIsUUFBSXVELEdBQUcsR0FBRyxFQUFWOztBQUNBLFNBQUssSUFBSTdGLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1RSxLQUFLLENBQUN4RixNQUExQixFQUFrQ2lCLENBQUMsRUFBbkMsRUFBdUM7QUFBRTZGLFNBQUcsQ0FBQzdGLENBQUQsQ0FBSCxHQUFTc0MsQ0FBQyxDQUFDaUMsS0FBSyxDQUFDdkUsQ0FBRCxDQUFOLEVBQVdBLENBQVgsQ0FBVjtBQUEwQjs7QUFDbkUsV0FBTzZGLEdBQVA7QUFDRDs7QUFFRCxXQUFTQyxZQUFULENBQXNCdkIsS0FBdEIsRUFBNkJwQyxLQUE3QixFQUFvQzRELEtBQXBDLEVBQTJDO0FBQ3pDLFFBQUliLEdBQUcsR0FBRyxDQUFWO0FBQUEsUUFBYWMsUUFBUSxHQUFHRCxLQUFLLENBQUM1RCxLQUFELENBQTdCOztBQUNBLFdBQU8rQyxHQUFHLEdBQUdYLEtBQUssQ0FBQ3hGLE1BQVosSUFBc0JnSCxLQUFLLENBQUN4QixLQUFLLENBQUNXLEdBQUQsQ0FBTixDQUFMLElBQXFCYyxRQUFsRCxFQUE0RDtBQUFFZCxTQUFHO0FBQUs7O0FBQ3RFWCxTQUFLLENBQUMwQixNQUFOLENBQWFmLEdBQWIsRUFBa0IsQ0FBbEIsRUFBcUIvQyxLQUFyQjtBQUNEOztBQUVELFdBQVMrRCxPQUFULEdBQW1CLENBQUU7O0FBRXJCLFdBQVNDLFNBQVQsQ0FBbUJDLElBQW5CLEVBQXlCQyxLQUF6QixFQUFnQztBQUM5QixRQUFJQyxJQUFKOztBQUNBLFFBQUlDLE1BQU0sQ0FBQ0MsTUFBWCxFQUFtQjtBQUNqQkYsVUFBSSxHQUFHQyxNQUFNLENBQUNDLE1BQVAsQ0FBY0osSUFBZCxDQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0xGLGFBQU8sQ0FBQ3pELFNBQVIsR0FBb0IyRCxJQUFwQjtBQUNBRSxVQUFJLEdBQUcsSUFBSUosT0FBSixFQUFQO0FBQ0Q7O0FBQ0QsUUFBSUcsS0FBSixFQUFXO0FBQUV4RCxhQUFPLENBQUN3RCxLQUFELEVBQVFDLElBQVIsQ0FBUDtBQUF1Qjs7QUFDcEMsV0FBT0EsSUFBUDtBQUNEOztBQUVELE1BQUlHLDBCQUEwQixHQUFHLDJHQUFqQzs7QUFDQSxXQUFTQyxlQUFULENBQXlCQyxFQUF6QixFQUE2QjtBQUMzQixXQUFPLEtBQUtuSyxJQUFMLENBQVVtSyxFQUFWLEtBQWlCQSxFQUFFLEdBQUcsTUFBTCxLQUNyQkEsRUFBRSxDQUFDQyxXQUFILE1BQW9CRCxFQUFFLENBQUNFLFdBQUgsRUFBcEIsSUFBd0NKLDBCQUEwQixDQUFDakssSUFBM0IsQ0FBZ0NtSyxFQUFoQyxDQURuQixDQUF4QjtBQUVEOztBQUNELFdBQVNHLFVBQVQsQ0FBb0JILEVBQXBCLEVBQXdCSSxNQUF4QixFQUFnQztBQUM5QixRQUFJLENBQUNBLE1BQUwsRUFBYTtBQUFFLGFBQU9MLGVBQWUsQ0FBQ0MsRUFBRCxDQUF0QjtBQUE0Qjs7QUFDM0MsUUFBSUksTUFBTSxDQUFDQyxNQUFQLENBQWNyRCxPQUFkLENBQXNCLEtBQXRCLElBQStCLENBQUMsQ0FBaEMsSUFBcUMrQyxlQUFlLENBQUNDLEVBQUQsQ0FBeEQsRUFBOEQ7QUFBRSxhQUFPLElBQVA7QUFBYTs7QUFDN0UsV0FBT0ksTUFBTSxDQUFDdkssSUFBUCxDQUFZbUssRUFBWixDQUFQO0FBQ0Q7O0FBRUQsV0FBU00sT0FBVCxDQUFpQm5FLEdBQWpCLEVBQXNCO0FBQ3BCLFNBQUssSUFBSVcsQ0FBVCxJQUFjWCxHQUFkLEVBQW1CO0FBQUUsVUFBSUEsR0FBRyxDQUFDSSxjQUFKLENBQW1CTyxDQUFuQixLQUF5QlgsR0FBRyxDQUFDVyxDQUFELENBQWhDLEVBQXFDO0FBQUUsZUFBTyxLQUFQO0FBQWM7QUFBRTs7QUFDNUUsV0FBTyxJQUFQO0FBQ0QsR0EzUWtCLENBNlFuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxNQUFJeUQsY0FBYyxHQUFHLDQ0REFBckI7O0FBQ0EsV0FBU0MsZUFBVCxDQUF5QlIsRUFBekIsRUFBNkI7QUFBRSxXQUFPQSxFQUFFLENBQUNTLFVBQUgsQ0FBYyxDQUFkLEtBQW9CLEdBQXBCLElBQTJCRixjQUFjLENBQUMxSyxJQUFmLENBQW9CbUssRUFBcEIsQ0FBbEM7QUFBMkQsR0FuUnZFLENBcVJuQjs7O0FBQ0EsV0FBU1Usa0JBQVQsQ0FBNEJDLEdBQTVCLEVBQWlDcEMsR0FBakMsRUFBc0NxQyxHQUF0QyxFQUEyQztBQUN6QyxXQUFPLENBQUNBLEdBQUcsR0FBRyxDQUFOLEdBQVVyQyxHQUFHLEdBQUcsQ0FBaEIsR0FBb0JBLEdBQUcsR0FBR29DLEdBQUcsQ0FBQ3ZJLE1BQS9CLEtBQTBDb0ksZUFBZSxDQUFDRyxHQUFHLENBQUNFLE1BQUosQ0FBV3RDLEdBQVgsQ0FBRCxDQUFoRSxFQUFtRjtBQUFFQSxTQUFHLElBQUlxQyxHQUFQO0FBQWE7O0FBQ2xHLFdBQU9yQyxHQUFQO0FBQ0QsR0F6UmtCLENBMlJuQjtBQUNBO0FBQ0E7OztBQUNBLFdBQVN1QyxTQUFULENBQW1CQyxJQUFuQixFQUF5QkMsSUFBekIsRUFBK0JDLEVBQS9CLEVBQW1DO0FBQ2pDO0FBQ0E7QUFDQSxRQUFJTCxHQUFHLEdBQUdJLElBQUksR0FBR0MsRUFBUCxHQUFZLENBQUMsQ0FBYixHQUFpQixDQUEzQjs7QUFDQSxhQUFTO0FBQ1AsVUFBSUQsSUFBSSxJQUFJQyxFQUFaLEVBQWdCO0FBQUUsZUFBT0QsSUFBUDtBQUFhOztBQUMvQixVQUFJRSxJQUFJLEdBQUcsQ0FBQ0YsSUFBSSxHQUFHQyxFQUFSLElBQWMsQ0FBekI7QUFBQSxVQUE0QkUsR0FBRyxHQUFHUCxHQUFHLEdBQUcsQ0FBTixHQUFVbEMsSUFBSSxDQUFDMEMsSUFBTCxDQUFVRixJQUFWLENBQVYsR0FBNEJ4QyxJQUFJLENBQUMyQyxLQUFMLENBQVdILElBQVgsQ0FBOUQ7O0FBQ0EsVUFBSUMsR0FBRyxJQUFJSCxJQUFYLEVBQWlCO0FBQUUsZUFBT0QsSUFBSSxDQUFDSSxHQUFELENBQUosR0FBWUgsSUFBWixHQUFtQkMsRUFBMUI7QUFBOEI7O0FBQ2pELFVBQUlGLElBQUksQ0FBQ0ksR0FBRCxDQUFSLEVBQWU7QUFBRUYsVUFBRSxHQUFHRSxHQUFMO0FBQVcsT0FBNUIsTUFDSztBQUFFSCxZQUFJLEdBQUdHLEdBQUcsR0FBR1AsR0FBYjtBQUFtQjtBQUMzQjtBQUNGLEdBelNrQixDQTJTbkI7OztBQUVBLFdBQVNVLG1CQUFULENBQTZCQyxLQUE3QixFQUFvQ1AsSUFBcEMsRUFBMENDLEVBQTFDLEVBQThDdEYsQ0FBOUMsRUFBaUQ7QUFDL0MsUUFBSSxDQUFDNEYsS0FBTCxFQUFZO0FBQUUsYUFBTzVGLENBQUMsQ0FBQ3FGLElBQUQsRUFBT0MsRUFBUCxFQUFXLEtBQVgsRUFBa0IsQ0FBbEIsQ0FBUjtBQUE4Qjs7QUFDNUMsUUFBSU8sS0FBSyxHQUFHLEtBQVo7O0FBQ0EsU0FBSyxJQUFJbkksQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2tJLEtBQUssQ0FBQ25KLE1BQTFCLEVBQWtDLEVBQUVpQixDQUFwQyxFQUF1QztBQUNyQyxVQUFJb0ksSUFBSSxHQUFHRixLQUFLLENBQUNsSSxDQUFELENBQWhCOztBQUNBLFVBQUlvSSxJQUFJLENBQUNULElBQUwsR0FBWUMsRUFBWixJQUFrQlEsSUFBSSxDQUFDUixFQUFMLEdBQVVELElBQTVCLElBQW9DQSxJQUFJLElBQUlDLEVBQVIsSUFBY1EsSUFBSSxDQUFDUixFQUFMLElBQVdELElBQWpFLEVBQXVFO0FBQ3JFckYsU0FBQyxDQUFDK0MsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTRCxJQUFJLENBQUNULElBQWQsRUFBb0JBLElBQXBCLENBQUQsRUFBNEJ0QyxJQUFJLENBQUNDLEdBQUwsQ0FBUzhDLElBQUksQ0FBQ1IsRUFBZCxFQUFrQkEsRUFBbEIsQ0FBNUIsRUFBbURRLElBQUksQ0FBQ0UsS0FBTCxJQUFjLENBQWQsR0FBa0IsS0FBbEIsR0FBMEIsS0FBN0UsRUFBb0Z0SSxDQUFwRixDQUFEO0FBQ0FtSSxhQUFLLEdBQUcsSUFBUjtBQUNEO0FBQ0Y7O0FBQ0QsUUFBSSxDQUFDQSxLQUFMLEVBQVk7QUFBRTdGLE9BQUMsQ0FBQ3FGLElBQUQsRUFBT0MsRUFBUCxFQUFXLEtBQVgsQ0FBRDtBQUFxQjtBQUNwQzs7QUFFRCxNQUFJVyxTQUFTLEdBQUcsSUFBaEI7O0FBQ0EsV0FBU0MsYUFBVCxDQUF1Qk4sS0FBdkIsRUFBOEJ2QixFQUE5QixFQUFrQzhCLE1BQWxDLEVBQTBDO0FBQ3hDLFFBQUlOLEtBQUo7QUFDQUksYUFBUyxHQUFHLElBQVo7O0FBQ0EsU0FBSyxJQUFJdkksQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2tJLEtBQUssQ0FBQ25KLE1BQTFCLEVBQWtDLEVBQUVpQixDQUFwQyxFQUF1QztBQUNyQyxVQUFJMEksR0FBRyxHQUFHUixLQUFLLENBQUNsSSxDQUFELENBQWY7O0FBQ0EsVUFBSTBJLEdBQUcsQ0FBQ2YsSUFBSixHQUFXaEIsRUFBWCxJQUFpQitCLEdBQUcsQ0FBQ2QsRUFBSixHQUFTakIsRUFBOUIsRUFBa0M7QUFBRSxlQUFPM0csQ0FBUDtBQUFVOztBQUM5QyxVQUFJMEksR0FBRyxDQUFDZCxFQUFKLElBQVVqQixFQUFkLEVBQWtCO0FBQ2hCLFlBQUkrQixHQUFHLENBQUNmLElBQUosSUFBWWUsR0FBRyxDQUFDZCxFQUFoQixJQUFzQmEsTUFBTSxJQUFJLFFBQXBDLEVBQThDO0FBQUVOLGVBQUssR0FBR25JLENBQVI7QUFBWSxTQUE1RCxNQUNLO0FBQUV1SSxtQkFBUyxHQUFHdkksQ0FBWjtBQUFnQjtBQUN4Qjs7QUFDRCxVQUFJMEksR0FBRyxDQUFDZixJQUFKLElBQVloQixFQUFoQixFQUFvQjtBQUNsQixZQUFJK0IsR0FBRyxDQUFDZixJQUFKLElBQVllLEdBQUcsQ0FBQ2QsRUFBaEIsSUFBc0JhLE1BQU0sSUFBSSxRQUFwQyxFQUE4QztBQUFFTixlQUFLLEdBQUduSSxDQUFSO0FBQVksU0FBNUQsTUFDSztBQUFFdUksbUJBQVMsR0FBR3ZJLENBQVo7QUFBZ0I7QUFDeEI7QUFDRjs7QUFDRCxXQUFPbUksS0FBSyxJQUFJLElBQVQsR0FBZ0JBLEtBQWhCLEdBQXdCSSxTQUEvQjtBQUNELEdBM1VrQixDQTZVbkI7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7QUFDQSxNQUFJSSxZQUFZLEdBQUksWUFBVztBQUM3QjtBQUNBLFFBQUlDLFFBQVEsR0FBRywwUEFBZixDQUY2QixDQUc3Qjs7QUFDQSxRQUFJQyxXQUFXLEdBQUcsNFBBQWxCOztBQUNBLGFBQVNDLFFBQVQsQ0FBa0JDLElBQWxCLEVBQXdCO0FBQ3RCLFVBQUlBLElBQUksSUFBSSxJQUFaLEVBQWtCO0FBQUUsZUFBT0gsUUFBUSxDQUFDcEIsTUFBVCxDQUFnQnVCLElBQWhCLENBQVA7QUFBOEIsT0FBbEQsTUFDSyxJQUFJLFNBQVNBLElBQVQsSUFBaUJBLElBQUksSUFBSSxLQUE3QixFQUFvQztBQUFFLGVBQU8sR0FBUDtBQUFZLE9BQWxELE1BQ0EsSUFBSSxTQUFTQSxJQUFULElBQWlCQSxJQUFJLElBQUksS0FBN0IsRUFBb0M7QUFBRSxlQUFPRixXQUFXLENBQUNyQixNQUFaLENBQW1CdUIsSUFBSSxHQUFHLEtBQTFCLENBQVA7QUFBeUMsT0FBL0UsTUFDQSxJQUFJLFNBQVNBLElBQVQsSUFBaUJBLElBQUksSUFBSSxLQUE3QixFQUFvQztBQUFFLGVBQU8sR0FBUDtBQUFZLE9BQWxELE1BQ0EsSUFBSSxVQUFVQSxJQUFWLElBQWtCQSxJQUFJLElBQUksTUFBOUIsRUFBc0M7QUFBRSxlQUFPLEdBQVA7QUFBWSxPQUFwRCxNQUNBLElBQUlBLElBQUksSUFBSSxNQUFaLEVBQW9CO0FBQUUsZUFBTyxHQUFQO0FBQVksT0FBbEMsTUFDQTtBQUFFLGVBQU8sR0FBUDtBQUFZO0FBQ3BCOztBQUVELFFBQUlDLE1BQU0sR0FBRywyQ0FBYjtBQUNBLFFBQUlDLFNBQVMsR0FBRyxRQUFoQjtBQUFBLFFBQTBCQyxRQUFRLEdBQUcsT0FBckM7QUFBQSxRQUE4Q0MsWUFBWSxHQUFHLFFBQTdEO0FBQUEsUUFBdUVDLFdBQVcsR0FBRyxNQUFyRjs7QUFFQSxhQUFTQyxRQUFULENBQWtCZixLQUFsQixFQUF5QlgsSUFBekIsRUFBK0JDLEVBQS9CLEVBQW1DO0FBQ2pDLFdBQUtVLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFdBQUtYLElBQUwsR0FBWUEsSUFBWjtBQUFrQixXQUFLQyxFQUFMLEdBQVVBLEVBQVY7QUFDbkI7O0FBRUQsV0FBTyxVQUFTTixHQUFULEVBQWNnQyxTQUFkLEVBQXlCO0FBQzlCLFVBQUlDLFNBQVMsR0FBR0QsU0FBUyxJQUFJLEtBQWIsR0FBcUIsR0FBckIsR0FBMkIsR0FBM0M7O0FBRUEsVUFBSWhDLEdBQUcsQ0FBQ3ZJLE1BQUosSUFBYyxDQUFkLElBQW1CdUssU0FBUyxJQUFJLEtBQWIsSUFBc0IsQ0FBQ04sTUFBTSxDQUFDeE0sSUFBUCxDQUFZOEssR0FBWixDQUE5QyxFQUFnRTtBQUFFLGVBQU8sS0FBUDtBQUFjOztBQUNoRixVQUFJa0MsR0FBRyxHQUFHbEMsR0FBRyxDQUFDdkksTUFBZDtBQUFBLFVBQXNCMEssS0FBSyxHQUFHLEVBQTlCOztBQUNBLFdBQUssSUFBSXpKLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd3SixHQUFwQixFQUF5QixFQUFFeEosQ0FBM0IsRUFDRTtBQUFFeUosYUFBSyxDQUFDaEUsSUFBTixDQUFXcUQsUUFBUSxDQUFDeEIsR0FBRyxDQUFDRixVQUFKLENBQWVwSCxDQUFmLENBQUQsQ0FBbkI7QUFBMEMsT0FOaEIsQ0FROUI7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFdBQUssSUFBSTBKLEdBQUcsR0FBRyxDQUFWLEVBQWFDLElBQUksR0FBR0osU0FBekIsRUFBb0NHLEdBQUcsR0FBR0YsR0FBMUMsRUFBK0MsRUFBRUUsR0FBakQsRUFBc0Q7QUFDcEQsWUFBSUUsSUFBSSxHQUFHSCxLQUFLLENBQUNDLEdBQUQsQ0FBaEI7O0FBQ0EsWUFBSUUsSUFBSSxJQUFJLEdBQVosRUFBaUI7QUFBRUgsZUFBSyxDQUFDQyxHQUFELENBQUwsR0FBYUMsSUFBYjtBQUFvQixTQUF2QyxNQUNLO0FBQUVBLGNBQUksR0FBR0MsSUFBUDtBQUFjO0FBQ3RCLE9BaEI2QixDQWtCOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBSyxJQUFJQyxHQUFHLEdBQUcsQ0FBVixFQUFhbkIsR0FBRyxHQUFHYSxTQUF4QixFQUFtQ00sR0FBRyxHQUFHTCxHQUF6QyxFQUE4QyxFQUFFSyxHQUFoRCxFQUFxRDtBQUNuRCxZQUFJQyxNQUFNLEdBQUdMLEtBQUssQ0FBQ0ksR0FBRCxDQUFsQjs7QUFDQSxZQUFJQyxNQUFNLElBQUksR0FBVixJQUFpQnBCLEdBQUcsSUFBSSxHQUE1QixFQUFpQztBQUFFZSxlQUFLLENBQUNJLEdBQUQsQ0FBTCxHQUFhLEdBQWI7QUFBbUIsU0FBdEQsTUFDSyxJQUFJWCxRQUFRLENBQUMxTSxJQUFULENBQWNzTixNQUFkLENBQUosRUFBMkI7QUFBRXBCLGFBQUcsR0FBR29CLE1BQU47O0FBQWMsY0FBSUEsTUFBTSxJQUFJLEdBQWQsRUFBbUI7QUFBRUwsaUJBQUssQ0FBQ0ksR0FBRCxDQUFMLEdBQWEsR0FBYjtBQUFtQjtBQUFFO0FBQzNGLE9BM0I2QixDQTZCOUI7QUFDQTtBQUNBOzs7QUFDQSxXQUFLLElBQUlFLEdBQUcsR0FBRyxDQUFWLEVBQWFDLE1BQU0sR0FBR1AsS0FBSyxDQUFDLENBQUQsQ0FBaEMsRUFBcUNNLEdBQUcsR0FBR1AsR0FBRyxHQUFHLENBQWpELEVBQW9ELEVBQUVPLEdBQXRELEVBQTJEO0FBQ3pELFlBQUlFLE1BQU0sR0FBR1IsS0FBSyxDQUFDTSxHQUFELENBQWxCOztBQUNBLFlBQUlFLE1BQU0sSUFBSSxHQUFWLElBQWlCRCxNQUFNLElBQUksR0FBM0IsSUFBa0NQLEtBQUssQ0FBQ00sR0FBRyxHQUFDLENBQUwsQ0FBTCxJQUFnQixHQUF0RCxFQUEyRDtBQUFFTixlQUFLLENBQUNNLEdBQUQsQ0FBTCxHQUFhLEdBQWI7QUFBbUIsU0FBaEYsTUFDSyxJQUFJRSxNQUFNLElBQUksR0FBVixJQUFpQkQsTUFBTSxJQUFJUCxLQUFLLENBQUNNLEdBQUcsR0FBQyxDQUFMLENBQWhDLEtBQ0NDLE1BQU0sSUFBSSxHQUFWLElBQWlCQSxNQUFNLElBQUksR0FENUIsQ0FBSixFQUNzQztBQUFFUCxlQUFLLENBQUNNLEdBQUQsQ0FBTCxHQUFhQyxNQUFiO0FBQXNCOztBQUNuRUEsY0FBTSxHQUFHQyxNQUFUO0FBQ0QsT0F0QzZCLENBd0M5QjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBSyxJQUFJQyxHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHVixHQUF4QixFQUE2QixFQUFFVSxHQUEvQixFQUFvQztBQUNsQyxZQUFJQyxNQUFNLEdBQUdWLEtBQUssQ0FBQ1MsR0FBRCxDQUFsQjs7QUFDQSxZQUFJQyxNQUFNLElBQUksR0FBZCxFQUFtQjtBQUFFVixlQUFLLENBQUNTLEdBQUQsQ0FBTCxHQUFhLEdBQWI7QUFBbUIsU0FBeEMsTUFDSyxJQUFJQyxNQUFNLElBQUksR0FBZCxFQUFtQjtBQUN0QixjQUFJN0osR0FBRyxHQUFJLEtBQUssQ0FBaEI7O0FBQ0EsZUFBS0EsR0FBRyxHQUFHNEosR0FBRyxHQUFHLENBQWpCLEVBQW9CNUosR0FBRyxHQUFHa0osR0FBTixJQUFhQyxLQUFLLENBQUNuSixHQUFELENBQUwsSUFBYyxHQUEvQyxFQUFvRCxFQUFFQSxHQUF0RCxFQUEyRCxDQUFFOztBQUM3RCxjQUFJOEosT0FBTyxHQUFJRixHQUFHLElBQUlULEtBQUssQ0FBQ1MsR0FBRyxHQUFDLENBQUwsQ0FBTCxJQUFnQixHQUF4QixJQUFpQzVKLEdBQUcsR0FBR2tKLEdBQU4sSUFBYUMsS0FBSyxDQUFDbkosR0FBRCxDQUFMLElBQWMsR0FBNUQsR0FBbUUsR0FBbkUsR0FBeUUsR0FBdkY7O0FBQ0EsZUFBSyxJQUFJK0osQ0FBQyxHQUFHSCxHQUFiLEVBQWtCRyxDQUFDLEdBQUcvSixHQUF0QixFQUEyQixFQUFFK0osQ0FBN0IsRUFBZ0M7QUFBRVosaUJBQUssQ0FBQ1ksQ0FBRCxDQUFMLEdBQVdELE9BQVg7QUFBcUI7O0FBQ3ZERixhQUFHLEdBQUc1SixHQUFHLEdBQUcsQ0FBWjtBQUNEO0FBQ0YsT0F0RDZCLENBd0Q5QjtBQUNBO0FBQ0E7OztBQUNBLFdBQUssSUFBSWdLLEdBQUcsR0FBRyxDQUFWLEVBQWFDLEtBQUssR0FBR2hCLFNBQTFCLEVBQXFDZSxHQUFHLEdBQUdkLEdBQTNDLEVBQWdELEVBQUVjLEdBQWxELEVBQXVEO0FBQ3JELFlBQUlFLE1BQU0sR0FBR2YsS0FBSyxDQUFDYSxHQUFELENBQWxCOztBQUNBLFlBQUlDLEtBQUssSUFBSSxHQUFULElBQWdCQyxNQUFNLElBQUksR0FBOUIsRUFBbUM7QUFBRWYsZUFBSyxDQUFDYSxHQUFELENBQUwsR0FBYSxHQUFiO0FBQW1CLFNBQXhELE1BQ0ssSUFBSXBCLFFBQVEsQ0FBQzFNLElBQVQsQ0FBY2dPLE1BQWQsQ0FBSixFQUEyQjtBQUFFRCxlQUFLLEdBQUdDLE1BQVI7QUFBaUI7QUFDcEQsT0EvRDZCLENBaUU5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFdBQUssSUFBSUMsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBR2pCLEdBQXhCLEVBQTZCLEVBQUVpQixHQUEvQixFQUFvQztBQUNsQyxZQUFJeEIsU0FBUyxDQUFDek0sSUFBVixDQUFlaU4sS0FBSyxDQUFDZ0IsR0FBRCxDQUFwQixDQUFKLEVBQWdDO0FBQzlCLGNBQUlDLEtBQUssR0FBSSxLQUFLLENBQWxCOztBQUNBLGVBQUtBLEtBQUssR0FBR0QsR0FBRyxHQUFHLENBQW5CLEVBQXNCQyxLQUFLLEdBQUdsQixHQUFSLElBQWVQLFNBQVMsQ0FBQ3pNLElBQVYsQ0FBZWlOLEtBQUssQ0FBQ2lCLEtBQUQsQ0FBcEIsQ0FBckMsRUFBbUUsRUFBRUEsS0FBckUsRUFBNEUsQ0FBRTs7QUFDOUUsY0FBSUMsTUFBTSxHQUFHLENBQUNGLEdBQUcsR0FBR2hCLEtBQUssQ0FBQ2dCLEdBQUcsR0FBQyxDQUFMLENBQVIsR0FBa0JsQixTQUF0QixLQUFvQyxHQUFqRDtBQUNBLGNBQUkzSyxLQUFLLEdBQUcsQ0FBQzhMLEtBQUssR0FBR2xCLEdBQVIsR0FBY0MsS0FBSyxDQUFDaUIsS0FBRCxDQUFuQixHQUE2Qm5CLFNBQTlCLEtBQTRDLEdBQXhEO0FBQ0EsY0FBSXFCLFNBQVMsR0FBR0QsTUFBTSxJQUFJL0wsS0FBVixHQUFtQitMLE1BQU0sR0FBRyxHQUFILEdBQVMsR0FBbEMsR0FBeUNwQixTQUF6RDs7QUFDQSxlQUFLLElBQUlzQixHQUFHLEdBQUdKLEdBQWYsRUFBb0JJLEdBQUcsR0FBR0gsS0FBMUIsRUFBaUMsRUFBRUcsR0FBbkMsRUFBd0M7QUFBRXBCLGlCQUFLLENBQUNvQixHQUFELENBQUwsR0FBYUQsU0FBYjtBQUF5Qjs7QUFDbkVILGFBQUcsR0FBR0MsS0FBSyxHQUFHLENBQWQ7QUFDRDtBQUNGLE9BakY2QixDQW1GOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsVUFBSXhDLEtBQUssR0FBRyxFQUFaO0FBQUEsVUFBZ0I0QyxDQUFoQjs7QUFDQSxXQUFLLElBQUlDLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUd2QixHQUF4QixHQUE4QjtBQUM1QixZQUFJTCxZQUFZLENBQUMzTSxJQUFiLENBQWtCaU4sS0FBSyxDQUFDc0IsR0FBRCxDQUF2QixDQUFKLEVBQW1DO0FBQ2pDLGNBQUkxSyxLQUFLLEdBQUcwSyxHQUFaOztBQUNBLGVBQUssRUFBRUEsR0FBUCxFQUFZQSxHQUFHLEdBQUd2QixHQUFOLElBQWFMLFlBQVksQ0FBQzNNLElBQWIsQ0FBa0JpTixLQUFLLENBQUNzQixHQUFELENBQXZCLENBQXpCLEVBQXdELEVBQUVBLEdBQTFELEVBQStELENBQUU7O0FBQ2pFN0MsZUFBSyxDQUFDekMsSUFBTixDQUFXLElBQUk0RCxRQUFKLENBQWEsQ0FBYixFQUFnQmhKLEtBQWhCLEVBQXVCMEssR0FBdkIsQ0FBWDtBQUNELFNBSkQsTUFJTztBQUNMLGNBQUk3RixHQUFHLEdBQUc2RixHQUFWO0FBQUEsY0FBZUMsRUFBRSxHQUFHOUMsS0FBSyxDQUFDbkosTUFBMUI7QUFBQSxjQUFrQ2tNLEtBQUssR0FBRzNCLFNBQVMsSUFBSSxLQUFiLEdBQXFCLENBQXJCLEdBQXlCLENBQW5FOztBQUNBLGVBQUssRUFBRXlCLEdBQVAsRUFBWUEsR0FBRyxHQUFHdkIsR0FBTixJQUFhQyxLQUFLLENBQUNzQixHQUFELENBQUwsSUFBYyxHQUF2QyxFQUE0QyxFQUFFQSxHQUE5QyxFQUFtRCxDQUFFOztBQUNyRCxlQUFLLElBQUlHLEdBQUcsR0FBR2hHLEdBQWYsRUFBb0JnRyxHQUFHLEdBQUdILEdBQTFCLEdBQWdDO0FBQzlCLGdCQUFJM0IsV0FBVyxDQUFDNU0sSUFBWixDQUFpQmlOLEtBQUssQ0FBQ3lCLEdBQUQsQ0FBdEIsQ0FBSixFQUFrQztBQUNoQyxrQkFBSWhHLEdBQUcsR0FBR2dHLEdBQVYsRUFBZTtBQUFFaEQscUJBQUssQ0FBQ2pDLE1BQU4sQ0FBYStFLEVBQWIsRUFBaUIsQ0FBakIsRUFBb0IsSUFBSTNCLFFBQUosQ0FBYSxDQUFiLEVBQWdCbkUsR0FBaEIsRUFBcUJnRyxHQUFyQixDQUFwQjtBQUFnREYsa0JBQUUsSUFBSUMsS0FBTjtBQUFjOztBQUMvRSxrQkFBSUUsTUFBTSxHQUFHRCxHQUFiOztBQUNBLG1CQUFLLEVBQUVBLEdBQVAsRUFBWUEsR0FBRyxHQUFHSCxHQUFOLElBQWEzQixXQUFXLENBQUM1TSxJQUFaLENBQWlCaU4sS0FBSyxDQUFDeUIsR0FBRCxDQUF0QixDQUF6QixFQUF1RCxFQUFFQSxHQUF6RCxFQUE4RCxDQUFFOztBQUNoRWhELG1CQUFLLENBQUNqQyxNQUFOLENBQWErRSxFQUFiLEVBQWlCLENBQWpCLEVBQW9CLElBQUkzQixRQUFKLENBQWEsQ0FBYixFQUFnQjhCLE1BQWhCLEVBQXdCRCxHQUF4QixDQUFwQjtBQUNBRixnQkFBRSxJQUFJQyxLQUFOO0FBQ0EvRixpQkFBRyxHQUFHZ0csR0FBTjtBQUNELGFBUEQsTUFPTztBQUFFLGdCQUFFQSxHQUFGO0FBQVE7QUFDbEI7O0FBQ0QsY0FBSWhHLEdBQUcsR0FBRzZGLEdBQVYsRUFBZTtBQUFFN0MsaUJBQUssQ0FBQ2pDLE1BQU4sQ0FBYStFLEVBQWIsRUFBaUIsQ0FBakIsRUFBb0IsSUFBSTNCLFFBQUosQ0FBYSxDQUFiLEVBQWdCbkUsR0FBaEIsRUFBcUI2RixHQUFyQixDQUFwQjtBQUFpRDtBQUNuRTtBQUNGOztBQUNELFVBQUl6QixTQUFTLElBQUksS0FBakIsRUFBd0I7QUFDdEIsWUFBSXBCLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU0ksS0FBVCxJQUFrQixDQUFsQixLQUF3QndDLENBQUMsR0FBR3hELEdBQUcsQ0FBQ3JKLEtBQUosQ0FBVSxNQUFWLENBQTVCLENBQUosRUFBb0Q7QUFDbERpSyxlQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNQLElBQVQsR0FBZ0JtRCxDQUFDLENBQUMsQ0FBRCxDQUFELENBQUsvTCxNQUFyQjtBQUNBbUosZUFBSyxDQUFDa0QsT0FBTixDQUFjLElBQUkvQixRQUFKLENBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQnlCLENBQUMsQ0FBQyxDQUFELENBQUQsQ0FBSy9MLE1BQXhCLENBQWQ7QUFDRDs7QUFDRCxZQUFJMkcsR0FBRyxDQUFDd0MsS0FBRCxDQUFILENBQVdJLEtBQVgsSUFBb0IsQ0FBcEIsS0FBMEJ3QyxDQUFDLEdBQUd4RCxHQUFHLENBQUNySixLQUFKLENBQVUsTUFBVixDQUE5QixDQUFKLEVBQXNEO0FBQ3BEeUgsYUFBRyxDQUFDd0MsS0FBRCxDQUFILENBQVdOLEVBQVgsSUFBaUJrRCxDQUFDLENBQUMsQ0FBRCxDQUFELENBQUsvTCxNQUF0QjtBQUNBbUosZUFBSyxDQUFDekMsSUFBTixDQUFXLElBQUk0RCxRQUFKLENBQWEsQ0FBYixFQUFnQkcsR0FBRyxHQUFHc0IsQ0FBQyxDQUFDLENBQUQsQ0FBRCxDQUFLL0wsTUFBM0IsRUFBbUN5SyxHQUFuQyxDQUFYO0FBQ0Q7QUFDRjs7QUFFRCxhQUFPRixTQUFTLElBQUksS0FBYixHQUFxQnBCLEtBQUssQ0FBQ21ELE9BQU4sRUFBckIsR0FBdUNuRCxLQUE5QztBQUNELEtBMUhEO0FBMkhELEdBbEprQixFQUFuQixDQXBXbUIsQ0F3Zm5CO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU29ELFFBQVQsQ0FBa0JDLElBQWxCLEVBQXdCakMsU0FBeEIsRUFBbUM7QUFDakMsUUFBSXBCLEtBQUssR0FBR3FELElBQUksQ0FBQ3JELEtBQWpCOztBQUNBLFFBQUlBLEtBQUssSUFBSSxJQUFiLEVBQW1CO0FBQUVBLFdBQUssR0FBR3FELElBQUksQ0FBQ3JELEtBQUwsR0FBYVMsWUFBWSxDQUFDNEMsSUFBSSxDQUFDQyxJQUFOLEVBQVlsQyxTQUFaLENBQWpDO0FBQTBEOztBQUMvRSxXQUFPcEIsS0FBUDtBQUNELEdBL2ZrQixDQWlnQm5CO0FBRUE7QUFDQTs7O0FBRUEsTUFBSXVELFVBQVUsR0FBRyxFQUFqQjs7QUFFQSxNQUFJQyxFQUFFLEdBQUcsU0FBTEEsRUFBSyxDQUFTQyxPQUFULEVBQWtCL0IsSUFBbEIsRUFBd0J0SCxDQUF4QixFQUEyQjtBQUNsQyxRQUFJcUosT0FBTyxDQUFDQyxnQkFBWixFQUE4QjtBQUM1QkQsYUFBTyxDQUFDQyxnQkFBUixDQUF5QmhDLElBQXpCLEVBQStCdEgsQ0FBL0IsRUFBa0MsS0FBbEM7QUFDRCxLQUZELE1BRU8sSUFBSXFKLE9BQU8sQ0FBQ0UsV0FBWixFQUF5QjtBQUM5QkYsYUFBTyxDQUFDRSxXQUFSLENBQW9CLE9BQU9qQyxJQUEzQixFQUFpQ3RILENBQWpDO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsVUFBSXNELEdBQUcsR0FBRytGLE9BQU8sQ0FBQ0csU0FBUixLQUFzQkgsT0FBTyxDQUFDRyxTQUFSLEdBQW9CLEVBQTFDLENBQVY7QUFDQWxHLFNBQUcsQ0FBQ2dFLElBQUQsQ0FBSCxHQUFZLENBQUNoRSxHQUFHLENBQUNnRSxJQUFELENBQUgsSUFBYTZCLFVBQWQsRUFBMEJNLE1BQTFCLENBQWlDekosQ0FBakMsQ0FBWjtBQUNEO0FBQ0YsR0FURDs7QUFXQSxXQUFTMEosV0FBVCxDQUFxQkwsT0FBckIsRUFBOEIvQixJQUE5QixFQUFvQztBQUNsQyxXQUFPK0IsT0FBTyxDQUFDRyxTQUFSLElBQXFCSCxPQUFPLENBQUNHLFNBQVIsQ0FBa0JsQyxJQUFsQixDQUFyQixJQUFnRDZCLFVBQXZEO0FBQ0Q7O0FBRUQsV0FBU1EsR0FBVCxDQUFhTixPQUFiLEVBQXNCL0IsSUFBdEIsRUFBNEJ0SCxDQUE1QixFQUErQjtBQUM3QixRQUFJcUosT0FBTyxDQUFDTyxtQkFBWixFQUFpQztBQUMvQlAsYUFBTyxDQUFDTyxtQkFBUixDQUE0QnRDLElBQTVCLEVBQWtDdEgsQ0FBbEMsRUFBcUMsS0FBckM7QUFDRCxLQUZELE1BRU8sSUFBSXFKLE9BQU8sQ0FBQ1EsV0FBWixFQUF5QjtBQUM5QlIsYUFBTyxDQUFDUSxXQUFSLENBQW9CLE9BQU92QyxJQUEzQixFQUFpQ3RILENBQWpDO0FBQ0QsS0FGTSxNQUVBO0FBQ0wsVUFBSXNELEdBQUcsR0FBRytGLE9BQU8sQ0FBQ0csU0FBbEI7QUFBQSxVQUE2Qm5HLEdBQUcsR0FBR0MsR0FBRyxJQUFJQSxHQUFHLENBQUNnRSxJQUFELENBQTdDOztBQUNBLFVBQUlqRSxHQUFKLEVBQVM7QUFDUCxZQUFJN0csS0FBSyxHQUFHNkUsT0FBTyxDQUFDZ0MsR0FBRCxFQUFNckQsQ0FBTixDQUFuQjs7QUFDQSxZQUFJeEQsS0FBSyxHQUFHLENBQUMsQ0FBYixFQUNFO0FBQUU4RyxhQUFHLENBQUNnRSxJQUFELENBQUgsR0FBWWpFLEdBQUcsQ0FBQzlHLEtBQUosQ0FBVSxDQUFWLEVBQWFDLEtBQWIsRUFBb0JpTixNQUFwQixDQUEyQnBHLEdBQUcsQ0FBQzlHLEtBQUosQ0FBVUMsS0FBSyxHQUFHLENBQWxCLENBQTNCLENBQVo7QUFBK0Q7QUFDcEU7QUFDRjtBQUNGOztBQUVELFdBQVNzTixNQUFULENBQWdCVCxPQUFoQixFQUF5Qi9CO0FBQUs7QUFBOUIsSUFBK0M7QUFDN0MsUUFBSXlDLFFBQVEsR0FBR0wsV0FBVyxDQUFDTCxPQUFELEVBQVUvQixJQUFWLENBQTFCOztBQUNBLFFBQUksQ0FBQ3lDLFFBQVEsQ0FBQ3ROLE1BQWQsRUFBc0I7QUFBRTtBQUFROztBQUNoQyxRQUFJd0QsSUFBSSxHQUFHQyxLQUFLLENBQUNDLFNBQU4sQ0FBZ0I1RCxLQUFoQixDQUFzQjZELElBQXRCLENBQTJCQyxTQUEzQixFQUFzQyxDQUF0QyxDQUFYOztBQUNBLFNBQUssSUFBSTNDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxTSxRQUFRLENBQUN0TixNQUE3QixFQUFxQyxFQUFFaUIsQ0FBdkMsRUFBMEM7QUFBRXFNLGNBQVEsQ0FBQ3JNLENBQUQsQ0FBUixDQUFZNEMsS0FBWixDQUFrQixJQUFsQixFQUF3QkwsSUFBeEI7QUFBZ0M7QUFDN0UsR0EzaUJrQixDQTZpQm5CO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBUytKLGNBQVQsQ0FBd0JDLEVBQXhCLEVBQTRCdE4sQ0FBNUIsRUFBK0J1TixRQUEvQixFQUF5QztBQUN2QyxRQUFJLE9BQU92TixDQUFQLElBQVksUUFBaEIsRUFDRTtBQUFFQSxPQUFDLEdBQUc7QUFBQzJLLFlBQUksRUFBRTNLLENBQVA7QUFBVXdOLHNCQUFjLEVBQUUsMEJBQVc7QUFBRSxlQUFLQyxnQkFBTCxHQUF3QixJQUF4QjtBQUErQjtBQUF0RSxPQUFKO0FBQThFOztBQUNsRk4sVUFBTSxDQUFDRyxFQUFELEVBQUtDLFFBQVEsSUFBSXZOLENBQUMsQ0FBQzJLLElBQW5CLEVBQXlCMkMsRUFBekIsRUFBNkJ0TixDQUE3QixDQUFOO0FBQ0EsV0FBTzBOLGtCQUFrQixDQUFDMU4sQ0FBRCxDQUFsQixJQUF5QkEsQ0FBQyxDQUFDMk4sZ0JBQWxDO0FBQ0Q7O0FBRUQsV0FBU0Msb0JBQVQsQ0FBOEJOLEVBQTlCLEVBQWtDO0FBQ2hDLFFBQUk1RyxHQUFHLEdBQUc0RyxFQUFFLENBQUNULFNBQUgsSUFBZ0JTLEVBQUUsQ0FBQ1QsU0FBSCxDQUFhZ0IsY0FBdkM7O0FBQ0EsUUFBSSxDQUFDbkgsR0FBTCxFQUFVO0FBQUU7QUFBUTs7QUFDcEIsUUFBSXZCLEdBQUcsR0FBR21JLEVBQUUsQ0FBQ1EsS0FBSCxDQUFTQyxzQkFBVCxLQUFvQ1QsRUFBRSxDQUFDUSxLQUFILENBQVNDLHNCQUFULEdBQWtDLEVBQXRFLENBQVY7O0FBQ0EsU0FBSyxJQUFJaE4sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzJGLEdBQUcsQ0FBQzVHLE1BQXhCLEVBQWdDLEVBQUVpQixDQUFsQyxFQUFxQztBQUFFLFVBQUkyRCxPQUFPLENBQUNTLEdBQUQsRUFBTXVCLEdBQUcsQ0FBQzNGLENBQUQsQ0FBVCxDQUFQLElBQXdCLENBQUMsQ0FBN0IsRUFDckM7QUFBRW9FLFdBQUcsQ0FBQ3FCLElBQUosQ0FBU0UsR0FBRyxDQUFDM0YsQ0FBRCxDQUFaO0FBQW1CO0FBQUU7QUFDMUI7O0FBRUQsV0FBU2lOLFVBQVQsQ0FBb0J0QixPQUFwQixFQUE2Qi9CLElBQTdCLEVBQW1DO0FBQ2pDLFdBQU9vQyxXQUFXLENBQUNMLE9BQUQsRUFBVS9CLElBQVYsQ0FBWCxDQUEyQjdLLE1BQTNCLEdBQW9DLENBQTNDO0FBQ0QsR0Fqa0JrQixDQW1rQm5CO0FBQ0E7OztBQUNBLFdBQVNtTyxVQUFULENBQW9CQyxJQUFwQixFQUEwQjtBQUN4QkEsUUFBSSxDQUFDMUssU0FBTCxDQUFlaUosRUFBZixHQUFvQixVQUFTOUIsSUFBVCxFQUFldEgsQ0FBZixFQUFrQjtBQUFDb0osUUFBRSxDQUFDLElBQUQsRUFBTzlCLElBQVAsRUFBYXRILENBQWIsQ0FBRjtBQUFtQixLQUExRDs7QUFDQTZLLFFBQUksQ0FBQzFLLFNBQUwsQ0FBZXdKLEdBQWYsR0FBcUIsVUFBU3JDLElBQVQsRUFBZXRILENBQWYsRUFBa0I7QUFBQzJKLFNBQUcsQ0FBQyxJQUFELEVBQU9yQyxJQUFQLEVBQWF0SCxDQUFiLENBQUg7QUFBb0IsS0FBNUQ7QUFDRCxHQXhrQmtCLENBMGtCbkI7QUFDQTs7O0FBRUEsV0FBUzhLLGdCQUFULENBQTBCbk8sQ0FBMUIsRUFBNkI7QUFDM0IsUUFBSUEsQ0FBQyxDQUFDd04sY0FBTixFQUFzQjtBQUFFeE4sT0FBQyxDQUFDd04sY0FBRjtBQUFxQixLQUE3QyxNQUNLO0FBQUV4TixPQUFDLENBQUNvTyxXQUFGLEdBQWdCLEtBQWhCO0FBQXdCO0FBQ2hDOztBQUNELFdBQVNDLGlCQUFULENBQTJCck8sQ0FBM0IsRUFBOEI7QUFDNUIsUUFBSUEsQ0FBQyxDQUFDc08sZUFBTixFQUF1QjtBQUFFdE8sT0FBQyxDQUFDc08sZUFBRjtBQUFzQixLQUEvQyxNQUNLO0FBQUV0TyxPQUFDLENBQUN1TyxZQUFGLEdBQWlCLElBQWpCO0FBQXdCO0FBQ2hDOztBQUNELFdBQVNiLGtCQUFULENBQTRCMU4sQ0FBNUIsRUFBK0I7QUFDN0IsV0FBT0EsQ0FBQyxDQUFDeU4sZ0JBQUYsSUFBc0IsSUFBdEIsR0FBNkJ6TixDQUFDLENBQUN5TixnQkFBL0IsR0FBa0R6TixDQUFDLENBQUNvTyxXQUFGLElBQWlCLEtBQTFFO0FBQ0Q7O0FBQ0QsV0FBU0ksTUFBVCxDQUFnQnhPLENBQWhCLEVBQW1CO0FBQUNtTyxvQkFBZ0IsQ0FBQ25PLENBQUQsQ0FBaEI7QUFBcUJxTyxxQkFBaUIsQ0FBQ3JPLENBQUQsQ0FBakI7QUFBc0I7O0FBRS9ELFdBQVN5TyxRQUFULENBQWtCek8sQ0FBbEIsRUFBcUI7QUFBQyxXQUFPQSxDQUFDLENBQUM4RCxNQUFGLElBQVk5RCxDQUFDLENBQUMwTyxVQUFyQjtBQUFnQzs7QUFDdEQsV0FBU0MsUUFBVCxDQUFrQjNPLENBQWxCLEVBQXFCO0FBQ25CLFFBQUkyQyxDQUFDLEdBQUczQyxDQUFDLENBQUM0TyxLQUFWOztBQUNBLFFBQUlqTSxDQUFDLElBQUksSUFBVCxFQUFlO0FBQ2IsVUFBSTNDLENBQUMsQ0FBQzZPLE1BQUYsR0FBVyxDQUFmLEVBQWtCO0FBQUVsTSxTQUFDLEdBQUcsQ0FBSjtBQUFRLE9BQTVCLE1BQ0ssSUFBSTNDLENBQUMsQ0FBQzZPLE1BQUYsR0FBVyxDQUFmLEVBQWtCO0FBQUVsTSxTQUFDLEdBQUcsQ0FBSjtBQUFRLE9BQTVCLE1BQ0EsSUFBSTNDLENBQUMsQ0FBQzZPLE1BQUYsR0FBVyxDQUFmLEVBQWtCO0FBQUVsTSxTQUFDLEdBQUcsQ0FBSjtBQUFRO0FBQ2xDOztBQUNELFFBQUkvRCxHQUFHLElBQUlvQixDQUFDLENBQUM4TyxPQUFULElBQW9Cbk0sQ0FBQyxJQUFJLENBQTdCLEVBQWdDO0FBQUVBLE9BQUMsR0FBRyxDQUFKO0FBQVE7O0FBQzFDLFdBQU9BLENBQVA7QUFDRCxHQXBtQmtCLENBc21CbkI7OztBQUNBLE1BQUlvTSxXQUFXLEdBQUcsWUFBVztBQUMzQjtBQUNBO0FBQ0EsUUFBSW5SLEVBQUUsSUFBSUMsVUFBVSxHQUFHLENBQXZCLEVBQTBCO0FBQUUsYUFBTyxLQUFQO0FBQWM7O0FBQzFDLFFBQUltUixHQUFHLEdBQUd4TyxHQUFHLENBQUMsS0FBRCxDQUFiO0FBQ0EsV0FBTyxlQUFld08sR0FBZixJQUFzQixjQUFjQSxHQUEzQztBQUNELEdBTmlCLEVBQWxCOztBQVFBLE1BQUlDLGFBQUo7O0FBQ0EsV0FBU0MsZ0JBQVQsQ0FBMEJDLE9BQTFCLEVBQW1DO0FBQ2pDLFFBQUlGLGFBQWEsSUFBSSxJQUFyQixFQUEyQjtBQUN6QixVQUFJMVIsSUFBSSxHQUFHaUQsR0FBRyxDQUFDLE1BQUQsRUFBUyxRQUFULENBQWQ7QUFDQUgsMEJBQW9CLENBQUM4TyxPQUFELEVBQVUzTyxHQUFHLENBQUMsTUFBRCxFQUFTLENBQUNqRCxJQUFELEVBQU9PLFFBQVEsQ0FBQ2dELGNBQVQsQ0FBd0IsR0FBeEIsQ0FBUCxDQUFULENBQWIsQ0FBcEI7O0FBQ0EsVUFBSXFPLE9BQU8sQ0FBQy9PLFVBQVIsQ0FBbUJnUCxZQUFuQixJQUFtQyxDQUF2QyxFQUNFO0FBQUVILHFCQUFhLEdBQUcxUixJQUFJLENBQUM4UixXQUFMLElBQW9CLENBQXBCLElBQXlCOVIsSUFBSSxDQUFDNlIsWUFBTCxHQUFvQixDQUE3QyxJQUFrRCxFQUFFeFIsRUFBRSxJQUFJQyxVQUFVLEdBQUcsQ0FBckIsQ0FBbEU7QUFBNEY7QUFDakc7O0FBQ0QsUUFBSTJCLElBQUksR0FBR3lQLGFBQWEsR0FBR3pPLEdBQUcsQ0FBQyxNQUFELEVBQVMsUUFBVCxDQUFOLEdBQ3RCQSxHQUFHLENBQUMsTUFBRCxFQUFTLE1BQVQsRUFBbUIsSUFBbkIsRUFBeUIsdURBQXpCLENBREw7QUFFQWhCLFFBQUksQ0FBQ3lCLFlBQUwsQ0FBa0IsU0FBbEIsRUFBNkIsRUFBN0I7QUFDQSxXQUFPekIsSUFBUDtBQUNELEdBM25Ca0IsQ0E2bkJuQjs7O0FBQ0EsTUFBSThQLFlBQUo7O0FBQ0EsV0FBU0MsZUFBVCxDQUF5QkosT0FBekIsRUFBa0M7QUFDaEMsUUFBSUcsWUFBWSxJQUFJLElBQXBCLEVBQTBCO0FBQUUsYUFBT0EsWUFBUDtBQUFxQjs7QUFDakQsUUFBSUUsR0FBRyxHQUFHblAsb0JBQW9CLENBQUM4TyxPQUFELEVBQVVyUixRQUFRLENBQUNnRCxjQUFULENBQXdCLFVBQXhCLENBQVYsQ0FBOUI7QUFDQSxRQUFJMk8sRUFBRSxHQUFHdk8sS0FBSyxDQUFDc08sR0FBRCxFQUFNLENBQU4sRUFBUyxDQUFULENBQUwsQ0FBaUJFLHFCQUFqQixFQUFUO0FBQ0EsUUFBSUMsRUFBRSxHQUFHek8sS0FBSyxDQUFDc08sR0FBRCxFQUFNLENBQU4sRUFBUyxDQUFULENBQUwsQ0FBaUJFLHFCQUFqQixFQUFUO0FBQ0EzUCxrQkFBYyxDQUFDb1AsT0FBRCxDQUFkOztBQUNBLFFBQUksQ0FBQ00sRUFBRCxJQUFPQSxFQUFFLENBQUNHLElBQUgsSUFBV0gsRUFBRSxDQUFDSSxLQUF6QixFQUFnQztBQUFFLGFBQU8sS0FBUDtBQUFjLEtBTmhCLENBTWlCOzs7QUFDakQsV0FBT1AsWUFBWSxHQUFJSyxFQUFFLENBQUNFLEtBQUgsR0FBV0osRUFBRSxDQUFDSSxLQUFkLEdBQXNCLENBQTdDO0FBQ0QsR0F2b0JrQixDQXlvQm5CO0FBQ0E7OztBQUNBLE1BQUlDLGNBQWMsR0FBRyxRQUFRak4sS0FBUixDQUFjLElBQWQsRUFBb0IvQyxNQUFwQixJQUE4QixDQUE5QixHQUFrQyxVQUFVcUUsTUFBVixFQUFrQjtBQUN2RSxRQUFJOEIsR0FBRyxHQUFHLENBQVY7QUFBQSxRQUFhOEosTUFBTSxHQUFHLEVBQXRCO0FBQUEsUUFBMEJDLENBQUMsR0FBRzdMLE1BQU0sQ0FBQ3JFLE1BQXJDOztBQUNBLFdBQU9tRyxHQUFHLElBQUkrSixDQUFkLEVBQWlCO0FBQ2YsVUFBSUMsRUFBRSxHQUFHOUwsTUFBTSxDQUFDTyxPQUFQLENBQWUsSUFBZixFQUFxQnVCLEdBQXJCLENBQVQ7O0FBQ0EsVUFBSWdLLEVBQUUsSUFBSSxDQUFDLENBQVgsRUFBYztBQUFFQSxVQUFFLEdBQUc5TCxNQUFNLENBQUNyRSxNQUFaO0FBQXFCOztBQUNyQyxVQUFJd00sSUFBSSxHQUFHbkksTUFBTSxDQUFDdkUsS0FBUCxDQUFhcUcsR0FBYixFQUFrQjlCLE1BQU0sQ0FBQ29FLE1BQVAsQ0FBYzBILEVBQUUsR0FBRyxDQUFuQixLQUF5QixJQUF6QixHQUFnQ0EsRUFBRSxHQUFHLENBQXJDLEdBQXlDQSxFQUEzRCxDQUFYO0FBQ0EsVUFBSUMsRUFBRSxHQUFHNUQsSUFBSSxDQUFDNUgsT0FBTCxDQUFhLElBQWIsQ0FBVDs7QUFDQSxVQUFJd0wsRUFBRSxJQUFJLENBQUMsQ0FBWCxFQUFjO0FBQ1pILGNBQU0sQ0FBQ3ZKLElBQVAsQ0FBWThGLElBQUksQ0FBQzFNLEtBQUwsQ0FBVyxDQUFYLEVBQWNzUSxFQUFkLENBQVo7QUFDQWpLLFdBQUcsSUFBSWlLLEVBQUUsR0FBRyxDQUFaO0FBQ0QsT0FIRCxNQUdPO0FBQ0xILGNBQU0sQ0FBQ3ZKLElBQVAsQ0FBWThGLElBQVo7QUFDQXJHLFdBQUcsR0FBR2dLLEVBQUUsR0FBRyxDQUFYO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPRixNQUFQO0FBQ0QsR0FoQm9CLEdBZ0JqQixVQUFVNUwsTUFBVixFQUFrQjtBQUFFLFdBQU9BLE1BQU0sQ0FBQ3RCLEtBQVAsQ0FBYSxVQUFiLENBQVA7QUFBa0MsR0FoQjFEO0FBa0JBLE1BQUlzTixZQUFZLEdBQUdDLE1BQU0sQ0FBQ0MsWUFBUCxHQUFzQixVQUFVQyxFQUFWLEVBQWM7QUFDckQsUUFBSTtBQUFFLGFBQU9BLEVBQUUsQ0FBQ3ROLGNBQUgsSUFBcUJzTixFQUFFLENBQUNyTixZQUEvQjtBQUE2QyxLQUFuRCxDQUNBLE9BQU1qRCxDQUFOLEVBQVM7QUFBRSxhQUFPLEtBQVA7QUFBYztBQUMxQixHQUhrQixHQUdmLFVBQVVzUSxFQUFWLEVBQWM7QUFDaEIsUUFBSXBQLEtBQUo7O0FBQ0EsUUFBSTtBQUFDQSxXQUFLLEdBQUdvUCxFQUFFLENBQUNDLGFBQUgsQ0FBaUJDLFNBQWpCLENBQTJCclAsV0FBM0IsRUFBUjtBQUFrRCxLQUF2RCxDQUNBLE9BQU1uQixDQUFOLEVBQVMsQ0FBRTs7QUFDWCxRQUFJLENBQUNrQixLQUFELElBQVVBLEtBQUssQ0FBQ3VQLGFBQU4sTUFBeUJILEVBQXZDLEVBQTJDO0FBQUUsYUFBTyxLQUFQO0FBQWM7O0FBQzNELFdBQU9wUCxLQUFLLENBQUN3UCxnQkFBTixDQUF1QixZQUF2QixFQUFxQ3hQLEtBQXJDLEtBQStDLENBQXREO0FBQ0QsR0FURDs7QUFXQSxNQUFJeVAsWUFBWSxHQUFJLFlBQVk7QUFDOUIsUUFBSTNRLENBQUMsR0FBR1EsR0FBRyxDQUFDLEtBQUQsQ0FBWDs7QUFDQSxRQUFJLFlBQVlSLENBQWhCLEVBQW1CO0FBQUUsYUFBTyxJQUFQO0FBQWE7O0FBQ2xDQSxLQUFDLENBQUNpQixZQUFGLENBQWUsUUFBZixFQUF5QixTQUF6QjtBQUNBLFdBQU8sT0FBT2pCLENBQUMsQ0FBQzRRLE1BQVQsSUFBbUIsVUFBMUI7QUFDRCxHQUxrQixFQUFuQjs7QUFPQSxNQUFJQyxjQUFjLEdBQUcsSUFBckI7O0FBQ0EsV0FBU0MsaUJBQVQsQ0FBMkIzQixPQUEzQixFQUFvQztBQUNsQyxRQUFJMEIsY0FBYyxJQUFJLElBQXRCLEVBQTRCO0FBQUUsYUFBT0EsY0FBUDtBQUF1Qjs7QUFDckQsUUFBSXJSLElBQUksR0FBR2Esb0JBQW9CLENBQUM4TyxPQUFELEVBQVUzTyxHQUFHLENBQUMsTUFBRCxFQUFTLEdBQVQsQ0FBYixDQUEvQjtBQUNBLFFBQUl1USxNQUFNLEdBQUd2UixJQUFJLENBQUNrUSxxQkFBTCxFQUFiO0FBQ0EsUUFBSXNCLFNBQVMsR0FBRzlQLEtBQUssQ0FBQzFCLElBQUQsRUFBTyxDQUFQLEVBQVUsQ0FBVixDQUFMLENBQWtCa1EscUJBQWxCLEVBQWhCO0FBQ0EsV0FBT21CLGNBQWMsR0FBR3pLLElBQUksQ0FBQzZLLEdBQUwsQ0FBU0YsTUFBTSxDQUFDbkIsSUFBUCxHQUFjb0IsU0FBUyxDQUFDcEIsSUFBakMsSUFBeUMsQ0FBakU7QUFDRCxHQXRyQmtCLENBd3JCbkI7OztBQUNBLE1BQUlzQixLQUFLLEdBQUcsRUFBWjtBQUFBLE1BQWdCQyxTQUFTLEdBQUcsRUFBNUIsQ0F6ckJtQixDQTJyQm5CO0FBQ0E7QUFDQTs7QUFDQSxXQUFTQyxVQUFULENBQW9CQyxJQUFwQixFQUEwQkMsSUFBMUIsRUFBZ0M7QUFDOUIsUUFBSTVOLFNBQVMsQ0FBQzVELE1BQVYsR0FBbUIsQ0FBdkIsRUFDRTtBQUFFd1IsVUFBSSxDQUFDQyxZQUFMLEdBQW9CaE8sS0FBSyxDQUFDQyxTQUFOLENBQWdCNUQsS0FBaEIsQ0FBc0I2RCxJQUF0QixDQUEyQkMsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBcEI7QUFBK0Q7O0FBQ25Fd04sU0FBSyxDQUFDRyxJQUFELENBQUwsR0FBY0MsSUFBZDtBQUNEOztBQUVELFdBQVNFLFVBQVQsQ0FBb0JDLElBQXBCLEVBQTBCQyxJQUExQixFQUFnQztBQUM5QlAsYUFBUyxDQUFDTSxJQUFELENBQVQsR0FBa0JDLElBQWxCO0FBQ0QsR0F0c0JrQixDQXdzQm5CO0FBQ0E7OztBQUNBLFdBQVNDLFdBQVQsQ0FBcUJELElBQXJCLEVBQTJCO0FBQ3pCLFFBQUksT0FBT0EsSUFBUCxJQUFlLFFBQWYsSUFBMkJQLFNBQVMsQ0FBQ2xOLGNBQVYsQ0FBeUJ5TixJQUF6QixDQUEvQixFQUErRDtBQUM3REEsVUFBSSxHQUFHUCxTQUFTLENBQUNPLElBQUQsQ0FBaEI7QUFDRCxLQUZELE1BRU8sSUFBSUEsSUFBSSxJQUFJLE9BQU9BLElBQUksQ0FBQ0wsSUFBWixJQUFvQixRQUE1QixJQUF3Q0YsU0FBUyxDQUFDbE4sY0FBVixDQUF5QnlOLElBQUksQ0FBQ0wsSUFBOUIsQ0FBNUMsRUFBaUY7QUFDdEYsVUFBSW5JLEtBQUssR0FBR2lJLFNBQVMsQ0FBQ08sSUFBSSxDQUFDTCxJQUFOLENBQXJCOztBQUNBLFVBQUksT0FBT25JLEtBQVAsSUFBZ0IsUUFBcEIsRUFBOEI7QUFBRUEsYUFBSyxHQUFHO0FBQUNtSSxjQUFJLEVBQUVuSTtBQUFQLFNBQVI7QUFBd0I7O0FBQ3hEd0ksVUFBSSxHQUFHeEssU0FBUyxDQUFDZ0MsS0FBRCxFQUFRd0ksSUFBUixDQUFoQjtBQUNBQSxVQUFJLENBQUNMLElBQUwsR0FBWW5JLEtBQUssQ0FBQ21JLElBQWxCO0FBQ0QsS0FMTSxNQUtBLElBQUksT0FBT0ssSUFBUCxJQUFlLFFBQWYsSUFBMkIsMEJBQTBCblUsSUFBMUIsQ0FBK0JtVSxJQUEvQixDQUEvQixFQUFxRTtBQUMxRSxhQUFPQyxXQUFXLENBQUMsaUJBQUQsQ0FBbEI7QUFDRCxLQUZNLE1BRUEsSUFBSSxPQUFPRCxJQUFQLElBQWUsUUFBZixJQUEyQiwyQkFBMkJuVSxJQUEzQixDQUFnQ21VLElBQWhDLENBQS9CLEVBQXNFO0FBQzNFLGFBQU9DLFdBQVcsQ0FBQyxrQkFBRCxDQUFsQjtBQUNEOztBQUNELFFBQUksT0FBT0QsSUFBUCxJQUFlLFFBQW5CLEVBQTZCO0FBQUUsYUFBTztBQUFDTCxZQUFJLEVBQUVLO0FBQVAsT0FBUDtBQUFxQixLQUFwRCxNQUNLO0FBQUUsYUFBT0EsSUFBSSxJQUFJO0FBQUNMLFlBQUksRUFBRTtBQUFQLE9BQWY7QUFBK0I7QUFDdkMsR0F6dEJrQixDQTJ0Qm5CO0FBQ0E7OztBQUNBLFdBQVNPLE9BQVQsQ0FBaUJDLE9BQWpCLEVBQTBCSCxJQUExQixFQUFnQztBQUM5QkEsUUFBSSxHQUFHQyxXQUFXLENBQUNELElBQUQsQ0FBbEI7QUFDQSxRQUFJSSxRQUFRLEdBQUdaLEtBQUssQ0FBQ1EsSUFBSSxDQUFDTCxJQUFOLENBQXBCOztBQUNBLFFBQUksQ0FBQ1MsUUFBTCxFQUFlO0FBQUUsYUFBT0YsT0FBTyxDQUFDQyxPQUFELEVBQVUsWUFBVixDQUFkO0FBQXVDOztBQUN4RCxRQUFJRSxPQUFPLEdBQUdELFFBQVEsQ0FBQ0QsT0FBRCxFQUFVSCxJQUFWLENBQXRCOztBQUNBLFFBQUlNLGNBQWMsQ0FBQy9OLGNBQWYsQ0FBOEJ5TixJQUFJLENBQUNMLElBQW5DLENBQUosRUFBOEM7QUFDNUMsVUFBSVksSUFBSSxHQUFHRCxjQUFjLENBQUNOLElBQUksQ0FBQ0wsSUFBTixDQUF6Qjs7QUFDQSxXQUFLLElBQUlyTixJQUFULElBQWlCaU8sSUFBakIsRUFBdUI7QUFDckIsWUFBSSxDQUFDQSxJQUFJLENBQUNoTyxjQUFMLENBQW9CRCxJQUFwQixDQUFMLEVBQWdDO0FBQUU7QUFBVTs7QUFDNUMsWUFBSStOLE9BQU8sQ0FBQzlOLGNBQVIsQ0FBdUJELElBQXZCLENBQUosRUFBa0M7QUFBRStOLGlCQUFPLENBQUMsTUFBTS9OLElBQVAsQ0FBUCxHQUFzQitOLE9BQU8sQ0FBQy9OLElBQUQsQ0FBN0I7QUFBc0M7O0FBQzFFK04sZUFBTyxDQUFDL04sSUFBRCxDQUFQLEdBQWdCaU8sSUFBSSxDQUFDak8sSUFBRCxDQUFwQjtBQUNEO0FBQ0Y7O0FBQ0QrTixXQUFPLENBQUNWLElBQVIsR0FBZUssSUFBSSxDQUFDTCxJQUFwQjs7QUFDQSxRQUFJSyxJQUFJLENBQUNRLFVBQVQsRUFBcUI7QUFBRUgsYUFBTyxDQUFDRyxVQUFSLEdBQXFCUixJQUFJLENBQUNRLFVBQTFCO0FBQXVDOztBQUM5RCxRQUFJUixJQUFJLENBQUNTLFNBQVQsRUFBb0I7QUFBRSxXQUFLLElBQUlDLE1BQVQsSUFBbUJWLElBQUksQ0FBQ1MsU0FBeEIsRUFDcEI7QUFBRUosZUFBTyxDQUFDSyxNQUFELENBQVAsR0FBa0JWLElBQUksQ0FBQ1MsU0FBTCxDQUFlQyxNQUFmLENBQWxCO0FBQTJDO0FBQUU7O0FBRWpELFdBQU9MLE9BQVA7QUFDRCxHQWh2QmtCLENBa3ZCbkI7QUFDQTs7O0FBQ0EsTUFBSUMsY0FBYyxHQUFHLEVBQXJCOztBQUNBLFdBQVNLLFVBQVQsQ0FBb0JmLElBQXBCLEVBQTBCZ0IsVUFBMUIsRUFBc0M7QUFDcEMsUUFBSUwsSUFBSSxHQUFHRCxjQUFjLENBQUMvTixjQUFmLENBQThCcU4sSUFBOUIsSUFBc0NVLGNBQWMsQ0FBQ1YsSUFBRCxDQUFwRCxHQUE4RFUsY0FBYyxDQUFDVixJQUFELENBQWQsR0FBdUIsRUFBaEc7QUFDQTFOLFdBQU8sQ0FBQzBPLFVBQUQsRUFBYUwsSUFBYixDQUFQO0FBQ0Q7O0FBRUQsV0FBU00sU0FBVCxDQUFtQmpCLElBQW5CLEVBQXlCa0IsS0FBekIsRUFBZ0M7QUFDOUIsUUFBSUEsS0FBSyxLQUFLLElBQWQsRUFBb0I7QUFBRSxhQUFPQSxLQUFQO0FBQWM7O0FBQ3BDLFFBQUlsQixJQUFJLENBQUNpQixTQUFULEVBQW9CO0FBQUUsYUFBT2pCLElBQUksQ0FBQ2lCLFNBQUwsQ0FBZUMsS0FBZixDQUFQO0FBQThCOztBQUNwRCxRQUFJQyxNQUFNLEdBQUcsRUFBYjs7QUFDQSxTQUFLLElBQUlqTyxDQUFULElBQWNnTyxLQUFkLEVBQXFCO0FBQ25CLFVBQUlFLEdBQUcsR0FBR0YsS0FBSyxDQUFDaE8sQ0FBRCxDQUFmOztBQUNBLFVBQUlrTyxHQUFHLFlBQVluUCxLQUFuQixFQUEwQjtBQUFFbVAsV0FBRyxHQUFHQSxHQUFHLENBQUM1RixNQUFKLENBQVcsRUFBWCxDQUFOO0FBQXVCOztBQUNuRDJGLFlBQU0sQ0FBQ2pPLENBQUQsQ0FBTixHQUFZa08sR0FBWjtBQUNEOztBQUNELFdBQU9ELE1BQVA7QUFDRCxHQXB3QmtCLENBc3dCbkI7QUFDQTs7O0FBQ0EsV0FBU0UsU0FBVCxDQUFtQnJCLElBQW5CLEVBQXlCa0IsS0FBekIsRUFBZ0M7QUFDOUIsUUFBSUksSUFBSjs7QUFDQSxXQUFPdEIsSUFBSSxDQUFDcUIsU0FBWixFQUF1QjtBQUNyQkMsVUFBSSxHQUFHdEIsSUFBSSxDQUFDcUIsU0FBTCxDQUFlSCxLQUFmLENBQVA7O0FBQ0EsVUFBSSxDQUFDSSxJQUFELElBQVNBLElBQUksQ0FBQ3RCLElBQUwsSUFBYUEsSUFBMUIsRUFBZ0M7QUFBRTtBQUFPOztBQUN6Q2tCLFdBQUssR0FBR0ksSUFBSSxDQUFDSixLQUFiO0FBQ0FsQixVQUFJLEdBQUdzQixJQUFJLENBQUN0QixJQUFaO0FBQ0Q7O0FBQ0QsV0FBT3NCLElBQUksSUFBSTtBQUFDdEIsVUFBSSxFQUFFQSxJQUFQO0FBQWFrQixXQUFLLEVBQUVBO0FBQXBCLEtBQWY7QUFDRDs7QUFFRCxXQUFTSyxVQUFULENBQW9CdkIsSUFBcEIsRUFBMEJ3QixFQUExQixFQUE4QkMsRUFBOUIsRUFBa0M7QUFDaEMsV0FBT3pCLElBQUksQ0FBQ3VCLFVBQUwsR0FBa0J2QixJQUFJLENBQUN1QixVQUFMLENBQWdCQyxFQUFoQixFQUFvQkMsRUFBcEIsQ0FBbEIsR0FBNEMsSUFBbkQ7QUFDRCxHQXJ4QmtCLENBdXhCbkI7QUFFQTtBQUNBOzs7QUFFQSxNQUFJQyxZQUFZLEdBQUcsU0FBZkEsWUFBZSxDQUFTN08sTUFBVCxFQUFpQkMsT0FBakIsRUFBMEI2TyxVQUExQixFQUFzQztBQUN2RCxTQUFLaE4sR0FBTCxHQUFXLEtBQUs3RSxLQUFMLEdBQWEsQ0FBeEI7QUFDQSxTQUFLK0MsTUFBTCxHQUFjQSxNQUFkO0FBQ0EsU0FBS0MsT0FBTCxHQUFlQSxPQUFPLElBQUksQ0FBMUI7QUFDQSxTQUFLOE8sYUFBTCxHQUFxQixLQUFLQyxlQUFMLEdBQXVCLENBQTVDO0FBQ0EsU0FBS0MsU0FBTCxHQUFpQixDQUFqQjtBQUNBLFNBQUtILFVBQUwsR0FBa0JBLFVBQWxCO0FBQ0QsR0FQRDs7QUFTQUQsY0FBWSxDQUFDeFAsU0FBYixDQUF1QjZQLEdBQXZCLEdBQTZCLFlBQVk7QUFBQyxXQUFPLEtBQUtwTixHQUFMLElBQVksS0FBSzlCLE1BQUwsQ0FBWXJFLE1BQS9CO0FBQXNDLEdBQWhGOztBQUNBa1QsY0FBWSxDQUFDeFAsU0FBYixDQUF1QjhQLEdBQXZCLEdBQTZCLFlBQVk7QUFBQyxXQUFPLEtBQUtyTixHQUFMLElBQVksS0FBS21OLFNBQXhCO0FBQWtDLEdBQTVFOztBQUNBSixjQUFZLENBQUN4UCxTQUFiLENBQXVCK1AsSUFBdkIsR0FBOEIsWUFBWTtBQUFDLFdBQU8sS0FBS3BQLE1BQUwsQ0FBWW9FLE1BQVosQ0FBbUIsS0FBS3RDLEdBQXhCLEtBQWdDdU4sU0FBdkM7QUFBaUQsR0FBNUY7O0FBQ0FSLGNBQVksQ0FBQ3hQLFNBQWIsQ0FBdUJpUSxJQUF2QixHQUE4QixZQUFZO0FBQ3hDLFFBQUksS0FBS3hOLEdBQUwsR0FBVyxLQUFLOUIsTUFBTCxDQUFZckUsTUFBM0IsRUFDRTtBQUFFLGFBQU8sS0FBS3FFLE1BQUwsQ0FBWW9FLE1BQVosQ0FBbUIsS0FBS3RDLEdBQUwsRUFBbkIsQ0FBUDtBQUF1QztBQUM1QyxHQUhEOztBQUlBK00sY0FBWSxDQUFDeFAsU0FBYixDQUF1QmtRLEdBQXZCLEdBQTZCLFVBQVUxVSxLQUFWLEVBQWlCO0FBQzVDLFFBQUkwSSxFQUFFLEdBQUcsS0FBS3ZELE1BQUwsQ0FBWW9FLE1BQVosQ0FBbUIsS0FBS3RDLEdBQXhCLENBQVQ7QUFDQSxRQUFJME4sRUFBSjs7QUFDQSxRQUFJLE9BQU8zVSxLQUFQLElBQWdCLFFBQXBCLEVBQThCO0FBQUUyVSxRQUFFLEdBQUdqTSxFQUFFLElBQUkxSSxLQUFYO0FBQW1CLEtBQW5ELE1BQ0s7QUFBRTJVLFFBQUUsR0FBR2pNLEVBQUUsS0FBSzFJLEtBQUssQ0FBQ3pCLElBQU4sR0FBYXlCLEtBQUssQ0FBQ3pCLElBQU4sQ0FBV21LLEVBQVgsQ0FBYixHQUE4QjFJLEtBQUssQ0FBQzBJLEVBQUQsQ0FBeEMsQ0FBUDtBQUF1RDs7QUFDOUQsUUFBSWlNLEVBQUosRUFBUTtBQUFDLFFBQUUsS0FBSzFOLEdBQVA7QUFBWSxhQUFPeUIsRUFBUDtBQUFVO0FBQ2hDLEdBTkQ7O0FBT0FzTCxjQUFZLENBQUN4UCxTQUFiLENBQXVCb1EsUUFBdkIsR0FBa0MsVUFBVTVVLEtBQVYsRUFBaUI7QUFDakQsUUFBSW9DLEtBQUssR0FBRyxLQUFLNkUsR0FBakI7O0FBQ0EsV0FBTyxLQUFLeU4sR0FBTCxDQUFTMVUsS0FBVCxDQUFQLEVBQXVCLENBQUU7O0FBQ3pCLFdBQU8sS0FBS2lILEdBQUwsR0FBVzdFLEtBQWxCO0FBQ0QsR0FKRDs7QUFLQTRSLGNBQVksQ0FBQ3hQLFNBQWIsQ0FBdUJxUSxRQUF2QixHQUFrQyxZQUFZO0FBQzVDLFFBQUl6UyxLQUFLLEdBQUcsS0FBSzZFLEdBQWpCOztBQUNBLFdBQU8sYUFBYTFJLElBQWIsQ0FBa0IsS0FBSzRHLE1BQUwsQ0FBWW9FLE1BQVosQ0FBbUIsS0FBS3RDLEdBQXhCLENBQWxCLENBQVAsRUFBd0Q7QUFBRSxRQUFFLEtBQUtBLEdBQVA7QUFBYTs7QUFDdkUsV0FBTyxLQUFLQSxHQUFMLEdBQVc3RSxLQUFsQjtBQUNELEdBSkQ7O0FBS0E0UixjQUFZLENBQUN4UCxTQUFiLENBQXVCc1EsU0FBdkIsR0FBbUMsWUFBWTtBQUFDLFNBQUs3TixHQUFMLEdBQVcsS0FBSzlCLE1BQUwsQ0FBWXJFLE1BQXZCO0FBQStCLEdBQS9FOztBQUNBa1QsY0FBWSxDQUFDeFAsU0FBYixDQUF1QnVRLE1BQXZCLEdBQWdDLFVBQVVyTSxFQUFWLEVBQWM7QUFDNUMsUUFBSXdCLEtBQUssR0FBRyxLQUFLL0UsTUFBTCxDQUFZTyxPQUFaLENBQW9CZ0QsRUFBcEIsRUFBd0IsS0FBS3pCLEdBQTdCLENBQVo7O0FBQ0EsUUFBSWlELEtBQUssR0FBRyxDQUFDLENBQWIsRUFBZ0I7QUFBQyxXQUFLakQsR0FBTCxHQUFXaUQsS0FBWDtBQUFrQixhQUFPLElBQVA7QUFBWTtBQUNoRCxHQUhEOztBQUlBOEosY0FBWSxDQUFDeFAsU0FBYixDQUF1QndRLE1BQXZCLEdBQWdDLFVBQVV4UCxDQUFWLEVBQWE7QUFBQyxTQUFLeUIsR0FBTCxJQUFZekIsQ0FBWjtBQUFlLEdBQTdEOztBQUNBd08sY0FBWSxDQUFDeFAsU0FBYixDQUF1QnlRLE1BQXZCLEdBQWdDLFlBQVk7QUFDMUMsUUFBSSxLQUFLZixhQUFMLEdBQXFCLEtBQUs5UixLQUE5QixFQUFxQztBQUNuQyxXQUFLK1IsZUFBTCxHQUF1QmpQLFdBQVcsQ0FBQyxLQUFLQyxNQUFOLEVBQWMsS0FBSy9DLEtBQW5CLEVBQTBCLEtBQUtnRCxPQUEvQixFQUF3QyxLQUFLOE8sYUFBN0MsRUFBNEQsS0FBS0MsZUFBakUsQ0FBbEM7QUFDQSxXQUFLRCxhQUFMLEdBQXFCLEtBQUs5UixLQUExQjtBQUNEOztBQUNELFdBQU8sS0FBSytSLGVBQUwsSUFBd0IsS0FBS0MsU0FBTCxHQUFpQmxQLFdBQVcsQ0FBQyxLQUFLQyxNQUFOLEVBQWMsS0FBS2lQLFNBQW5CLEVBQThCLEtBQUtoUCxPQUFuQyxDQUE1QixHQUEwRSxDQUFsRyxDQUFQO0FBQ0QsR0FORDs7QUFPQTRPLGNBQVksQ0FBQ3hQLFNBQWIsQ0FBdUIwUSxXQUF2QixHQUFxQyxZQUFZO0FBQy9DLFdBQU9oUSxXQUFXLENBQUMsS0FBS0MsTUFBTixFQUFjLElBQWQsRUFBb0IsS0FBS0MsT0FBekIsQ0FBWCxJQUNKLEtBQUtnUCxTQUFMLEdBQWlCbFAsV0FBVyxDQUFDLEtBQUtDLE1BQU4sRUFBYyxLQUFLaVAsU0FBbkIsRUFBOEIsS0FBS2hQLE9BQW5DLENBQTVCLEdBQTBFLENBRHRFLENBQVA7QUFFRCxHQUhEOztBQUlBNE8sY0FBWSxDQUFDeFAsU0FBYixDQUF1QnhFLEtBQXZCLEdBQStCLFVBQVVtVixPQUFWLEVBQW1CQyxPQUFuQixFQUE0QkMsZUFBNUIsRUFBNkM7QUFDMUUsUUFBSSxPQUFPRixPQUFQLElBQWtCLFFBQXRCLEVBQWdDO0FBQzlCLFVBQUlHLEtBQUssR0FBRyxTQUFSQSxLQUFRLENBQVVqTSxHQUFWLEVBQWU7QUFBRSxlQUFPZ00sZUFBZSxHQUFHaE0sR0FBRyxDQUFDVCxXQUFKLEVBQUgsR0FBdUJTLEdBQTdDO0FBQW1ELE9BQWhGOztBQUNBLFVBQUlrTSxNQUFNLEdBQUcsS0FBS3BRLE1BQUwsQ0FBWW9RLE1BQVosQ0FBbUIsS0FBS3RPLEdBQXhCLEVBQTZCa08sT0FBTyxDQUFDclUsTUFBckMsQ0FBYjs7QUFDQSxVQUFJd1UsS0FBSyxDQUFDQyxNQUFELENBQUwsSUFBaUJELEtBQUssQ0FBQ0gsT0FBRCxDQUExQixFQUFxQztBQUNuQyxZQUFJQyxPQUFPLEtBQUssS0FBaEIsRUFBdUI7QUFBRSxlQUFLbk8sR0FBTCxJQUFZa08sT0FBTyxDQUFDclUsTUFBcEI7QUFBNkI7O0FBQ3RELGVBQU8sSUFBUDtBQUNEO0FBQ0YsS0FQRCxNQU9PO0FBQ0wsVUFBSWQsS0FBSyxHQUFHLEtBQUttRixNQUFMLENBQVl2RSxLQUFaLENBQWtCLEtBQUtxRyxHQUF2QixFQUE0QmpILEtBQTVCLENBQWtDbVYsT0FBbEMsQ0FBWjs7QUFDQSxVQUFJblYsS0FBSyxJQUFJQSxLQUFLLENBQUNhLEtBQU4sR0FBYyxDQUEzQixFQUE4QjtBQUFFLGVBQU8sSUFBUDtBQUFhOztBQUM3QyxVQUFJYixLQUFLLElBQUlvVixPQUFPLEtBQUssS0FBekIsRUFBZ0M7QUFBRSxhQUFLbk8sR0FBTCxJQUFZakgsS0FBSyxDQUFDLENBQUQsQ0FBTCxDQUFTYyxNQUFyQjtBQUE4Qjs7QUFDaEUsYUFBT2QsS0FBUDtBQUNEO0FBQ0YsR0FkRDs7QUFlQWdVLGNBQVksQ0FBQ3hQLFNBQWIsQ0FBdUIvRCxPQUF2QixHQUFpQyxZQUFXO0FBQUMsV0FBTyxLQUFLMEUsTUFBTCxDQUFZdkUsS0FBWixDQUFrQixLQUFLd0IsS0FBdkIsRUFBOEIsS0FBSzZFLEdBQW5DLENBQVA7QUFBK0MsR0FBNUY7O0FBQ0ErTSxjQUFZLENBQUN4UCxTQUFiLENBQXVCZ1IsY0FBdkIsR0FBd0MsVUFBVWhRLENBQVYsRUFBYWlRLEtBQWIsRUFBb0I7QUFDMUQsU0FBS3JCLFNBQUwsSUFBa0I1TyxDQUFsQjs7QUFDQSxRQUFJO0FBQUUsYUFBT2lRLEtBQUssRUFBWjtBQUFnQixLQUF0QixTQUNRO0FBQUUsV0FBS3JCLFNBQUwsSUFBa0I1TyxDQUFsQjtBQUFzQjtBQUNqQyxHQUpEOztBQUtBd08sY0FBWSxDQUFDeFAsU0FBYixDQUF1QmtSLFNBQXZCLEdBQW1DLFVBQVVsUSxDQUFWLEVBQWE7QUFDOUMsUUFBSW1RLE1BQU0sR0FBRyxLQUFLMUIsVUFBbEI7QUFDQSxXQUFPMEIsTUFBTSxJQUFJQSxNQUFNLENBQUNELFNBQVAsQ0FBaUJsUSxDQUFqQixDQUFqQjtBQUNELEdBSEQ7O0FBSUF3TyxjQUFZLENBQUN4UCxTQUFiLENBQXVCb1IsU0FBdkIsR0FBbUMsWUFBWTtBQUM3QyxRQUFJRCxNQUFNLEdBQUcsS0FBSzFCLFVBQWxCO0FBQ0EsV0FBTzBCLE1BQU0sSUFBSUEsTUFBTSxDQUFDQyxTQUFQLENBQWlCLEtBQUszTyxHQUF0QixDQUFqQjtBQUNELEdBSEQsQ0F2MkJtQixDQTQyQm5COzs7QUFDQSxXQUFTNE8sT0FBVCxDQUFpQkMsR0FBakIsRUFBc0J0USxDQUF0QixFQUF5QjtBQUN2QkEsS0FBQyxJQUFJc1EsR0FBRyxDQUFDQyxLQUFUOztBQUNBLFFBQUl2USxDQUFDLEdBQUcsQ0FBSixJQUFTQSxDQUFDLElBQUlzUSxHQUFHLENBQUNFLElBQXRCLEVBQTRCO0FBQUUsWUFBTSxJQUFJQyxLQUFKLENBQVUsdUJBQXVCelEsQ0FBQyxHQUFHc1EsR0FBRyxDQUFDQyxLQUEvQixJQUF3QyxtQkFBbEQsQ0FBTjtBQUE4RTs7QUFDNUcsUUFBSUcsS0FBSyxHQUFHSixHQUFaOztBQUNBLFdBQU8sQ0FBQ0ksS0FBSyxDQUFDQyxLQUFkLEVBQXFCO0FBQ25CLFdBQUssSUFBSXBVLENBQUMsR0FBRyxDQUFiLEdBQWlCLEVBQUVBLENBQW5CLEVBQXNCO0FBQ3BCLFlBQUltQixLQUFLLEdBQUdnVCxLQUFLLENBQUNFLFFBQU4sQ0FBZXJVLENBQWYsQ0FBWjtBQUFBLFlBQStCc1UsRUFBRSxHQUFHblQsS0FBSyxDQUFDb1QsU0FBTixFQUFwQzs7QUFDQSxZQUFJOVEsQ0FBQyxHQUFHNlEsRUFBUixFQUFZO0FBQUVILGVBQUssR0FBR2hULEtBQVI7QUFBZTtBQUFPOztBQUNwQ3NDLFNBQUMsSUFBSTZRLEVBQUw7QUFDRDtBQUNGOztBQUNELFdBQU9ILEtBQUssQ0FBQ0MsS0FBTixDQUFZM1EsQ0FBWixDQUFQO0FBQ0QsR0F6M0JrQixDQTIzQm5CO0FBQ0E7OztBQUNBLFdBQVMrUSxVQUFULENBQW9CVCxHQUFwQixFQUF5QjFULEtBQXpCLEVBQWdDQyxHQUFoQyxFQUFxQztBQUNuQyxRQUFJdUYsR0FBRyxHQUFHLEVBQVY7QUFBQSxRQUFjcEMsQ0FBQyxHQUFHcEQsS0FBSyxDQUFDa0wsSUFBeEI7QUFDQXdJLE9BQUcsQ0FBQ1UsSUFBSixDQUFTcFUsS0FBSyxDQUFDa0wsSUFBZixFQUFxQmpMLEdBQUcsQ0FBQ2lMLElBQUosR0FBVyxDQUFoQyxFQUFtQyxVQUFVQSxJQUFWLEVBQWdCO0FBQ2pELFVBQUlDLElBQUksR0FBR0QsSUFBSSxDQUFDQyxJQUFoQjs7QUFDQSxVQUFJL0gsQ0FBQyxJQUFJbkQsR0FBRyxDQUFDaUwsSUFBYixFQUFtQjtBQUFFQyxZQUFJLEdBQUdBLElBQUksQ0FBQzNNLEtBQUwsQ0FBVyxDQUFYLEVBQWN5QixHQUFHLENBQUNxRyxFQUFsQixDQUFQO0FBQStCOztBQUNwRCxVQUFJbEQsQ0FBQyxJQUFJcEQsS0FBSyxDQUFDa0wsSUFBZixFQUFxQjtBQUFFQyxZQUFJLEdBQUdBLElBQUksQ0FBQzNNLEtBQUwsQ0FBV3dCLEtBQUssQ0FBQ3NHLEVBQWpCLENBQVA7QUFBOEI7O0FBQ3JEZCxTQUFHLENBQUNKLElBQUosQ0FBUytGLElBQVQ7QUFDQSxRQUFFL0gsQ0FBRjtBQUNELEtBTkQ7QUFPQSxXQUFPb0MsR0FBUDtBQUNELEdBdjRCa0IsQ0F3NEJuQjs7O0FBQ0EsV0FBUzZPLFFBQVQsQ0FBa0JYLEdBQWxCLEVBQXVCcE0sSUFBdkIsRUFBNkJDLEVBQTdCLEVBQWlDO0FBQy9CLFFBQUkvQixHQUFHLEdBQUcsRUFBVjtBQUNBa08sT0FBRyxDQUFDVSxJQUFKLENBQVM5TSxJQUFULEVBQWVDLEVBQWYsRUFBbUIsVUFBVTJELElBQVYsRUFBZ0I7QUFBRTFGLFNBQUcsQ0FBQ0osSUFBSixDQUFTOEYsSUFBSSxDQUFDQyxJQUFkO0FBQXNCLEtBQTNELEVBRitCLENBRStCOztBQUM5RCxXQUFPM0YsR0FBUDtBQUNELEdBNzRCa0IsQ0ErNEJuQjtBQUNBOzs7QUFDQSxXQUFTOE8sZ0JBQVQsQ0FBMEJwSixJQUExQixFQUFnQ3FKLE1BQWhDLEVBQXdDO0FBQ3RDLFFBQUlDLElBQUksR0FBR0QsTUFBTSxHQUFHckosSUFBSSxDQUFDcUosTUFBekI7O0FBQ0EsUUFBSUMsSUFBSixFQUFVO0FBQUUsV0FBSyxJQUFJcFIsQ0FBQyxHQUFHOEgsSUFBYixFQUFtQjlILENBQW5CLEVBQXNCQSxDQUFDLEdBQUdBLENBQUMsQ0FBQ2xFLE1BQTVCLEVBQW9DO0FBQUVrRSxTQUFDLENBQUNtUixNQUFGLElBQVlDLElBQVo7QUFBbUI7QUFBRTtBQUN4RSxHQXA1QmtCLENBczVCbkI7QUFDQTs7O0FBQ0EsV0FBU0MsTUFBVCxDQUFnQnZKLElBQWhCLEVBQXNCO0FBQ3BCLFFBQUlBLElBQUksQ0FBQ2hNLE1BQUwsSUFBZSxJQUFuQixFQUF5QjtBQUFFLGFBQU8sSUFBUDtBQUFhOztBQUN4QyxRQUFJbUosR0FBRyxHQUFHNkMsSUFBSSxDQUFDaE0sTUFBZjtBQUFBLFFBQXVCd1YsRUFBRSxHQUFHcFIsT0FBTyxDQUFDK0UsR0FBRyxDQUFDMEwsS0FBTCxFQUFZN0ksSUFBWixDQUFuQzs7QUFDQSxTQUFLLElBQUk0SSxLQUFLLEdBQUd6TCxHQUFHLENBQUNuSixNQUFyQixFQUE2QjRVLEtBQTdCLEVBQW9DekwsR0FBRyxHQUFHeUwsS0FBTixFQUFhQSxLQUFLLEdBQUdBLEtBQUssQ0FBQzVVLE1BQS9ELEVBQXVFO0FBQ3JFLFdBQUssSUFBSVMsQ0FBQyxHQUFHLENBQWIsR0FBaUIsRUFBRUEsQ0FBbkIsRUFBc0I7QUFDcEIsWUFBSW1VLEtBQUssQ0FBQ0UsUUFBTixDQUFlclUsQ0FBZixLQUFxQjBJLEdBQXpCLEVBQThCO0FBQUU7QUFBTzs7QUFDdkNxTSxVQUFFLElBQUlaLEtBQUssQ0FBQ0UsUUFBTixDQUFlclUsQ0FBZixFQUFrQnVVLFNBQWxCLEVBQU47QUFDRDtBQUNGOztBQUNELFdBQU9RLEVBQUUsR0FBR3JNLEdBQUcsQ0FBQ3NMLEtBQWhCO0FBQ0QsR0FsNkJrQixDQW82Qm5CO0FBQ0E7OztBQUNBLFdBQVNnQixhQUFULENBQXNCYixLQUF0QixFQUE2QmMsQ0FBN0IsRUFBZ0M7QUFDOUIsUUFBSXhSLENBQUMsR0FBRzBRLEtBQUssQ0FBQ0gsS0FBZDs7QUFDQWtCLFNBQUssRUFBRSxHQUFHO0FBQ1IsV0FBSyxJQUFJeEwsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBR3lLLEtBQUssQ0FBQ0UsUUFBTixDQUFldFYsTUFBdkMsRUFBK0MsRUFBRTJLLEdBQWpELEVBQXNEO0FBQ3BELFlBQUl2SSxLQUFLLEdBQUdnVCxLQUFLLENBQUNFLFFBQU4sQ0FBZTNLLEdBQWYsQ0FBWjtBQUFBLFlBQWlDL0MsRUFBRSxHQUFHeEYsS0FBSyxDQUFDeVQsTUFBNUM7O0FBQ0EsWUFBSUssQ0FBQyxHQUFHdE8sRUFBUixFQUFZO0FBQUV3TixlQUFLLEdBQUdoVCxLQUFSO0FBQWUsbUJBQVMrVCxLQUFUO0FBQWdCOztBQUM3Q0QsU0FBQyxJQUFJdE8sRUFBTDtBQUNBbEQsU0FBQyxJQUFJdEMsS0FBSyxDQUFDb1QsU0FBTixFQUFMO0FBQ0Q7O0FBQ0QsYUFBTzlRLENBQVA7QUFDRCxLQVJNLFFBUUUsQ0FBQzBRLEtBQUssQ0FBQ0MsS0FSVDs7QUFTUCxRQUFJcFUsQ0FBQyxHQUFHLENBQVI7O0FBQ0EsV0FBT0EsQ0FBQyxHQUFHbVUsS0FBSyxDQUFDQyxLQUFOLENBQVlyVixNQUF2QixFQUErQixFQUFFaUIsQ0FBakMsRUFBb0M7QUFDbEMsVUFBSXVMLElBQUksR0FBRzRJLEtBQUssQ0FBQ0MsS0FBTixDQUFZcFUsQ0FBWixDQUFYO0FBQUEsVUFBMkJtVixFQUFFLEdBQUc1SixJQUFJLENBQUNxSixNQUFyQzs7QUFDQSxVQUFJSyxDQUFDLEdBQUdFLEVBQVIsRUFBWTtBQUFFO0FBQU87O0FBQ3JCRixPQUFDLElBQUlFLEVBQUw7QUFDRDs7QUFDRCxXQUFPMVIsQ0FBQyxHQUFHekQsQ0FBWDtBQUNEOztBQUVELFdBQVNvVixNQUFULENBQWdCckIsR0FBaEIsRUFBcUI5RSxDQUFyQixFQUF3QjtBQUFDLFdBQU9BLENBQUMsSUFBSThFLEdBQUcsQ0FBQ0MsS0FBVCxJQUFrQi9FLENBQUMsR0FBRzhFLEdBQUcsQ0FBQ0MsS0FBSixHQUFZRCxHQUFHLENBQUNFLElBQTdDO0FBQWtEOztBQUUzRSxXQUFTb0IsYUFBVCxDQUF1QnZFLE9BQXZCLEVBQWdDOVEsQ0FBaEMsRUFBbUM7QUFDakMsV0FBT3NWLE1BQU0sQ0FBQ3hFLE9BQU8sQ0FBQ3lFLG1CQUFSLENBQTRCdlYsQ0FBQyxHQUFHOFEsT0FBTyxDQUFDMEUsZUFBeEMsQ0FBRCxDQUFiO0FBQ0QsR0E5N0JrQixDQWc4Qm5COzs7QUFDQSxXQUFTQyxHQUFULENBQWFsSyxJQUFiLEVBQW1CNUUsRUFBbkIsRUFBdUI4QixNQUF2QixFQUErQjtBQUM3QixRQUFLQSxNQUFNLEtBQUssS0FBSyxDQUFyQixFQUF5QkEsTUFBTSxHQUFHLElBQVQ7O0FBRXpCLFFBQUksRUFBRSxnQkFBZ0JnTixHQUFsQixDQUFKLEVBQTRCO0FBQUUsYUFBTyxJQUFJQSxHQUFKLENBQVFsSyxJQUFSLEVBQWM1RSxFQUFkLEVBQWtCOEIsTUFBbEIsQ0FBUDtBQUFrQzs7QUFDaEUsU0FBSzhDLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUs1RSxFQUFMLEdBQVVBLEVBQVY7QUFDQSxTQUFLOEIsTUFBTCxHQUFjQSxNQUFkO0FBQ0QsR0F4OEJrQixDQTA4Qm5CO0FBQ0E7OztBQUNBLFdBQVNpTixHQUFULENBQWEvVCxDQUFiLEVBQWdCQyxDQUFoQixFQUFtQjtBQUFFLFdBQU9ELENBQUMsQ0FBQzRKLElBQUYsR0FBUzNKLENBQUMsQ0FBQzJKLElBQVgsSUFBbUI1SixDQUFDLENBQUNnRixFQUFGLEdBQU8vRSxDQUFDLENBQUMrRSxFQUFuQztBQUF1Qzs7QUFFNUQsV0FBU2dQLGNBQVQsQ0FBd0JoVSxDQUF4QixFQUEyQkMsQ0FBM0IsRUFBOEI7QUFBRSxXQUFPRCxDQUFDLENBQUM4RyxNQUFGLElBQVk3RyxDQUFDLENBQUM2RyxNQUFkLElBQXdCaU4sR0FBRyxDQUFDL1QsQ0FBRCxFQUFJQyxDQUFKLENBQUgsSUFBYSxDQUE1QztBQUErQzs7QUFFL0UsV0FBU2dVLE9BQVQsQ0FBaUJDLENBQWpCLEVBQW9CO0FBQUMsV0FBT0osR0FBRyxDQUFDSSxDQUFDLENBQUN0SyxJQUFILEVBQVNzSyxDQUFDLENBQUNsUCxFQUFYLENBQVY7QUFBeUI7O0FBQzlDLFdBQVNtUCxNQUFULENBQWdCblUsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCO0FBQUUsV0FBTzhULEdBQUcsQ0FBQy9ULENBQUQsRUFBSUMsQ0FBSixDQUFILEdBQVksQ0FBWixHQUFnQkEsQ0FBaEIsR0FBb0JELENBQTNCO0FBQThCOztBQUN0RCxXQUFTb1UsTUFBVCxDQUFnQnBVLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQjtBQUFFLFdBQU84VCxHQUFHLENBQUMvVCxDQUFELEVBQUlDLENBQUosQ0FBSCxHQUFZLENBQVosR0FBZ0JELENBQWhCLEdBQW9CQyxDQUEzQjtBQUE4QixHQWw5Qm5DLENBbzlCbkI7QUFDQTs7O0FBQ0EsV0FBU29VLFFBQVQsQ0FBa0JqQyxHQUFsQixFQUF1QnRRLENBQXZCLEVBQTBCO0FBQUMsV0FBTzRCLElBQUksQ0FBQ2dELEdBQUwsQ0FBUzBMLEdBQUcsQ0FBQ0MsS0FBYixFQUFvQjNPLElBQUksQ0FBQ0MsR0FBTCxDQUFTN0IsQ0FBVCxFQUFZc1EsR0FBRyxDQUFDQyxLQUFKLEdBQVlELEdBQUcsQ0FBQ0UsSUFBaEIsR0FBdUIsQ0FBbkMsQ0FBcEIsQ0FBUDtBQUFrRTs7QUFDN0YsV0FBU2dDLFFBQVQsQ0FBaUJsQyxHQUFqQixFQUFzQjdPLEdBQXRCLEVBQTJCO0FBQ3pCLFFBQUlBLEdBQUcsQ0FBQ3FHLElBQUosR0FBV3dJLEdBQUcsQ0FBQ0MsS0FBbkIsRUFBMEI7QUFBRSxhQUFPeUIsR0FBRyxDQUFDMUIsR0FBRyxDQUFDQyxLQUFMLEVBQVksQ0FBWixDQUFWO0FBQTBCOztBQUN0RCxRQUFJa0MsSUFBSSxHQUFHbkMsR0FBRyxDQUFDQyxLQUFKLEdBQVlELEdBQUcsQ0FBQ0UsSUFBaEIsR0FBdUIsQ0FBbEM7O0FBQ0EsUUFBSS9PLEdBQUcsQ0FBQ3FHLElBQUosR0FBVzJLLElBQWYsRUFBcUI7QUFBRSxhQUFPVCxHQUFHLENBQUNTLElBQUQsRUFBT3BDLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNbUMsSUFBTixDQUFQLENBQW1CMUssSUFBbkIsQ0FBd0J6TSxNQUEvQixDQUFWO0FBQWtEOztBQUN6RSxXQUFPb1gsU0FBUyxDQUFDalIsR0FBRCxFQUFNNE8sT0FBTyxDQUFDQyxHQUFELEVBQU03TyxHQUFHLENBQUNxRyxJQUFWLENBQVAsQ0FBdUJDLElBQXZCLENBQTRCek0sTUFBbEMsQ0FBaEI7QUFDRDs7QUFDRCxXQUFTb1gsU0FBVCxDQUFtQmpSLEdBQW5CLEVBQXdCa1IsT0FBeEIsRUFBaUM7QUFDL0IsUUFBSXpQLEVBQUUsR0FBR3pCLEdBQUcsQ0FBQ3lCLEVBQWI7O0FBQ0EsUUFBSUEsRUFBRSxJQUFJLElBQU4sSUFBY0EsRUFBRSxHQUFHeVAsT0FBdkIsRUFBZ0M7QUFBRSxhQUFPWCxHQUFHLENBQUN2USxHQUFHLENBQUNxRyxJQUFMLEVBQVc2SyxPQUFYLENBQVY7QUFBK0IsS0FBakUsTUFDSyxJQUFJelAsRUFBRSxHQUFHLENBQVQsRUFBWTtBQUFFLGFBQU84TyxHQUFHLENBQUN2USxHQUFHLENBQUNxRyxJQUFMLEVBQVcsQ0FBWCxDQUFWO0FBQXlCLEtBQXZDLE1BQ0E7QUFBRSxhQUFPckcsR0FBUDtBQUFZO0FBQ3BCOztBQUNELFdBQVNtUixZQUFULENBQXNCdEMsR0FBdEIsRUFBMkJ4UCxLQUEzQixFQUFrQztBQUNoQyxRQUFJc0IsR0FBRyxHQUFHLEVBQVY7O0FBQ0EsU0FBSyxJQUFJN0YsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VFLEtBQUssQ0FBQ3hGLE1BQTFCLEVBQWtDaUIsQ0FBQyxFQUFuQyxFQUF1QztBQUFFNkYsU0FBRyxDQUFDN0YsQ0FBRCxDQUFILEdBQVNpVyxRQUFPLENBQUNsQyxHQUFELEVBQU14UCxLQUFLLENBQUN2RSxDQUFELENBQVgsQ0FBaEI7QUFBa0M7O0FBQzNFLFdBQU82RixHQUFQO0FBQ0Q7O0FBRUQsTUFBSXlRLFlBQVksR0FBRyxTQUFmQSxZQUFlLENBQVM3RSxLQUFULEVBQWdCa0MsU0FBaEIsRUFBMkI7QUFDNUMsU0FBS2xDLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFNBQUtrQyxTQUFMLEdBQWlCQSxTQUFqQjtBQUNELEdBSEQ7O0FBS0EsTUFBSTRDLE9BQU8sR0FBRyxTQUFWQSxPQUFVLENBQVN4QyxHQUFULEVBQWN0QyxLQUFkLEVBQXFCbEcsSUFBckIsRUFBMkJvSSxTQUEzQixFQUFzQztBQUNsRCxTQUFLbEMsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBS3NDLEdBQUwsR0FBV0EsR0FBWDtBQUNBLFNBQUt4SSxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLaUwsWUFBTCxHQUFvQjdDLFNBQVMsSUFBSSxDQUFqQztBQUNBLFNBQUs4QyxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsU0FBS0MsWUFBTCxHQUFvQixDQUFwQjtBQUNELEdBUEQ7O0FBU0FILFNBQU8sQ0FBQzlULFNBQVIsQ0FBa0JrUixTQUFsQixHQUE4QixVQUFVbFEsQ0FBVixFQUFhO0FBQ3pDLFFBQUk4SCxJQUFJLEdBQUcsS0FBS3dJLEdBQUwsQ0FBU0QsT0FBVCxDQUFpQixLQUFLdkksSUFBTCxHQUFZOUgsQ0FBN0IsQ0FBWDs7QUFDQSxRQUFJOEgsSUFBSSxJQUFJLElBQVIsSUFBZ0I5SCxDQUFDLEdBQUcsS0FBSytTLFlBQTdCLEVBQTJDO0FBQUUsV0FBS0EsWUFBTCxHQUFvQi9TLENBQXBCO0FBQXdCOztBQUNyRSxXQUFPOEgsSUFBUDtBQUNELEdBSkQ7O0FBTUFnTCxTQUFPLENBQUM5VCxTQUFSLENBQWtCb1IsU0FBbEIsR0FBOEIsVUFBVXBRLENBQVYsRUFBYTtBQUN6QyxRQUFJLENBQUMsS0FBS2dULFVBQVYsRUFBc0I7QUFBRSxhQUFPLElBQVA7QUFBYTs7QUFDckMsV0FBTyxLQUFLQSxVQUFMLENBQWdCLEtBQUtDLFlBQXJCLEtBQXNDalQsQ0FBN0MsRUFDRTtBQUFFLFdBQUtpVCxZQUFMLElBQXFCLENBQXJCO0FBQXlCOztBQUM3QixRQUFJOU0sSUFBSSxHQUFHLEtBQUs2TSxVQUFMLENBQWdCLEtBQUtDLFlBQUwsR0FBb0IsQ0FBcEMsQ0FBWDtBQUNBLFdBQU87QUFBQzlNLFVBQUksRUFBRUEsSUFBSSxJQUFJQSxJQUFJLENBQUNRLE9BQUwsQ0FBYSxpQkFBYixFQUFnQyxFQUFoQyxDQUFmO0FBQ0M2SixVQUFJLEVBQUUsS0FBS3dDLFVBQUwsQ0FBZ0IsS0FBS0MsWUFBckIsSUFBcUNqVDtBQUQ1QyxLQUFQO0FBRUQsR0FQRDs7QUFTQThTLFNBQU8sQ0FBQzlULFNBQVIsQ0FBa0JrVSxRQUFsQixHQUE2QixZQUFZO0FBQ3ZDLFNBQUtwTCxJQUFMOztBQUNBLFFBQUksS0FBS2lMLFlBQUwsR0FBb0IsQ0FBeEIsRUFBMkI7QUFBRSxXQUFLQSxZQUFMO0FBQXNCO0FBQ3BELEdBSEQ7O0FBS0FELFNBQU8sQ0FBQ0ssU0FBUixHQUFvQixVQUFVN0MsR0FBVixFQUFlOEMsS0FBZixFQUFzQnRMLElBQXRCLEVBQTRCO0FBQzlDLFFBQUlzTCxLQUFLLFlBQVlQLFlBQXJCLEVBQ0U7QUFBRSxhQUFPLElBQUlDLE9BQUosQ0FBWXhDLEdBQVosRUFBaUJ2QyxTQUFTLENBQUN1QyxHQUFHLENBQUN4RCxJQUFMLEVBQVdzRyxLQUFLLENBQUNwRixLQUFqQixDQUExQixFQUFtRGxHLElBQW5ELEVBQXlEc0wsS0FBSyxDQUFDbEQsU0FBL0QsQ0FBUDtBQUFrRixLQUR0RixNQUdFO0FBQUUsYUFBTyxJQUFJNEMsT0FBSixDQUFZeEMsR0FBWixFQUFpQnZDLFNBQVMsQ0FBQ3VDLEdBQUcsQ0FBQ3hELElBQUwsRUFBV3NHLEtBQVgsQ0FBMUIsRUFBNkN0TCxJQUE3QyxDQUFQO0FBQTJEO0FBQ2hFLEdBTEQ7O0FBT0FnTCxTQUFPLENBQUM5VCxTQUFSLENBQWtCcVUsSUFBbEIsR0FBeUIsVUFBVUMsSUFBVixFQUFnQjtBQUN2QyxRQUFJdEYsS0FBSyxHQUFHc0YsSUFBSSxLQUFLLEtBQVQsR0FBaUJ2RixTQUFTLENBQUMsS0FBS3VDLEdBQUwsQ0FBU3hELElBQVYsRUFBZ0IsS0FBS2tCLEtBQXJCLENBQTFCLEdBQXdELEtBQUtBLEtBQXpFO0FBQ0EsV0FBTyxLQUFLK0UsWUFBTCxHQUFvQixDQUFwQixHQUF3QixJQUFJRixZQUFKLENBQWlCN0UsS0FBakIsRUFBd0IsS0FBSytFLFlBQTdCLENBQXhCLEdBQXFFL0UsS0FBNUU7QUFDRCxHQUhELENBbGhDbUIsQ0F3aENuQjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU3VGLGFBQVQsQ0FBdUJ6SyxFQUF2QixFQUEyQmhCLElBQTNCLEVBQWlDMEwsT0FBakMsRUFBMENDLFVBQTFDLEVBQXNEO0FBQ3BEO0FBQ0E7QUFDQSxRQUFJQyxFQUFFLEdBQUcsQ0FBQzVLLEVBQUUsQ0FBQ2tGLEtBQUgsQ0FBUzJGLE9BQVYsQ0FBVDtBQUFBLFFBQTZCQyxXQUFXLEdBQUcsRUFBM0MsQ0FIb0QsQ0FJcEQ7O0FBQ0FDLFdBQU8sQ0FBQy9LLEVBQUQsRUFBS2hCLElBQUksQ0FBQ0MsSUFBVixFQUFnQmUsRUFBRSxDQUFDd0gsR0FBSCxDQUFPeEQsSUFBdkIsRUFBNkIwRyxPQUE3QixFQUFzQyxVQUFVM1csR0FBVixFQUFlVixLQUFmLEVBQXNCO0FBQUUsYUFBT3VYLEVBQUUsQ0FBQzFSLElBQUgsQ0FBUW5GLEdBQVIsRUFBYVYsS0FBYixDQUFQO0FBQTZCLEtBQTNGLEVBQ0N5WCxXQURELEVBQ2NILFVBRGQsQ0FBUDtBQUVBLFFBQUl6RixLQUFLLEdBQUd3RixPQUFPLENBQUN4RixLQUFwQixDQVBvRCxDQVNwRDs7QUFDQSxRQUFJOEYsSUFBSSxHQUFHLFNBQVBBLElBQU8sQ0FBV0MsQ0FBWCxFQUFlO0FBQ3hCUCxhQUFPLENBQUNSLFVBQVIsR0FBcUJVLEVBQXJCO0FBQ0EsVUFBSU0sT0FBTyxHQUFHbEwsRUFBRSxDQUFDa0YsS0FBSCxDQUFTaUcsUUFBVCxDQUFrQkYsQ0FBbEIsQ0FBZDtBQUFBLFVBQW9DeFgsQ0FBQyxHQUFHLENBQXhDO0FBQUEsVUFBMkNnTCxFQUFFLEdBQUcsQ0FBaEQ7QUFDQWlNLGFBQU8sQ0FBQ3hGLEtBQVIsR0FBZ0IsSUFBaEI7QUFDQTZGLGFBQU8sQ0FBQy9LLEVBQUQsRUFBS2hCLElBQUksQ0FBQ0MsSUFBVixFQUFnQmlNLE9BQU8sQ0FBQ2xILElBQXhCLEVBQThCMEcsT0FBOUIsRUFBdUMsVUFBVTNXLEdBQVYsRUFBZVYsS0FBZixFQUFzQjtBQUNsRSxZQUFJUyxLQUFLLEdBQUdMLENBQVosQ0FEa0UsQ0FFbEU7O0FBQ0EsZUFBT2dMLEVBQUUsR0FBRzFLLEdBQVosRUFBaUI7QUFDZixjQUFJcVgsS0FBSyxHQUFHUixFQUFFLENBQUNuWCxDQUFELENBQWQ7O0FBQ0EsY0FBSTJYLEtBQUssR0FBR3JYLEdBQVosRUFDRTtBQUFFNlcsY0FBRSxDQUFDbFIsTUFBSCxDQUFVakcsQ0FBVixFQUFhLENBQWIsRUFBZ0JNLEdBQWhCLEVBQXFCNlcsRUFBRSxDQUFDblgsQ0FBQyxHQUFDLENBQUgsQ0FBdkIsRUFBOEIyWCxLQUE5QjtBQUF1Qzs7QUFDM0MzWCxXQUFDLElBQUksQ0FBTDtBQUNBZ0wsWUFBRSxHQUFHM0YsSUFBSSxDQUFDQyxHQUFMLENBQVNoRixHQUFULEVBQWNxWCxLQUFkLENBQUw7QUFDRDs7QUFDRCxZQUFJLENBQUMvWCxLQUFMLEVBQVk7QUFBRTtBQUFROztBQUN0QixZQUFJNlgsT0FBTyxDQUFDRyxNQUFaLEVBQW9CO0FBQ2xCVCxZQUFFLENBQUNsUixNQUFILENBQVU1RixLQUFWLEVBQWlCTCxDQUFDLEdBQUdLLEtBQXJCLEVBQTRCQyxHQUE1QixFQUFpQyxhQUFhVixLQUE5QztBQUNBSSxXQUFDLEdBQUdLLEtBQUssR0FBRyxDQUFaO0FBQ0QsU0FIRCxNQUdPO0FBQ0wsaUJBQU9BLEtBQUssR0FBR0wsQ0FBZixFQUFrQkssS0FBSyxJQUFJLENBQTNCLEVBQThCO0FBQzVCLGdCQUFJcUksR0FBRyxHQUFHeU8sRUFBRSxDQUFDOVcsS0FBSyxHQUFDLENBQVAsQ0FBWjtBQUNBOFcsY0FBRSxDQUFDOVcsS0FBSyxHQUFDLENBQVAsQ0FBRixHQUFjLENBQUNxSSxHQUFHLEdBQUdBLEdBQUcsR0FBRyxHQUFULEdBQWUsRUFBbkIsSUFBeUIsVUFBekIsR0FBc0M5SSxLQUFwRDtBQUNEO0FBQ0Y7QUFDRixPQXBCTSxFQW9CSnlYLFdBcEJJLENBQVA7QUFxQkFKLGFBQU8sQ0FBQ3hGLEtBQVIsR0FBZ0JBLEtBQWhCO0FBQ0F3RixhQUFPLENBQUNSLFVBQVIsR0FBcUIsSUFBckI7QUFDQVEsYUFBTyxDQUFDUCxZQUFSLEdBQXVCLENBQXZCO0FBQ0QsS0E1QkQ7O0FBOEJBLFNBQUssSUFBSWMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2pMLEVBQUUsQ0FBQ2tGLEtBQUgsQ0FBU2lHLFFBQVQsQ0FBa0IzWSxNQUF0QyxFQUE4QyxFQUFFeVksQ0FBaEQ7QUFBbURELFVBQUksQ0FBRUMsQ0FBRixDQUFKO0FBQW5EOztBQUVBLFdBQU87QUFBQ0ssWUFBTSxFQUFFVixFQUFUO0FBQWFXLGFBQU8sRUFBRVQsV0FBVyxDQUFDVSxPQUFaLElBQXVCVixXQUFXLENBQUNXLFNBQW5DLEdBQStDWCxXQUEvQyxHQUE2RDtBQUFuRixLQUFQO0FBQ0Q7O0FBRUQsV0FBU1ksYUFBVCxDQUF1QjFMLEVBQXZCLEVBQTJCaEIsSUFBM0IsRUFBaUMyTSxjQUFqQyxFQUFpRDtBQUMvQyxRQUFJLENBQUMzTSxJQUFJLENBQUNzTSxNQUFOLElBQWdCdE0sSUFBSSxDQUFDc00sTUFBTCxDQUFZLENBQVosS0FBa0J0TCxFQUFFLENBQUNrRixLQUFILENBQVMyRixPQUEvQyxFQUF3RDtBQUN0RCxVQUFJSCxPQUFPLEdBQUdrQixnQkFBZ0IsQ0FBQzVMLEVBQUQsRUFBS3VJLE1BQU0sQ0FBQ3ZKLElBQUQsQ0FBWCxDQUE5QjtBQUNBLFVBQUk2TSxVQUFVLEdBQUc3TSxJQUFJLENBQUNDLElBQUwsQ0FBVXpNLE1BQVYsR0FBbUJ3TixFQUFFLENBQUN1RSxPQUFILENBQVd1SCxrQkFBOUIsSUFBb0Q3RyxTQUFTLENBQUNqRixFQUFFLENBQUN3SCxHQUFILENBQU94RCxJQUFSLEVBQWMwRyxPQUFPLENBQUN4RixLQUF0QixDQUE5RTtBQUNBLFVBQUl6QyxNQUFNLEdBQUdnSSxhQUFhLENBQUN6SyxFQUFELEVBQUtoQixJQUFMLEVBQVcwTCxPQUFYLENBQTFCOztBQUNBLFVBQUltQixVQUFKLEVBQWdCO0FBQUVuQixlQUFPLENBQUN4RixLQUFSLEdBQWdCMkcsVUFBaEI7QUFBNkI7O0FBQy9DN00sVUFBSSxDQUFDK00sVUFBTCxHQUFrQnJCLE9BQU8sQ0FBQ0gsSUFBUixDQUFhLENBQUNzQixVQUFkLENBQWxCO0FBQ0E3TSxVQUFJLENBQUNzTSxNQUFMLEdBQWM3SSxNQUFNLENBQUM2SSxNQUFyQjs7QUFDQSxVQUFJN0ksTUFBTSxDQUFDOEksT0FBWCxFQUFvQjtBQUFFdk0sWUFBSSxDQUFDZ04sWUFBTCxHQUFvQnZKLE1BQU0sQ0FBQzhJLE9BQTNCO0FBQXFDLE9BQTNELE1BQ0ssSUFBSXZNLElBQUksQ0FBQ2dOLFlBQVQsRUFBdUI7QUFBRWhOLFlBQUksQ0FBQ2dOLFlBQUwsR0FBb0IsSUFBcEI7QUFBMkI7O0FBQ3pELFVBQUlMLGNBQWMsS0FBSzNMLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT3lFLGlCQUE5QixFQUNFO0FBQUVqTSxVQUFFLENBQUN3SCxHQUFILENBQU8wRSxZQUFQLEdBQXNCcFQsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTa0UsRUFBRSxDQUFDd0gsR0FBSCxDQUFPMEUsWUFBaEIsRUFBOEIsRUFBRWxNLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT3lFLGlCQUF2QyxDQUF0QjtBQUFrRjtBQUN2Rjs7QUFDRCxXQUFPak4sSUFBSSxDQUFDc00sTUFBWjtBQUNEOztBQUVELFdBQVNNLGdCQUFULENBQTBCNUwsRUFBMUIsRUFBOEI5SSxDQUE5QixFQUFpQ2lWLE9BQWpDLEVBQTBDO0FBQ3hDLFFBQUkzRSxHQUFHLEdBQUd4SCxFQUFFLENBQUN3SCxHQUFiO0FBQUEsUUFBa0I0RSxPQUFPLEdBQUdwTSxFQUFFLENBQUNvTSxPQUEvQjs7QUFDQSxRQUFJLENBQUM1RSxHQUFHLENBQUN4RCxJQUFKLENBQVN1QixVQUFkLEVBQTBCO0FBQUUsYUFBTyxJQUFJeUUsT0FBSixDQUFZeEMsR0FBWixFQUFpQixJQUFqQixFQUF1QnRRLENBQXZCLENBQVA7QUFBa0M7O0FBQzlELFFBQUlwRCxLQUFLLEdBQUd1WSxhQUFhLENBQUNyTSxFQUFELEVBQUs5SSxDQUFMLEVBQVFpVixPQUFSLENBQXpCO0FBQ0EsUUFBSTdCLEtBQUssR0FBR3hXLEtBQUssR0FBRzBULEdBQUcsQ0FBQ0MsS0FBWixJQUFxQkYsT0FBTyxDQUFDQyxHQUFELEVBQU0xVCxLQUFLLEdBQUcsQ0FBZCxDQUFQLENBQXdCaVksVUFBekQ7QUFDQSxRQUFJckIsT0FBTyxHQUFHSixLQUFLLEdBQUdOLE9BQU8sQ0FBQ0ssU0FBUixDQUFrQjdDLEdBQWxCLEVBQXVCOEMsS0FBdkIsRUFBOEJ4VyxLQUE5QixDQUFILEdBQTBDLElBQUlrVyxPQUFKLENBQVl4QyxHQUFaLEVBQWlCakMsVUFBVSxDQUFDaUMsR0FBRyxDQUFDeEQsSUFBTCxDQUEzQixFQUF1Q2xRLEtBQXZDLENBQTdEO0FBRUEwVCxPQUFHLENBQUNVLElBQUosQ0FBU3BVLEtBQVQsRUFBZ0JvRCxDQUFoQixFQUFtQixVQUFVOEgsSUFBVixFQUFnQjtBQUNqQ3NOLGlCQUFXLENBQUN0TSxFQUFELEVBQUtoQixJQUFJLENBQUNDLElBQVYsRUFBZ0J5TCxPQUFoQixDQUFYO0FBQ0EsVUFBSS9SLEdBQUcsR0FBRytSLE9BQU8sQ0FBQzFMLElBQWxCO0FBQ0FBLFVBQUksQ0FBQytNLFVBQUwsR0FBa0JwVCxHQUFHLElBQUl6QixDQUFDLEdBQUcsQ0FBWCxJQUFnQnlCLEdBQUcsR0FBRyxDQUFOLElBQVcsQ0FBM0IsSUFBZ0NBLEdBQUcsSUFBSXlULE9BQU8sQ0FBQ0csUUFBZixJQUEyQjVULEdBQUcsR0FBR3lULE9BQU8sQ0FBQ0ksTUFBekUsR0FBa0Y5QixPQUFPLENBQUNILElBQVIsRUFBbEYsR0FBbUcsSUFBckg7QUFDQUcsYUFBTyxDQUFDTixRQUFSO0FBQ0QsS0FMRDs7QUFNQSxRQUFJK0IsT0FBSixFQUFhO0FBQUUzRSxTQUFHLENBQUMwRSxZQUFKLEdBQW1CeEIsT0FBTyxDQUFDMUwsSUFBM0I7QUFBa0M7O0FBQ2pELFdBQU8wTCxPQUFQO0FBQ0QsR0F4bUNrQixDQTBtQ25CO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBUzRCLFdBQVQsQ0FBcUJ0TSxFQUFyQixFQUF5QmYsSUFBekIsRUFBK0J5TCxPQUEvQixFQUF3QytCLE9BQXhDLEVBQWlEO0FBQy9DLFFBQUl6SSxJQUFJLEdBQUdoRSxFQUFFLENBQUN3SCxHQUFILENBQU94RCxJQUFsQjtBQUNBLFFBQUkwSSxNQUFNLEdBQUcsSUFBSWhILFlBQUosQ0FBaUJ6RyxJQUFqQixFQUF1QmUsRUFBRSxDQUFDdUUsT0FBSCxDQUFXek4sT0FBbEMsRUFBMkM0VCxPQUEzQyxDQUFiO0FBQ0FnQyxVQUFNLENBQUM1WSxLQUFQLEdBQWU0WSxNQUFNLENBQUMvVCxHQUFQLEdBQWE4VCxPQUFPLElBQUksQ0FBdkM7O0FBQ0EsUUFBSXhOLElBQUksSUFBSSxFQUFaLEVBQWdCO0FBQUUwTixtQkFBYSxDQUFDM0ksSUFBRCxFQUFPMEcsT0FBTyxDQUFDeEYsS0FBZixDQUFiO0FBQXFDOztBQUN2RCxXQUFPLENBQUN3SCxNQUFNLENBQUMzRyxHQUFQLEVBQVIsRUFBc0I7QUFDcEI2RyxlQUFTLENBQUM1SSxJQUFELEVBQU8wSSxNQUFQLEVBQWVoQyxPQUFPLENBQUN4RixLQUF2QixDQUFUO0FBQ0F3SCxZQUFNLENBQUM1WSxLQUFQLEdBQWU0WSxNQUFNLENBQUMvVCxHQUF0QjtBQUNEO0FBQ0Y7O0FBRUQsV0FBU2dVLGFBQVQsQ0FBdUIzSSxJQUF2QixFQUE2QmtCLEtBQTdCLEVBQW9DO0FBQ2xDLFFBQUlsQixJQUFJLENBQUM2SSxTQUFULEVBQW9CO0FBQUUsYUFBTzdJLElBQUksQ0FBQzZJLFNBQUwsQ0FBZTNILEtBQWYsQ0FBUDtBQUE4Qjs7QUFDcEQsUUFBSSxDQUFDbEIsSUFBSSxDQUFDcUIsU0FBVixFQUFxQjtBQUFFO0FBQVE7O0FBQy9CLFFBQUk4QixLQUFLLEdBQUc5QixTQUFTLENBQUNyQixJQUFELEVBQU9rQixLQUFQLENBQXJCOztBQUNBLFFBQUlpQyxLQUFLLENBQUNuRCxJQUFOLENBQVc2SSxTQUFmLEVBQTBCO0FBQUUsYUFBTzFGLEtBQUssQ0FBQ25ELElBQU4sQ0FBVzZJLFNBQVgsQ0FBcUIxRixLQUFLLENBQUNqQyxLQUEzQixDQUFQO0FBQTBDO0FBQ3ZFOztBQUVELFdBQVMwSCxTQUFULENBQW1CNUksSUFBbkIsRUFBeUIwSSxNQUF6QixFQUFpQ3hILEtBQWpDLEVBQXdDaUMsS0FBeEMsRUFBK0M7QUFDN0MsU0FBSyxJQUFJMVQsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxFQUFwQixFQUF3QkEsQ0FBQyxFQUF6QixFQUE2QjtBQUMzQixVQUFJMFQsS0FBSixFQUFXO0FBQUVBLGFBQUssQ0FBQyxDQUFELENBQUwsR0FBVzlCLFNBQVMsQ0FBQ3JCLElBQUQsRUFBT2tCLEtBQVAsQ0FBVCxDQUF1QmxCLElBQWxDO0FBQXlDOztBQUN0RCxVQUFJM1EsS0FBSyxHQUFHMlEsSUFBSSxDQUFDOEksS0FBTCxDQUFXSixNQUFYLEVBQW1CeEgsS0FBbkIsQ0FBWjs7QUFDQSxVQUFJd0gsTUFBTSxDQUFDL1QsR0FBUCxHQUFhK1QsTUFBTSxDQUFDNVksS0FBeEIsRUFBK0I7QUFBRSxlQUFPVCxLQUFQO0FBQWM7QUFDaEQ7O0FBQ0QsVUFBTSxJQUFJc1UsS0FBSixDQUFVLFVBQVUzRCxJQUFJLENBQUNELElBQWYsR0FBc0IsNEJBQWhDLENBQU47QUFDRDs7QUFFRCxNQUFJZ0osS0FBSyxHQUFHLFNBQVJBLEtBQVEsQ0FBU0wsTUFBVCxFQUFpQnJQLElBQWpCLEVBQXVCNkgsS0FBdkIsRUFBOEI7QUFDeEMsU0FBS3BSLEtBQUwsR0FBYTRZLE1BQU0sQ0FBQzVZLEtBQXBCO0FBQTJCLFNBQUtDLEdBQUwsR0FBVzJZLE1BQU0sQ0FBQy9ULEdBQWxCO0FBQzNCLFNBQUs5QixNQUFMLEdBQWM2VixNQUFNLENBQUN2YSxPQUFQLEVBQWQ7QUFDQSxTQUFLa0wsSUFBTCxHQUFZQSxJQUFJLElBQUksSUFBcEI7QUFDQSxTQUFLNkgsS0FBTCxHQUFhQSxLQUFiO0FBQ0QsR0FMRCxDQXhvQ21CLENBK29DbkI7OztBQUNBLFdBQVM4SCxTQUFULENBQW1CaE4sRUFBbkIsRUFBdUJySCxHQUF2QixFQUE0QndULE9BQTVCLEVBQXFDYyxPQUFyQyxFQUE4QztBQUM1QyxRQUFJekYsR0FBRyxHQUFHeEgsRUFBRSxDQUFDd0gsR0FBYjtBQUFBLFFBQWtCeEQsSUFBSSxHQUFHd0QsR0FBRyxDQUFDeEQsSUFBN0I7QUFBQSxRQUFtQzNRLEtBQW5DO0FBQ0FzRixPQUFHLEdBQUcrUSxRQUFPLENBQUNsQyxHQUFELEVBQU03TyxHQUFOLENBQWI7QUFDQSxRQUFJcUcsSUFBSSxHQUFHdUksT0FBTyxDQUFDQyxHQUFELEVBQU03TyxHQUFHLENBQUNxRyxJQUFWLENBQWxCO0FBQUEsUUFBbUMwTCxPQUFPLEdBQUdrQixnQkFBZ0IsQ0FBQzVMLEVBQUQsRUFBS3JILEdBQUcsQ0FBQ3FHLElBQVQsRUFBZW1OLE9BQWYsQ0FBN0Q7QUFDQSxRQUFJTyxNQUFNLEdBQUcsSUFBSWhILFlBQUosQ0FBaUIxRyxJQUFJLENBQUNDLElBQXRCLEVBQTRCZSxFQUFFLENBQUN1RSxPQUFILENBQVd6TixPQUF2QyxFQUFnRDRULE9BQWhELENBQWI7QUFBQSxRQUF1RXdDLE1BQXZFOztBQUNBLFFBQUlELE9BQUosRUFBYTtBQUFFQyxZQUFNLEdBQUcsRUFBVDtBQUFjOztBQUM3QixXQUFPLENBQUNELE9BQU8sSUFBSVAsTUFBTSxDQUFDL1QsR0FBUCxHQUFhQSxHQUFHLENBQUN5QixFQUE3QixLQUFvQyxDQUFDc1MsTUFBTSxDQUFDM0csR0FBUCxFQUE1QyxFQUEwRDtBQUN4RDJHLFlBQU0sQ0FBQzVZLEtBQVAsR0FBZTRZLE1BQU0sQ0FBQy9ULEdBQXRCO0FBQ0F0RixXQUFLLEdBQUd1WixTQUFTLENBQUM1SSxJQUFELEVBQU8wSSxNQUFQLEVBQWVoQyxPQUFPLENBQUN4RixLQUF2QixDQUFqQjs7QUFDQSxVQUFJK0gsT0FBSixFQUFhO0FBQUVDLGNBQU0sQ0FBQ2hVLElBQVAsQ0FBWSxJQUFJNlQsS0FBSixDQUFVTCxNQUFWLEVBQWtCclosS0FBbEIsRUFBeUI0UixTQUFTLENBQUN1QyxHQUFHLENBQUN4RCxJQUFMLEVBQVcwRyxPQUFPLENBQUN4RixLQUFuQixDQUFsQyxDQUFaO0FBQTRFO0FBQzVGOztBQUNELFdBQU8rSCxPQUFPLEdBQUdDLE1BQUgsR0FBWSxJQUFJSCxLQUFKLENBQVVMLE1BQVYsRUFBa0JyWixLQUFsQixFQUF5QnFYLE9BQU8sQ0FBQ3hGLEtBQWpDLENBQTFCO0FBQ0Q7O0FBRUQsV0FBU2lJLGtCQUFULENBQTRCOVAsSUFBNUIsRUFBa0MrUCxNQUFsQyxFQUEwQztBQUN4QyxRQUFJL1AsSUFBSixFQUFVO0FBQUUsZUFBUztBQUNuQixZQUFJZ1EsU0FBUyxHQUFHaFEsSUFBSSxDQUFDM0wsS0FBTCxDQUFXLG1DQUFYLENBQWhCOztBQUNBLFlBQUksQ0FBQzJiLFNBQUwsRUFBZ0I7QUFBRTtBQUFPOztBQUN6QmhRLFlBQUksR0FBR0EsSUFBSSxDQUFDL0ssS0FBTCxDQUFXLENBQVgsRUFBYythLFNBQVMsQ0FBQzlhLEtBQXhCLElBQWlDOEssSUFBSSxDQUFDL0ssS0FBTCxDQUFXK2EsU0FBUyxDQUFDOWEsS0FBVixHQUFrQjhhLFNBQVMsQ0FBQyxDQUFELENBQVQsQ0FBYTdhLE1BQTFDLENBQXhDO0FBQ0EsWUFBSWtFLElBQUksR0FBRzJXLFNBQVMsQ0FBQyxDQUFELENBQVQsR0FBZSxTQUFmLEdBQTJCLFdBQXRDOztBQUNBLFlBQUlELE1BQU0sQ0FBQzFXLElBQUQsQ0FBTixJQUFnQixJQUFwQixFQUNFO0FBQUUwVyxnQkFBTSxDQUFDMVcsSUFBRCxDQUFOLEdBQWUyVyxTQUFTLENBQUMsQ0FBRCxDQUF4QjtBQUE4QixTQURsQyxNQUVLLElBQUksQ0FBRSxJQUFJcmIsTUFBSixDQUFXLGNBQWNxYixTQUFTLENBQUMsQ0FBRCxDQUF2QixHQUE2QixXQUF4QyxDQUFELENBQXVEcGQsSUFBdkQsQ0FBNERtZCxNQUFNLENBQUMxVyxJQUFELENBQWxFLENBQUwsRUFDSDtBQUFFMFcsZ0JBQU0sQ0FBQzFXLElBQUQsQ0FBTixJQUFnQixNQUFNMlcsU0FBUyxDQUFDLENBQUQsQ0FBL0I7QUFBcUM7QUFDMUM7QUFBRTs7QUFDSCxXQUFPaFEsSUFBUDtBQUNELEdBMXFDa0IsQ0E0cUNuQjs7O0FBQ0EsV0FBUzBOLE9BQVQsQ0FBaUIvSyxFQUFqQixFQUFxQmYsSUFBckIsRUFBMkIrRSxJQUEzQixFQUFpQzBHLE9BQWpDLEVBQTBDM1UsQ0FBMUMsRUFBNkMrVSxXQUE3QyxFQUEwREgsVUFBMUQsRUFBc0U7QUFDcEUsUUFBSTJDLFlBQVksR0FBR3RKLElBQUksQ0FBQ3NKLFlBQXhCOztBQUNBLFFBQUlBLFlBQVksSUFBSSxJQUFwQixFQUEwQjtBQUFFQSxrQkFBWSxHQUFHdE4sRUFBRSxDQUFDdUUsT0FBSCxDQUFXK0ksWUFBMUI7QUFBeUM7O0FBQ3JFLFFBQUlDLFFBQVEsR0FBRyxDQUFmO0FBQUEsUUFBa0JDLFFBQVEsR0FBRyxJQUE3QjtBQUNBLFFBQUlkLE1BQU0sR0FBRyxJQUFJaEgsWUFBSixDQUFpQnpHLElBQWpCLEVBQXVCZSxFQUFFLENBQUN1RSxPQUFILENBQVd6TixPQUFsQyxFQUEyQzRULE9BQTNDLENBQWI7QUFBQSxRQUFrRXJYLEtBQWxFO0FBQ0EsUUFBSThULEtBQUssR0FBR25ILEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBV2tKLFlBQVgsSUFBMkIsQ0FBQyxJQUFELENBQXZDOztBQUNBLFFBQUl4TyxJQUFJLElBQUksRUFBWixFQUFnQjtBQUFFa08sd0JBQWtCLENBQUNSLGFBQWEsQ0FBQzNJLElBQUQsRUFBTzBHLE9BQU8sQ0FBQ3hGLEtBQWYsQ0FBZCxFQUFxQzRGLFdBQXJDLENBQWxCO0FBQXNFOztBQUN4RixXQUFPLENBQUM0QixNQUFNLENBQUMzRyxHQUFQLEVBQVIsRUFBc0I7QUFDcEIsVUFBSTJHLE1BQU0sQ0FBQy9ULEdBQVAsR0FBYXFILEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBV3VILGtCQUE1QixFQUFnRDtBQUM5Q3dCLG9CQUFZLEdBQUcsS0FBZjs7QUFDQSxZQUFJM0MsVUFBSixFQUFnQjtBQUFFMkIscUJBQVcsQ0FBQ3RNLEVBQUQsRUFBS2YsSUFBTCxFQUFXeUwsT0FBWCxFQUFvQmdDLE1BQU0sQ0FBQy9ULEdBQTNCLENBQVg7QUFBNkM7O0FBQy9EK1QsY0FBTSxDQUFDL1QsR0FBUCxHQUFhc0csSUFBSSxDQUFDek0sTUFBbEI7QUFDQWEsYUFBSyxHQUFHLElBQVI7QUFDRCxPQUxELE1BS087QUFDTEEsYUFBSyxHQUFHOFosa0JBQWtCLENBQUNQLFNBQVMsQ0FBQzVJLElBQUQsRUFBTzBJLE1BQVAsRUFBZWhDLE9BQU8sQ0FBQ3hGLEtBQXZCLEVBQThCaUMsS0FBOUIsQ0FBVixFQUFnRDJELFdBQWhELENBQTFCO0FBQ0Q7O0FBQ0QsVUFBSTNELEtBQUosRUFBVztBQUNULFlBQUl1RyxLQUFLLEdBQUd2RyxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNwRCxJQUFyQjs7QUFDQSxZQUFJMkosS0FBSixFQUFXO0FBQUVyYSxlQUFLLEdBQUcsUUFBUUEsS0FBSyxHQUFHcWEsS0FBSyxHQUFHLEdBQVIsR0FBY3JhLEtBQWpCLEdBQXlCcWEsS0FBdEMsQ0FBUjtBQUF1RDtBQUNyRTs7QUFDRCxVQUFJLENBQUNKLFlBQUQsSUFBaUJFLFFBQVEsSUFBSW5hLEtBQWpDLEVBQXdDO0FBQ3RDLGVBQU9rYSxRQUFRLEdBQUdiLE1BQU0sQ0FBQzVZLEtBQXpCLEVBQWdDO0FBQzlCeVosa0JBQVEsR0FBR3pVLElBQUksQ0FBQ0MsR0FBTCxDQUFTMlQsTUFBTSxDQUFDNVksS0FBaEIsRUFBdUJ5WixRQUFRLEdBQUcsSUFBbEMsQ0FBWDtBQUNBeFgsV0FBQyxDQUFDd1gsUUFBRCxFQUFXQyxRQUFYLENBQUQ7QUFDRDs7QUFDREEsZ0JBQVEsR0FBR25hLEtBQVg7QUFDRDs7QUFDRHFaLFlBQU0sQ0FBQzVZLEtBQVAsR0FBZTRZLE1BQU0sQ0FBQy9ULEdBQXRCO0FBQ0Q7O0FBQ0QsV0FBTzRVLFFBQVEsR0FBR2IsTUFBTSxDQUFDL1QsR0FBekIsRUFBOEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsVUFBSUEsR0FBRyxHQUFHRyxJQUFJLENBQUNDLEdBQUwsQ0FBUzJULE1BQU0sQ0FBQy9ULEdBQWhCLEVBQXFCNFUsUUFBUSxHQUFHLElBQWhDLENBQVY7QUFDQXhYLE9BQUMsQ0FBQzRDLEdBQUQsRUFBTTZVLFFBQU4sQ0FBRDtBQUNBRCxjQUFRLEdBQUc1VSxHQUFYO0FBQ0Q7QUFDRixHQWx0Q2tCLENBb3RDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBUzBULGFBQVQsQ0FBdUJyTSxFQUF2QixFQUEyQjlJLENBQTNCLEVBQThCaVYsT0FBOUIsRUFBdUM7QUFDckMsUUFBSXdCLFNBQUo7QUFBQSxRQUFlQyxPQUFmO0FBQUEsUUFBd0JwRyxHQUFHLEdBQUd4SCxFQUFFLENBQUN3SCxHQUFqQztBQUNBLFFBQUlxRyxHQUFHLEdBQUcxQixPQUFPLEdBQUcsQ0FBQyxDQUFKLEdBQVFqVixDQUFDLElBQUk4SSxFQUFFLENBQUN3SCxHQUFILENBQU94RCxJQUFQLENBQVlxQixTQUFaLEdBQXdCLElBQXhCLEdBQStCLEdBQW5DLENBQTFCOztBQUNBLFNBQUssSUFBSXBPLE1BQU0sR0FBR0MsQ0FBbEIsRUFBcUJELE1BQU0sR0FBRzRXLEdBQTlCLEVBQW1DLEVBQUU1VyxNQUFyQyxFQUE2QztBQUMzQyxVQUFJQSxNQUFNLElBQUl1USxHQUFHLENBQUNDLEtBQWxCLEVBQXlCO0FBQUUsZUFBT0QsR0FBRyxDQUFDQyxLQUFYO0FBQWtCOztBQUM3QyxVQUFJekksSUFBSSxHQUFHdUksT0FBTyxDQUFDQyxHQUFELEVBQU12USxNQUFNLEdBQUcsQ0FBZixDQUFsQjtBQUFBLFVBQXFDNUUsS0FBSyxHQUFHMk0sSUFBSSxDQUFDK00sVUFBbEQ7O0FBQ0EsVUFBSTFaLEtBQUssS0FBSyxDQUFDOFosT0FBRCxJQUFZbFYsTUFBTSxJQUFJNUUsS0FBSyxZQUFZMFgsWUFBakIsR0FBZ0MxWCxLQUFLLENBQUMrVSxTQUF0QyxHQUFrRCxDQUF0RCxDQUFOLElBQWtFSSxHQUFHLENBQUMwRSxZQUF2RixDQUFULEVBQ0U7QUFBRSxlQUFPalYsTUFBUDtBQUFlOztBQUNuQixVQUFJNlcsUUFBUSxHQUFHbFgsV0FBVyxDQUFDb0ksSUFBSSxDQUFDQyxJQUFOLEVBQVksSUFBWixFQUFrQmUsRUFBRSxDQUFDdUUsT0FBSCxDQUFXek4sT0FBN0IsQ0FBMUI7O0FBQ0EsVUFBSThXLE9BQU8sSUFBSSxJQUFYLElBQW1CRCxTQUFTLEdBQUdHLFFBQW5DLEVBQTZDO0FBQzNDRixlQUFPLEdBQUczVyxNQUFNLEdBQUcsQ0FBbkI7QUFDQTBXLGlCQUFTLEdBQUdHLFFBQVo7QUFDRDtBQUNGOztBQUNELFdBQU9GLE9BQVA7QUFDRDs7QUFFRCxXQUFTRyxlQUFULENBQXlCdkcsR0FBekIsRUFBOEJ0USxDQUE5QixFQUFpQztBQUMvQnNRLE9BQUcsQ0FBQzBFLFlBQUosR0FBbUJwVCxJQUFJLENBQUNDLEdBQUwsQ0FBU3lPLEdBQUcsQ0FBQzBFLFlBQWIsRUFBMkJoVixDQUEzQixDQUFuQjs7QUFDQSxRQUFJc1EsR0FBRyxDQUFDeUUsaUJBQUosR0FBd0IvVSxDQUFDLEdBQUcsRUFBaEMsRUFBb0M7QUFBRTtBQUFROztBQUM5QyxRQUFJcEQsS0FBSyxHQUFHMFQsR0FBRyxDQUFDQyxLQUFoQjs7QUFDQSxTQUFLLElBQUl6SSxJQUFJLEdBQUc5SCxDQUFDLEdBQUcsQ0FBcEIsRUFBdUI4SCxJQUFJLEdBQUdsTCxLQUE5QixFQUFxQ2tMLElBQUksRUFBekMsRUFBNkM7QUFDM0MsVUFBSXNMLEtBQUssR0FBRy9DLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNeEksSUFBTixDQUFQLENBQW1CK00sVUFBL0IsQ0FEMkMsQ0FFM0M7QUFDQTtBQUNBOztBQUNBLFVBQUl6QixLQUFLLEtBQUssRUFBRUEsS0FBSyxZQUFZUCxZQUFuQixLQUFvQy9LLElBQUksR0FBR3NMLEtBQUssQ0FBQ2xELFNBQWIsR0FBeUJsUSxDQUFsRSxDQUFULEVBQStFO0FBQzdFcEQsYUFBSyxHQUFHa0wsSUFBSSxHQUFHLENBQWY7QUFDQTtBQUNEO0FBQ0Y7O0FBQ0R3SSxPQUFHLENBQUN5RSxpQkFBSixHQUF3Qm5ULElBQUksQ0FBQ0MsR0FBTCxDQUFTeU8sR0FBRyxDQUFDeUUsaUJBQWIsRUFBZ0NuWSxLQUFoQyxDQUF4QjtBQUNELEdBenZDa0IsQ0EydkNuQjs7O0FBQ0EsTUFBSWthLGdCQUFnQixHQUFHLEtBQXZCO0FBQUEsTUFBOEJDLGlCQUFpQixHQUFHLEtBQWxEOztBQUVBLFdBQVNDLGdCQUFULEdBQTRCO0FBQzFCRixvQkFBZ0IsR0FBRyxJQUFuQjtBQUNEOztBQUVELFdBQVNHLGlCQUFULEdBQTZCO0FBQzNCRixxQkFBaUIsR0FBRyxJQUFwQjtBQUNELEdBcHdDa0IsQ0Fzd0NuQjs7O0FBRUEsV0FBU0csVUFBVCxDQUFvQkMsTUFBcEIsRUFBNEJqVCxJQUE1QixFQUFrQ0MsRUFBbEMsRUFBc0M7QUFDcEMsU0FBS2dULE1BQUwsR0FBY0EsTUFBZDtBQUNBLFNBQUtqVCxJQUFMLEdBQVlBLElBQVo7QUFBa0IsU0FBS0MsRUFBTCxHQUFVQSxFQUFWO0FBQ25CLEdBM3dDa0IsQ0E2d0NuQjs7O0FBQ0EsV0FBU2lULGdCQUFULENBQTBCQyxLQUExQixFQUFpQ0YsTUFBakMsRUFBeUM7QUFDdkMsUUFBSUUsS0FBSixFQUFXO0FBQUUsV0FBSyxJQUFJOWEsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzhhLEtBQUssQ0FBQy9iLE1BQTFCLEVBQWtDLEVBQUVpQixDQUFwQyxFQUF1QztBQUNsRCxZQUFJK2EsSUFBSSxHQUFHRCxLQUFLLENBQUM5YSxDQUFELENBQWhCOztBQUNBLFlBQUkrYSxJQUFJLENBQUNILE1BQUwsSUFBZUEsTUFBbkIsRUFBMkI7QUFBRSxpQkFBT0csSUFBUDtBQUFhO0FBQzNDO0FBQUU7QUFDSixHQW54Q2tCLENBb3hDbkI7QUFDQTs7O0FBQ0EsV0FBU0MsZ0JBQVQsQ0FBMEJGLEtBQTFCLEVBQWlDQyxJQUFqQyxFQUF1QztBQUNyQyxRQUFJdmEsQ0FBSjs7QUFDQSxTQUFLLElBQUlSLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc4YSxLQUFLLENBQUMvYixNQUExQixFQUFrQyxFQUFFaUIsQ0FBcEMsRUFDRTtBQUFFLFVBQUk4YSxLQUFLLENBQUM5YSxDQUFELENBQUwsSUFBWSthLElBQWhCLEVBQXNCO0FBQUUsU0FBQ3ZhLENBQUMsS0FBS0EsQ0FBQyxHQUFHLEVBQVQsQ0FBRixFQUFnQmlGLElBQWhCLENBQXFCcVYsS0FBSyxDQUFDOWEsQ0FBRCxDQUExQjtBQUFpQztBQUFFOztBQUMvRCxXQUFPUSxDQUFQO0FBQ0QsR0EzeENrQixDQTR4Q25COzs7QUFDQSxXQUFTeWEsYUFBVCxDQUF1QjFQLElBQXZCLEVBQTZCd1AsSUFBN0IsRUFBbUM7QUFDakN4UCxRQUFJLENBQUMyUCxXQUFMLEdBQW1CM1AsSUFBSSxDQUFDMlAsV0FBTCxHQUFtQjNQLElBQUksQ0FBQzJQLFdBQUwsQ0FBaUJuUCxNQUFqQixDQUF3QixDQUFDZ1AsSUFBRCxDQUF4QixDQUFuQixHQUFxRCxDQUFDQSxJQUFELENBQXhFO0FBQ0FBLFFBQUksQ0FBQ0gsTUFBTCxDQUFZTyxVQUFaLENBQXVCNVAsSUFBdkI7QUFDRCxHQWh5Q2tCLENBa3lDbkI7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFdBQVM2UCxpQkFBVCxDQUEyQkMsR0FBM0IsRUFBZ0NDLE9BQWhDLEVBQXlDQyxRQUF6QyxFQUFtRDtBQUNqRCxRQUFJQyxFQUFKOztBQUNBLFFBQUlILEdBQUosRUFBUztBQUFFLFdBQUssSUFBSXJiLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxYixHQUFHLENBQUN0YyxNQUF4QixFQUFnQyxFQUFFaUIsQ0FBbEMsRUFBcUM7QUFDOUMsWUFBSSthLElBQUksR0FBR00sR0FBRyxDQUFDcmIsQ0FBRCxDQUFkO0FBQUEsWUFBbUI0YSxNQUFNLEdBQUdHLElBQUksQ0FBQ0gsTUFBakM7QUFDQSxZQUFJYSxZQUFZLEdBQUdWLElBQUksQ0FBQ3BULElBQUwsSUFBYSxJQUFiLEtBQXNCaVQsTUFBTSxDQUFDYyxhQUFQLEdBQXVCWCxJQUFJLENBQUNwVCxJQUFMLElBQWEyVCxPQUFwQyxHQUE4Q1AsSUFBSSxDQUFDcFQsSUFBTCxHQUFZMlQsT0FBaEYsQ0FBbkI7O0FBQ0EsWUFBSUcsWUFBWSxJQUFJVixJQUFJLENBQUNwVCxJQUFMLElBQWEyVCxPQUFiLElBQXdCVixNQUFNLENBQUNoUixJQUFQLElBQWUsVUFBdkMsS0FBc0QsQ0FBQzJSLFFBQUQsSUFBYSxDQUFDUixJQUFJLENBQUNILE1BQUwsQ0FBWWUsVUFBaEYsQ0FBcEIsRUFBaUg7QUFDL0csY0FBSUMsU0FBUyxHQUFHYixJQUFJLENBQUNuVCxFQUFMLElBQVcsSUFBWCxLQUFvQmdULE1BQU0sQ0FBQ2lCLGNBQVAsR0FBd0JkLElBQUksQ0FBQ25ULEVBQUwsSUFBVzBULE9BQW5DLEdBQTZDUCxJQUFJLENBQUNuVCxFQUFMLEdBQVUwVCxPQUEzRSxDQUFoQjtBQUNDLFdBQUNFLEVBQUUsS0FBS0EsRUFBRSxHQUFHLEVBQVYsQ0FBSCxFQUFrQi9WLElBQWxCLENBQXVCLElBQUlrVixVQUFKLENBQWVDLE1BQWYsRUFBdUJHLElBQUksQ0FBQ3BULElBQTVCLEVBQWtDaVUsU0FBUyxHQUFHLElBQUgsR0FBVWIsSUFBSSxDQUFDblQsRUFBMUQsQ0FBdkI7QUFDRjtBQUNGO0FBQUU7O0FBQ0gsV0FBTzRULEVBQVA7QUFDRDs7QUFDRCxXQUFTTSxnQkFBVCxDQUEwQlQsR0FBMUIsRUFBK0JVLEtBQS9CLEVBQXNDUixRQUF0QyxFQUFnRDtBQUM5QyxRQUFJQyxFQUFKOztBQUNBLFFBQUlILEdBQUosRUFBUztBQUFFLFdBQUssSUFBSXJiLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxYixHQUFHLENBQUN0YyxNQUF4QixFQUFnQyxFQUFFaUIsQ0FBbEMsRUFBcUM7QUFDOUMsWUFBSSthLElBQUksR0FBR00sR0FBRyxDQUFDcmIsQ0FBRCxDQUFkO0FBQUEsWUFBbUI0YSxNQUFNLEdBQUdHLElBQUksQ0FBQ0gsTUFBakM7QUFDQSxZQUFJZ0IsU0FBUyxHQUFHYixJQUFJLENBQUNuVCxFQUFMLElBQVcsSUFBWCxLQUFvQmdULE1BQU0sQ0FBQ2lCLGNBQVAsR0FBd0JkLElBQUksQ0FBQ25ULEVBQUwsSUFBV21VLEtBQW5DLEdBQTJDaEIsSUFBSSxDQUFDblQsRUFBTCxHQUFVbVUsS0FBekUsQ0FBaEI7O0FBQ0EsWUFBSUgsU0FBUyxJQUFJYixJQUFJLENBQUNwVCxJQUFMLElBQWFvVSxLQUFiLElBQXNCbkIsTUFBTSxDQUFDaFIsSUFBUCxJQUFlLFVBQXJDLEtBQW9ELENBQUMyUixRQUFELElBQWFSLElBQUksQ0FBQ0gsTUFBTCxDQUFZZSxVQUE3RSxDQUFqQixFQUEyRztBQUN6RyxjQUFJRixZQUFZLEdBQUdWLElBQUksQ0FBQ3BULElBQUwsSUFBYSxJQUFiLEtBQXNCaVQsTUFBTSxDQUFDYyxhQUFQLEdBQXVCWCxJQUFJLENBQUNwVCxJQUFMLElBQWFvVSxLQUFwQyxHQUE0Q2hCLElBQUksQ0FBQ3BULElBQUwsR0FBWW9VLEtBQTlFLENBQW5CO0FBQ0MsV0FBQ1AsRUFBRSxLQUFLQSxFQUFFLEdBQUcsRUFBVixDQUFILEVBQWtCL1YsSUFBbEIsQ0FBdUIsSUFBSWtWLFVBQUosQ0FBZUMsTUFBZixFQUF1QmEsWUFBWSxHQUFHLElBQUgsR0FBVVYsSUFBSSxDQUFDcFQsSUFBTCxHQUFZb1UsS0FBekQsRUFDY2hCLElBQUksQ0FBQ25ULEVBQUwsSUFBVyxJQUFYLEdBQWtCLElBQWxCLEdBQXlCbVQsSUFBSSxDQUFDblQsRUFBTCxHQUFVbVUsS0FEakQsQ0FBdkI7QUFFRjtBQUNGO0FBQUU7O0FBQ0gsV0FBT1AsRUFBUDtBQUNELEdBOXpDa0IsQ0FnMENuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFdBQVNRLHNCQUFULENBQWdDakksR0FBaEMsRUFBcUNrSSxNQUFyQyxFQUE2QztBQUMzQyxRQUFJQSxNQUFNLENBQUNDLElBQVgsRUFBaUI7QUFBRSxhQUFPLElBQVA7QUFBYTs7QUFDaEMsUUFBSUMsUUFBUSxHQUFHL0csTUFBTSxDQUFDckIsR0FBRCxFQUFNa0ksTUFBTSxDQUFDdFUsSUFBUCxDQUFZNEQsSUFBbEIsQ0FBTixJQUFpQ3VJLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNa0ksTUFBTSxDQUFDdFUsSUFBUCxDQUFZNEQsSUFBbEIsQ0FBUCxDQUErQjJQLFdBQS9FO0FBQ0EsUUFBSWtCLE9BQU8sR0FBR2hILE1BQU0sQ0FBQ3JCLEdBQUQsRUFBTWtJLE1BQU0sQ0FBQ3JVLEVBQVAsQ0FBVTJELElBQWhCLENBQU4sSUFBK0J1SSxPQUFPLENBQUNDLEdBQUQsRUFBTWtJLE1BQU0sQ0FBQ3JVLEVBQVAsQ0FBVTJELElBQWhCLENBQVAsQ0FBNkIyUCxXQUExRTs7QUFDQSxRQUFJLENBQUNpQixRQUFELElBQWEsQ0FBQ0MsT0FBbEIsRUFBMkI7QUFBRSxhQUFPLElBQVA7QUFBYTs7QUFFMUMsUUFBSWQsT0FBTyxHQUFHVyxNQUFNLENBQUN0VSxJQUFQLENBQVloQixFQUExQjtBQUFBLFFBQThCb1YsS0FBSyxHQUFHRSxNQUFNLENBQUNyVSxFQUFQLENBQVVqQixFQUFoRDtBQUFBLFFBQW9ENFUsUUFBUSxHQUFHN0YsR0FBRyxDQUFDdUcsTUFBTSxDQUFDdFUsSUFBUixFQUFjc1UsTUFBTSxDQUFDclUsRUFBckIsQ0FBSCxJQUErQixDQUE5RixDQU4yQyxDQU8zQzs7QUFDQSxRQUFJb00sS0FBSyxHQUFHb0gsaUJBQWlCLENBQUNlLFFBQUQsRUFBV2IsT0FBWCxFQUFvQkMsUUFBcEIsQ0FBN0I7QUFDQSxRQUFJckYsSUFBSSxHQUFHNEYsZ0JBQWdCLENBQUNNLE9BQUQsRUFBVUwsS0FBVixFQUFpQlIsUUFBakIsQ0FBM0IsQ0FUMkMsQ0FXM0M7O0FBQ0EsUUFBSWMsUUFBUSxHQUFHSixNQUFNLENBQUN6USxJQUFQLENBQVl6TSxNQUFaLElBQXNCLENBQXJDO0FBQUEsUUFBd0N1ZCxNQUFNLEdBQUc1VyxHQUFHLENBQUN1VyxNQUFNLENBQUN6USxJQUFSLENBQUgsQ0FBaUJ6TSxNQUFqQixJQUEyQnNkLFFBQVEsR0FBR2YsT0FBSCxHQUFhLENBQWhELENBQWpEOztBQUNBLFFBQUl0SCxLQUFKLEVBQVc7QUFDVDtBQUNBLFdBQUssSUFBSWhVLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdnVSxLQUFLLENBQUNqVixNQUExQixFQUFrQyxFQUFFaUIsQ0FBcEMsRUFBdUM7QUFDckMsWUFBSSthLElBQUksR0FBRy9HLEtBQUssQ0FBQ2hVLENBQUQsQ0FBaEI7O0FBQ0EsWUFBSSthLElBQUksQ0FBQ25ULEVBQUwsSUFBVyxJQUFmLEVBQXFCO0FBQ25CLGNBQUlPLEtBQUssR0FBRzBTLGdCQUFnQixDQUFDM0UsSUFBRCxFQUFPNkUsSUFBSSxDQUFDSCxNQUFaLENBQTVCOztBQUNBLGNBQUksQ0FBQ3pTLEtBQUwsRUFBWTtBQUFFNFMsZ0JBQUksQ0FBQ25ULEVBQUwsR0FBVTBULE9BQVY7QUFBb0IsV0FBbEMsTUFDSyxJQUFJZSxRQUFKLEVBQWM7QUFBRXRCLGdCQUFJLENBQUNuVCxFQUFMLEdBQVVPLEtBQUssQ0FBQ1AsRUFBTixJQUFZLElBQVosR0FBbUIsSUFBbkIsR0FBMEJPLEtBQUssQ0FBQ1AsRUFBTixHQUFXMFUsTUFBL0M7QUFBd0Q7QUFDOUU7QUFDRjtBQUNGOztBQUNELFFBQUlwRyxJQUFKLEVBQVU7QUFDUjtBQUNBLFdBQUssSUFBSXhNLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUd3TSxJQUFJLENBQUNuWCxNQUE3QixFQUFxQyxFQUFFMkssR0FBdkMsRUFBNEM7QUFDMUMsWUFBSTZTLE1BQU0sR0FBR3JHLElBQUksQ0FBQ3hNLEdBQUQsQ0FBakI7O0FBQ0EsWUFBSTZTLE1BQU0sQ0FBQzNVLEVBQVAsSUFBYSxJQUFqQixFQUF1QjtBQUFFMlUsZ0JBQU0sQ0FBQzNVLEVBQVAsSUFBYTBVLE1BQWI7QUFBc0I7O0FBQy9DLFlBQUlDLE1BQU0sQ0FBQzVVLElBQVAsSUFBZSxJQUFuQixFQUF5QjtBQUN2QixjQUFJNlUsT0FBTyxHQUFHM0IsZ0JBQWdCLENBQUM3RyxLQUFELEVBQVF1SSxNQUFNLENBQUMzQixNQUFmLENBQTlCOztBQUNBLGNBQUksQ0FBQzRCLE9BQUwsRUFBYztBQUNaRCxrQkFBTSxDQUFDNVUsSUFBUCxHQUFjMlUsTUFBZDs7QUFDQSxnQkFBSUQsUUFBSixFQUFjO0FBQUUsZUFBQ3JJLEtBQUssS0FBS0EsS0FBSyxHQUFHLEVBQWIsQ0FBTixFQUF3QnZPLElBQXhCLENBQTZCOFcsTUFBN0I7QUFBdUM7QUFDeEQ7QUFDRixTQU5ELE1BTU87QUFDTEEsZ0JBQU0sQ0FBQzVVLElBQVAsSUFBZTJVLE1BQWY7O0FBQ0EsY0FBSUQsUUFBSixFQUFjO0FBQUUsYUFBQ3JJLEtBQUssS0FBS0EsS0FBSyxHQUFHLEVBQWIsQ0FBTixFQUF3QnZPLElBQXhCLENBQTZCOFcsTUFBN0I7QUFBdUM7QUFDeEQ7QUFDRjtBQUNGLEtBeEMwQyxDQXlDM0M7OztBQUNBLFFBQUl2SSxLQUFKLEVBQVc7QUFBRUEsV0FBSyxHQUFHeUksZUFBZSxDQUFDekksS0FBRCxDQUF2QjtBQUFpQzs7QUFDOUMsUUFBSWtDLElBQUksSUFBSUEsSUFBSSxJQUFJbEMsS0FBcEIsRUFBMkI7QUFBRWtDLFVBQUksR0FBR3VHLGVBQWUsQ0FBQ3ZHLElBQUQsQ0FBdEI7QUFBK0I7O0FBRTVELFFBQUl3RyxVQUFVLEdBQUcsQ0FBQzFJLEtBQUQsQ0FBakI7O0FBQ0EsUUFBSSxDQUFDcUksUUFBTCxFQUFlO0FBQ2I7QUFDQSxVQUFJTSxHQUFHLEdBQUdWLE1BQU0sQ0FBQ3pRLElBQVAsQ0FBWXpNLE1BQVosR0FBcUIsQ0FBL0I7QUFBQSxVQUFrQzZkLFVBQWxDOztBQUNBLFVBQUlELEdBQUcsR0FBRyxDQUFOLElBQVczSSxLQUFmLEVBQ0U7QUFBRSxhQUFLLElBQUluSyxHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHbUssS0FBSyxDQUFDalYsTUFBOUIsRUFBc0MsRUFBRThLLEdBQXhDLEVBQ0E7QUFBRSxjQUFJbUssS0FBSyxDQUFDbkssR0FBRCxDQUFMLENBQVdqQyxFQUFYLElBQWlCLElBQXJCLEVBQ0E7QUFBRSxhQUFDZ1YsVUFBVSxLQUFLQSxVQUFVLEdBQUcsRUFBbEIsQ0FBWCxFQUFrQ25YLElBQWxDLENBQXVDLElBQUlrVixVQUFKLENBQWUzRyxLQUFLLENBQUNuSyxHQUFELENBQUwsQ0FBVytRLE1BQTFCLEVBQWtDLElBQWxDLEVBQXdDLElBQXhDLENBQXZDO0FBQXdGO0FBQUU7QUFBRTs7QUFDcEcsV0FBSyxJQUFJN1EsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBRzRTLEdBQXhCLEVBQTZCLEVBQUU1UyxHQUEvQixFQUNFO0FBQUUyUyxrQkFBVSxDQUFDalgsSUFBWCxDQUFnQm1YLFVBQWhCO0FBQThCOztBQUNsQ0YsZ0JBQVUsQ0FBQ2pYLElBQVgsQ0FBZ0J5USxJQUFoQjtBQUNEOztBQUNELFdBQU93RyxVQUFQO0FBQ0QsR0FoNENrQixDQWs0Q25CO0FBQ0E7OztBQUNBLFdBQVNELGVBQVQsQ0FBeUIzQixLQUF6QixFQUFnQztBQUM5QixTQUFLLElBQUk5YSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHOGEsS0FBSyxDQUFDL2IsTUFBMUIsRUFBa0MsRUFBRWlCLENBQXBDLEVBQXVDO0FBQ3JDLFVBQUkrYSxJQUFJLEdBQUdELEtBQUssQ0FBQzlhLENBQUQsQ0FBaEI7O0FBQ0EsVUFBSSthLElBQUksQ0FBQ3BULElBQUwsSUFBYSxJQUFiLElBQXFCb1QsSUFBSSxDQUFDcFQsSUFBTCxJQUFhb1QsSUFBSSxDQUFDblQsRUFBdkMsSUFBNkNtVCxJQUFJLENBQUNILE1BQUwsQ0FBWWlDLGNBQVosS0FBK0IsS0FBaEYsRUFDRTtBQUFFL0IsYUFBSyxDQUFDN1UsTUFBTixDQUFhakcsQ0FBQyxFQUFkLEVBQWtCLENBQWxCO0FBQXVCO0FBQzVCOztBQUNELFFBQUksQ0FBQzhhLEtBQUssQ0FBQy9iLE1BQVgsRUFBbUI7QUFBRSxhQUFPLElBQVA7QUFBYTs7QUFDbEMsV0FBTytiLEtBQVA7QUFDRCxHQTU0Q2tCLENBODRDbkI7OztBQUNBLFdBQVNnQyxvQkFBVCxDQUE4Qi9JLEdBQTlCLEVBQW1DcE0sSUFBbkMsRUFBeUNDLEVBQXpDLEVBQTZDO0FBQzNDLFFBQUltVixPQUFPLEdBQUcsSUFBZDtBQUNBaEosT0FBRyxDQUFDVSxJQUFKLENBQVM5TSxJQUFJLENBQUM0RCxJQUFkLEVBQW9CM0QsRUFBRSxDQUFDMkQsSUFBSCxHQUFVLENBQTlCLEVBQWlDLFVBQVVBLElBQVYsRUFBZ0I7QUFDL0MsVUFBSUEsSUFBSSxDQUFDMlAsV0FBVCxFQUFzQjtBQUFFLGFBQUssSUFBSWxiLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1TCxJQUFJLENBQUMyUCxXQUFMLENBQWlCbmMsTUFBckMsRUFBNkMsRUFBRWlCLENBQS9DLEVBQWtEO0FBQ3hFLGNBQUlnZCxJQUFJLEdBQUd6UixJQUFJLENBQUMyUCxXQUFMLENBQWlCbGIsQ0FBakIsRUFBb0I0YSxNQUEvQjs7QUFDQSxjQUFJb0MsSUFBSSxDQUFDQyxRQUFMLEtBQWtCLENBQUNGLE9BQUQsSUFBWXBaLE9BQU8sQ0FBQ29aLE9BQUQsRUFBVUMsSUFBVixDQUFQLElBQTBCLENBQUMsQ0FBekQsQ0FBSixFQUNFO0FBQUUsYUFBQ0QsT0FBTyxLQUFLQSxPQUFPLEdBQUcsRUFBZixDQUFSLEVBQTRCdFgsSUFBNUIsQ0FBaUN1WCxJQUFqQztBQUF5QztBQUM5QztBQUFFO0FBQ0osS0FORDs7QUFPQSxRQUFJLENBQUNELE9BQUwsRUFBYztBQUFFLGFBQU8sSUFBUDtBQUFhOztBQUM3QixRQUFJRyxLQUFLLEdBQUcsQ0FBQztBQUFDdlYsVUFBSSxFQUFFQSxJQUFQO0FBQWFDLFFBQUUsRUFBRUE7QUFBakIsS0FBRCxDQUFaOztBQUNBLFNBQUssSUFBSTVILENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcrYyxPQUFPLENBQUNoZSxNQUE1QixFQUFvQyxFQUFFaUIsQ0FBdEMsRUFBeUM7QUFDdkMsVUFBSW1kLEVBQUUsR0FBR0osT0FBTyxDQUFDL2MsQ0FBRCxDQUFoQjtBQUFBLFVBQXFCOEssQ0FBQyxHQUFHcVMsRUFBRSxDQUFDQyxJQUFILENBQVEsQ0FBUixDQUF6Qjs7QUFDQSxXQUFLLElBQUkvUyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNlMsS0FBSyxDQUFDbmUsTUFBMUIsRUFBa0MsRUFBRXNMLENBQXBDLEVBQXVDO0FBQ3JDLFlBQUlnVCxDQUFDLEdBQUdILEtBQUssQ0FBQzdTLENBQUQsQ0FBYjs7QUFDQSxZQUFJcUwsR0FBRyxDQUFDMkgsQ0FBQyxDQUFDelYsRUFBSCxFQUFPa0QsQ0FBQyxDQUFDbkQsSUFBVCxDQUFILEdBQW9CLENBQXBCLElBQXlCK04sR0FBRyxDQUFDMkgsQ0FBQyxDQUFDMVYsSUFBSCxFQUFTbUQsQ0FBQyxDQUFDbEQsRUFBWCxDQUFILEdBQW9CLENBQWpELEVBQW9EO0FBQUU7QUFBVTs7QUFDaEUsWUFBSTBWLFFBQVEsR0FBRyxDQUFDalQsQ0FBRCxFQUFJLENBQUosQ0FBZjtBQUFBLFlBQXVCa1QsS0FBSyxHQUFHN0gsR0FBRyxDQUFDMkgsQ0FBQyxDQUFDMVYsSUFBSCxFQUFTbUQsQ0FBQyxDQUFDbkQsSUFBWCxDQUFsQztBQUFBLFlBQW9ENlYsR0FBRyxHQUFHOUgsR0FBRyxDQUFDMkgsQ0FBQyxDQUFDelYsRUFBSCxFQUFPa0QsQ0FBQyxDQUFDbEQsRUFBVCxDQUE3RDs7QUFDQSxZQUFJMlYsS0FBSyxHQUFHLENBQVIsSUFBYSxDQUFDSixFQUFFLENBQUN6QixhQUFKLElBQXFCLENBQUM2QixLQUF2QyxFQUNFO0FBQUVELGtCQUFRLENBQUM3WCxJQUFULENBQWM7QUFBQ2tDLGdCQUFJLEVBQUUwVixDQUFDLENBQUMxVixJQUFUO0FBQWVDLGNBQUUsRUFBRWtELENBQUMsQ0FBQ25EO0FBQXJCLFdBQWQ7QUFBNEM7O0FBQ2hELFlBQUk2VixHQUFHLEdBQUcsQ0FBTixJQUFXLENBQUNMLEVBQUUsQ0FBQ3RCLGNBQUosSUFBc0IsQ0FBQzJCLEdBQXRDLEVBQ0U7QUFBRUYsa0JBQVEsQ0FBQzdYLElBQVQsQ0FBYztBQUFDa0MsZ0JBQUksRUFBRW1ELENBQUMsQ0FBQ2xELEVBQVQ7QUFBYUEsY0FBRSxFQUFFeVYsQ0FBQyxDQUFDelY7QUFBbkIsV0FBZDtBQUF3Qzs7QUFDNUNzVixhQUFLLENBQUNqWCxNQUFOLENBQWFyRCxLQUFiLENBQW1Cc2EsS0FBbkIsRUFBMEJJLFFBQTFCO0FBQ0FqVCxTQUFDLElBQUlpVCxRQUFRLENBQUN2ZSxNQUFULEdBQWtCLENBQXZCO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPbWUsS0FBUDtBQUNELEdBejZDa0IsQ0EyNkNuQjs7O0FBQ0EsV0FBU08saUJBQVQsQ0FBMkJsUyxJQUEzQixFQUFpQztBQUMvQixRQUFJdVAsS0FBSyxHQUFHdlAsSUFBSSxDQUFDMlAsV0FBakI7O0FBQ0EsUUFBSSxDQUFDSixLQUFMLEVBQVk7QUFBRTtBQUFROztBQUN0QixTQUFLLElBQUk5YSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHOGEsS0FBSyxDQUFDL2IsTUFBMUIsRUFBa0MsRUFBRWlCLENBQXBDLEVBQ0U7QUFBRThhLFdBQUssQ0FBQzlhLENBQUQsQ0FBTCxDQUFTNGEsTUFBVCxDQUFnQjhDLFVBQWhCLENBQTJCblMsSUFBM0I7QUFBbUM7O0FBQ3ZDQSxRQUFJLENBQUMyUCxXQUFMLEdBQW1CLElBQW5CO0FBQ0Q7O0FBQ0QsV0FBU3lDLGlCQUFULENBQTJCcFMsSUFBM0IsRUFBaUN1UCxLQUFqQyxFQUF3QztBQUN0QyxRQUFJLENBQUNBLEtBQUwsRUFBWTtBQUFFO0FBQVE7O0FBQ3RCLFNBQUssSUFBSTlhLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc4YSxLQUFLLENBQUMvYixNQUExQixFQUFrQyxFQUFFaUIsQ0FBcEMsRUFDRTtBQUFFOGEsV0FBSyxDQUFDOWEsQ0FBRCxDQUFMLENBQVM0YSxNQUFULENBQWdCTyxVQUFoQixDQUEyQjVQLElBQTNCO0FBQW1DOztBQUN2Q0EsUUFBSSxDQUFDMlAsV0FBTCxHQUFtQkosS0FBbkI7QUFDRCxHQXg3Q2tCLENBMDdDbkI7QUFDQTs7O0FBQ0EsV0FBUzhDLFNBQVQsQ0FBbUJoRCxNQUFuQixFQUEyQjtBQUFFLFdBQU9BLE1BQU0sQ0FBQ2MsYUFBUCxHQUF1QixDQUFDLENBQXhCLEdBQTRCLENBQW5DO0FBQXNDOztBQUNuRSxXQUFTbUMsVUFBVCxDQUFvQmpELE1BQXBCLEVBQTRCO0FBQUUsV0FBT0EsTUFBTSxDQUFDaUIsY0FBUCxHQUF3QixDQUF4QixHQUE0QixDQUFuQztBQUFzQyxHQTc3Q2pELENBKzdDbkI7QUFDQTtBQUNBOzs7QUFDQSxXQUFTaUMsdUJBQVQsQ0FBaUNuYyxDQUFqQyxFQUFvQ0MsQ0FBcEMsRUFBdUM7QUFDckMsUUFBSW1jLE9BQU8sR0FBR3BjLENBQUMsQ0FBQ3lTLEtBQUYsQ0FBUXJWLE1BQVIsR0FBaUI2QyxDQUFDLENBQUN3UyxLQUFGLENBQVFyVixNQUF2Qzs7QUFDQSxRQUFJZ2YsT0FBTyxJQUFJLENBQWYsRUFBa0I7QUFBRSxhQUFPQSxPQUFQO0FBQWdCOztBQUNwQyxRQUFJQyxJQUFJLEdBQUdyYyxDQUFDLENBQUN5YixJQUFGLEVBQVg7QUFBQSxRQUFxQmEsSUFBSSxHQUFHcmMsQ0FBQyxDQUFDd2IsSUFBRixFQUE1QjtBQUNBLFFBQUljLE9BQU8sR0FBR3hJLEdBQUcsQ0FBQ3NJLElBQUksQ0FBQ3JXLElBQU4sRUFBWXNXLElBQUksQ0FBQ3RXLElBQWpCLENBQUgsSUFBNkJpVyxTQUFTLENBQUNqYyxDQUFELENBQVQsR0FBZWljLFNBQVMsQ0FBQ2hjLENBQUQsQ0FBbkU7O0FBQ0EsUUFBSXNjLE9BQUosRUFBYTtBQUFFLGFBQU8sQ0FBQ0EsT0FBUjtBQUFpQjs7QUFDaEMsUUFBSUMsS0FBSyxHQUFHekksR0FBRyxDQUFDc0ksSUFBSSxDQUFDcFcsRUFBTixFQUFVcVcsSUFBSSxDQUFDclcsRUFBZixDQUFILElBQXlCaVcsVUFBVSxDQUFDbGMsQ0FBRCxDQUFWLEdBQWdCa2MsVUFBVSxDQUFDamMsQ0FBRCxDQUEvRDs7QUFDQSxRQUFJdWMsS0FBSixFQUFXO0FBQUUsYUFBT0EsS0FBUDtBQUFjOztBQUMzQixXQUFPdmMsQ0FBQyxDQUFDaUMsRUFBRixHQUFPbEMsQ0FBQyxDQUFDa0MsRUFBaEI7QUFDRCxHQTM4Q2tCLENBNjhDbkI7QUFDQTs7O0FBQ0EsV0FBU3VhLG1CQUFULENBQTZCN1MsSUFBN0IsRUFBbUNsTCxLQUFuQyxFQUEwQztBQUN4QyxRQUFJZ2UsR0FBRyxHQUFHN0QsaUJBQWlCLElBQUlqUCxJQUFJLENBQUMyUCxXQUFwQztBQUFBLFFBQWlEL1MsS0FBakQ7O0FBQ0EsUUFBSWtXLEdBQUosRUFBUztBQUFFLFdBQUssSUFBSUMsRUFBRSxHQUFJLEtBQUssQ0FBZixFQUFtQnRlLENBQUMsR0FBRyxDQUE1QixFQUErQkEsQ0FBQyxHQUFHcWUsR0FBRyxDQUFDdGYsTUFBdkMsRUFBK0MsRUFBRWlCLENBQWpELEVBQW9EO0FBQzdEc2UsVUFBRSxHQUFHRCxHQUFHLENBQUNyZSxDQUFELENBQVI7O0FBQ0EsWUFBSXNlLEVBQUUsQ0FBQzFELE1BQUgsQ0FBVTJELFNBQVYsSUFBdUIsQ0FBQ2xlLEtBQUssR0FBR2llLEVBQUUsQ0FBQzNXLElBQU4sR0FBYTJXLEVBQUUsQ0FBQzFXLEVBQXRCLEtBQTZCLElBQXBELEtBQ0MsQ0FBQ08sS0FBRCxJQUFVMlYsdUJBQXVCLENBQUMzVixLQUFELEVBQVFtVyxFQUFFLENBQUMxRCxNQUFYLENBQXZCLEdBQTRDLENBRHZELENBQUosRUFFRTtBQUFFelMsZUFBSyxHQUFHbVcsRUFBRSxDQUFDMUQsTUFBWDtBQUFvQjtBQUN6QjtBQUFFOztBQUNILFdBQU96UyxLQUFQO0FBQ0Q7O0FBQ0QsV0FBU3FXLG9CQUFULENBQThCalQsSUFBOUIsRUFBb0M7QUFBRSxXQUFPNlMsbUJBQW1CLENBQUM3UyxJQUFELEVBQU8sSUFBUCxDQUExQjtBQUF3Qzs7QUFDOUUsV0FBU2tULGtCQUFULENBQTRCbFQsSUFBNUIsRUFBa0M7QUFBRSxXQUFPNlMsbUJBQW1CLENBQUM3UyxJQUFELEVBQU8sS0FBUCxDQUExQjtBQUF5Qzs7QUFFN0UsV0FBU21ULG1CQUFULENBQTZCblQsSUFBN0IsRUFBbUM1RSxFQUFuQyxFQUF1QztBQUNyQyxRQUFJMFgsR0FBRyxHQUFHN0QsaUJBQWlCLElBQUlqUCxJQUFJLENBQUMyUCxXQUFwQztBQUFBLFFBQWlEL1MsS0FBakQ7O0FBQ0EsUUFBSWtXLEdBQUosRUFBUztBQUFFLFdBQUssSUFBSXJlLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxZSxHQUFHLENBQUN0ZixNQUF4QixFQUFnQyxFQUFFaUIsQ0FBbEMsRUFBcUM7QUFDOUMsWUFBSXNlLEVBQUUsR0FBR0QsR0FBRyxDQUFDcmUsQ0FBRCxDQUFaOztBQUNBLFlBQUlzZSxFQUFFLENBQUMxRCxNQUFILENBQVUyRCxTQUFWLEtBQXdCRCxFQUFFLENBQUMzVyxJQUFILElBQVcsSUFBWCxJQUFtQjJXLEVBQUUsQ0FBQzNXLElBQUgsR0FBVWhCLEVBQXJELE1BQTZEMlgsRUFBRSxDQUFDMVcsRUFBSCxJQUFTLElBQVQsSUFBaUIwVyxFQUFFLENBQUMxVyxFQUFILEdBQVFqQixFQUF0RixNQUNDLENBQUN3QixLQUFELElBQVUyVix1QkFBdUIsQ0FBQzNWLEtBQUQsRUFBUW1XLEVBQUUsQ0FBQzFELE1BQVgsQ0FBdkIsR0FBNEMsQ0FEdkQsQ0FBSixFQUMrRDtBQUFFelMsZUFBSyxHQUFHbVcsRUFBRSxDQUFDMUQsTUFBWDtBQUFvQjtBQUN0RjtBQUFFOztBQUNILFdBQU96UyxLQUFQO0FBQ0QsR0FwK0NrQixDQXMrQ25CO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU3dXLHlCQUFULENBQW1DNUssR0FBbkMsRUFBd0NlLE1BQXhDLEVBQWdEbk4sSUFBaEQsRUFBc0RDLEVBQXRELEVBQTBEZ1QsTUFBMUQsRUFBa0U7QUFDaEUsUUFBSXJQLElBQUksR0FBR3VJLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNZSxNQUFOLENBQWxCO0FBQ0EsUUFBSXVKLEdBQUcsR0FBRzdELGlCQUFpQixJQUFJalAsSUFBSSxDQUFDMlAsV0FBcEM7O0FBQ0EsUUFBSW1ELEdBQUosRUFBUztBQUFFLFdBQUssSUFBSXJlLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxZSxHQUFHLENBQUN0ZixNQUF4QixFQUFnQyxFQUFFaUIsQ0FBbEMsRUFBcUM7QUFDOUMsWUFBSXNlLEVBQUUsR0FBR0QsR0FBRyxDQUFDcmUsQ0FBRCxDQUFaOztBQUNBLFlBQUksQ0FBQ3NlLEVBQUUsQ0FBQzFELE1BQUgsQ0FBVTJELFNBQWYsRUFBMEI7QUFBRTtBQUFVOztBQUN0QyxZQUFJcFcsS0FBSyxHQUFHbVcsRUFBRSxDQUFDMUQsTUFBSCxDQUFVd0MsSUFBVixDQUFlLENBQWYsQ0FBWjtBQUNBLFlBQUljLE9BQU8sR0FBR3hJLEdBQUcsQ0FBQ3ZOLEtBQUssQ0FBQ1IsSUFBUCxFQUFhQSxJQUFiLENBQUgsSUFBeUJpVyxTQUFTLENBQUNVLEVBQUUsQ0FBQzFELE1BQUosQ0FBVCxHQUF1QmdELFNBQVMsQ0FBQ2hELE1BQUQsQ0FBdkU7QUFDQSxZQUFJdUQsS0FBSyxHQUFHekksR0FBRyxDQUFDdk4sS0FBSyxDQUFDUCxFQUFQLEVBQVdBLEVBQVgsQ0FBSCxJQUFxQmlXLFVBQVUsQ0FBQ1MsRUFBRSxDQUFDMUQsTUFBSixDQUFWLEdBQXdCaUQsVUFBVSxDQUFDakQsTUFBRCxDQUFuRTs7QUFDQSxZQUFJc0QsT0FBTyxJQUFJLENBQVgsSUFBZ0JDLEtBQUssSUFBSSxDQUF6QixJQUE4QkQsT0FBTyxJQUFJLENBQVgsSUFBZ0JDLEtBQUssSUFBSSxDQUEzRCxFQUE4RDtBQUFFO0FBQVU7O0FBQzFFLFlBQUlELE9BQU8sSUFBSSxDQUFYLEtBQWlCSSxFQUFFLENBQUMxRCxNQUFILENBQVVpQixjQUFWLElBQTRCakIsTUFBTSxDQUFDYyxhQUFuQyxHQUFtRGhHLEdBQUcsQ0FBQ3ZOLEtBQUssQ0FBQ1AsRUFBUCxFQUFXRCxJQUFYLENBQUgsSUFBdUIsQ0FBMUUsR0FBOEUrTixHQUFHLENBQUN2TixLQUFLLENBQUNQLEVBQVAsRUFBV0QsSUFBWCxDQUFILEdBQXNCLENBQXJILEtBQ0F1VyxPQUFPLElBQUksQ0FBWCxLQUFpQkksRUFBRSxDQUFDMUQsTUFBSCxDQUFVaUIsY0FBVixJQUE0QmpCLE1BQU0sQ0FBQ2MsYUFBbkMsR0FBbURoRyxHQUFHLENBQUN2TixLQUFLLENBQUNSLElBQVAsRUFBYUMsRUFBYixDQUFILElBQXVCLENBQTFFLEdBQThFOE4sR0FBRyxDQUFDdk4sS0FBSyxDQUFDUixJQUFQLEVBQWFDLEVBQWIsQ0FBSCxHQUFzQixDQUFySCxDQURKLEVBRUU7QUFBRSxpQkFBTyxJQUFQO0FBQWE7QUFDbEI7QUFBRTtBQUNKLEdBdi9Da0IsQ0F5L0NuQjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU2dYLFVBQVQsQ0FBb0JyVCxJQUFwQixFQUEwQjtBQUN4QixRQUFJc1QsTUFBSjs7QUFDQSxXQUFPQSxNQUFNLEdBQUdMLG9CQUFvQixDQUFDalQsSUFBRCxDQUFwQyxFQUNFO0FBQUVBLFVBQUksR0FBR3NULE1BQU0sQ0FBQ3pCLElBQVAsQ0FBWSxDQUFDLENBQWIsRUFBZ0IsSUFBaEIsRUFBc0I3UixJQUE3QjtBQUFvQzs7QUFDeEMsV0FBT0EsSUFBUDtBQUNEOztBQUVELFdBQVN1VCxhQUFULENBQXVCdlQsSUFBdkIsRUFBNkI7QUFDM0IsUUFBSXNULE1BQUo7O0FBQ0EsV0FBT0EsTUFBTSxHQUFHSixrQkFBa0IsQ0FBQ2xULElBQUQsQ0FBbEMsRUFDRTtBQUFFQSxVQUFJLEdBQUdzVCxNQUFNLENBQUN6QixJQUFQLENBQVksQ0FBWixFQUFlLElBQWYsRUFBcUI3UixJQUE1QjtBQUFtQzs7QUFDdkMsV0FBT0EsSUFBUDtBQUNELEdBemdEa0IsQ0EyZ0RuQjtBQUNBOzs7QUFDQSxXQUFTd1QsbUJBQVQsQ0FBNkJ4VCxJQUE3QixFQUFtQztBQUNqQyxRQUFJc1QsTUFBSixFQUFZekssS0FBWjs7QUFDQSxXQUFPeUssTUFBTSxHQUFHSixrQkFBa0IsQ0FBQ2xULElBQUQsQ0FBbEMsRUFBMEM7QUFDeENBLFVBQUksR0FBR3NULE1BQU0sQ0FBQ3pCLElBQVAsQ0FBWSxDQUFaLEVBQWUsSUFBZixFQUFxQjdSLElBQTVCO0FBQ0MsT0FBQzZJLEtBQUssS0FBS0EsS0FBSyxHQUFHLEVBQWIsQ0FBTixFQUF3QjNPLElBQXhCLENBQTZCOEYsSUFBN0I7QUFDRjs7QUFDRCxXQUFPNkksS0FBUDtBQUNELEdBcGhEa0IsQ0FzaERuQjtBQUNBOzs7QUFDQSxXQUFTNEssWUFBVCxDQUFzQmpMLEdBQXRCLEVBQTJCa0wsS0FBM0IsRUFBa0M7QUFDaEMsUUFBSTFULElBQUksR0FBR3VJLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNa0wsS0FBTixDQUFsQjtBQUFBLFFBQWdDQyxHQUFHLEdBQUdOLFVBQVUsQ0FBQ3JULElBQUQsQ0FBaEQ7O0FBQ0EsUUFBSUEsSUFBSSxJQUFJMlQsR0FBWixFQUFpQjtBQUFFLGFBQU9ELEtBQVA7QUFBYzs7QUFDakMsV0FBT25LLE1BQU0sQ0FBQ29LLEdBQUQsQ0FBYjtBQUNELEdBNWhEa0IsQ0E4aERuQjtBQUNBOzs7QUFDQSxXQUFTQyxlQUFULENBQXlCcEwsR0FBekIsRUFBOEJrTCxLQUE5QixFQUFxQztBQUNuQyxRQUFJQSxLQUFLLEdBQUdsTCxHQUFHLENBQUNxTCxRQUFKLEVBQVosRUFBNEI7QUFBRSxhQUFPSCxLQUFQO0FBQWM7O0FBQzVDLFFBQUkxVCxJQUFJLEdBQUd1SSxPQUFPLENBQUNDLEdBQUQsRUFBTWtMLEtBQU4sQ0FBbEI7QUFBQSxRQUFnQ0osTUFBaEM7O0FBQ0EsUUFBSSxDQUFDUSxZQUFZLENBQUN0TCxHQUFELEVBQU14SSxJQUFOLENBQWpCLEVBQThCO0FBQUUsYUFBTzBULEtBQVA7QUFBYzs7QUFDOUMsV0FBT0osTUFBTSxHQUFHSixrQkFBa0IsQ0FBQ2xULElBQUQsQ0FBbEMsRUFDRTtBQUFFQSxVQUFJLEdBQUdzVCxNQUFNLENBQUN6QixJQUFQLENBQVksQ0FBWixFQUFlLElBQWYsRUFBcUI3UixJQUE1QjtBQUFtQzs7QUFDdkMsV0FBT3VKLE1BQU0sQ0FBQ3ZKLElBQUQsQ0FBTixHQUFlLENBQXRCO0FBQ0QsR0F2aURrQixDQXlpRG5CO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBUzhULFlBQVQsQ0FBc0J0TCxHQUF0QixFQUEyQnhJLElBQTNCLEVBQWlDO0FBQy9CLFFBQUk4UyxHQUFHLEdBQUc3RCxpQkFBaUIsSUFBSWpQLElBQUksQ0FBQzJQLFdBQXBDOztBQUNBLFFBQUltRCxHQUFKLEVBQVM7QUFBRSxXQUFLLElBQUlDLEVBQUUsR0FBSSxLQUFLLENBQWYsRUFBbUJ0ZSxDQUFDLEdBQUcsQ0FBNUIsRUFBK0JBLENBQUMsR0FBR3FlLEdBQUcsQ0FBQ3RmLE1BQXZDLEVBQStDLEVBQUVpQixDQUFqRCxFQUFvRDtBQUM3RHNlLFVBQUUsR0FBR0QsR0FBRyxDQUFDcmUsQ0FBRCxDQUFSOztBQUNBLFlBQUksQ0FBQ3NlLEVBQUUsQ0FBQzFELE1BQUgsQ0FBVTJELFNBQWYsRUFBMEI7QUFBRTtBQUFVOztBQUN0QyxZQUFJRCxFQUFFLENBQUMzVyxJQUFILElBQVcsSUFBZixFQUFxQjtBQUFFLGlCQUFPLElBQVA7QUFBYTs7QUFDcEMsWUFBSTJXLEVBQUUsQ0FBQzFELE1BQUgsQ0FBVTBFLFVBQWQsRUFBMEI7QUFBRTtBQUFVOztBQUN0QyxZQUFJaEIsRUFBRSxDQUFDM1csSUFBSCxJQUFXLENBQVgsSUFBZ0IyVyxFQUFFLENBQUMxRCxNQUFILENBQVVjLGFBQTFCLElBQTJDNkQsaUJBQWlCLENBQUN4TCxHQUFELEVBQU14SSxJQUFOLEVBQVkrUyxFQUFaLENBQWhFLEVBQ0U7QUFBRSxpQkFBTyxJQUFQO0FBQWE7QUFDbEI7QUFBRTtBQUNKOztBQUNELFdBQVNpQixpQkFBVCxDQUEyQnhMLEdBQTNCLEVBQWdDeEksSUFBaEMsRUFBc0N3UCxJQUF0QyxFQUE0QztBQUMxQyxRQUFJQSxJQUFJLENBQUNuVCxFQUFMLElBQVcsSUFBZixFQUFxQjtBQUNuQixVQUFJdEgsR0FBRyxHQUFHeWEsSUFBSSxDQUFDSCxNQUFMLENBQVl3QyxJQUFaLENBQWlCLENBQWpCLEVBQW9CLElBQXBCLENBQVY7QUFDQSxhQUFPbUMsaUJBQWlCLENBQUN4TCxHQUFELEVBQU16VCxHQUFHLENBQUNpTCxJQUFWLEVBQWdCc1AsZ0JBQWdCLENBQUN2YSxHQUFHLENBQUNpTCxJQUFKLENBQVMyUCxXQUFWLEVBQXVCSCxJQUFJLENBQUNILE1BQTVCLENBQWhDLENBQXhCO0FBQ0Q7O0FBQ0QsUUFBSUcsSUFBSSxDQUFDSCxNQUFMLENBQVlpQixjQUFaLElBQThCZCxJQUFJLENBQUNuVCxFQUFMLElBQVcyRCxJQUFJLENBQUNDLElBQUwsQ0FBVXpNLE1BQXZELEVBQ0U7QUFBRSxhQUFPLElBQVA7QUFBYTs7QUFDakIsU0FBSyxJQUFJdWYsRUFBRSxHQUFJLEtBQUssQ0FBZixFQUFtQnRlLENBQUMsR0FBRyxDQUE1QixFQUErQkEsQ0FBQyxHQUFHdUwsSUFBSSxDQUFDMlAsV0FBTCxDQUFpQm5jLE1BQXBELEVBQTRELEVBQUVpQixDQUE5RCxFQUFpRTtBQUMvRHNlLFFBQUUsR0FBRy9TLElBQUksQ0FBQzJQLFdBQUwsQ0FBaUJsYixDQUFqQixDQUFMOztBQUNBLFVBQUlzZSxFQUFFLENBQUMxRCxNQUFILENBQVUyRCxTQUFWLElBQXVCLENBQUNELEVBQUUsQ0FBQzFELE1BQUgsQ0FBVTBFLFVBQWxDLElBQWdEaEIsRUFBRSxDQUFDM1csSUFBSCxJQUFXb1QsSUFBSSxDQUFDblQsRUFBaEUsS0FDQzBXLEVBQUUsQ0FBQzFXLEVBQUgsSUFBUyxJQUFULElBQWlCMFcsRUFBRSxDQUFDMVcsRUFBSCxJQUFTbVQsSUFBSSxDQUFDcFQsSUFEaEMsTUFFQzJXLEVBQUUsQ0FBQzFELE1BQUgsQ0FBVWMsYUFBVixJQUEyQlgsSUFBSSxDQUFDSCxNQUFMLENBQVlpQixjQUZ4QyxLQUdBMEQsaUJBQWlCLENBQUN4TCxHQUFELEVBQU14SSxJQUFOLEVBQVkrUyxFQUFaLENBSHJCLEVBR3NDO0FBQUUsZUFBTyxJQUFQO0FBQWE7QUFDdEQ7QUFDRixHQXJrRGtCLENBdWtEbkI7OztBQUNBLFdBQVNrQixhQUFULENBQXNCQyxPQUF0QixFQUErQjtBQUM3QkEsV0FBTyxHQUFHYixVQUFVLENBQUNhLE9BQUQsQ0FBcEI7QUFFQSxRQUFJeEssQ0FBQyxHQUFHLENBQVI7QUFBQSxRQUFXZCxLQUFLLEdBQUdzTCxPQUFPLENBQUNsZ0IsTUFBM0I7O0FBQ0EsU0FBSyxJQUFJUyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbVUsS0FBSyxDQUFDQyxLQUFOLENBQVlyVixNQUFoQyxFQUF3QyxFQUFFaUIsQ0FBMUMsRUFBNkM7QUFDM0MsVUFBSXVMLElBQUksR0FBRzRJLEtBQUssQ0FBQ0MsS0FBTixDQUFZcFUsQ0FBWixDQUFYOztBQUNBLFVBQUl1TCxJQUFJLElBQUlrVSxPQUFaLEVBQXFCO0FBQUU7QUFBTyxPQUE5QixNQUNLO0FBQUV4SyxTQUFDLElBQUkxSixJQUFJLENBQUNxSixNQUFWO0FBQW1CO0FBQzNCOztBQUNELFNBQUssSUFBSXlJLENBQUMsR0FBR2xKLEtBQUssQ0FBQzVVLE1BQW5CLEVBQTJCOGQsQ0FBM0IsRUFBOEJsSixLQUFLLEdBQUdrSixDQUFSLEVBQVdBLENBQUMsR0FBR2xKLEtBQUssQ0FBQzVVLE1BQW5ELEVBQTJEO0FBQ3pELFdBQUssSUFBSW1LLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUcyVCxDQUFDLENBQUNoSixRQUFGLENBQVd0VixNQUFuQyxFQUEyQyxFQUFFMkssR0FBN0MsRUFBa0Q7QUFDaEQsWUFBSWhCLEdBQUcsR0FBRzJVLENBQUMsQ0FBQ2hKLFFBQUYsQ0FBVzNLLEdBQVgsQ0FBVjs7QUFDQSxZQUFJaEIsR0FBRyxJQUFJeUwsS0FBWCxFQUFrQjtBQUFFO0FBQU8sU0FBM0IsTUFDSztBQUFFYyxXQUFDLElBQUl2TSxHQUFHLENBQUNrTSxNQUFUO0FBQWtCO0FBQzFCO0FBQ0Y7O0FBQ0QsV0FBT0ssQ0FBUDtBQUNELEdBemxEa0IsQ0EybERuQjtBQUNBO0FBQ0E7OztBQUNBLFdBQVN5SyxVQUFULENBQW9CblUsSUFBcEIsRUFBMEI7QUFDeEIsUUFBSUEsSUFBSSxDQUFDcUosTUFBTCxJQUFlLENBQW5CLEVBQXNCO0FBQUUsYUFBTyxDQUFQO0FBQVU7O0FBQ2xDLFFBQUlwTCxHQUFHLEdBQUcrQixJQUFJLENBQUNDLElBQUwsQ0FBVXpNLE1BQXBCO0FBQUEsUUFBNEI4ZixNQUE1QjtBQUFBLFFBQW9DblcsR0FBRyxHQUFHNkMsSUFBMUM7O0FBQ0EsV0FBT3NULE1BQU0sR0FBR0wsb0JBQW9CLENBQUM5VixHQUFELENBQXBDLEVBQTJDO0FBQ3pDLFVBQUlQLEtBQUssR0FBRzBXLE1BQU0sQ0FBQ3pCLElBQVAsQ0FBWSxDQUFaLEVBQWUsSUFBZixDQUFaO0FBQ0ExVSxTQUFHLEdBQUdQLEtBQUssQ0FBQ1IsSUFBTixDQUFXNEQsSUFBakI7QUFDQS9CLFNBQUcsSUFBSXJCLEtBQUssQ0FBQ1IsSUFBTixDQUFXaEIsRUFBWCxHQUFnQndCLEtBQUssQ0FBQ1AsRUFBTixDQUFTakIsRUFBaEM7QUFDRDs7QUFDRCtCLE9BQUcsR0FBRzZDLElBQU47O0FBQ0EsV0FBT3NULE1BQU0sR0FBR0osa0JBQWtCLENBQUMvVixHQUFELENBQWxDLEVBQXlDO0FBQ3ZDLFVBQUk4VCxPQUFPLEdBQUdxQyxNQUFNLENBQUN6QixJQUFQLENBQVksQ0FBWixFQUFlLElBQWYsQ0FBZDtBQUNBNVQsU0FBRyxJQUFJZCxHQUFHLENBQUM4QyxJQUFKLENBQVN6TSxNQUFULEdBQWtCeWQsT0FBTyxDQUFDN1UsSUFBUixDQUFhaEIsRUFBdEM7QUFDQStCLFNBQUcsR0FBRzhULE9BQU8sQ0FBQzVVLEVBQVIsQ0FBVzJELElBQWpCO0FBQ0EvQixTQUFHLElBQUlkLEdBQUcsQ0FBQzhDLElBQUosQ0FBU3pNLE1BQVQsR0FBa0J5ZCxPQUFPLENBQUM1VSxFQUFSLENBQVdqQixFQUFwQztBQUNEOztBQUNELFdBQU82QyxHQUFQO0FBQ0QsR0E5bURrQixDQWduRG5COzs7QUFDQSxXQUFTbVcsV0FBVCxDQUFxQnBULEVBQXJCLEVBQXlCO0FBQ3ZCLFFBQUlxVCxDQUFDLEdBQUdyVCxFQUFFLENBQUNvTSxPQUFYO0FBQUEsUUFBb0I1RSxHQUFHLEdBQUd4SCxFQUFFLENBQUN3SCxHQUE3QjtBQUNBNkwsS0FBQyxDQUFDQyxPQUFGLEdBQVkvTCxPQUFPLENBQUNDLEdBQUQsRUFBTUEsR0FBRyxDQUFDQyxLQUFWLENBQW5CO0FBQ0E0TCxLQUFDLENBQUNFLGFBQUYsR0FBa0JKLFVBQVUsQ0FBQ0UsQ0FBQyxDQUFDQyxPQUFILENBQTVCO0FBQ0FELEtBQUMsQ0FBQ0csY0FBRixHQUFtQixJQUFuQjtBQUNBaE0sT0FBRyxDQUFDVSxJQUFKLENBQVMsVUFBVWxKLElBQVYsRUFBZ0I7QUFDdkIsVUFBSS9CLEdBQUcsR0FBR2tXLFVBQVUsQ0FBQ25VLElBQUQsQ0FBcEI7O0FBQ0EsVUFBSS9CLEdBQUcsR0FBR29XLENBQUMsQ0FBQ0UsYUFBWixFQUEyQjtBQUN6QkYsU0FBQyxDQUFDRSxhQUFGLEdBQWtCdFcsR0FBbEI7QUFDQW9XLFNBQUMsQ0FBQ0MsT0FBRixHQUFZdFUsSUFBWjtBQUNEO0FBQ0YsS0FORDtBQU9ELEdBN25Ea0IsQ0ErbkRuQjtBQUVBO0FBQ0E7OztBQUNBLE1BQUl5VSxJQUFJLEdBQUcsU0FBUEEsSUFBTyxDQUFTeFUsSUFBVCxFQUFlMFAsV0FBZixFQUE0QitFLGNBQTVCLEVBQTRDO0FBQ3JELFNBQUt6VSxJQUFMLEdBQVlBLElBQVo7QUFDQW1TLHFCQUFpQixDQUFDLElBQUQsRUFBT3pDLFdBQVAsQ0FBakI7QUFDQSxTQUFLdEcsTUFBTCxHQUFjcUwsY0FBYyxHQUFHQSxjQUFjLENBQUMsSUFBRCxDQUFqQixHQUEwQixDQUF0RDtBQUNELEdBSkQ7O0FBTUFELE1BQUksQ0FBQ3ZkLFNBQUwsQ0FBZXFTLE1BQWYsR0FBd0IsWUFBWTtBQUFFLFdBQU9BLE1BQU0sQ0FBQyxJQUFELENBQWI7QUFBcUIsR0FBM0Q7O0FBQ0E1SCxZQUFVLENBQUM4UyxJQUFELENBQVYsQ0Exb0RtQixDQTRvRG5CO0FBQ0E7QUFDQTs7QUFDQSxXQUFTRSxVQUFULENBQW9CM1UsSUFBcEIsRUFBMEJDLElBQTFCLEVBQWdDMFAsV0FBaEMsRUFBNkMrRSxjQUE3QyxFQUE2RDtBQUMzRDFVLFFBQUksQ0FBQ0MsSUFBTCxHQUFZQSxJQUFaOztBQUNBLFFBQUlELElBQUksQ0FBQytNLFVBQVQsRUFBcUI7QUFBRS9NLFVBQUksQ0FBQytNLFVBQUwsR0FBa0IsSUFBbEI7QUFBeUI7O0FBQ2hELFFBQUkvTSxJQUFJLENBQUNzTSxNQUFULEVBQWlCO0FBQUV0TSxVQUFJLENBQUNzTSxNQUFMLEdBQWMsSUFBZDtBQUFxQjs7QUFDeEMsUUFBSXRNLElBQUksQ0FBQ3JELEtBQUwsSUFBYyxJQUFsQixFQUF3QjtBQUFFcUQsVUFBSSxDQUFDckQsS0FBTCxHQUFhLElBQWI7QUFBb0I7O0FBQzlDdVYscUJBQWlCLENBQUNsUyxJQUFELENBQWpCO0FBQ0FvUyxxQkFBaUIsQ0FBQ3BTLElBQUQsRUFBTzJQLFdBQVAsQ0FBakI7QUFDQSxRQUFJaUYsU0FBUyxHQUFHRixjQUFjLEdBQUdBLGNBQWMsQ0FBQzFVLElBQUQsQ0FBakIsR0FBMEIsQ0FBeEQ7O0FBQ0EsUUFBSTRVLFNBQVMsSUFBSTVVLElBQUksQ0FBQ3FKLE1BQXRCLEVBQThCO0FBQUVELHNCQUFnQixDQUFDcEosSUFBRCxFQUFPNFUsU0FBUCxDQUFoQjtBQUFvQztBQUNyRSxHQXhwRGtCLENBMHBEbkI7OztBQUNBLFdBQVNDLFdBQVQsQ0FBcUI3VSxJQUFyQixFQUEyQjtBQUN6QkEsUUFBSSxDQUFDaE0sTUFBTCxHQUFjLElBQWQ7QUFDQWtlLHFCQUFpQixDQUFDbFMsSUFBRCxDQUFqQjtBQUNELEdBOXBEa0IsQ0FncURuQjtBQUNBO0FBQ0E7OztBQUNBLE1BQUk4VSxpQkFBaUIsR0FBRyxFQUF4QjtBQUFBLE1BQTRCQyx5QkFBeUIsR0FBRyxFQUF4RDs7QUFDQSxXQUFTQyxtQkFBVCxDQUE2QjNnQixLQUE3QixFQUFvQ2tSLE9BQXBDLEVBQTZDO0FBQzNDLFFBQUksQ0FBQ2xSLEtBQUQsSUFBVSxRQUFRcEQsSUFBUixDQUFhb0QsS0FBYixDQUFkLEVBQW1DO0FBQUUsYUFBTyxJQUFQO0FBQWE7O0FBQ2xELFFBQUk0Z0IsS0FBSyxHQUFHMVAsT0FBTyxDQUFDa0osWUFBUixHQUF1QnNHLHlCQUF2QixHQUFtREQsaUJBQS9EO0FBQ0EsV0FBT0csS0FBSyxDQUFDNWdCLEtBQUQsQ0FBTCxLQUNKNGdCLEtBQUssQ0FBQzVnQixLQUFELENBQUwsR0FBZUEsS0FBSyxDQUFDd0ssT0FBTixDQUFjLE1BQWQsRUFBc0IsT0FBdEIsQ0FEWCxDQUFQO0FBRUQsR0F6cURrQixDQTJxRG5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFdBQVNxVyxnQkFBVCxDQUEwQmxVLEVBQTFCLEVBQThCbVUsUUFBOUIsRUFBd0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsUUFBSS9nQixPQUFPLEdBQUdNLElBQUksQ0FBQyxNQUFELEVBQVMsSUFBVCxFQUFlLElBQWYsRUFBcUJoRCxNQUFNLEdBQUcscUJBQUgsR0FBMkIsSUFBdEQsQ0FBbEI7QUFDQSxRQUFJMGpCLE9BQU8sR0FBRztBQUFDQyxTQUFHLEVBQUUzZ0IsSUFBSSxDQUFDLEtBQUQsRUFBUSxDQUFDTixPQUFELENBQVIsRUFBbUIsaUJBQW5CLENBQVY7QUFBaURBLGFBQU8sRUFBRUEsT0FBMUQ7QUFDQ3dGLFNBQUcsRUFBRSxDQUROO0FBQ1NELFNBQUcsRUFBRSxDQURkO0FBQ2lCcUgsUUFBRSxFQUFFQSxFQURyQjtBQUVDc1UsbUJBQWEsRUFBRSxLQUZoQjtBQUdDQyxpQkFBVyxFQUFFdlUsRUFBRSxDQUFDd1UsU0FBSCxDQUFhLGNBQWI7QUFIZCxLQUFkO0FBSUFMLFlBQVEsQ0FBQ3RTLE9BQVQsR0FBbUIsRUFBbkIsQ0FUc0MsQ0FXdEM7O0FBQ0EsU0FBSyxJQUFJcE8sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsS0FBSzBnQixRQUFRLENBQUNNLElBQVQsR0FBZ0JOLFFBQVEsQ0FBQ00sSUFBVCxDQUFjamlCLE1BQTlCLEdBQXVDLENBQTVDLENBQWpCLEVBQWlFaUIsQ0FBQyxFQUFsRSxFQUFzRTtBQUNwRSxVQUFJdUwsSUFBSSxHQUFHdkwsQ0FBQyxHQUFHMGdCLFFBQVEsQ0FBQ00sSUFBVCxDQUFjaGhCLENBQUMsR0FBRyxDQUFsQixDQUFILEdBQTBCMGdCLFFBQVEsQ0FBQ25WLElBQS9DO0FBQUEsVUFBcURyRCxLQUFLLEdBQUksS0FBSyxDQUFuRTtBQUNBeVksYUFBTyxDQUFDemIsR0FBUixHQUFjLENBQWQ7QUFDQXliLGFBQU8sQ0FBQ00sUUFBUixHQUFtQkMsVUFBbkIsQ0FIb0UsQ0FJcEU7QUFDQTs7QUFDQSxVQUFJMVMsZUFBZSxDQUFDakMsRUFBRSxDQUFDb00sT0FBSCxDQUFXdkssT0FBWixDQUFmLEtBQXdDbEcsS0FBSyxHQUFHb0QsUUFBUSxDQUFDQyxJQUFELEVBQU9nQixFQUFFLENBQUN3SCxHQUFILENBQU96SyxTQUFkLENBQXhELENBQUosRUFDRTtBQUFFcVgsZUFBTyxDQUFDTSxRQUFSLEdBQW1CRSxpQkFBaUIsQ0FBQ1IsT0FBTyxDQUFDTSxRQUFULEVBQW1CL1ksS0FBbkIsQ0FBcEM7QUFBZ0U7O0FBQ3BFeVksYUFBTyxDQUFDL2EsR0FBUixHQUFjLEVBQWQ7QUFDQSxVQUFJd2IsbUJBQW1CLEdBQUdWLFFBQVEsSUFBSW5VLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBVzBJLGdCQUF2QixJQUEyQ3ZNLE1BQU0sQ0FBQ3ZKLElBQUQsQ0FBM0U7QUFDQStWLHVCQUFpQixDQUFDL1YsSUFBRCxFQUFPb1YsT0FBUCxFQUFnQjFJLGFBQWEsQ0FBQzFMLEVBQUQsRUFBS2hCLElBQUwsRUFBVzZWLG1CQUFYLENBQTdCLENBQWpCOztBQUNBLFVBQUk3VixJQUFJLENBQUNnTixZQUFULEVBQXVCO0FBQ3JCLFlBQUloTixJQUFJLENBQUNnTixZQUFMLENBQWtCUixPQUF0QixFQUNFO0FBQUU0SSxpQkFBTyxDQUFDNUksT0FBUixHQUFrQnJXLFdBQVcsQ0FBQzZKLElBQUksQ0FBQ2dOLFlBQUwsQ0FBa0JSLE9BQW5CLEVBQTRCNEksT0FBTyxDQUFDNUksT0FBUixJQUFtQixFQUEvQyxDQUE3QjtBQUFrRjs7QUFDdEYsWUFBSXhNLElBQUksQ0FBQ2dOLFlBQUwsQ0FBa0JQLFNBQXRCLEVBQ0U7QUFBRTJJLGlCQUFPLENBQUMzSSxTQUFSLEdBQW9CdFcsV0FBVyxDQUFDNkosSUFBSSxDQUFDZ04sWUFBTCxDQUFrQlAsU0FBbkIsRUFBOEIySSxPQUFPLENBQUMzSSxTQUFSLElBQXFCLEVBQW5ELENBQS9CO0FBQXdGO0FBQzdGLE9BaEJtRSxDQWtCcEU7OztBQUNBLFVBQUkySSxPQUFPLENBQUMvYSxHQUFSLENBQVk3RyxNQUFaLElBQXNCLENBQTFCLEVBQ0U7QUFBRTRoQixlQUFPLENBQUMvYSxHQUFSLENBQVlILElBQVosQ0FBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsRUFBdUJrYixPQUFPLENBQUNoaEIsT0FBUixDQUFnQkgsV0FBaEIsQ0FBNEIyTyxnQkFBZ0IsQ0FBQzVCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3ZLLE9BQVosQ0FBNUMsQ0FBdkI7QUFBNEYsT0FwQjVCLENBc0JwRTs7O0FBQ0EsVUFBSXBPLENBQUMsSUFBSSxDQUFULEVBQVk7QUFDVjBnQixnQkFBUSxDQUFDdFMsT0FBVCxDQUFpQnhJLEdBQWpCLEdBQXVCK2EsT0FBTyxDQUFDL2EsR0FBL0I7QUFDQThhLGdCQUFRLENBQUN0UyxPQUFULENBQWlCb1MsS0FBakIsR0FBeUIsRUFBekI7QUFDRCxPQUhELE1BR087QUFDWCxTQUFDRSxRQUFRLENBQUN0UyxPQUFULENBQWlCbVQsSUFBakIsS0FBMEJiLFFBQVEsQ0FBQ3RTLE9BQVQsQ0FBaUJtVCxJQUFqQixHQUF3QixFQUFsRCxDQUFELEVBQXdEOWIsSUFBeEQsQ0FBNkRrYixPQUFPLENBQUMvYSxHQUFyRTtBQUNPLFNBQUM4YSxRQUFRLENBQUN0UyxPQUFULENBQWlCb1QsTUFBakIsS0FBNEJkLFFBQVEsQ0FBQ3RTLE9BQVQsQ0FBaUJvVCxNQUFqQixHQUEwQixFQUF0RCxDQUFELEVBQTREL2IsSUFBNUQsQ0FBaUUsRUFBakU7QUFDRjtBQUNGLEtBMUNxQyxDQTRDdEM7OztBQUNBLFFBQUl4SSxNQUFKLEVBQVk7QUFDVixVQUFJaVosSUFBSSxHQUFHeUssT0FBTyxDQUFDaGhCLE9BQVIsQ0FBZ0I4aEIsU0FBM0I7O0FBQ0EsVUFBSSxhQUFhamxCLElBQWIsQ0FBa0IwWixJQUFJLENBQUN2WCxTQUF2QixLQUFzQ3VYLElBQUksQ0FBQ3dMLGFBQUwsSUFBc0J4TCxJQUFJLENBQUN3TCxhQUFMLENBQW1CLFNBQW5CLENBQWhFLEVBQ0U7QUFBRWYsZUFBTyxDQUFDaGhCLE9BQVIsQ0FBZ0JoQixTQUFoQixHQUE0QixrQkFBNUI7QUFBaUQ7QUFDdEQ7O0FBRUR5TixVQUFNLENBQUNHLEVBQUQsRUFBSyxZQUFMLEVBQW1CQSxFQUFuQixFQUF1Qm1VLFFBQVEsQ0FBQ25WLElBQWhDLEVBQXNDb1YsT0FBTyxDQUFDQyxHQUE5QyxDQUFOOztBQUNBLFFBQUlELE9BQU8sQ0FBQ0MsR0FBUixDQUFZamlCLFNBQWhCLEVBQ0U7QUFBRWdpQixhQUFPLENBQUMzSSxTQUFSLEdBQW9CdFcsV0FBVyxDQUFDaWYsT0FBTyxDQUFDQyxHQUFSLENBQVlqaUIsU0FBYixFQUF3QmdpQixPQUFPLENBQUMzSSxTQUFSLElBQXFCLEVBQTdDLENBQS9CO0FBQWtGOztBQUV0RixXQUFPMkksT0FBUDtBQUNEOztBQUVELFdBQVNnQiw2QkFBVCxDQUF1Q2hiLEVBQXZDLEVBQTJDO0FBQ3pDLFFBQUkwUyxLQUFLLEdBQUc1WixHQUFHLENBQUMsTUFBRCxFQUFTLFFBQVQsRUFBbUIsZ0JBQW5CLENBQWY7QUFDQTRaLFNBQUssQ0FBQ3VJLEtBQU4sR0FBYyxRQUFRamIsRUFBRSxDQUFDUyxVQUFILENBQWMsQ0FBZCxFQUFpQjFDLFFBQWpCLENBQTBCLEVBQTFCLENBQXRCO0FBQ0EyVSxTQUFLLENBQUNuWixZQUFOLENBQW1CLFlBQW5CLEVBQWlDbVosS0FBSyxDQUFDdUksS0FBdkM7QUFDQSxXQUFPdkksS0FBUDtBQUNELEdBL3VEa0IsQ0FpdkRuQjtBQUNBOzs7QUFDQSxXQUFTNkgsVUFBVCxDQUFvQlAsT0FBcEIsRUFBNkJuVixJQUE3QixFQUFtQzVMLEtBQW5DLEVBQTBDaWlCLFVBQTFDLEVBQXNEQyxRQUF0RCxFQUFnRUMsR0FBaEUsRUFBcUVDLFVBQXJFLEVBQWlGO0FBQy9FLFFBQUksQ0FBQ3hXLElBQUwsRUFBVztBQUFFO0FBQVE7O0FBQ3JCLFFBQUl5VyxXQUFXLEdBQUd0QixPQUFPLENBQUNHLFdBQVIsR0FBc0JBLFdBQVcsQ0FBQ3RWLElBQUQsRUFBT21WLE9BQU8sQ0FBQ0UsYUFBZixDQUFqQyxHQUFpRXJWLElBQW5GO0FBQ0EsUUFBSTBXLE9BQU8sR0FBR3ZCLE9BQU8sQ0FBQ3BVLEVBQVIsQ0FBV2tGLEtBQVgsQ0FBaUIwUSxZQUEvQjtBQUFBLFFBQTZDQyxRQUFRLEdBQUcsS0FBeEQ7QUFDQSxRQUFJemlCLE9BQUo7O0FBQ0EsUUFBSSxDQUFDdWlCLE9BQU8sQ0FBQzFsQixJQUFSLENBQWFnUCxJQUFiLENBQUwsRUFBeUI7QUFDdkJtVixhQUFPLENBQUN4YixHQUFSLElBQWVxRyxJQUFJLENBQUN6TSxNQUFwQjtBQUNBWSxhQUFPLEdBQUc1QyxRQUFRLENBQUNnRCxjQUFULENBQXdCa2lCLFdBQXhCLENBQVY7QUFDQXRCLGFBQU8sQ0FBQy9hLEdBQVIsQ0FBWUgsSUFBWixDQUFpQmtiLE9BQU8sQ0FBQ3piLEdBQXpCLEVBQThCeWIsT0FBTyxDQUFDemIsR0FBUixHQUFjc0csSUFBSSxDQUFDek0sTUFBakQsRUFBeURZLE9BQXpEOztBQUNBLFVBQUk5QyxFQUFFLElBQUlDLFVBQVUsR0FBRyxDQUF2QixFQUEwQjtBQUFFc2xCLGdCQUFRLEdBQUcsSUFBWDtBQUFrQjs7QUFDOUN6QixhQUFPLENBQUN6YixHQUFSLElBQWVzRyxJQUFJLENBQUN6TSxNQUFwQjtBQUNELEtBTkQsTUFNTztBQUNMWSxhQUFPLEdBQUc1QyxRQUFRLENBQUNzbEIsc0JBQVQsRUFBVjtBQUNBLFVBQUluZCxHQUFHLEdBQUcsQ0FBVjs7QUFDQSxhQUFPLElBQVAsRUFBYTtBQUNYZ2QsZUFBTyxDQUFDSSxTQUFSLEdBQW9CcGQsR0FBcEI7QUFDQSxZQUFJNEYsQ0FBQyxHQUFHb1gsT0FBTyxDQUFDdmxCLElBQVIsQ0FBYTZPLElBQWIsQ0FBUjtBQUNBLFlBQUlwRyxPQUFPLEdBQUcwRixDQUFDLEdBQUdBLENBQUMsQ0FBQ2hNLEtBQUYsR0FBVW9HLEdBQWIsR0FBbUJzRyxJQUFJLENBQUN6TSxNQUFMLEdBQWNtRyxHQUFoRDs7QUFDQSxZQUFJRSxPQUFKLEVBQWE7QUFDWCxjQUFJcUosR0FBRyxHQUFHMVIsUUFBUSxDQUFDZ0QsY0FBVCxDQUF3QmtpQixXQUFXLENBQUNwakIsS0FBWixDQUFrQnFHLEdBQWxCLEVBQXVCQSxHQUFHLEdBQUdFLE9BQTdCLENBQXhCLENBQVY7O0FBQ0EsY0FBSXZJLEVBQUUsSUFBSUMsVUFBVSxHQUFHLENBQXZCLEVBQTBCO0FBQUU2QyxtQkFBTyxDQUFDSCxXQUFSLENBQW9CQyxHQUFHLENBQUMsTUFBRCxFQUFTLENBQUNnUCxHQUFELENBQVQsQ0FBdkI7QUFBMEMsV0FBdEUsTUFDSztBQUFFOU8sbUJBQU8sQ0FBQ0gsV0FBUixDQUFvQmlQLEdBQXBCO0FBQTJCOztBQUNsQ2tTLGlCQUFPLENBQUMvYSxHQUFSLENBQVlILElBQVosQ0FBaUJrYixPQUFPLENBQUN6YixHQUF6QixFQUE4QnliLE9BQU8sQ0FBQ3piLEdBQVIsR0FBY0UsT0FBNUMsRUFBcURxSixHQUFyRDtBQUNBa1MsaUJBQU8sQ0FBQ3hiLEdBQVIsSUFBZUMsT0FBZjtBQUNBdWIsaUJBQU8sQ0FBQ3piLEdBQVIsSUFBZUUsT0FBZjtBQUNEOztBQUNELFlBQUksQ0FBQzBGLENBQUwsRUFBUTtBQUFFO0FBQU87O0FBQ2pCNUYsV0FBRyxJQUFJRSxPQUFPLEdBQUcsQ0FBakI7QUFDQSxZQUFJbWQsS0FBSyxHQUFJLEtBQUssQ0FBbEI7O0FBQ0EsWUFBSXpYLENBQUMsQ0FBQyxDQUFELENBQUQsSUFBUSxJQUFaLEVBQWtCO0FBQ2hCLGNBQUl6SCxPQUFPLEdBQUdzZCxPQUFPLENBQUNwVSxFQUFSLENBQVd1RSxPQUFYLENBQW1Cek4sT0FBakM7QUFBQSxjQUEwQ21mLFFBQVEsR0FBR25mLE9BQU8sR0FBR3NkLE9BQU8sQ0FBQ3hiLEdBQVIsR0FBYzlCLE9BQTdFO0FBQ0FrZixlQUFLLEdBQUc1aUIsT0FBTyxDQUFDSCxXQUFSLENBQW9CQyxHQUFHLENBQUMsTUFBRCxFQUFTK0YsUUFBUSxDQUFDZ2QsUUFBRCxDQUFqQixFQUE2QixRQUE3QixDQUF2QixDQUFSO0FBQ0FELGVBQUssQ0FBQ3JpQixZQUFOLENBQW1CLE1BQW5CLEVBQTJCLGNBQTNCO0FBQ0FxaUIsZUFBSyxDQUFDcmlCLFlBQU4sQ0FBbUIsU0FBbkIsRUFBOEIsSUFBOUI7QUFDQXlnQixpQkFBTyxDQUFDeGIsR0FBUixJQUFlcWQsUUFBZjtBQUNELFNBTkQsTUFNTyxJQUFJMVgsQ0FBQyxDQUFDLENBQUQsQ0FBRCxJQUFRLElBQVIsSUFBZ0JBLENBQUMsQ0FBQyxDQUFELENBQUQsSUFBUSxJQUE1QixFQUFrQztBQUN2Q3lYLGVBQUssR0FBRzVpQixPQUFPLENBQUNILFdBQVIsQ0FBb0JDLEdBQUcsQ0FBQyxNQUFELEVBQVNxTCxDQUFDLENBQUMsQ0FBRCxDQUFELElBQVEsSUFBUixHQUFlLFFBQWYsR0FBMEIsUUFBbkMsRUFBNkMsZ0JBQTdDLENBQXZCLENBQVI7QUFDQXlYLGVBQUssQ0FBQ3JpQixZQUFOLENBQW1CLFNBQW5CLEVBQThCNEssQ0FBQyxDQUFDLENBQUQsQ0FBL0I7QUFDQTZWLGlCQUFPLENBQUN4YixHQUFSLElBQWUsQ0FBZjtBQUNELFNBSk0sTUFJQTtBQUNMb2QsZUFBSyxHQUFHNUIsT0FBTyxDQUFDcFUsRUFBUixDQUFXdUUsT0FBWCxDQUFtQjJSLHNCQUFuQixDQUEwQzNYLENBQUMsQ0FBQyxDQUFELENBQTNDLENBQVI7QUFDQXlYLGVBQUssQ0FBQ3JpQixZQUFOLENBQW1CLFNBQW5CLEVBQThCNEssQ0FBQyxDQUFDLENBQUQsQ0FBL0I7O0FBQ0EsY0FBSWpPLEVBQUUsSUFBSUMsVUFBVSxHQUFHLENBQXZCLEVBQTBCO0FBQUU2QyxtQkFBTyxDQUFDSCxXQUFSLENBQW9CQyxHQUFHLENBQUMsTUFBRCxFQUFTLENBQUM4aUIsS0FBRCxDQUFULENBQXZCO0FBQTRDLFdBQXhFLE1BQ0s7QUFBRTVpQixtQkFBTyxDQUFDSCxXQUFSLENBQW9CK2lCLEtBQXBCO0FBQTZCOztBQUNwQzVCLGlCQUFPLENBQUN4YixHQUFSLElBQWUsQ0FBZjtBQUNEOztBQUNEd2IsZUFBTyxDQUFDL2EsR0FBUixDQUFZSCxJQUFaLENBQWlCa2IsT0FBTyxDQUFDemIsR0FBekIsRUFBOEJ5YixPQUFPLENBQUN6YixHQUFSLEdBQWMsQ0FBNUMsRUFBK0NxZCxLQUEvQztBQUNBNUIsZUFBTyxDQUFDemIsR0FBUjtBQUNEO0FBQ0Y7O0FBQ0R5YixXQUFPLENBQUNFLGFBQVIsR0FBd0JvQixXQUFXLENBQUM3YSxVQUFaLENBQXVCb0UsSUFBSSxDQUFDek0sTUFBTCxHQUFjLENBQXJDLEtBQTJDLEVBQW5FOztBQUNBLFFBQUlhLEtBQUssSUFBSWlpQixVQUFULElBQXVCQyxRQUF2QixJQUFtQ00sUUFBbkMsSUFBK0NMLEdBQS9DLElBQXNEQyxVQUExRCxFQUFzRTtBQUNwRSxVQUFJVSxTQUFTLEdBQUc5aUIsS0FBSyxJQUFJLEVBQXpCOztBQUNBLFVBQUlpaUIsVUFBSixFQUFnQjtBQUFFYSxpQkFBUyxJQUFJYixVQUFiO0FBQTBCOztBQUM1QyxVQUFJQyxRQUFKLEVBQWM7QUFBRVksaUJBQVMsSUFBSVosUUFBYjtBQUF3Qjs7QUFDeEMsVUFBSXpJLEtBQUssR0FBRzVaLEdBQUcsQ0FBQyxNQUFELEVBQVMsQ0FBQ0UsT0FBRCxDQUFULEVBQW9CK2lCLFNBQXBCLEVBQStCWCxHQUEvQixDQUFmOztBQUNBLFVBQUlDLFVBQUosRUFBZ0I7QUFDZCxhQUFLLElBQUlXLElBQVQsSUFBaUJYLFVBQWpCLEVBQTZCO0FBQUUsY0FBSUEsVUFBVSxDQUFDOWUsY0FBWCxDQUEwQnlmLElBQTFCLEtBQW1DQSxJQUFJLElBQUksT0FBM0MsSUFBc0RBLElBQUksSUFBSSxPQUFsRSxFQUM3QjtBQUFFdEosaUJBQUssQ0FBQ25aLFlBQU4sQ0FBbUJ5aUIsSUFBbkIsRUFBeUJYLFVBQVUsQ0FBQ1csSUFBRCxDQUFuQztBQUE2QztBQUFFO0FBQ3BEOztBQUNELGFBQU9oQyxPQUFPLENBQUNoaEIsT0FBUixDQUFnQkgsV0FBaEIsQ0FBNEI2WixLQUE1QixDQUFQO0FBQ0Q7O0FBQ0RzSCxXQUFPLENBQUNoaEIsT0FBUixDQUFnQkgsV0FBaEIsQ0FBNEJHLE9BQTVCO0FBQ0QsR0FsekRrQixDQW96RG5CO0FBQ0E7OztBQUNBLFdBQVNtaEIsV0FBVCxDQUFxQnRWLElBQXJCLEVBQTJCb1gsY0FBM0IsRUFBMkM7QUFDekMsUUFBSXBYLElBQUksQ0FBQ3pNLE1BQUwsR0FBYyxDQUFkLElBQW1CLENBQUMsS0FBS3ZDLElBQUwsQ0FBVWdQLElBQVYsQ0FBeEIsRUFBeUM7QUFBRSxhQUFPQSxJQUFQO0FBQWE7O0FBQ3hELFFBQUlxWCxXQUFXLEdBQUdELGNBQWxCO0FBQUEsUUFBa0M1VCxNQUFNLEdBQUcsRUFBM0M7O0FBQ0EsU0FBSyxJQUFJaFAsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3dMLElBQUksQ0FBQ3pNLE1BQXpCLEVBQWlDaUIsQ0FBQyxFQUFsQyxFQUFzQztBQUNwQyxVQUFJMkcsRUFBRSxHQUFHNkUsSUFBSSxDQUFDaEUsTUFBTCxDQUFZeEgsQ0FBWixDQUFUOztBQUNBLFVBQUkyRyxFQUFFLElBQUksR0FBTixJQUFha2MsV0FBYixLQUE2QjdpQixDQUFDLElBQUl3TCxJQUFJLENBQUN6TSxNQUFMLEdBQWMsQ0FBbkIsSUFBd0J5TSxJQUFJLENBQUNwRSxVQUFMLENBQWdCcEgsQ0FBQyxHQUFHLENBQXBCLEtBQTBCLEVBQS9FLENBQUosRUFDRTtBQUFFMkcsVUFBRSxHQUFHLE1BQUw7QUFBZ0I7O0FBQ3BCcUksWUFBTSxJQUFJckksRUFBVjtBQUNBa2MsaUJBQVcsR0FBR2xjLEVBQUUsSUFBSSxHQUFwQjtBQUNEOztBQUNELFdBQU9xSSxNQUFQO0FBQ0QsR0FqMERrQixDQW0wRG5CO0FBQ0E7OztBQUNBLFdBQVNtUyxpQkFBVCxDQUEyQnpOLEtBQTNCLEVBQWtDeEwsS0FBbEMsRUFBeUM7QUFDdkMsV0FBTyxVQUFVeVksT0FBVixFQUFtQm5WLElBQW5CLEVBQXlCNUwsS0FBekIsRUFBZ0NpaUIsVUFBaEMsRUFBNENDLFFBQTVDLEVBQXNEQyxHQUF0RCxFQUEyREMsVUFBM0QsRUFBdUU7QUFDNUVwaUIsV0FBSyxHQUFHQSxLQUFLLEdBQUdBLEtBQUssR0FBRyxrQkFBWCxHQUFnQyxpQkFBN0M7QUFDQSxVQUFJUyxLQUFLLEdBQUdzZ0IsT0FBTyxDQUFDemIsR0FBcEI7QUFBQSxVQUF5QjVFLEdBQUcsR0FBR0QsS0FBSyxHQUFHbUwsSUFBSSxDQUFDek0sTUFBNUM7O0FBQ0EsZUFBUztBQUNQO0FBQ0EsWUFBSXFKLElBQUksR0FBSSxLQUFLLENBQWpCOztBQUNBLGFBQUssSUFBSXBJLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdrSSxLQUFLLENBQUNuSixNQUExQixFQUFrQ2lCLENBQUMsRUFBbkMsRUFBdUM7QUFDckNvSSxjQUFJLEdBQUdGLEtBQUssQ0FBQ2xJLENBQUQsQ0FBWjs7QUFDQSxjQUFJb0ksSUFBSSxDQUFDUixFQUFMLEdBQVV2SCxLQUFWLElBQW1CK0gsSUFBSSxDQUFDVCxJQUFMLElBQWF0SCxLQUFwQyxFQUEyQztBQUFFO0FBQU87QUFDckQ7O0FBQ0QsWUFBSStILElBQUksQ0FBQ1IsRUFBTCxJQUFXdEgsR0FBZixFQUFvQjtBQUFFLGlCQUFPb1QsS0FBSyxDQUFDaU4sT0FBRCxFQUFVblYsSUFBVixFQUFnQjVMLEtBQWhCLEVBQXVCaWlCLFVBQXZCLEVBQW1DQyxRQUFuQyxFQUE2Q0MsR0FBN0MsRUFBa0RDLFVBQWxELENBQVo7QUFBMkU7O0FBQ2pHdE8sYUFBSyxDQUFDaU4sT0FBRCxFQUFVblYsSUFBSSxDQUFDM00sS0FBTCxDQUFXLENBQVgsRUFBY3VKLElBQUksQ0FBQ1IsRUFBTCxHQUFVdkgsS0FBeEIsQ0FBVixFQUEwQ1QsS0FBMUMsRUFBaURpaUIsVUFBakQsRUFBNkQsSUFBN0QsRUFBbUVFLEdBQW5FLEVBQXdFQyxVQUF4RSxDQUFMO0FBQ0FILGtCQUFVLEdBQUcsSUFBYjtBQUNBclcsWUFBSSxHQUFHQSxJQUFJLENBQUMzTSxLQUFMLENBQVd1SixJQUFJLENBQUNSLEVBQUwsR0FBVXZILEtBQXJCLENBQVA7QUFDQUEsYUFBSyxHQUFHK0gsSUFBSSxDQUFDUixFQUFiO0FBQ0Q7QUFDRixLQWhCRDtBQWlCRDs7QUFFRCxXQUFTa2Isa0JBQVQsQ0FBNEJuQyxPQUE1QixFQUFxQzFNLElBQXJDLEVBQTJDMkcsTUFBM0MsRUFBbURtSSxZQUFuRCxFQUFpRTtBQUMvRCxRQUFJQyxNQUFNLEdBQUcsQ0FBQ0QsWUFBRCxJQUFpQm5JLE1BQU0sQ0FBQzBFLFVBQXJDOztBQUNBLFFBQUkwRCxNQUFKLEVBQVk7QUFBRXJDLGFBQU8sQ0FBQy9hLEdBQVIsQ0FBWUgsSUFBWixDQUFpQmtiLE9BQU8sQ0FBQ3piLEdBQXpCLEVBQThCeWIsT0FBTyxDQUFDemIsR0FBUixHQUFjK08sSUFBNUMsRUFBa0QrTyxNQUFsRDtBQUE0RDs7QUFDMUUsUUFBSSxDQUFDRCxZQUFELElBQWlCcEMsT0FBTyxDQUFDcFUsRUFBUixDQUFXb00sT0FBWCxDQUFtQnNLLEtBQW5CLENBQXlCQyxxQkFBOUMsRUFBcUU7QUFDbkUsVUFBSSxDQUFDRixNQUFMLEVBQ0U7QUFBRUEsY0FBTSxHQUFHckMsT0FBTyxDQUFDaGhCLE9BQVIsQ0FBZ0JILFdBQWhCLENBQTRCekMsUUFBUSxDQUFDOEMsYUFBVCxDQUF1QixNQUF2QixDQUE1QixDQUFUO0FBQXVFOztBQUMzRW1qQixZQUFNLENBQUM5aUIsWUFBUCxDQUFvQixXQUFwQixFQUFpQzBhLE1BQU0sQ0FBQy9XLEVBQXhDO0FBQ0Q7O0FBQ0QsUUFBSW1mLE1BQUosRUFBWTtBQUNWckMsYUFBTyxDQUFDcFUsRUFBUixDQUFXb00sT0FBWCxDQUFtQnNLLEtBQW5CLENBQXlCRSxhQUF6QixDQUF1Q0gsTUFBdkM7QUFDQXJDLGFBQU8sQ0FBQ2hoQixPQUFSLENBQWdCSCxXQUFoQixDQUE0QndqQixNQUE1QjtBQUNEOztBQUNEckMsV0FBTyxDQUFDemIsR0FBUixJQUFlK08sSUFBZjtBQUNBME0sV0FBTyxDQUFDRSxhQUFSLEdBQXdCLEtBQXhCO0FBQ0QsR0F2MkRrQixDQXkyRG5CO0FBQ0E7OztBQUNBLFdBQVNTLGlCQUFULENBQTJCL1YsSUFBM0IsRUFBaUNvVixPQUFqQyxFQUEwQzlJLE1BQTFDLEVBQWtEO0FBQ2hELFFBQUlpRCxLQUFLLEdBQUd2UCxJQUFJLENBQUMyUCxXQUFqQjtBQUFBLFFBQThCa0ksT0FBTyxHQUFHN1gsSUFBSSxDQUFDQyxJQUE3QztBQUFBLFFBQW1EUixFQUFFLEdBQUcsQ0FBeEQ7O0FBQ0EsUUFBSSxDQUFDOFAsS0FBTCxFQUFZO0FBQ1YsV0FBSyxJQUFJcFIsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBR21PLE1BQU0sQ0FBQzlZLE1BQS9CLEVBQXVDMkssR0FBRyxJQUFFLENBQTVDLEVBQ0U7QUFBRWlYLGVBQU8sQ0FBQ00sUUFBUixDQUFpQk4sT0FBakIsRUFBMEJ5QyxPQUFPLENBQUN2a0IsS0FBUixDQUFjbU0sRUFBZCxFQUFrQkEsRUFBRSxHQUFHNk0sTUFBTSxDQUFDbk8sR0FBRCxDQUE3QixDQUExQixFQUErRDZXLG1CQUFtQixDQUFDMUksTUFBTSxDQUFDbk8sR0FBRyxHQUFDLENBQUwsQ0FBUCxFQUFnQmlYLE9BQU8sQ0FBQ3BVLEVBQVIsQ0FBV3VFLE9BQTNCLENBQWxGO0FBQXlIOztBQUM3SDtBQUNEOztBQUVELFFBQUl0SCxHQUFHLEdBQUc0WixPQUFPLENBQUNya0IsTUFBbEI7QUFBQSxRQUEwQm1HLEdBQUcsR0FBRyxDQUFoQztBQUFBLFFBQW1DbEYsQ0FBQyxHQUFHLENBQXZDO0FBQUEsUUFBMEN3TCxJQUFJLEdBQUcsRUFBakQ7QUFBQSxRQUFxRDVMLEtBQXJEO0FBQUEsUUFBNERtaUIsR0FBNUQ7QUFDQSxRQUFJc0IsVUFBVSxHQUFHLENBQWpCO0FBQUEsUUFBb0JDLFNBQXBCO0FBQUEsUUFBK0JDLFlBQS9CO0FBQUEsUUFBNkNDLGNBQTdDO0FBQUEsUUFBNkRqRixTQUE3RDtBQUFBLFFBQXdFeUQsVUFBeEU7O0FBQ0EsYUFBUztBQUNQLFVBQUlxQixVQUFVLElBQUluZSxHQUFsQixFQUF1QjtBQUFFO0FBQ3ZCb2UsaUJBQVMsR0FBR0MsWUFBWSxHQUFHQyxjQUFjLEdBQUd6QixHQUFHLEdBQUcsRUFBbEQ7QUFDQUMsa0JBQVUsR0FBRyxJQUFiO0FBQ0F6RCxpQkFBUyxHQUFHLElBQVo7QUFBa0I4RSxrQkFBVSxHQUFHSSxRQUFiO0FBQ2xCLFlBQUlDLGNBQWMsR0FBRyxFQUFyQjtBQUFBLFlBQXlCQyxTQUFTLEdBQUksS0FBSyxDQUEzQzs7QUFDQSxhQUFLLElBQUl0WixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHeVEsS0FBSyxDQUFDL2IsTUFBMUIsRUFBa0MsRUFBRXNMLENBQXBDLEVBQXVDO0FBQ3JDLGNBQUlpVSxFQUFFLEdBQUd4RCxLQUFLLENBQUN6USxDQUFELENBQWQ7QUFBQSxjQUFtQlMsQ0FBQyxHQUFHd1QsRUFBRSxDQUFDMUQsTUFBMUI7O0FBQ0EsY0FBSTlQLENBQUMsQ0FBQ2xCLElBQUYsSUFBVSxVQUFWLElBQXdCMFUsRUFBRSxDQUFDM1csSUFBSCxJQUFXekMsR0FBbkMsSUFBMEM0RixDQUFDLENBQUN3VSxVQUFoRCxFQUE0RDtBQUMxRG9FLDBCQUFjLENBQUNqZSxJQUFmLENBQW9CcUYsQ0FBcEI7QUFDRCxXQUZELE1BRU8sSUFBSXdULEVBQUUsQ0FBQzNXLElBQUgsSUFBV3pDLEdBQVgsS0FBbUJvWixFQUFFLENBQUMxVyxFQUFILElBQVMsSUFBVCxJQUFpQjBXLEVBQUUsQ0FBQzFXLEVBQUgsR0FBUTFDLEdBQXpCLElBQWdDNEYsQ0FBQyxDQUFDeVQsU0FBRixJQUFlRCxFQUFFLENBQUMxVyxFQUFILElBQVMxQyxHQUF4QixJQUErQm9aLEVBQUUsQ0FBQzNXLElBQUgsSUFBV3pDLEdBQTdGLENBQUosRUFBdUc7QUFDNUcsZ0JBQUlvWixFQUFFLENBQUMxVyxFQUFILElBQVMsSUFBVCxJQUFpQjBXLEVBQUUsQ0FBQzFXLEVBQUgsSUFBUzFDLEdBQTFCLElBQWlDbWUsVUFBVSxHQUFHL0UsRUFBRSxDQUFDMVcsRUFBckQsRUFBeUQ7QUFDdkR5Yix3QkFBVSxHQUFHL0UsRUFBRSxDQUFDMVcsRUFBaEI7QUFDQTJiLDBCQUFZLEdBQUcsRUFBZjtBQUNEOztBQUNELGdCQUFJelksQ0FBQyxDQUFDbk0sU0FBTixFQUFpQjtBQUFFMmtCLHVCQUFTLElBQUksTUFBTXhZLENBQUMsQ0FBQ25NLFNBQXJCO0FBQWlDOztBQUNwRCxnQkFBSW1NLENBQUMsQ0FBQ2lYLEdBQU4sRUFBVztBQUFFQSxpQkFBRyxHQUFHLENBQUNBLEdBQUcsR0FBR0EsR0FBRyxHQUFHLEdBQVQsR0FBZSxFQUFuQixJQUF5QmpYLENBQUMsQ0FBQ2lYLEdBQWpDO0FBQXVDOztBQUNwRCxnQkFBSWpYLENBQUMsQ0FBQytXLFVBQUYsSUFBZ0J2RCxFQUFFLENBQUMzVyxJQUFILElBQVd6QyxHQUEvQixFQUFvQztBQUFFc2UsNEJBQWMsSUFBSSxNQUFNMVksQ0FBQyxDQUFDK1csVUFBMUI7QUFBdUM7O0FBQzdFLGdCQUFJL1csQ0FBQyxDQUFDZ1gsUUFBRixJQUFjeEQsRUFBRSxDQUFDMVcsRUFBSCxJQUFTeWIsVUFBM0IsRUFBdUM7QUFBRSxlQUFDTSxTQUFTLEtBQUtBLFNBQVMsR0FBRyxFQUFqQixDQUFWLEVBQWdDbGUsSUFBaEMsQ0FBcUNxRixDQUFDLENBQUNnWCxRQUF2QyxFQUFpRHhELEVBQUUsQ0FBQzFXLEVBQXBEO0FBQTBELGFBUlMsQ0FTNUc7QUFDQTs7O0FBQ0EsZ0JBQUlrRCxDQUFDLENBQUM4VyxLQUFOLEVBQWE7QUFBRSxlQUFDSSxVQUFVLEtBQUtBLFVBQVUsR0FBRyxFQUFsQixDQUFYLEVBQWtDSixLQUFsQyxHQUEwQzlXLENBQUMsQ0FBQzhXLEtBQTVDO0FBQW9EOztBQUNuRSxnQkFBSTlXLENBQUMsQ0FBQ2tYLFVBQU4sRUFBa0I7QUFDaEIsbUJBQUssSUFBSVcsSUFBVCxJQUFpQjdYLENBQUMsQ0FBQ2tYLFVBQW5CLEVBQ0U7QUFBRSxpQkFBQ0EsVUFBVSxLQUFLQSxVQUFVLEdBQUcsRUFBbEIsQ0FBWCxFQUFrQ1csSUFBbEMsSUFBMEM3WCxDQUFDLENBQUNrWCxVQUFGLENBQWFXLElBQWIsQ0FBMUM7QUFBK0Q7QUFDcEU7O0FBQ0QsZ0JBQUk3WCxDQUFDLENBQUN5VCxTQUFGLEtBQWdCLENBQUNBLFNBQUQsSUFBY1QsdUJBQXVCLENBQUNTLFNBQVMsQ0FBQzNELE1BQVgsRUFBbUI5UCxDQUFuQixDQUF2QixHQUErQyxDQUE3RSxDQUFKLEVBQ0U7QUFBRXlULHVCQUFTLEdBQUdELEVBQVo7QUFBaUI7QUFDdEIsV0FsQk0sTUFrQkEsSUFBSUEsRUFBRSxDQUFDM1csSUFBSCxHQUFVekMsR0FBVixJQUFpQm1lLFVBQVUsR0FBRy9FLEVBQUUsQ0FBQzNXLElBQXJDLEVBQTJDO0FBQ2hEMGIsc0JBQVUsR0FBRy9FLEVBQUUsQ0FBQzNXLElBQWhCO0FBQ0Q7QUFDRjs7QUFDRCxZQUFJZ2MsU0FBSixFQUFlO0FBQUUsZUFBSyxJQUFJOVksR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBRzhZLFNBQVMsQ0FBQzVrQixNQUFsQyxFQUEwQzhMLEdBQUcsSUFBSSxDQUFqRCxFQUNmO0FBQUUsZ0JBQUk4WSxTQUFTLENBQUM5WSxHQUFHLEdBQUcsQ0FBUCxDQUFULElBQXNCd1ksVUFBMUIsRUFBc0M7QUFBRUUsMEJBQVksSUFBSSxNQUFNSSxTQUFTLENBQUM5WSxHQUFELENBQS9CO0FBQXVDO0FBQUU7QUFBRTs7QUFFdkYsWUFBSSxDQUFDMFQsU0FBRCxJQUFjQSxTQUFTLENBQUM1VyxJQUFWLElBQWtCekMsR0FBcEMsRUFBeUM7QUFBRSxlQUFLLElBQUlnRyxHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHd1ksY0FBYyxDQUFDM2tCLE1BQXZDLEVBQStDLEVBQUVtTSxHQUFqRCxFQUN6QztBQUFFNFgsOEJBQWtCLENBQUNuQyxPQUFELEVBQVUsQ0FBVixFQUFhK0MsY0FBYyxDQUFDeFksR0FBRCxDQUEzQixDQUFsQjtBQUFzRDtBQUFFOztBQUM1RCxZQUFJcVQsU0FBUyxJQUFJLENBQUNBLFNBQVMsQ0FBQzVXLElBQVYsSUFBa0IsQ0FBbkIsS0FBeUJ6QyxHQUExQyxFQUErQztBQUM3QzRkLDRCQUFrQixDQUFDbkMsT0FBRCxFQUFVLENBQUNwQyxTQUFTLENBQUMzVyxFQUFWLElBQWdCLElBQWhCLEdBQXVCNEIsR0FBRyxHQUFHLENBQTdCLEdBQWlDK1UsU0FBUyxDQUFDM1csRUFBNUMsSUFBa0QxQyxHQUE1RCxFQUNDcVosU0FBUyxDQUFDM0QsTUFEWCxFQUNtQjJELFNBQVMsQ0FBQzVXLElBQVYsSUFBa0IsSUFEckMsQ0FBbEI7O0FBRUEsY0FBSTRXLFNBQVMsQ0FBQzNXLEVBQVYsSUFBZ0IsSUFBcEIsRUFBMEI7QUFBRTtBQUFROztBQUNwQyxjQUFJMlcsU0FBUyxDQUFDM1csRUFBVixJQUFnQjFDLEdBQXBCLEVBQXlCO0FBQUVxWixxQkFBUyxHQUFHLEtBQVo7QUFBb0I7QUFDaEQ7QUFDRjs7QUFDRCxVQUFJclosR0FBRyxJQUFJc0UsR0FBWCxFQUFnQjtBQUFFO0FBQU87O0FBRXpCLFVBQUlvYSxJQUFJLEdBQUd2ZSxJQUFJLENBQUNDLEdBQUwsQ0FBU2tFLEdBQVQsRUFBYzZaLFVBQWQsQ0FBWDs7QUFDQSxhQUFPLElBQVAsRUFBYTtBQUNYLFlBQUk3WCxJQUFKLEVBQVU7QUFDUixjQUFJbEwsR0FBRyxHQUFHNEUsR0FBRyxHQUFHc0csSUFBSSxDQUFDek0sTUFBckI7O0FBQ0EsY0FBSSxDQUFDd2YsU0FBTCxFQUFnQjtBQUNkLGdCQUFJc0YsU0FBUyxHQUFHdmpCLEdBQUcsR0FBR3NqQixJQUFOLEdBQWFwWSxJQUFJLENBQUMzTSxLQUFMLENBQVcsQ0FBWCxFQUFjK2tCLElBQUksR0FBRzFlLEdBQXJCLENBQWIsR0FBeUNzRyxJQUF6RDtBQUNBbVYsbUJBQU8sQ0FBQ00sUUFBUixDQUFpQk4sT0FBakIsRUFBMEJrRCxTQUExQixFQUFxQ2prQixLQUFLLEdBQUdBLEtBQUssR0FBRzBqQixTQUFYLEdBQXVCQSxTQUFqRSxFQUNpQkUsY0FEakIsRUFDaUN0ZSxHQUFHLEdBQUcyZSxTQUFTLENBQUM5a0IsTUFBaEIsSUFBMEJza0IsVUFBMUIsR0FBdUNFLFlBQXZDLEdBQXNELEVBRHZGLEVBQzJGeEIsR0FEM0YsRUFDZ0dDLFVBRGhHO0FBRUQ7O0FBQ0QsY0FBSTFoQixHQUFHLElBQUlzakIsSUFBWCxFQUFpQjtBQUFDcFksZ0JBQUksR0FBR0EsSUFBSSxDQUFDM00sS0FBTCxDQUFXK2tCLElBQUksR0FBRzFlLEdBQWxCLENBQVA7QUFBK0JBLGVBQUcsR0FBRzBlLElBQU47QUFBWTtBQUFNOztBQUNuRTFlLGFBQUcsR0FBRzVFLEdBQU47QUFDQWtqQix3QkFBYyxHQUFHLEVBQWpCO0FBQ0Q7O0FBQ0RoWSxZQUFJLEdBQUc0WCxPQUFPLENBQUN2a0IsS0FBUixDQUFjbU0sRUFBZCxFQUFrQkEsRUFBRSxHQUFHNk0sTUFBTSxDQUFDN1gsQ0FBQyxFQUFGLENBQTdCLENBQVA7QUFDQUosYUFBSyxHQUFHMmdCLG1CQUFtQixDQUFDMUksTUFBTSxDQUFDN1gsQ0FBQyxFQUFGLENBQVAsRUFBYzJnQixPQUFPLENBQUNwVSxFQUFSLENBQVd1RSxPQUF6QixDQUEzQjtBQUNEO0FBQ0Y7QUFDRixHQXA3RGtCLENBdTdEbkI7QUFDQTtBQUNBOzs7QUFDQSxXQUFTZ1QsUUFBVCxDQUFrQi9QLEdBQWxCLEVBQXVCeEksSUFBdkIsRUFBNkIwVCxLQUE3QixFQUFvQztBQUNsQztBQUNBLFNBQUsxVCxJQUFMLEdBQVlBLElBQVosQ0FGa0MsQ0FHbEM7O0FBQ0EsU0FBS3lWLElBQUwsR0FBWWpDLG1CQUFtQixDQUFDeFQsSUFBRCxDQUEvQixDQUprQyxDQUtsQzs7QUFDQSxTQUFLMEksSUFBTCxHQUFZLEtBQUsrTSxJQUFMLEdBQVlsTSxNQUFNLENBQUNwUCxHQUFHLENBQUMsS0FBS3NiLElBQU4sQ0FBSixDQUFOLEdBQXlCL0IsS0FBekIsR0FBaUMsQ0FBN0MsR0FBaUQsQ0FBN0Q7QUFDQSxTQUFLeGdCLElBQUwsR0FBWSxLQUFLK00sSUFBTCxHQUFZLElBQXhCO0FBQ0EsU0FBS3VZLE1BQUwsR0FBYzFFLFlBQVksQ0FBQ3RMLEdBQUQsRUFBTXhJLElBQU4sQ0FBMUI7QUFDRCxHQW44RGtCLENBcThEbkI7OztBQUNBLFdBQVN5WSxjQUFULENBQXdCelgsRUFBeEIsRUFBNEI1RSxJQUE1QixFQUFrQ0MsRUFBbEMsRUFBc0M7QUFDcEMsUUFBSXJELEtBQUssR0FBRyxFQUFaO0FBQUEsUUFBZ0IwZixPQUFoQjs7QUFDQSxTQUFLLElBQUkvZSxHQUFHLEdBQUd5QyxJQUFmLEVBQXFCekMsR0FBRyxHQUFHMEMsRUFBM0IsRUFBK0IxQyxHQUFHLEdBQUcrZSxPQUFyQyxFQUE4QztBQUM1QyxVQUFJQyxJQUFJLEdBQUcsSUFBSUosUUFBSixDQUFhdlgsRUFBRSxDQUFDd0gsR0FBaEIsRUFBcUJELE9BQU8sQ0FBQ3ZILEVBQUUsQ0FBQ3dILEdBQUosRUFBUzdPLEdBQVQsQ0FBNUIsRUFBMkNBLEdBQTNDLENBQVg7QUFDQStlLGFBQU8sR0FBRy9lLEdBQUcsR0FBR2dmLElBQUksQ0FBQ2pRLElBQXJCO0FBQ0ExUCxXQUFLLENBQUNrQixJQUFOLENBQVd5ZSxJQUFYO0FBQ0Q7O0FBQ0QsV0FBTzNmLEtBQVA7QUFDRDs7QUFFRCxNQUFJNGYsY0FBYyxHQUFHLElBQXJCOztBQUVBLFdBQVNDLGFBQVQsQ0FBdUJDLEVBQXZCLEVBQTJCO0FBQ3pCLFFBQUlGLGNBQUosRUFBb0I7QUFDbEJBLG9CQUFjLENBQUNHLEdBQWYsQ0FBbUI3ZSxJQUFuQixDQUF3QjRlLEVBQXhCO0FBQ0QsS0FGRCxNQUVPO0FBQ0xBLFFBQUUsQ0FBQ0UsU0FBSCxHQUFlSixjQUFjLEdBQUc7QUFDOUJHLFdBQUcsRUFBRSxDQUFDRCxFQUFELENBRHlCO0FBRTlCRyx3QkFBZ0IsRUFBRTtBQUZZLE9BQWhDO0FBSUQ7QUFDRjs7QUFFRCxXQUFTQyxtQkFBVCxDQUE2QkMsS0FBN0IsRUFBb0M7QUFDbEM7QUFDQTtBQUNBLFFBQUlDLFNBQVMsR0FBR0QsS0FBSyxDQUFDRixnQkFBdEI7QUFBQSxRQUF3Q3hrQixDQUFDLEdBQUcsQ0FBNUM7O0FBQ0EsT0FBRztBQUNELGFBQU9BLENBQUMsR0FBRzJrQixTQUFTLENBQUM1bEIsTUFBckIsRUFBNkJpQixDQUFDLEVBQTlCLEVBQ0U7QUFBRTJrQixpQkFBUyxDQUFDM2tCLENBQUQsQ0FBVCxDQUFhMEMsSUFBYixDQUFrQixJQUFsQjtBQUEwQjs7QUFDOUIsV0FBSyxJQUFJMkgsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3FhLEtBQUssQ0FBQ0osR0FBTixDQUFVdmxCLE1BQTlCLEVBQXNDc0wsQ0FBQyxFQUF2QyxFQUEyQztBQUN6QyxZQUFJZ2EsRUFBRSxHQUFHSyxLQUFLLENBQUNKLEdBQU4sQ0FBVWphLENBQVYsQ0FBVDs7QUFDQSxZQUFJZ2EsRUFBRSxDQUFDclgsc0JBQVAsRUFDRTtBQUFFLGlCQUFPcVgsRUFBRSxDQUFDTyxvQkFBSCxHQUEwQlAsRUFBRSxDQUFDclgsc0JBQUgsQ0FBMEJqTyxNQUEzRCxFQUNBO0FBQUVzbEIsY0FBRSxDQUFDclgsc0JBQUgsQ0FBMEJxWCxFQUFFLENBQUNPLG9CQUFILEVBQTFCLEVBQXFEbGlCLElBQXJELENBQTBELElBQTFELEVBQWdFMmhCLEVBQUUsQ0FBQzlYLEVBQW5FO0FBQXlFO0FBQUU7QUFDbEY7QUFDRixLQVRELFFBU1N2TSxDQUFDLEdBQUcya0IsU0FBUyxDQUFDNWxCLE1BVHZCO0FBVUQ7O0FBRUQsV0FBUzhsQixlQUFULENBQXlCUixFQUF6QixFQUE2QlMsS0FBN0IsRUFBb0M7QUFDbEMsUUFBSUosS0FBSyxHQUFHTCxFQUFFLENBQUNFLFNBQWY7O0FBQ0EsUUFBSSxDQUFDRyxLQUFMLEVBQVk7QUFBRTtBQUFROztBQUV0QixRQUFJO0FBQUVELHlCQUFtQixDQUFDQyxLQUFELENBQW5CO0FBQTZCLEtBQW5DLFNBQ1E7QUFDTlAsb0JBQWMsR0FBRyxJQUFqQjtBQUNBVyxXQUFLLENBQUNKLEtBQUQsQ0FBTDtBQUNEO0FBQ0Y7O0FBRUQsTUFBSUssc0JBQXNCLEdBQUcsSUFBN0IsQ0F4L0RtQixDQTAvRG5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFdBQVNDLFdBQVQsQ0FBcUJyWixPQUFyQixFQUE4Qi9CO0FBQUs7QUFBbkMsSUFBb0Q7QUFDbEQsUUFBSWpFLEdBQUcsR0FBR3FHLFdBQVcsQ0FBQ0wsT0FBRCxFQUFVL0IsSUFBVixDQUFyQjs7QUFDQSxRQUFJLENBQUNqRSxHQUFHLENBQUM1RyxNQUFULEVBQWlCO0FBQUU7QUFBUTs7QUFDM0IsUUFBSXdELElBQUksR0FBR0MsS0FBSyxDQUFDQyxTQUFOLENBQWdCNUQsS0FBaEIsQ0FBc0I2RCxJQUF0QixDQUEyQkMsU0FBM0IsRUFBc0MsQ0FBdEMsQ0FBWDtBQUFBLFFBQXFEc2lCLElBQXJEOztBQUNBLFFBQUlkLGNBQUosRUFBb0I7QUFDbEJjLFVBQUksR0FBR2QsY0FBYyxDQUFDSyxnQkFBdEI7QUFDRCxLQUZELE1BRU8sSUFBSU8sc0JBQUosRUFBNEI7QUFDakNFLFVBQUksR0FBR0Ysc0JBQVA7QUFDRCxLQUZNLE1BRUE7QUFDTEUsVUFBSSxHQUFHRixzQkFBc0IsR0FBRyxFQUFoQztBQUNBNWdCLGdCQUFVLENBQUMrZ0IsaUJBQUQsRUFBb0IsQ0FBcEIsQ0FBVjtBQUNEOztBQUNELFFBQUkzTixJQUFJLEdBQUcsU0FBUEEsSUFBTyxDQUFXdlgsQ0FBWCxFQUFlO0FBQ3hCaWxCLFVBQUksQ0FBQ3hmLElBQUwsQ0FBVSxZQUFZO0FBQUUsZUFBT0UsR0FBRyxDQUFDM0YsQ0FBRCxDQUFILENBQU80QyxLQUFQLENBQWEsSUFBYixFQUFtQkwsSUFBbkIsQ0FBUDtBQUFrQyxPQUExRDtBQUNELEtBRkQ7O0FBSUEsU0FBSyxJQUFJdkMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzJGLEdBQUcsQ0FBQzVHLE1BQXhCLEVBQWdDLEVBQUVpQixDQUFsQztBQUNFdVgsVUFBSSxDQUFFdlgsQ0FBRixDQUFKO0FBREY7QUFFRDs7QUFFRCxXQUFTa2xCLGlCQUFULEdBQTZCO0FBQzNCLFFBQUlDLE9BQU8sR0FBR0osc0JBQWQ7QUFDQUEsMEJBQXNCLEdBQUcsSUFBekI7O0FBQ0EsU0FBSyxJQUFJL2tCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdtbEIsT0FBTyxDQUFDcG1CLE1BQTVCLEVBQW9DLEVBQUVpQixDQUF0QyxFQUF5QztBQUFFbWxCLGFBQU8sQ0FBQ25sQixDQUFELENBQVA7QUFBZTtBQUMzRCxHQXpoRWtCLENBMmhFbkI7QUFDQTtBQUNBOzs7QUFDQSxXQUFTb2xCLG9CQUFULENBQThCN1ksRUFBOUIsRUFBa0NtVSxRQUFsQyxFQUE0Q3pCLEtBQTVDLEVBQW1Eb0csSUFBbkQsRUFBeUQ7QUFDdkQsU0FBSyxJQUFJaGIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3FXLFFBQVEsQ0FBQzRFLE9BQVQsQ0FBaUJ2bUIsTUFBckMsRUFBNkNzTCxDQUFDLEVBQTlDLEVBQWtEO0FBQ2hELFVBQUlULElBQUksR0FBRzhXLFFBQVEsQ0FBQzRFLE9BQVQsQ0FBaUJqYixDQUFqQixDQUFYOztBQUNBLFVBQUlULElBQUksSUFBSSxNQUFaLEVBQW9CO0FBQUUyYixzQkFBYyxDQUFDaFosRUFBRCxFQUFLbVUsUUFBTCxDQUFkO0FBQStCLE9BQXJELE1BQ0ssSUFBSTlXLElBQUksSUFBSSxRQUFaLEVBQXNCO0FBQUU0Yix3QkFBZ0IsQ0FBQ2paLEVBQUQsRUFBS21VLFFBQUwsRUFBZXpCLEtBQWYsRUFBc0JvRyxJQUF0QixDQUFoQjtBQUE4QyxPQUF0RSxNQUNBLElBQUl6YixJQUFJLElBQUksT0FBWixFQUFxQjtBQUFFNmIseUJBQWlCLENBQUNsWixFQUFELEVBQUttVSxRQUFMLENBQWpCO0FBQWtDLE9BQXpELE1BQ0EsSUFBSTlXLElBQUksSUFBSSxRQUFaLEVBQXNCO0FBQUU4Yix5QkFBaUIsQ0FBQ25aLEVBQUQsRUFBS21VLFFBQUwsRUFBZTJFLElBQWYsQ0FBakI7QUFBd0M7QUFDdEU7O0FBQ0QzRSxZQUFRLENBQUM0RSxPQUFULEdBQW1CLElBQW5CO0FBQ0QsR0F2aUVrQixDQXlpRW5CO0FBQ0E7OztBQUNBLFdBQVNLLGlCQUFULENBQTJCakYsUUFBM0IsRUFBcUM7QUFDbkMsUUFBSUEsUUFBUSxDQUFDamlCLElBQVQsSUFBaUJpaUIsUUFBUSxDQUFDbFYsSUFBOUIsRUFBb0M7QUFDbENrVixjQUFRLENBQUNqaUIsSUFBVCxHQUFnQmdCLEdBQUcsQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjLElBQWQsRUFBb0Isb0JBQXBCLENBQW5COztBQUNBLFVBQUlpaEIsUUFBUSxDQUFDbFYsSUFBVCxDQUFjMUssVUFBbEIsRUFDRTtBQUFFNGYsZ0JBQVEsQ0FBQ2xWLElBQVQsQ0FBYzFLLFVBQWQsQ0FBeUI4a0IsWUFBekIsQ0FBc0NsRixRQUFRLENBQUNqaUIsSUFBL0MsRUFBcURpaUIsUUFBUSxDQUFDbFYsSUFBOUQ7QUFBc0U7O0FBQzFFa1YsY0FBUSxDQUFDamlCLElBQVQsQ0FBY2UsV0FBZCxDQUEwQmtoQixRQUFRLENBQUNsVixJQUFuQzs7QUFDQSxVQUFJM08sRUFBRSxJQUFJQyxVQUFVLEdBQUcsQ0FBdkIsRUFBMEI7QUFBRTRqQixnQkFBUSxDQUFDamlCLElBQVQsQ0FBY21CLEtBQWQsQ0FBb0JpbUIsTUFBcEIsR0FBNkIsQ0FBN0I7QUFBaUM7QUFDOUQ7O0FBQ0QsV0FBT25GLFFBQVEsQ0FBQ2ppQixJQUFoQjtBQUNEOztBQUVELFdBQVNxbkIsb0JBQVQsQ0FBOEJ2WixFQUE5QixFQUFrQ21VLFFBQWxDLEVBQTRDO0FBQzFDLFFBQUlwaUIsR0FBRyxHQUFHb2lCLFFBQVEsQ0FBQzNJLE9BQVQsR0FBbUIySSxRQUFRLENBQUMzSSxPQUFULEdBQW1CLEdBQW5CLElBQTBCMkksUUFBUSxDQUFDblYsSUFBVCxDQUFjd00sT0FBZCxJQUF5QixFQUFuRCxDQUFuQixHQUE0RTJJLFFBQVEsQ0FBQ25WLElBQVQsQ0FBY3dNLE9BQXBHOztBQUNBLFFBQUl6WixHQUFKLEVBQVM7QUFBRUEsU0FBRyxJQUFJLDRCQUFQO0FBQXNDOztBQUNqRCxRQUFJb2lCLFFBQVEsQ0FBQ3FGLFVBQWIsRUFBeUI7QUFDdkIsVUFBSXpuQixHQUFKLEVBQVM7QUFBRW9pQixnQkFBUSxDQUFDcUYsVUFBVCxDQUFvQnBuQixTQUFwQixHQUFnQ0wsR0FBaEM7QUFBc0MsT0FBakQsTUFDSztBQUFFb2lCLGdCQUFRLENBQUNxRixVQUFULENBQW9CamxCLFVBQXBCLENBQStCMUIsV0FBL0IsQ0FBMkNzaEIsUUFBUSxDQUFDcUYsVUFBcEQ7QUFBaUVyRixnQkFBUSxDQUFDcUYsVUFBVCxHQUFzQixJQUF0QjtBQUE2QjtBQUN0RyxLQUhELE1BR08sSUFBSXpuQixHQUFKLEVBQVM7QUFDZCxVQUFJMG5CLElBQUksR0FBR0wsaUJBQWlCLENBQUNqRixRQUFELENBQTVCO0FBQ0FBLGNBQVEsQ0FBQ3FGLFVBQVQsR0FBc0JDLElBQUksQ0FBQ0MsWUFBTCxDQUFrQnhtQixHQUFHLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBY25CLEdBQWQsQ0FBckIsRUFBeUMwbkIsSUFBSSxDQUFDM21CLFVBQTlDLENBQXRCO0FBQ0FrTixRQUFFLENBQUNvTSxPQUFILENBQVdzSyxLQUFYLENBQWlCRSxhQUFqQixDQUErQnpDLFFBQVEsQ0FBQ3FGLFVBQXhDO0FBQ0Q7QUFDRixHQWprRWtCLENBbWtFbkI7QUFDQTs7O0FBQ0EsV0FBU0csY0FBVCxDQUF3QjNaLEVBQXhCLEVBQTRCbVUsUUFBNUIsRUFBc0M7QUFDcEMsUUFBSXlGLEdBQUcsR0FBRzVaLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBVzBJLGdCQUFyQjs7QUFDQSxRQUFJOEUsR0FBRyxJQUFJQSxHQUFHLENBQUM1YSxJQUFKLElBQVltVixRQUFRLENBQUNuVixJQUFoQyxFQUFzQztBQUNwQ2dCLFFBQUUsQ0FBQ29NLE9BQUgsQ0FBVzBJLGdCQUFYLEdBQThCLElBQTlCO0FBQ0FYLGNBQVEsQ0FBQ3RTLE9BQVQsR0FBbUIrWCxHQUFHLENBQUMvWCxPQUF2QjtBQUNBLGFBQU8rWCxHQUFHLENBQUNDLEtBQVg7QUFDRDs7QUFDRCxXQUFPM0YsZ0JBQWdCLENBQUNsVSxFQUFELEVBQUttVSxRQUFMLENBQXZCO0FBQ0QsR0E3a0VrQixDQStrRW5CO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBUzZFLGNBQVQsQ0FBd0JoWixFQUF4QixFQUE0Qm1VLFFBQTVCLEVBQXNDO0FBQ3BDLFFBQUlwaUIsR0FBRyxHQUFHb2lCLFFBQVEsQ0FBQ2xWLElBQVQsQ0FBYzdNLFNBQXhCO0FBQ0EsUUFBSXluQixLQUFLLEdBQUdGLGNBQWMsQ0FBQzNaLEVBQUQsRUFBS21VLFFBQUwsQ0FBMUI7O0FBQ0EsUUFBSUEsUUFBUSxDQUFDbFYsSUFBVCxJQUFpQmtWLFFBQVEsQ0FBQ2ppQixJQUE5QixFQUFvQztBQUFFaWlCLGNBQVEsQ0FBQ2ppQixJQUFULEdBQWdCMm5CLEtBQUssQ0FBQ3hGLEdBQXRCO0FBQTRCOztBQUNsRUYsWUFBUSxDQUFDbFYsSUFBVCxDQUFjMUssVUFBZCxDQUF5QjhrQixZQUF6QixDQUFzQ1EsS0FBSyxDQUFDeEYsR0FBNUMsRUFBaURGLFFBQVEsQ0FBQ2xWLElBQTFEO0FBQ0FrVixZQUFRLENBQUNsVixJQUFULEdBQWdCNGEsS0FBSyxDQUFDeEYsR0FBdEI7O0FBQ0EsUUFBSXdGLEtBQUssQ0FBQ3JPLE9BQU4sSUFBaUIySSxRQUFRLENBQUMzSSxPQUExQixJQUFxQ3FPLEtBQUssQ0FBQ3BPLFNBQU4sSUFBbUIwSSxRQUFRLENBQUMxSSxTQUFyRSxFQUFnRjtBQUM5RTBJLGNBQVEsQ0FBQzNJLE9BQVQsR0FBbUJxTyxLQUFLLENBQUNyTyxPQUF6QjtBQUNBMkksY0FBUSxDQUFDMUksU0FBVCxHQUFxQm9PLEtBQUssQ0FBQ3BPLFNBQTNCO0FBQ0F5Tix1QkFBaUIsQ0FBQ2xaLEVBQUQsRUFBS21VLFFBQUwsQ0FBakI7QUFDRCxLQUpELE1BSU8sSUFBSXBpQixHQUFKLEVBQVM7QUFDZG9pQixjQUFRLENBQUNsVixJQUFULENBQWM3TSxTQUFkLEdBQTBCTCxHQUExQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBU21uQixpQkFBVCxDQUEyQmxaLEVBQTNCLEVBQStCbVUsUUFBL0IsRUFBeUM7QUFDdkNvRix3QkFBb0IsQ0FBQ3ZaLEVBQUQsRUFBS21VLFFBQUwsQ0FBcEI7O0FBQ0EsUUFBSUEsUUFBUSxDQUFDblYsSUFBVCxDQUFjOGEsU0FBbEIsRUFDRTtBQUFFVix1QkFBaUIsQ0FBQ2pGLFFBQUQsQ0FBakIsQ0FBNEIvaEIsU0FBNUIsR0FBd0MraEIsUUFBUSxDQUFDblYsSUFBVCxDQUFjOGEsU0FBdEQ7QUFBa0UsS0FEdEUsTUFFSyxJQUFJM0YsUUFBUSxDQUFDamlCLElBQVQsSUFBaUJpaUIsUUFBUSxDQUFDbFYsSUFBOUIsRUFDSDtBQUFFa1YsY0FBUSxDQUFDamlCLElBQVQsQ0FBY0UsU0FBZCxHQUEwQixFQUExQjtBQUErQjs7QUFDbkMsUUFBSXFaLFNBQVMsR0FBRzBJLFFBQVEsQ0FBQzFJLFNBQVQsR0FBcUIwSSxRQUFRLENBQUMxSSxTQUFULEdBQXFCLEdBQXJCLElBQTRCMEksUUFBUSxDQUFDblYsSUFBVCxDQUFjeU0sU0FBZCxJQUEyQixFQUF2RCxDQUFyQixHQUFrRjBJLFFBQVEsQ0FBQ25WLElBQVQsQ0FBY3lNLFNBQWhIO0FBQ0EwSSxZQUFRLENBQUNsVixJQUFULENBQWM3TSxTQUFkLEdBQTBCcVosU0FBUyxJQUFJLEVBQXZDO0FBQ0Q7O0FBRUQsV0FBU3dOLGdCQUFULENBQTBCalosRUFBMUIsRUFBOEJtVSxRQUE5QixFQUF3Q3pCLEtBQXhDLEVBQStDb0csSUFBL0MsRUFBcUQ7QUFDbkQsUUFBSTNFLFFBQVEsQ0FBQzRGLE1BQWIsRUFBcUI7QUFDbkI1RixjQUFRLENBQUNqaUIsSUFBVCxDQUFjVyxXQUFkLENBQTBCc2hCLFFBQVEsQ0FBQzRGLE1BQW5DO0FBQ0E1RixjQUFRLENBQUM0RixNQUFULEdBQWtCLElBQWxCO0FBQ0Q7O0FBQ0QsUUFBSTVGLFFBQVEsQ0FBQzZGLGdCQUFiLEVBQStCO0FBQzdCN0YsY0FBUSxDQUFDamlCLElBQVQsQ0FBY1csV0FBZCxDQUEwQnNoQixRQUFRLENBQUM2RixnQkFBbkM7QUFDQTdGLGNBQVEsQ0FBQzZGLGdCQUFULEdBQTRCLElBQTVCO0FBQ0Q7O0FBQ0QsUUFBSTdGLFFBQVEsQ0FBQ25WLElBQVQsQ0FBY2liLFdBQWxCLEVBQStCO0FBQzdCLFVBQUlSLElBQUksR0FBR0wsaUJBQWlCLENBQUNqRixRQUFELENBQTVCO0FBQ0FBLGNBQVEsQ0FBQzZGLGdCQUFULEdBQTRCOW1CLEdBQUcsQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjLGtDQUFrQ2loQixRQUFRLENBQUNuVixJQUFULENBQWNpYixXQUE5RCxFQUNFLFlBQVlqYSxFQUFFLENBQUN1RSxPQUFILENBQVcyVixXQUFYLEdBQXlCcEIsSUFBSSxDQUFDcUIsUUFBOUIsR0FBeUMsQ0FBQ3JCLElBQUksQ0FBQ3NCLGdCQUEzRCxJQUErRSxhQUEvRSxHQUFnR3RCLElBQUksQ0FBQ3NCLGdCQUFyRyxHQUF5SCxJQUQzSCxDQUEvQjtBQUVBcGEsUUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQkUsYUFBakIsQ0FBK0J6QyxRQUFRLENBQUM2RixnQkFBeEM7QUFDQVAsVUFBSSxDQUFDQyxZQUFMLENBQWtCdkYsUUFBUSxDQUFDNkYsZ0JBQTNCLEVBQTZDN0YsUUFBUSxDQUFDbFYsSUFBdEQ7QUFDRDs7QUFDRCxRQUFJdVIsT0FBTyxHQUFHMkQsUUFBUSxDQUFDblYsSUFBVCxDQUFjcWIsYUFBNUI7O0FBQ0EsUUFBSXJhLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVytWLFdBQVgsSUFBMEI5SixPQUE5QixFQUF1QztBQUNyQyxVQUFJK0osTUFBTSxHQUFHbkIsaUJBQWlCLENBQUNqRixRQUFELENBQTlCO0FBQ0EsVUFBSXFHLFVBQVUsR0FBR3JHLFFBQVEsQ0FBQzRGLE1BQVQsR0FBa0I3bUIsR0FBRyxDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMsMkJBQWQsRUFBNEMsWUFBWThNLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVzJWLFdBQVgsR0FBeUJwQixJQUFJLENBQUNxQixRQUE5QixHQUF5QyxDQUFDckIsSUFBSSxDQUFDc0IsZ0JBQTNELElBQStFLElBQTNILENBQXRDO0FBQ0FwYSxRQUFFLENBQUNvTSxPQUFILENBQVdzSyxLQUFYLENBQWlCRSxhQUFqQixDQUErQjRELFVBQS9CO0FBQ0FELFlBQU0sQ0FBQ2IsWUFBUCxDQUFvQmMsVUFBcEIsRUFBZ0NyRyxRQUFRLENBQUNsVixJQUF6Qzs7QUFDQSxVQUFJa1YsUUFBUSxDQUFDblYsSUFBVCxDQUFjaWIsV0FBbEIsRUFDRTtBQUFFTyxrQkFBVSxDQUFDcG9CLFNBQVgsSUFBd0IsTUFBTStoQixRQUFRLENBQUNuVixJQUFULENBQWNpYixXQUE1QztBQUEwRDs7QUFDOUQsVUFBSWphLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVytWLFdBQVgsS0FBMkIsQ0FBQzlKLE9BQUQsSUFBWSxDQUFDQSxPQUFPLENBQUMsd0JBQUQsQ0FBL0MsQ0FBSixFQUNFO0FBQUUyRCxnQkFBUSxDQUFDc0csVUFBVCxHQUFzQkQsVUFBVSxDQUFDdm5CLFdBQVgsQ0FDdEJDLEdBQUcsQ0FBQyxLQUFELEVBQVE0VixhQUFhLENBQUM5SSxFQUFFLENBQUN1RSxPQUFKLEVBQWFtTyxLQUFiLENBQXJCLEVBQ0MsNkNBREQsRUFFRSxXQUFZb0csSUFBSSxDQUFDNEIsVUFBTCxDQUFnQix3QkFBaEIsQ0FBWixHQUF5RCxhQUF6RCxHQUEwRTFhLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3VPLGlCQUFyRixHQUEwRyxJQUY1RyxDQURtQixDQUF0QjtBQUd5SDs7QUFDN0gsVUFBSW5LLE9BQUosRUFBYTtBQUFFLGFBQUssSUFBSW9LLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc1YSxFQUFFLENBQUNvTSxPQUFILENBQVd5TyxXQUFYLENBQXVCcm9CLE1BQTNDLEVBQW1ELEVBQUVvb0IsQ0FBckQsRUFBd0Q7QUFDckUsY0FBSXRqQixFQUFFLEdBQUcwSSxFQUFFLENBQUNvTSxPQUFILENBQVd5TyxXQUFYLENBQXVCRCxDQUF2QixFQUEwQnhvQixTQUFuQztBQUFBLGNBQThDd0osS0FBSyxHQUFHNFUsT0FBTyxDQUFDN1osY0FBUixDQUF1QlcsRUFBdkIsS0FBOEJrWixPQUFPLENBQUNsWixFQUFELENBQTNGOztBQUNBLGNBQUlzRSxLQUFKLEVBQ0U7QUFBRTRlLHNCQUFVLENBQUN2bkIsV0FBWCxDQUF1QkMsR0FBRyxDQUFDLEtBQUQsRUFBUSxDQUFDMEksS0FBRCxDQUFSLEVBQWlCLHVCQUFqQixFQUNBLFdBQVlrZCxJQUFJLENBQUM0QixVQUFMLENBQWdCcGpCLEVBQWhCLENBQVosR0FBbUMsYUFBbkMsR0FBb0R3aEIsSUFBSSxDQUFDZ0MsV0FBTCxDQUFpQnhqQixFQUFqQixDQUFwRCxHQUE0RSxJQUQ1RSxDQUExQjtBQUNnSDtBQUNySDtBQUFFO0FBQ0o7QUFDRjs7QUFFRCxXQUFTNmhCLGlCQUFULENBQTJCblosRUFBM0IsRUFBK0JtVSxRQUEvQixFQUF5QzJFLElBQXpDLEVBQStDO0FBQzdDLFFBQUkzRSxRQUFRLENBQUM0RyxTQUFiLEVBQXdCO0FBQUU1RyxjQUFRLENBQUM0RyxTQUFULEdBQXFCLElBQXJCO0FBQTRCOztBQUN0RCxRQUFJQyxRQUFRLEdBQUdscEIsU0FBUyxDQUFDLHVCQUFELENBQXhCOztBQUNBLFNBQUssSUFBSUksSUFBSSxHQUFHaWlCLFFBQVEsQ0FBQ2ppQixJQUFULENBQWNZLFVBQXpCLEVBQXFDcVQsSUFBSSxHQUFJLEtBQUssQ0FBdkQsRUFBMkRqVSxJQUEzRCxFQUFpRUEsSUFBSSxHQUFHaVUsSUFBeEUsRUFBOEU7QUFDNUVBLFVBQUksR0FBR2pVLElBQUksQ0FBQytvQixXQUFaOztBQUNBLFVBQUlELFFBQVEsQ0FBQy9xQixJQUFULENBQWNpQyxJQUFJLENBQUNFLFNBQW5CLENBQUosRUFBbUM7QUFBRStoQixnQkFBUSxDQUFDamlCLElBQVQsQ0FBY1csV0FBZCxDQUEwQlgsSUFBMUI7QUFBa0M7QUFDeEU7O0FBQ0RncEIscUJBQWlCLENBQUNsYixFQUFELEVBQUttVSxRQUFMLEVBQWUyRSxJQUFmLENBQWpCO0FBQ0QsR0F6cEVrQixDQTJwRW5COzs7QUFDQSxXQUFTcUMsZ0JBQVQsQ0FBMEJuYixFQUExQixFQUE4Qm1VLFFBQTlCLEVBQXdDekIsS0FBeEMsRUFBK0NvRyxJQUEvQyxFQUFxRDtBQUNuRCxRQUFJZSxLQUFLLEdBQUdGLGNBQWMsQ0FBQzNaLEVBQUQsRUFBS21VLFFBQUwsQ0FBMUI7QUFDQUEsWUFBUSxDQUFDbFYsSUFBVCxHQUFnQmtWLFFBQVEsQ0FBQ2ppQixJQUFULEdBQWdCMm5CLEtBQUssQ0FBQ3hGLEdBQXRDOztBQUNBLFFBQUl3RixLQUFLLENBQUNyTyxPQUFWLEVBQW1CO0FBQUUySSxjQUFRLENBQUMzSSxPQUFULEdBQW1CcU8sS0FBSyxDQUFDck8sT0FBekI7QUFBbUM7O0FBQ3hELFFBQUlxTyxLQUFLLENBQUNwTyxTQUFWLEVBQXFCO0FBQUUwSSxjQUFRLENBQUMxSSxTQUFULEdBQXFCb08sS0FBSyxDQUFDcE8sU0FBM0I7QUFBdUM7O0FBRTlEeU4scUJBQWlCLENBQUNsWixFQUFELEVBQUttVSxRQUFMLENBQWpCO0FBQ0E4RSxvQkFBZ0IsQ0FBQ2paLEVBQUQsRUFBS21VLFFBQUwsRUFBZXpCLEtBQWYsRUFBc0JvRyxJQUF0QixDQUFoQjtBQUNBb0MscUJBQWlCLENBQUNsYixFQUFELEVBQUttVSxRQUFMLEVBQWUyRSxJQUFmLENBQWpCO0FBQ0EsV0FBTzNFLFFBQVEsQ0FBQ2ppQixJQUFoQjtBQUNELEdBdHFFa0IsQ0F3cUVuQjtBQUNBOzs7QUFDQSxXQUFTZ3BCLGlCQUFULENBQTJCbGIsRUFBM0IsRUFBK0JtVSxRQUEvQixFQUF5QzJFLElBQXpDLEVBQStDO0FBQzdDc0Msd0JBQW9CLENBQUNwYixFQUFELEVBQUttVSxRQUFRLENBQUNuVixJQUFkLEVBQW9CbVYsUUFBcEIsRUFBOEIyRSxJQUE5QixFQUFvQyxJQUFwQyxDQUFwQjs7QUFDQSxRQUFJM0UsUUFBUSxDQUFDTSxJQUFiLEVBQW1CO0FBQUUsV0FBSyxJQUFJaGhCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcwZ0IsUUFBUSxDQUFDTSxJQUFULENBQWNqaUIsTUFBbEMsRUFBMENpQixDQUFDLEVBQTNDLEVBQ25CO0FBQUUybkIsNEJBQW9CLENBQUNwYixFQUFELEVBQUttVSxRQUFRLENBQUNNLElBQVQsQ0FBY2hoQixDQUFkLENBQUwsRUFBdUIwZ0IsUUFBdkIsRUFBaUMyRSxJQUFqQyxFQUF1QyxLQUF2QyxDQUFwQjtBQUFvRTtBQUFFO0FBQzNFOztBQUVELFdBQVNzQyxvQkFBVCxDQUE4QnBiLEVBQTlCLEVBQWtDaEIsSUFBbEMsRUFBd0NtVixRQUF4QyxFQUFrRDJFLElBQWxELEVBQXdEdUMsVUFBeEQsRUFBb0U7QUFDbEUsUUFBSSxDQUFDcmMsSUFBSSxDQUFDc2MsT0FBVixFQUFtQjtBQUFFO0FBQVE7O0FBQzdCLFFBQUk3QixJQUFJLEdBQUdMLGlCQUFpQixDQUFDakYsUUFBRCxDQUE1Qjs7QUFDQSxTQUFLLElBQUkxZ0IsQ0FBQyxHQUFHLENBQVIsRUFBVzhuQixFQUFFLEdBQUd2YyxJQUFJLENBQUNzYyxPQUExQixFQUFtQzduQixDQUFDLEdBQUc4bkIsRUFBRSxDQUFDL29CLE1BQTFDLEVBQWtELEVBQUVpQixDQUFwRCxFQUF1RDtBQUNyRCxVQUFJZ2pCLE1BQU0sR0FBRzhFLEVBQUUsQ0FBQzluQixDQUFELENBQWY7QUFBQSxVQUFvQnZCLElBQUksR0FBR2dCLEdBQUcsQ0FBQyxLQUFELEVBQVEsQ0FBQ3VqQixNQUFNLENBQUN2a0IsSUFBUixDQUFSLEVBQXVCLDJCQUEyQnVrQixNQUFNLENBQUNya0IsU0FBUCxHQUFtQixNQUFNcWtCLE1BQU0sQ0FBQ3JrQixTQUFoQyxHQUE0QyxFQUF2RSxDQUF2QixDQUE5Qjs7QUFDQSxVQUFJLENBQUNxa0IsTUFBTSxDQUFDK0UsaUJBQVosRUFBK0I7QUFBRXRwQixZQUFJLENBQUN5QixZQUFMLENBQWtCLGtCQUFsQixFQUFzQyxNQUF0QztBQUFnRDs7QUFDakY4bkIsd0JBQWtCLENBQUNoRixNQUFELEVBQVN2a0IsSUFBVCxFQUFlaWlCLFFBQWYsRUFBeUIyRSxJQUF6QixDQUFsQjtBQUNBOVksUUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQkUsYUFBakIsQ0FBK0Ixa0IsSUFBL0I7O0FBQ0EsVUFBSW1wQixVQUFVLElBQUk1RSxNQUFNLENBQUNpRixLQUF6QixFQUNFO0FBQUVqQyxZQUFJLENBQUNDLFlBQUwsQ0FBa0J4bkIsSUFBbEIsRUFBd0JpaUIsUUFBUSxDQUFDNEYsTUFBVCxJQUFtQjVGLFFBQVEsQ0FBQ2xWLElBQXBEO0FBQTRELE9BRGhFLE1BR0U7QUFBRXdhLFlBQUksQ0FBQ3htQixXQUFMLENBQWlCZixJQUFqQjtBQUF5Qjs7QUFDN0J1bUIsaUJBQVcsQ0FBQ2hDLE1BQUQsRUFBUyxRQUFULENBQVg7QUFDRDtBQUNGOztBQUVELFdBQVNnRixrQkFBVCxDQUE0QmhGLE1BQTVCLEVBQW9DdmtCLElBQXBDLEVBQTBDaWlCLFFBQTFDLEVBQW9EMkUsSUFBcEQsRUFBMEQ7QUFDeEQsUUFBSXJDLE1BQU0sQ0FBQ2tGLFNBQVgsRUFBc0I7QUFDeEIsT0FBQ3hILFFBQVEsQ0FBQzRHLFNBQVQsS0FBdUI1RyxRQUFRLENBQUM0RyxTQUFULEdBQXFCLEVBQTVDLENBQUQsRUFBa0Q3aEIsSUFBbEQsQ0FBdURoSCxJQUF2RDtBQUNJLFVBQUkwcEIsS0FBSyxHQUFHOUMsSUFBSSxDQUFDK0MsWUFBakI7QUFDQTNwQixVQUFJLENBQUNtQixLQUFMLENBQVdpUCxJQUFYLEdBQWtCd1csSUFBSSxDQUFDcUIsUUFBTCxHQUFnQixJQUFsQzs7QUFDQSxVQUFJLENBQUMxRCxNQUFNLENBQUNxRixXQUFaLEVBQXlCO0FBQ3ZCRixhQUFLLElBQUk5QyxJQUFJLENBQUNzQixnQkFBZDtBQUNBbG9CLFlBQUksQ0FBQ21CLEtBQUwsQ0FBVzBvQixXQUFYLEdBQXlCakQsSUFBSSxDQUFDc0IsZ0JBQUwsR0FBd0IsSUFBakQ7QUFDRDs7QUFDRGxvQixVQUFJLENBQUNtQixLQUFMLENBQVd1b0IsS0FBWCxHQUFtQkEsS0FBSyxHQUFHLElBQTNCO0FBQ0Q7O0FBQ0QsUUFBSW5GLE1BQU0sQ0FBQ3FGLFdBQVgsRUFBd0I7QUFDdEI1cEIsVUFBSSxDQUFDbUIsS0FBTCxDQUFXaW1CLE1BQVgsR0FBb0IsQ0FBcEI7QUFDQXBuQixVQUFJLENBQUNtQixLQUFMLENBQVcyb0IsUUFBWCxHQUFzQixVQUF0Qjs7QUFDQSxVQUFJLENBQUN2RixNQUFNLENBQUNrRixTQUFaLEVBQXVCO0FBQUV6cEIsWUFBSSxDQUFDbUIsS0FBTCxDQUFXNG9CLFVBQVgsR0FBd0IsQ0FBQ25ELElBQUksQ0FBQ3NCLGdCQUFOLEdBQXlCLElBQWpEO0FBQXdEO0FBQ2xGO0FBQ0Y7O0FBRUQsV0FBUzhCLFlBQVQsQ0FBc0J6RixNQUF0QixFQUE4QjtBQUM1QixRQUFJQSxNQUFNLENBQUNwTyxNQUFQLElBQWlCLElBQXJCLEVBQTJCO0FBQUUsYUFBT29PLE1BQU0sQ0FBQ3BPLE1BQWQ7QUFBc0I7O0FBQ25ELFFBQUlySSxFQUFFLEdBQUd5VyxNQUFNLENBQUNqUCxHQUFQLENBQVd4SCxFQUFwQjs7QUFDQSxRQUFJLENBQUNBLEVBQUwsRUFBUztBQUFFLGFBQU8sQ0FBUDtBQUFVOztBQUNyQixRQUFJLENBQUNyTCxRQUFRLENBQUNuRSxRQUFRLENBQUM0RCxJQUFWLEVBQWdCcWlCLE1BQU0sQ0FBQ3ZrQixJQUF2QixDQUFiLEVBQTJDO0FBQ3pDLFVBQUlpcUIsV0FBVyxHQUFHLHFCQUFsQjs7QUFDQSxVQUFJMUYsTUFBTSxDQUFDcUYsV0FBWCxFQUNFO0FBQUVLLG1CQUFXLElBQUksbUJBQW1CbmMsRUFBRSxDQUFDb00sT0FBSCxDQUFXZ1EsT0FBWCxDQUFtQnJhLFdBQXRDLEdBQW9ELEtBQW5FO0FBQTJFOztBQUMvRSxVQUFJMFUsTUFBTSxDQUFDa0YsU0FBWCxFQUNFO0FBQUVRLG1CQUFXLElBQUksWUFBWW5jLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV2lRLE9BQVgsQ0FBbUJDLFdBQS9CLEdBQTZDLEtBQTVEO0FBQW9FOztBQUN4RXZwQiwwQkFBb0IsQ0FBQ2lOLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3ZLLE9BQVosRUFBcUIzTyxHQUFHLENBQUMsS0FBRCxFQUFRLENBQUN1akIsTUFBTSxDQUFDdmtCLElBQVIsQ0FBUixFQUF1QixJQUF2QixFQUE2QmlxQixXQUE3QixDQUF4QixDQUFwQjtBQUNEOztBQUNELFdBQU8xRixNQUFNLENBQUNwTyxNQUFQLEdBQWdCb08sTUFBTSxDQUFDdmtCLElBQVAsQ0FBWXFDLFVBQVosQ0FBdUJ1TixZQUE5QztBQUNELEdBL3RFa0IsQ0FpdUVuQjs7O0FBQ0EsV0FBU3lhLGFBQVQsQ0FBdUJuUSxPQUF2QixFQUFnQzFaLENBQWhDLEVBQW1DO0FBQ2pDLFNBQUssSUFBSXdFLENBQUMsR0FBR2lLLFFBQVEsQ0FBQ3pPLENBQUQsQ0FBckIsRUFBMEJ3RSxDQUFDLElBQUlrVixPQUFPLENBQUNpUSxPQUF2QyxFQUFnRG5sQixDQUFDLEdBQUdBLENBQUMsQ0FBQzNDLFVBQXRELEVBQWtFO0FBQ2hFLFVBQUksQ0FBQzJDLENBQUQsSUFBT0EsQ0FBQyxDQUFDckMsUUFBRixJQUFjLENBQWQsSUFBbUJxQyxDQUFDLENBQUNzbEIsWUFBRixDQUFlLGtCQUFmLEtBQXNDLE1BQWhFLElBQ0N0bEIsQ0FBQyxDQUFDM0MsVUFBRixJQUFnQjZYLE9BQU8sQ0FBQ3FRLEtBQXhCLElBQWlDdmxCLENBQUMsSUFBSWtWLE9BQU8sQ0FBQ3NRLEtBRG5ELEVBRUU7QUFBRSxlQUFPLElBQVA7QUFBYTtBQUNsQjtBQUNGLEdBeHVFa0IsQ0EwdUVuQjs7O0FBRUEsV0FBU0MsVUFBVCxDQUFvQnZRLE9BQXBCLEVBQTZCO0FBQUMsV0FBT0EsT0FBTyxDQUFDd1EsU0FBUixDQUFrQkMsU0FBekI7QUFBbUM7O0FBQ2pFLFdBQVNDLFdBQVQsQ0FBcUIxUSxPQUFyQixFQUE4QjtBQUFDLFdBQU9BLE9BQU8sQ0FBQ3NRLEtBQVIsQ0FBYzVhLFlBQWQsR0FBNkJzSyxPQUFPLENBQUN3USxTQUFSLENBQWtCOWEsWUFBdEQ7QUFBbUU7O0FBQ2xHLFdBQVNpYixRQUFULENBQWtCM1EsT0FBbEIsRUFBMkI7QUFDekIsUUFBSUEsT0FBTyxDQUFDNFEsY0FBWixFQUE0QjtBQUFFLGFBQU81USxPQUFPLENBQUM0USxjQUFmO0FBQStCOztBQUM3RCxRQUFJdHFCLENBQUMsR0FBR0ssb0JBQW9CLENBQUNxWixPQUFPLENBQUN2SyxPQUFULEVBQWtCM08sR0FBRyxDQUFDLEtBQUQsRUFBUSxHQUFSLEVBQWEsc0JBQWIsQ0FBckIsQ0FBNUI7QUFDQSxRQUFJRyxLQUFLLEdBQUd5UCxNQUFNLENBQUNtYSxnQkFBUCxHQUEwQm5hLE1BQU0sQ0FBQ21hLGdCQUFQLENBQXdCdnFCLENBQXhCLENBQTFCLEdBQXVEQSxDQUFDLENBQUN3cUIsWUFBckU7QUFDQSxRQUFJQyxJQUFJLEdBQUc7QUFBQzdhLFVBQUksRUFBRThhLFFBQVEsQ0FBQy9wQixLQUFLLENBQUMwb0IsV0FBUCxDQUFmO0FBQW9DeFosV0FBSyxFQUFFNmEsUUFBUSxDQUFDL3BCLEtBQUssQ0FBQ2dxQixZQUFQO0FBQW5ELEtBQVg7O0FBQ0EsUUFBSSxDQUFDQyxLQUFLLENBQUNILElBQUksQ0FBQzdhLElBQU4sQ0FBTixJQUFxQixDQUFDZ2IsS0FBSyxDQUFDSCxJQUFJLENBQUM1YSxLQUFOLENBQS9CLEVBQTZDO0FBQUU2SixhQUFPLENBQUM0USxjQUFSLEdBQXlCRyxJQUF6QjtBQUFnQzs7QUFDL0UsV0FBT0EsSUFBUDtBQUNEOztBQUVELFdBQVNJLFNBQVQsQ0FBbUJ2ZCxFQUFuQixFQUF1QjtBQUFFLFdBQU8vSCxXQUFXLEdBQUcrSCxFQUFFLENBQUNvTSxPQUFILENBQVdvUixjQUFoQztBQUFnRDs7QUFDekUsV0FBU0MsWUFBVCxDQUFzQnpkLEVBQXRCLEVBQTBCO0FBQ3hCLFdBQU9BLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NSLFFBQVgsQ0FBb0JwQixXQUFwQixHQUFrQ2lCLFNBQVMsQ0FBQ3ZkLEVBQUQsQ0FBM0MsR0FBa0RBLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3VSLFFBQXBFO0FBQ0Q7O0FBQ0QsV0FBU0MsYUFBVCxDQUF1QjVkLEVBQXZCLEVBQTJCO0FBQ3pCLFdBQU9BLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NSLFFBQVgsQ0FBb0JHLFlBQXBCLEdBQW1DTixTQUFTLENBQUN2ZCxFQUFELENBQTVDLEdBQW1EQSxFQUFFLENBQUNvTSxPQUFILENBQVcwUixTQUFyRTtBQUNELEdBN3ZFa0IsQ0ErdkVuQjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU0MsaUJBQVQsQ0FBMkIvZCxFQUEzQixFQUErQm1VLFFBQS9CLEVBQXlDNkosSUFBekMsRUFBK0M7QUFDN0MsUUFBSUMsUUFBUSxHQUFHamUsRUFBRSxDQUFDdUUsT0FBSCxDQUFXMlosWUFBMUI7QUFDQSxRQUFJQyxRQUFRLEdBQUdGLFFBQVEsSUFBSVIsWUFBWSxDQUFDemQsRUFBRCxDQUF2Qzs7QUFDQSxRQUFJLENBQUNtVSxRQUFRLENBQUN0UyxPQUFULENBQWlCdWMsT0FBbEIsSUFBNkJILFFBQVEsSUFBSTlKLFFBQVEsQ0FBQ3RTLE9BQVQsQ0FBaUIrWixLQUFqQixJQUEwQnVDLFFBQXZFLEVBQWlGO0FBQy9FLFVBQUlDLE9BQU8sR0FBR2pLLFFBQVEsQ0FBQ3RTLE9BQVQsQ0FBaUJ1YyxPQUFqQixHQUEyQixFQUF6Qzs7QUFDQSxVQUFJSCxRQUFKLEVBQWM7QUFDWjlKLGdCQUFRLENBQUN0UyxPQUFULENBQWlCK1osS0FBakIsR0FBeUJ1QyxRQUF6QjtBQUNBLFlBQUlFLEtBQUssR0FBR2xLLFFBQVEsQ0FBQ2xWLElBQVQsQ0FBY25NLFVBQWQsQ0FBeUJ3ckIsY0FBekIsRUFBWjs7QUFDQSxhQUFLLElBQUk3cUIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzRxQixLQUFLLENBQUM3ckIsTUFBTixHQUFlLENBQW5DLEVBQXNDaUIsQ0FBQyxFQUF2QyxFQUEyQztBQUN6QyxjQUFJMEksR0FBRyxHQUFHa2lCLEtBQUssQ0FBQzVxQixDQUFELENBQWY7QUFBQSxjQUFvQjBTLElBQUksR0FBR2tZLEtBQUssQ0FBQzVxQixDQUFDLEdBQUcsQ0FBTCxDQUFoQzs7QUFDQSxjQUFJcUYsSUFBSSxDQUFDNkssR0FBTCxDQUFTeEgsR0FBRyxDQUFDb2lCLE1BQUosR0FBYXBZLElBQUksQ0FBQ29ZLE1BQTNCLElBQXFDLENBQXpDLEVBQ0U7QUFBRUgsbUJBQU8sQ0FBQ2xsQixJQUFSLENBQWEsQ0FBQ2lELEdBQUcsQ0FBQ29pQixNQUFKLEdBQWFwWSxJQUFJLENBQUNxWSxHQUFuQixJQUEwQixDQUExQixHQUE4QlIsSUFBSSxDQUFDUSxHQUFoRDtBQUF1RDtBQUM1RDtBQUNGOztBQUNESixhQUFPLENBQUNsbEIsSUFBUixDQUFhOGtCLElBQUksQ0FBQ08sTUFBTCxHQUFjUCxJQUFJLENBQUNRLEdBQWhDO0FBQ0Q7QUFDRixHQW54RWtCLENBcXhFbkI7QUFDQTtBQUNBOzs7QUFDQSxXQUFTQyxlQUFULENBQXlCdEssUUFBekIsRUFBbUNuVixJQUFuQyxFQUF5QzBULEtBQXpDLEVBQWdEO0FBQzlDLFFBQUl5QixRQUFRLENBQUNuVixJQUFULElBQWlCQSxJQUFyQixFQUNFO0FBQUUsYUFBTztBQUFDM0YsV0FBRyxFQUFFOGEsUUFBUSxDQUFDdFMsT0FBVCxDQUFpQnhJLEdBQXZCO0FBQTRCNGEsYUFBSyxFQUFFRSxRQUFRLENBQUN0UyxPQUFULENBQWlCb1M7QUFBcEQsT0FBUDtBQUFtRTs7QUFDdkUsU0FBSyxJQUFJeGdCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcwZ0IsUUFBUSxDQUFDTSxJQUFULENBQWNqaUIsTUFBbEMsRUFBMENpQixDQUFDLEVBQTNDLEVBQ0U7QUFBRSxVQUFJMGdCLFFBQVEsQ0FBQ00sSUFBVCxDQUFjaGhCLENBQWQsS0FBb0J1TCxJQUF4QixFQUNBO0FBQUUsZUFBTztBQUFDM0YsYUFBRyxFQUFFOGEsUUFBUSxDQUFDdFMsT0FBVCxDQUFpQm1ULElBQWpCLENBQXNCdmhCLENBQXRCLENBQU47QUFBZ0N3Z0IsZUFBSyxFQUFFRSxRQUFRLENBQUN0UyxPQUFULENBQWlCb1QsTUFBakIsQ0FBd0J4aEIsQ0FBeEI7QUFBdkMsU0FBUDtBQUEyRTtBQUFFOztBQUNuRixTQUFLLElBQUkwSixHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHZ1gsUUFBUSxDQUFDTSxJQUFULENBQWNqaUIsTUFBdEMsRUFBOEMySyxHQUFHLEVBQWpELEVBQ0U7QUFBRSxVQUFJb0wsTUFBTSxDQUFDNEwsUUFBUSxDQUFDTSxJQUFULENBQWN0WCxHQUFkLENBQUQsQ0FBTixHQUE2QnVWLEtBQWpDLEVBQ0E7QUFBRSxlQUFPO0FBQUNyWixhQUFHLEVBQUU4YSxRQUFRLENBQUN0UyxPQUFULENBQWlCbVQsSUFBakIsQ0FBc0I3WCxHQUF0QixDQUFOO0FBQWtDOFcsZUFBSyxFQUFFRSxRQUFRLENBQUN0UyxPQUFULENBQWlCb1QsTUFBakIsQ0FBd0I5WCxHQUF4QixDQUF6QztBQUF1RWlCLGdCQUFNLEVBQUU7QUFBL0UsU0FBUDtBQUE2RjtBQUFFO0FBQ3RHLEdBanlFa0IsQ0FteUVuQjtBQUNBOzs7QUFDQSxXQUFTc2dCLHlCQUFULENBQW1DMWUsRUFBbkMsRUFBdUNoQixJQUF2QyxFQUE2QztBQUMzQ0EsUUFBSSxHQUFHcVQsVUFBVSxDQUFDclQsSUFBRCxDQUFqQjtBQUNBLFFBQUkwVCxLQUFLLEdBQUduSyxNQUFNLENBQUN2SixJQUFELENBQWxCO0FBQ0EsUUFBSTJZLElBQUksR0FBRzNYLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBVzBJLGdCQUFYLEdBQThCLElBQUl5QyxRQUFKLENBQWF2WCxFQUFFLENBQUN3SCxHQUFoQixFQUFxQnhJLElBQXJCLEVBQTJCMFQsS0FBM0IsQ0FBekM7QUFDQWlGLFFBQUksQ0FBQ2pGLEtBQUwsR0FBYUEsS0FBYjtBQUNBLFFBQUltSCxLQUFLLEdBQUdsQyxJQUFJLENBQUNrQyxLQUFMLEdBQWEzRixnQkFBZ0IsQ0FBQ2xVLEVBQUQsRUFBSzJYLElBQUwsQ0FBekM7QUFDQUEsUUFBSSxDQUFDMVksSUFBTCxHQUFZNGEsS0FBSyxDQUFDeEYsR0FBbEI7QUFDQXRoQix3QkFBb0IsQ0FBQ2lOLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3VTLFdBQVosRUFBeUI5RSxLQUFLLENBQUN4RixHQUEvQixDQUFwQjtBQUNBLFdBQU9zRCxJQUFQO0FBQ0QsR0E5eUVrQixDQWd6RW5CO0FBQ0E7OztBQUNBLFdBQVNpSCxXQUFULENBQXFCNWUsRUFBckIsRUFBeUJoQixJQUF6QixFQUErQjVFLEVBQS9CLEVBQW1DeWtCLElBQW5DLEVBQXlDO0FBQ3ZDLFdBQU9DLG1CQUFtQixDQUFDOWUsRUFBRCxFQUFLK2UscUJBQXFCLENBQUMvZSxFQUFELEVBQUtoQixJQUFMLENBQTFCLEVBQXNDNUUsRUFBdEMsRUFBMEN5a0IsSUFBMUMsQ0FBMUI7QUFDRCxHQXB6RWtCLENBc3pFbkI7OztBQUNBLFdBQVNHLGVBQVQsQ0FBeUJoZixFQUF6QixFQUE2QjBTLEtBQTdCLEVBQW9DO0FBQ2xDLFFBQUlBLEtBQUssSUFBSTFTLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV0csUUFBcEIsSUFBZ0NtRyxLQUFLLEdBQUcxUyxFQUFFLENBQUNvTSxPQUFILENBQVdJLE1BQXZELEVBQ0U7QUFBRSxhQUFPeE0sRUFBRSxDQUFDb00sT0FBSCxDQUFXdUwsSUFBWCxDQUFnQnNILGFBQWEsQ0FBQ2pmLEVBQUQsRUFBSzBTLEtBQUwsQ0FBN0IsQ0FBUDtBQUFrRDs7QUFDdEQsUUFBSWtILEdBQUcsR0FBRzVaLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBVzBJLGdCQUFyQjs7QUFDQSxRQUFJOEUsR0FBRyxJQUFJbEgsS0FBSyxJQUFJa0gsR0FBRyxDQUFDbEgsS0FBcEIsSUFBNkJBLEtBQUssR0FBR2tILEdBQUcsQ0FBQ2xILEtBQUosR0FBWWtILEdBQUcsQ0FBQ2xTLElBQXpELEVBQ0U7QUFBRSxhQUFPa1MsR0FBUDtBQUFZO0FBQ2pCLEdBN3pFa0IsQ0ErekVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFTbUYscUJBQVQsQ0FBK0IvZSxFQUEvQixFQUFtQ2hCLElBQW5DLEVBQXlDO0FBQ3ZDLFFBQUkwVCxLQUFLLEdBQUduSyxNQUFNLENBQUN2SixJQUFELENBQWxCO0FBQ0EsUUFBSTJZLElBQUksR0FBR3FILGVBQWUsQ0FBQ2hmLEVBQUQsRUFBSzBTLEtBQUwsQ0FBMUI7O0FBQ0EsUUFBSWlGLElBQUksSUFBSSxDQUFDQSxJQUFJLENBQUMxWSxJQUFsQixFQUF3QjtBQUN0QjBZLFVBQUksR0FBRyxJQUFQO0FBQ0QsS0FGRCxNQUVPLElBQUlBLElBQUksSUFBSUEsSUFBSSxDQUFDb0IsT0FBakIsRUFBMEI7QUFDL0JGLDBCQUFvQixDQUFDN1ksRUFBRCxFQUFLMlgsSUFBTCxFQUFXakYsS0FBWCxFQUFrQndNLGFBQWEsQ0FBQ2xmLEVBQUQsQ0FBL0IsQ0FBcEI7QUFDQUEsUUFBRSxDQUFDUSxLQUFILENBQVMyZSxXQUFULEdBQXVCLElBQXZCO0FBQ0Q7O0FBQ0QsUUFBSSxDQUFDeEgsSUFBTCxFQUNFO0FBQUVBLFVBQUksR0FBRytHLHlCQUF5QixDQUFDMWUsRUFBRCxFQUFLaEIsSUFBTCxDQUFoQztBQUE2Qzs7QUFFakQsUUFBSXNHLElBQUksR0FBR21aLGVBQWUsQ0FBQzlHLElBQUQsRUFBTzNZLElBQVAsRUFBYTBULEtBQWIsQ0FBMUI7QUFDQSxXQUFPO0FBQ0wxVCxVQUFJLEVBQUVBLElBREQ7QUFDTzJZLFVBQUksRUFBRUEsSUFEYjtBQUNtQnFHLFVBQUksRUFBRSxJQUR6QjtBQUVMM2tCLFNBQUcsRUFBRWlNLElBQUksQ0FBQ2pNLEdBRkw7QUFFVTRhLFdBQUssRUFBRTNPLElBQUksQ0FBQzJPLEtBRnRCO0FBRTZCN1YsWUFBTSxFQUFFa0gsSUFBSSxDQUFDbEgsTUFGMUM7QUFHTGdoQixnQkFBVSxFQUFFO0FBSFAsS0FBUDtBQUtELEdBdDFFa0IsQ0F3MUVuQjtBQUNBOzs7QUFDQSxXQUFTTixtQkFBVCxDQUE2QjllLEVBQTdCLEVBQWlDcWYsUUFBakMsRUFBMkNqbEIsRUFBM0MsRUFBK0N5a0IsSUFBL0MsRUFBcURTLFNBQXJELEVBQWdFO0FBQzlELFFBQUlELFFBQVEsQ0FBQ2poQixNQUFiLEVBQXFCO0FBQUVoRSxRQUFFLEdBQUcsQ0FBQyxDQUFOO0FBQVU7O0FBQ2pDLFFBQUltbEIsR0FBRyxHQUFHbmxCLEVBQUUsSUFBSXlrQixJQUFJLElBQUksRUFBWixDQUFaO0FBQUEsUUFBNkJqakIsS0FBN0I7O0FBQ0EsUUFBSXlqQixRQUFRLENBQUNwTCxLQUFULENBQWV0ZCxjQUFmLENBQThCNG9CLEdBQTlCLENBQUosRUFBd0M7QUFDdEMzakIsV0FBSyxHQUFHeWpCLFFBQVEsQ0FBQ3BMLEtBQVQsQ0FBZXNMLEdBQWYsQ0FBUjtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUksQ0FBQ0YsUUFBUSxDQUFDckIsSUFBZCxFQUNFO0FBQUVxQixnQkFBUSxDQUFDckIsSUFBVCxHQUFnQnFCLFFBQVEsQ0FBQzFILElBQVQsQ0FBYzFZLElBQWQsQ0FBbUJtRCxxQkFBbkIsRUFBaEI7QUFBNkQ7O0FBQ2pFLFVBQUksQ0FBQ2lkLFFBQVEsQ0FBQ0QsVUFBZCxFQUEwQjtBQUN4QnJCLHlCQUFpQixDQUFDL2QsRUFBRCxFQUFLcWYsUUFBUSxDQUFDMUgsSUFBZCxFQUFvQjBILFFBQVEsQ0FBQ3JCLElBQTdCLENBQWpCO0FBQ0FxQixnQkFBUSxDQUFDRCxVQUFULEdBQXNCLElBQXRCO0FBQ0Q7O0FBQ0R4akIsV0FBSyxHQUFHNGpCLGdCQUFnQixDQUFDeGYsRUFBRCxFQUFLcWYsUUFBTCxFQUFlamxCLEVBQWYsRUFBbUJ5a0IsSUFBbkIsQ0FBeEI7O0FBQ0EsVUFBSSxDQUFDampCLEtBQUssQ0FBQzZqQixLQUFYLEVBQWtCO0FBQUVKLGdCQUFRLENBQUNwTCxLQUFULENBQWVzTCxHQUFmLElBQXNCM2pCLEtBQXRCO0FBQThCO0FBQ25EOztBQUNELFdBQU87QUFBQzBHLFVBQUksRUFBRTFHLEtBQUssQ0FBQzBHLElBQWI7QUFBbUJDLFdBQUssRUFBRTNHLEtBQUssQ0FBQzJHLEtBQWhDO0FBQ0NpYyxTQUFHLEVBQUVjLFNBQVMsR0FBRzFqQixLQUFLLENBQUM4akIsSUFBVCxHQUFnQjlqQixLQUFLLENBQUM0aUIsR0FEckM7QUFFQ0QsWUFBTSxFQUFFZSxTQUFTLEdBQUcxakIsS0FBSyxDQUFDK2pCLE9BQVQsR0FBbUIvakIsS0FBSyxDQUFDMmlCO0FBRjNDLEtBQVA7QUFHRDs7QUFFRCxNQUFJcUIsUUFBUSxHQUFHO0FBQUN0ZCxRQUFJLEVBQUUsQ0FBUDtBQUFVQyxTQUFLLEVBQUUsQ0FBakI7QUFBb0JpYyxPQUFHLEVBQUUsQ0FBekI7QUFBNEJELFVBQU0sRUFBRTtBQUFwQyxHQUFmOztBQUVBLFdBQVNzQixzQkFBVCxDQUFnQ3htQixHQUFoQyxFQUFxQ2UsRUFBckMsRUFBeUN5a0IsSUFBekMsRUFBK0M7QUFDN0MsUUFBSTNzQixJQUFKLEVBQVU0QixLQUFWLEVBQWlCQyxHQUFqQixFQUFzQlMsUUFBdEIsRUFBZ0NzckIsTUFBaEMsRUFBd0NDLElBQXhDLENBRDZDLENBRTdDO0FBQ0E7O0FBQ0EsU0FBSyxJQUFJdHNCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0RixHQUFHLENBQUM3RyxNQUF4QixFQUFnQ2lCLENBQUMsSUFBSSxDQUFyQyxFQUF3QztBQUN0Q3FzQixZQUFNLEdBQUd6bUIsR0FBRyxDQUFDNUYsQ0FBRCxDQUFaO0FBQ0Fzc0IsVUFBSSxHQUFHMW1CLEdBQUcsQ0FBQzVGLENBQUMsR0FBRyxDQUFMLENBQVY7O0FBQ0EsVUFBSTJHLEVBQUUsR0FBRzBsQixNQUFULEVBQWlCO0FBQ2Zoc0IsYUFBSyxHQUFHLENBQVI7QUFBV0MsV0FBRyxHQUFHLENBQU47QUFDWFMsZ0JBQVEsR0FBRyxNQUFYO0FBQ0QsT0FIRCxNQUdPLElBQUk0RixFQUFFLEdBQUcybEIsSUFBVCxFQUFlO0FBQ3BCanNCLGFBQUssR0FBR3NHLEVBQUUsR0FBRzBsQixNQUFiO0FBQ0EvckIsV0FBRyxHQUFHRCxLQUFLLEdBQUcsQ0FBZDtBQUNELE9BSE0sTUFHQSxJQUFJTCxDQUFDLElBQUk0RixHQUFHLENBQUM3RyxNQUFKLEdBQWEsQ0FBbEIsSUFBdUI0SCxFQUFFLElBQUkybEIsSUFBTixJQUFjMW1CLEdBQUcsQ0FBQzVGLENBQUMsR0FBRyxDQUFMLENBQUgsR0FBYTJHLEVBQXRELEVBQTBEO0FBQy9EckcsV0FBRyxHQUFHZ3NCLElBQUksR0FBR0QsTUFBYjtBQUNBaHNCLGFBQUssR0FBR0MsR0FBRyxHQUFHLENBQWQ7O0FBQ0EsWUFBSXFHLEVBQUUsSUFBSTJsQixJQUFWLEVBQWdCO0FBQUV2ckIsa0JBQVEsR0FBRyxPQUFYO0FBQXFCO0FBQ3hDOztBQUNELFVBQUlWLEtBQUssSUFBSSxJQUFiLEVBQW1CO0FBQ2pCNUIsWUFBSSxHQUFHbUgsR0FBRyxDQUFDNUYsQ0FBQyxHQUFHLENBQUwsQ0FBVjs7QUFDQSxZQUFJcXNCLE1BQU0sSUFBSUMsSUFBVixJQUFrQmxCLElBQUksS0FBSzNzQixJQUFJLENBQUNrZCxVQUFMLEdBQWtCLE1BQWxCLEdBQTJCLE9BQWhDLENBQTFCLEVBQ0U7QUFBRTVhLGtCQUFRLEdBQUdxcUIsSUFBWDtBQUFrQjs7QUFDdEIsWUFBSUEsSUFBSSxJQUFJLE1BQVIsSUFBa0IvcUIsS0FBSyxJQUFJLENBQS9CLEVBQ0U7QUFBRSxpQkFBT0wsQ0FBQyxJQUFJNEYsR0FBRyxDQUFDNUYsQ0FBQyxHQUFHLENBQUwsQ0FBSCxJQUFjNEYsR0FBRyxDQUFDNUYsQ0FBQyxHQUFHLENBQUwsQ0FBdEIsSUFBaUM0RixHQUFHLENBQUM1RixDQUFDLEdBQUcsQ0FBTCxDQUFILENBQVcyYixVQUFuRCxFQUErRDtBQUMvRGxkLGdCQUFJLEdBQUdtSCxHQUFHLENBQUMsQ0FBQzVGLENBQUMsSUFBSSxDQUFOLElBQVcsQ0FBWixDQUFWO0FBQ0FlLG9CQUFRLEdBQUcsTUFBWDtBQUNEO0FBQUU7O0FBQ0wsWUFBSXFxQixJQUFJLElBQUksT0FBUixJQUFtQi9xQixLQUFLLElBQUlpc0IsSUFBSSxHQUFHRCxNQUF2QyxFQUNFO0FBQUUsaUJBQU9yc0IsQ0FBQyxHQUFHNEYsR0FBRyxDQUFDN0csTUFBSixHQUFhLENBQWpCLElBQXNCNkcsR0FBRyxDQUFDNUYsQ0FBQyxHQUFHLENBQUwsQ0FBSCxJQUFjNEYsR0FBRyxDQUFDNUYsQ0FBQyxHQUFHLENBQUwsQ0FBdkMsSUFBa0QsQ0FBQzRGLEdBQUcsQ0FBQzVGLENBQUMsR0FBRyxDQUFMLENBQUgsQ0FBVzJiLFVBQXJFLEVBQWlGO0FBQ2pGbGQsZ0JBQUksR0FBR21ILEdBQUcsQ0FBQyxDQUFDNUYsQ0FBQyxJQUFJLENBQU4sSUFBVyxDQUFaLENBQVY7QUFDQWUsb0JBQVEsR0FBRyxPQUFYO0FBQ0Q7QUFBRTs7QUFDTDtBQUNEO0FBQ0Y7O0FBQ0QsV0FBTztBQUFDdEMsVUFBSSxFQUFFQSxJQUFQO0FBQWE0QixXQUFLLEVBQUVBLEtBQXBCO0FBQTJCQyxTQUFHLEVBQUVBLEdBQWhDO0FBQXFDUyxjQUFRLEVBQUVBLFFBQS9DO0FBQXlEd3JCLGdCQUFVLEVBQUVGLE1BQXJFO0FBQTZFRyxjQUFRLEVBQUVGO0FBQXZGLEtBQVA7QUFDRDs7QUFFRCxXQUFTRyxhQUFULENBQXVCN0IsS0FBdkIsRUFBOEJRLElBQTlCLEVBQW9DO0FBQ2xDLFFBQUliLElBQUksR0FBRzRCLFFBQVg7O0FBQ0EsUUFBSWYsSUFBSSxJQUFJLE1BQVosRUFBb0I7QUFBRSxXQUFLLElBQUlwckIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzRxQixLQUFLLENBQUM3ckIsTUFBMUIsRUFBa0NpQixDQUFDLEVBQW5DLEVBQXVDO0FBQzNELFlBQUksQ0FBQ3VxQixJQUFJLEdBQUdLLEtBQUssQ0FBQzVxQixDQUFELENBQWIsRUFBa0I2TyxJQUFsQixJQUEwQjBiLElBQUksQ0FBQ3piLEtBQW5DLEVBQTBDO0FBQUU7QUFBTztBQUNwRDtBQUFFLEtBRkgsTUFFUztBQUFFLFdBQUssSUFBSXBGLEdBQUcsR0FBR2toQixLQUFLLENBQUM3ckIsTUFBTixHQUFlLENBQTlCLEVBQWlDMkssR0FBRyxJQUFJLENBQXhDLEVBQTJDQSxHQUFHLEVBQTlDLEVBQWtEO0FBQzNELFlBQUksQ0FBQzZnQixJQUFJLEdBQUdLLEtBQUssQ0FBQ2xoQixHQUFELENBQWIsRUFBb0JtRixJQUFwQixJQUE0QjBiLElBQUksQ0FBQ3piLEtBQXJDLEVBQTRDO0FBQUU7QUFBTztBQUN0RDtBQUFFOztBQUNILFdBQU95YixJQUFQO0FBQ0Q7O0FBRUQsV0FBU3dCLGdCQUFULENBQTBCeGYsRUFBMUIsRUFBOEJxZixRQUE5QixFQUF3Q2psQixFQUF4QyxFQUE0Q3lrQixJQUE1QyxFQUFrRDtBQUNoRCxRQUFJc0IsS0FBSyxHQUFHTixzQkFBc0IsQ0FBQ1IsUUFBUSxDQUFDaG1CLEdBQVYsRUFBZWUsRUFBZixFQUFtQnlrQixJQUFuQixDQUFsQztBQUNBLFFBQUkzc0IsSUFBSSxHQUFHaXVCLEtBQUssQ0FBQ2p1QixJQUFqQjtBQUFBLFFBQXVCNEIsS0FBSyxHQUFHcXNCLEtBQUssQ0FBQ3JzQixLQUFyQztBQUFBLFFBQTRDQyxHQUFHLEdBQUdvc0IsS0FBSyxDQUFDcHNCLEdBQXhEO0FBQUEsUUFBNkRTLFFBQVEsR0FBRzJyQixLQUFLLENBQUMzckIsUUFBOUU7QUFFQSxRQUFJd3BCLElBQUo7O0FBQ0EsUUFBSTlyQixJQUFJLENBQUMyQyxRQUFMLElBQWlCLENBQXJCLEVBQXdCO0FBQUU7QUFDeEIsV0FBSyxJQUFJc0ksR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBRyxDQUF4QixFQUEyQkEsR0FBRyxFQUE5QixFQUFrQztBQUFFO0FBQ2xDLGVBQU9ySixLQUFLLElBQUk4RyxlQUFlLENBQUN5a0IsUUFBUSxDQUFDcmdCLElBQVQsQ0FBY0MsSUFBZCxDQUFtQmhFLE1BQW5CLENBQTBCa2xCLEtBQUssQ0FBQ0gsVUFBTixHQUFtQmxzQixLQUE3QyxDQUFELENBQS9CLEVBQXNGO0FBQUUsWUFBRUEsS0FBRjtBQUFVOztBQUNsRyxlQUFPcXNCLEtBQUssQ0FBQ0gsVUFBTixHQUFtQmpzQixHQUFuQixHQUF5Qm9zQixLQUFLLENBQUNGLFFBQS9CLElBQTJDcmxCLGVBQWUsQ0FBQ3lrQixRQUFRLENBQUNyZ0IsSUFBVCxDQUFjQyxJQUFkLENBQW1CaEUsTUFBbkIsQ0FBMEJrbEIsS0FBSyxDQUFDSCxVQUFOLEdBQW1CanNCLEdBQTdDLENBQUQsQ0FBakUsRUFBc0g7QUFBRSxZQUFFQSxHQUFGO0FBQVE7O0FBQ2hJLFlBQUl6RCxFQUFFLElBQUlDLFVBQVUsR0FBRyxDQUFuQixJQUF3QnVELEtBQUssSUFBSSxDQUFqQyxJQUFzQ0MsR0FBRyxJQUFJb3NCLEtBQUssQ0FBQ0YsUUFBTixHQUFpQkUsS0FBSyxDQUFDSCxVQUF4RSxFQUNFO0FBQUVoQyxjQUFJLEdBQUc5ckIsSUFBSSxDQUFDcUMsVUFBTCxDQUFnQjZOLHFCQUFoQixFQUFQO0FBQWlELFNBRHJELE1BR0U7QUFBRTRiLGNBQUksR0FBR2tDLGFBQWEsQ0FBQ3RzQixLQUFLLENBQUMxQixJQUFELEVBQU80QixLQUFQLEVBQWNDLEdBQWQsQ0FBTCxDQUF3QnVxQixjQUF4QixFQUFELEVBQTJDTyxJQUEzQyxDQUFwQjtBQUF1RTs7QUFDM0UsWUFBSWIsSUFBSSxDQUFDMWIsSUFBTCxJQUFhMGIsSUFBSSxDQUFDemIsS0FBbEIsSUFBMkJ6TyxLQUFLLElBQUksQ0FBeEMsRUFBMkM7QUFBRTtBQUFPOztBQUNwREMsV0FBRyxHQUFHRCxLQUFOO0FBQ0FBLGFBQUssR0FBR0EsS0FBSyxHQUFHLENBQWhCO0FBQ0FVLGdCQUFRLEdBQUcsT0FBWDtBQUNEOztBQUNELFVBQUlsRSxFQUFFLElBQUlDLFVBQVUsR0FBRyxFQUF2QixFQUEyQjtBQUFFeXRCLFlBQUksR0FBR29DLHlCQUF5QixDQUFDcGdCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3ZLLE9BQVosRUFBcUJtYyxJQUFyQixDQUFoQztBQUE2RDtBQUMzRixLQWRELE1BY087QUFBRTtBQUNQLFVBQUlscUIsS0FBSyxHQUFHLENBQVosRUFBZTtBQUFFVSxnQkFBUSxHQUFHcXFCLElBQUksR0FBRyxPQUFsQjtBQUE0Qjs7QUFDN0MsVUFBSVIsS0FBSjs7QUFDQSxVQUFJcmUsRUFBRSxDQUFDdUUsT0FBSCxDQUFXMlosWUFBWCxJQUEyQixDQUFDRyxLQUFLLEdBQUduc0IsSUFBSSxDQUFDb3NCLGNBQUwsRUFBVCxFQUFnQzlyQixNQUFoQyxHQUF5QyxDQUF4RSxFQUNFO0FBQUV3ckIsWUFBSSxHQUFHSyxLQUFLLENBQUNRLElBQUksSUFBSSxPQUFSLEdBQWtCUixLQUFLLENBQUM3ckIsTUFBTixHQUFlLENBQWpDLEdBQXFDLENBQXRDLENBQVo7QUFBdUQsT0FEM0QsTUFHRTtBQUFFd3JCLFlBQUksR0FBRzlyQixJQUFJLENBQUNrUSxxQkFBTCxFQUFQO0FBQXNDO0FBQzNDOztBQUNELFFBQUk5UixFQUFFLElBQUlDLFVBQVUsR0FBRyxDQUFuQixJQUF3QixDQUFDdUQsS0FBekIsS0FBbUMsQ0FBQ2txQixJQUFELElBQVMsQ0FBQ0EsSUFBSSxDQUFDMWIsSUFBTixJQUFjLENBQUMwYixJQUFJLENBQUN6YixLQUFoRSxDQUFKLEVBQTRFO0FBQzFFLFVBQUk4ZCxLQUFLLEdBQUdudUIsSUFBSSxDQUFDcUMsVUFBTCxDQUFnQitwQixjQUFoQixHQUFpQyxDQUFqQyxDQUFaOztBQUNBLFVBQUkrQixLQUFKLEVBQ0U7QUFBRXJDLFlBQUksR0FBRztBQUFDMWIsY0FBSSxFQUFFK2QsS0FBSyxDQUFDL2QsSUFBYjtBQUFtQkMsZUFBSyxFQUFFOGQsS0FBSyxDQUFDL2QsSUFBTixHQUFhZ2UsU0FBUyxDQUFDdGdCLEVBQUUsQ0FBQ29NLE9BQUosQ0FBaEQ7QUFBOERvUyxhQUFHLEVBQUU2QixLQUFLLENBQUM3QixHQUF6RTtBQUE4RUQsZ0JBQU0sRUFBRThCLEtBQUssQ0FBQzlCO0FBQTVGLFNBQVA7QUFBNkcsT0FEakgsTUFHRTtBQUFFUCxZQUFJLEdBQUc0QixRQUFQO0FBQWtCO0FBQ3ZCOztBQUVELFFBQUlGLElBQUksR0FBRzFCLElBQUksQ0FBQ1EsR0FBTCxHQUFXYSxRQUFRLENBQUNyQixJQUFULENBQWNRLEdBQXBDO0FBQUEsUUFBeUMrQixJQUFJLEdBQUd2QyxJQUFJLENBQUNPLE1BQUwsR0FBY2MsUUFBUSxDQUFDckIsSUFBVCxDQUFjUSxHQUE1RTtBQUNBLFFBQUlqakIsR0FBRyxHQUFHLENBQUNta0IsSUFBSSxHQUFHYSxJQUFSLElBQWdCLENBQTFCO0FBQ0EsUUFBSW5DLE9BQU8sR0FBR2lCLFFBQVEsQ0FBQzFILElBQVQsQ0FBYzlWLE9BQWQsQ0FBc0J1YyxPQUFwQztBQUNBLFFBQUkzcUIsQ0FBQyxHQUFHLENBQVI7O0FBQ0EsV0FBT0EsQ0FBQyxHQUFHMnFCLE9BQU8sQ0FBQzVyQixNQUFSLEdBQWlCLENBQTVCLEVBQStCaUIsQ0FBQyxFQUFoQyxFQUNFO0FBQUUsVUFBSThILEdBQUcsR0FBRzZpQixPQUFPLENBQUMzcUIsQ0FBRCxDQUFqQixFQUFzQjtBQUFFO0FBQU87QUFBRTs7QUFDckMsUUFBSStxQixHQUFHLEdBQUcvcUIsQ0FBQyxHQUFHMnFCLE9BQU8sQ0FBQzNxQixDQUFDLEdBQUcsQ0FBTCxDQUFWLEdBQW9CLENBQS9CO0FBQUEsUUFBa0Mrc0IsR0FBRyxHQUFHcEMsT0FBTyxDQUFDM3FCLENBQUQsQ0FBL0M7QUFDQSxRQUFJZ1AsTUFBTSxHQUFHO0FBQUNILFVBQUksRUFBRSxDQUFDOU4sUUFBUSxJQUFJLE9BQVosR0FBc0J3cEIsSUFBSSxDQUFDemIsS0FBM0IsR0FBbUN5YixJQUFJLENBQUMxYixJQUF6QyxJQUFpRCtjLFFBQVEsQ0FBQ3JCLElBQVQsQ0FBYzFiLElBQXRFO0FBQ0NDLFdBQUssRUFBRSxDQUFDL04sUUFBUSxJQUFJLE1BQVosR0FBcUJ3cEIsSUFBSSxDQUFDMWIsSUFBMUIsR0FBaUMwYixJQUFJLENBQUN6YixLQUF2QyxJQUFnRDhjLFFBQVEsQ0FBQ3JCLElBQVQsQ0FBYzFiLElBRHRFO0FBRUNrYyxTQUFHLEVBQUVBLEdBRk47QUFFV0QsWUFBTSxFQUFFaUM7QUFGbkIsS0FBYjs7QUFHQSxRQUFJLENBQUN4QyxJQUFJLENBQUMxYixJQUFOLElBQWMsQ0FBQzBiLElBQUksQ0FBQ3piLEtBQXhCLEVBQStCO0FBQUVFLFlBQU0sQ0FBQ2dkLEtBQVAsR0FBZSxJQUFmO0FBQXNCOztBQUN2RCxRQUFJLENBQUN6ZixFQUFFLENBQUN1RSxPQUFILENBQVdrYyx5QkFBaEIsRUFBMkM7QUFBRWhlLFlBQU0sQ0FBQ2lkLElBQVAsR0FBY0EsSUFBZDtBQUFvQmpkLFlBQU0sQ0FBQ2tkLE9BQVAsR0FBaUJZLElBQWpCO0FBQXdCOztBQUV6RixXQUFPOWQsTUFBUDtBQUNELEdBajlFa0IsQ0FtOUVuQjtBQUNBOzs7QUFDQSxXQUFTMmQseUJBQVQsQ0FBbUN2ZSxPQUFuQyxFQUE0Q21jLElBQTVDLEVBQWtEO0FBQ2hELFFBQUksQ0FBQ2xiLE1BQU0sQ0FBQzRkLE1BQVIsSUFBa0JBLE1BQU0sQ0FBQ0MsV0FBUCxJQUFzQixJQUF4QyxJQUNBRCxNQUFNLENBQUNDLFdBQVAsSUFBc0JELE1BQU0sQ0FBQ0UsVUFEN0IsSUFDMkMsQ0FBQ3BkLGlCQUFpQixDQUFDM0IsT0FBRCxDQURqRSxFQUVFO0FBQUUsYUFBT21jLElBQVA7QUFBYTs7QUFDakIsUUFBSTZDLE1BQU0sR0FBR0gsTUFBTSxDQUFDQyxXQUFQLEdBQXFCRCxNQUFNLENBQUNFLFVBQXpDO0FBQ0EsUUFBSUUsTUFBTSxHQUFHSixNQUFNLENBQUNLLFdBQVAsR0FBcUJMLE1BQU0sQ0FBQ00sVUFBekM7QUFDQSxXQUFPO0FBQUMxZSxVQUFJLEVBQUUwYixJQUFJLENBQUMxYixJQUFMLEdBQVl1ZSxNQUFuQjtBQUEyQnRlLFdBQUssRUFBRXliLElBQUksQ0FBQ3piLEtBQUwsR0FBYXNlLE1BQS9DO0FBQ0NyQyxTQUFHLEVBQUVSLElBQUksQ0FBQ1EsR0FBTCxHQUFXc0MsTUFEakI7QUFDeUJ2QyxZQUFNLEVBQUVQLElBQUksQ0FBQ08sTUFBTCxHQUFjdUM7QUFEL0MsS0FBUDtBQUVEOztBQUVELFdBQVNHLDRCQUFULENBQXNDOU0sUUFBdEMsRUFBZ0Q7QUFDOUMsUUFBSUEsUUFBUSxDQUFDdFMsT0FBYixFQUFzQjtBQUNwQnNTLGNBQVEsQ0FBQ3RTLE9BQVQsQ0FBaUJvUyxLQUFqQixHQUF5QixFQUF6QjtBQUNBRSxjQUFRLENBQUN0UyxPQUFULENBQWlCdWMsT0FBakIsR0FBMkIsSUFBM0I7O0FBQ0EsVUFBSWpLLFFBQVEsQ0FBQ00sSUFBYixFQUFtQjtBQUFFLGFBQUssSUFBSWhoQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMGdCLFFBQVEsQ0FBQ00sSUFBVCxDQUFjamlCLE1BQWxDLEVBQTBDaUIsQ0FBQyxFQUEzQyxFQUNuQjtBQUFFMGdCLGtCQUFRLENBQUN0UyxPQUFULENBQWlCb1QsTUFBakIsQ0FBd0J4aEIsQ0FBeEIsSUFBNkIsRUFBN0I7QUFBa0M7QUFBRTtBQUN6QztBQUNGOztBQUVELFdBQVN5dEIseUJBQVQsQ0FBbUNsaEIsRUFBbkMsRUFBdUM7QUFDckNBLE1BQUUsQ0FBQ29NLE9BQUgsQ0FBVytVLGVBQVgsR0FBNkIsSUFBN0I7QUFDQTF1QixrQkFBYyxDQUFDdU4sRUFBRSxDQUFDb00sT0FBSCxDQUFXdVMsV0FBWixDQUFkOztBQUNBLFNBQUssSUFBSWxyQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdU0sRUFBRSxDQUFDb00sT0FBSCxDQUFXdUwsSUFBWCxDQUFnQm5sQixNQUFwQyxFQUE0Q2lCLENBQUMsRUFBN0MsRUFDRTtBQUFFd3RCLGtDQUE0QixDQUFDamhCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3VMLElBQVgsQ0FBZ0Jsa0IsQ0FBaEIsQ0FBRCxDQUE1QjtBQUFtRDtBQUN4RDs7QUFFRCxXQUFTMnRCLFdBQVQsQ0FBcUJwaEIsRUFBckIsRUFBeUI7QUFDdkJraEIsNkJBQXlCLENBQUNsaEIsRUFBRCxDQUF6QjtBQUNBQSxNQUFFLENBQUNvTSxPQUFILENBQVdpVixlQUFYLEdBQTZCcmhCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV2tWLGdCQUFYLEdBQThCdGhCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBVzRRLGNBQVgsR0FBNEIsSUFBdkY7O0FBQ0EsUUFBSSxDQUFDaGQsRUFBRSxDQUFDdUUsT0FBSCxDQUFXMlosWUFBaEIsRUFBOEI7QUFBRWxlLFFBQUUsQ0FBQ29NLE9BQUgsQ0FBV29ILGNBQVgsR0FBNEIsSUFBNUI7QUFBbUM7O0FBQ25FeFQsTUFBRSxDQUFDb00sT0FBSCxDQUFXbVYsWUFBWCxHQUEwQixJQUExQjtBQUNEOztBQUVELFdBQVNDLFdBQVQsR0FBdUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsUUFBSTV3QixNQUFNLElBQUlRLE9BQWQsRUFBdUI7QUFBRSxhQUFPLEVBQUVaLFFBQVEsQ0FBQzRELElBQVQsQ0FBY2dPLHFCQUFkLEdBQXNDRSxJQUF0QyxHQUE2QzhhLFFBQVEsQ0FBQ0gsZ0JBQWdCLENBQUN6c0IsUUFBUSxDQUFDNEQsSUFBVixDQUFoQixDQUFnQzZuQixVQUFqQyxDQUF2RCxDQUFQO0FBQTZHOztBQUN0SSxXQUFPblosTUFBTSxDQUFDMmUsV0FBUCxJQUFzQixDQUFDanhCLFFBQVEsQ0FBQ2t4QixlQUFULElBQTRCbHhCLFFBQVEsQ0FBQzRELElBQXRDLEVBQTRDdXRCLFVBQXpFO0FBQ0Q7O0FBQ0QsV0FBU0MsV0FBVCxHQUF1QjtBQUNyQixRQUFJaHhCLE1BQU0sSUFBSVEsT0FBZCxFQUF1QjtBQUFFLGFBQU8sRUFBRVosUUFBUSxDQUFDNEQsSUFBVCxDQUFjZ08scUJBQWQsR0FBc0NvYyxHQUF0QyxHQUE0Q3BCLFFBQVEsQ0FBQ0gsZ0JBQWdCLENBQUN6c0IsUUFBUSxDQUFDNEQsSUFBVixDQUFoQixDQUFnQ3l0QixTQUFqQyxDQUF0RCxDQUFQO0FBQTJHOztBQUNwSSxXQUFPL2UsTUFBTSxDQUFDZ2YsV0FBUCxJQUFzQixDQUFDdHhCLFFBQVEsQ0FBQ2t4QixlQUFULElBQTRCbHhCLFFBQVEsQ0FBQzRELElBQXRDLEVBQTRDMnRCLFNBQXpFO0FBQ0Q7O0FBRUQsV0FBU0MsZUFBVCxDQUF5QjlPLE9BQXpCLEVBQWtDO0FBQ2hDLFFBQUk3SyxNQUFNLEdBQUcsQ0FBYjs7QUFDQSxRQUFJNkssT0FBTyxDQUFDb0ksT0FBWixFQUFxQjtBQUFFLFdBQUssSUFBSTduQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHeWYsT0FBTyxDQUFDb0ksT0FBUixDQUFnQjlvQixNQUFwQyxFQUE0QyxFQUFFaUIsQ0FBOUMsRUFBaUQ7QUFBRSxZQUFJeWYsT0FBTyxDQUFDb0ksT0FBUixDQUFnQjduQixDQUFoQixFQUFtQmlvQixLQUF2QixFQUN4RTtBQUFFclQsZ0JBQU0sSUFBSTZULFlBQVksQ0FBQ2hKLE9BQU8sQ0FBQ29JLE9BQVIsQ0FBZ0I3bkIsQ0FBaEIsQ0FBRCxDQUF0QjtBQUE2QztBQUFFO0FBQUU7O0FBQ3JELFdBQU80VSxNQUFQO0FBQ0QsR0F2Z0ZrQixDQXlnRm5CO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFTNFosZUFBVCxDQUF5QmppQixFQUF6QixFQUE2QmtULE9BQTdCLEVBQXNDOEssSUFBdEMsRUFBNEN0VCxPQUE1QyxFQUFxRHdYLGNBQXJELEVBQXFFO0FBQ25FLFFBQUksQ0FBQ0EsY0FBTCxFQUFxQjtBQUNuQixVQUFJN1osTUFBTSxHQUFHMlosZUFBZSxDQUFDOU8sT0FBRCxDQUE1QjtBQUNBOEssVUFBSSxDQUFDUSxHQUFMLElBQVluVyxNQUFaO0FBQW9CMlYsVUFBSSxDQUFDTyxNQUFMLElBQWVsVyxNQUFmO0FBQ3JCOztBQUNELFFBQUlxQyxPQUFPLElBQUksTUFBZixFQUF1QjtBQUFFLGFBQU9zVCxJQUFQO0FBQWE7O0FBQ3RDLFFBQUksQ0FBQ3RULE9BQUwsRUFBYztBQUFFQSxhQUFPLEdBQUcsT0FBVjtBQUFvQjs7QUFDcEMsUUFBSXlYLElBQUksR0FBR2xQLGFBQVksQ0FBQ0MsT0FBRCxDQUF2Qjs7QUFDQSxRQUFJeEksT0FBTyxJQUFJLE9BQWYsRUFBd0I7QUFBRXlYLFVBQUksSUFBSXhGLFVBQVUsQ0FBQzNjLEVBQUUsQ0FBQ29NLE9BQUosQ0FBbEI7QUFBaUMsS0FBM0QsTUFDSztBQUFFK1YsVUFBSSxJQUFJbmlCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV2dXLFVBQW5CO0FBQWdDOztBQUN2QyxRQUFJMVgsT0FBTyxJQUFJLE1BQVgsSUFBcUJBLE9BQU8sSUFBSSxRQUFwQyxFQUE4QztBQUM1QyxVQUFJMlgsSUFBSSxHQUFHcmlCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3dRLFNBQVgsQ0FBcUJ4YSxxQkFBckIsRUFBWDtBQUNBK2YsVUFBSSxJQUFJRSxJQUFJLENBQUM3RCxHQUFMLElBQVk5VCxPQUFPLElBQUksUUFBWCxHQUFzQixDQUF0QixHQUEwQmtYLFdBQVcsRUFBakQsQ0FBUjtBQUNBLFVBQUlVLElBQUksR0FBR0QsSUFBSSxDQUFDL2YsSUFBTCxJQUFhb0ksT0FBTyxJQUFJLFFBQVgsR0FBc0IsQ0FBdEIsR0FBMEI4VyxXQUFXLEVBQWxELENBQVg7QUFDQXhELFVBQUksQ0FBQzFiLElBQUwsSUFBYWdnQixJQUFiO0FBQW1CdEUsVUFBSSxDQUFDemIsS0FBTCxJQUFjK2YsSUFBZDtBQUNwQjs7QUFDRHRFLFFBQUksQ0FBQ1EsR0FBTCxJQUFZMkQsSUFBWjtBQUFrQm5FLFFBQUksQ0FBQ08sTUFBTCxJQUFlNEQsSUFBZjtBQUNsQixXQUFPbkUsSUFBUDtBQUNELEdBL2hGa0IsQ0FpaUZuQjtBQUNBOzs7QUFDQSxXQUFTdUUsZUFBVCxDQUF5QnZpQixFQUF6QixFQUE2QndpQixNQUE3QixFQUFxQzlYLE9BQXJDLEVBQThDO0FBQzVDLFFBQUlBLE9BQU8sSUFBSSxLQUFmLEVBQXNCO0FBQUUsYUFBTzhYLE1BQVA7QUFBZTs7QUFDdkMsUUFBSWxnQixJQUFJLEdBQUdrZ0IsTUFBTSxDQUFDbGdCLElBQWxCO0FBQUEsUUFBd0JrYyxHQUFHLEdBQUdnRSxNQUFNLENBQUNoRSxHQUFyQyxDQUY0QyxDQUc1Qzs7QUFDQSxRQUFJOVQsT0FBTyxJQUFJLE1BQWYsRUFBdUI7QUFDckJwSSxVQUFJLElBQUlrZixXQUFXLEVBQW5CO0FBQ0FoRCxTQUFHLElBQUlvRCxXQUFXLEVBQWxCO0FBQ0QsS0FIRCxNQUdPLElBQUlsWCxPQUFPLElBQUksT0FBWCxJQUFzQixDQUFDQSxPQUEzQixFQUFvQztBQUN6QyxVQUFJK1gsUUFBUSxHQUFHemlCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3FRLEtBQVgsQ0FBaUJyYSxxQkFBakIsRUFBZjtBQUNBRSxVQUFJLElBQUltZ0IsUUFBUSxDQUFDbmdCLElBQWpCO0FBQ0FrYyxTQUFHLElBQUlpRSxRQUFRLENBQUNqRSxHQUFoQjtBQUNEOztBQUVELFFBQUlrRSxZQUFZLEdBQUcxaUIsRUFBRSxDQUFDb00sT0FBSCxDQUFXd1EsU0FBWCxDQUFxQnhhLHFCQUFyQixFQUFuQjtBQUNBLFdBQU87QUFBQ0UsVUFBSSxFQUFFQSxJQUFJLEdBQUdvZ0IsWUFBWSxDQUFDcGdCLElBQTNCO0FBQWlDa2MsU0FBRyxFQUFFQSxHQUFHLEdBQUdrRSxZQUFZLENBQUNsRTtBQUF6RCxLQUFQO0FBQ0Q7O0FBRUQsV0FBU21FLFdBQVQsQ0FBb0IzaUIsRUFBcEIsRUFBd0JySCxHQUF4QixFQUE2QitSLE9BQTdCLEVBQXNDd0ksT0FBdEMsRUFBK0MyTCxJQUEvQyxFQUFxRDtBQUNuRCxRQUFJLENBQUMzTCxPQUFMLEVBQWM7QUFBRUEsYUFBTyxHQUFHM0wsT0FBTyxDQUFDdkgsRUFBRSxDQUFDd0gsR0FBSixFQUFTN08sR0FBRyxDQUFDcUcsSUFBYixDQUFqQjtBQUFzQzs7QUFDdEQsV0FBT2lqQixlQUFlLENBQUNqaUIsRUFBRCxFQUFLa1QsT0FBTCxFQUFjMEwsV0FBVyxDQUFDNWUsRUFBRCxFQUFLa1QsT0FBTCxFQUFjdmEsR0FBRyxDQUFDeUIsRUFBbEIsRUFBc0J5a0IsSUFBdEIsQ0FBekIsRUFBc0RuVSxPQUF0RCxDQUF0QjtBQUNELEdBdmpGa0IsQ0F5akZuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU2tZLGFBQVQsQ0FBc0I1aUIsRUFBdEIsRUFBMEJySCxHQUExQixFQUErQitSLE9BQS9CLEVBQXdDd0ksT0FBeEMsRUFBaUQyUCxlQUFqRCxFQUFrRXZELFNBQWxFLEVBQTZFO0FBQzNFcE0sV0FBTyxHQUFHQSxPQUFPLElBQUkzTCxPQUFPLENBQUN2SCxFQUFFLENBQUN3SCxHQUFKLEVBQVM3TyxHQUFHLENBQUNxRyxJQUFiLENBQTVCOztBQUNBLFFBQUksQ0FBQzZqQixlQUFMLEVBQXNCO0FBQUVBLHFCQUFlLEdBQUc5RCxxQkFBcUIsQ0FBQy9lLEVBQUQsRUFBS2tULE9BQUwsQ0FBdkM7QUFBdUQ7O0FBQy9FLGFBQVM0UCxHQUFULENBQWExb0IsRUFBYixFQUFpQm1JLEtBQWpCLEVBQXdCO0FBQ3RCLFVBQUloRSxDQUFDLEdBQUd1Z0IsbUJBQW1CLENBQUM5ZSxFQUFELEVBQUs2aUIsZUFBTCxFQUFzQnpvQixFQUF0QixFQUEwQm1JLEtBQUssR0FBRyxPQUFILEdBQWEsTUFBNUMsRUFBb0QrYyxTQUFwRCxDQUEzQjs7QUFDQSxVQUFJL2MsS0FBSixFQUFXO0FBQUVoRSxTQUFDLENBQUMrRCxJQUFGLEdBQVMvRCxDQUFDLENBQUNnRSxLQUFYO0FBQW1CLE9BQWhDLE1BQXNDO0FBQUVoRSxTQUFDLENBQUNnRSxLQUFGLEdBQVVoRSxDQUFDLENBQUMrRCxJQUFaO0FBQW1COztBQUMzRCxhQUFPMmYsZUFBZSxDQUFDamlCLEVBQUQsRUFBS2tULE9BQUwsRUFBYzNVLENBQWQsRUFBaUJtTSxPQUFqQixDQUF0QjtBQUNEOztBQUNELFFBQUkvTyxLQUFLLEdBQUdvRCxRQUFRLENBQUNtVSxPQUFELEVBQVVsVCxFQUFFLENBQUN3SCxHQUFILENBQU96SyxTQUFqQixDQUFwQjtBQUFBLFFBQWlEM0MsRUFBRSxHQUFHekIsR0FBRyxDQUFDeUIsRUFBMUQ7QUFBQSxRQUE4RDhCLE1BQU0sR0FBR3ZELEdBQUcsQ0FBQ3VELE1BQTNFOztBQUNBLFFBQUk5QixFQUFFLElBQUk4WSxPQUFPLENBQUNqVSxJQUFSLENBQWF6TSxNQUF2QixFQUErQjtBQUM3QjRILFFBQUUsR0FBRzhZLE9BQU8sQ0FBQ2pVLElBQVIsQ0FBYXpNLE1BQWxCO0FBQ0EwSixZQUFNLEdBQUcsUUFBVDtBQUNELEtBSEQsTUFHTyxJQUFJOUIsRUFBRSxJQUFJLENBQVYsRUFBYTtBQUNsQkEsUUFBRSxHQUFHLENBQUw7QUFDQThCLFlBQU0sR0FBRyxPQUFUO0FBQ0Q7O0FBQ0QsUUFBSSxDQUFDUCxLQUFMLEVBQVk7QUFBRSxhQUFPbW5CLEdBQUcsQ0FBQzVtQixNQUFNLElBQUksUUFBVixHQUFxQjlCLEVBQUUsR0FBRyxDQUExQixHQUE4QkEsRUFBL0IsRUFBbUM4QixNQUFNLElBQUksUUFBN0MsQ0FBVjtBQUFrRTs7QUFFaEYsYUFBUzZtQixPQUFULENBQWlCM29CLEVBQWpCLEVBQXFCNG9CLE9BQXJCLEVBQThCQyxNQUE5QixFQUFzQztBQUNwQyxVQUFJcG5CLElBQUksR0FBR0YsS0FBSyxDQUFDcW5CLE9BQUQsQ0FBaEI7QUFBQSxVQUEyQnpnQixLQUFLLEdBQUcxRyxJQUFJLENBQUNFLEtBQUwsSUFBYyxDQUFqRDtBQUNBLGFBQU8rbUIsR0FBRyxDQUFDRyxNQUFNLEdBQUc3b0IsRUFBRSxHQUFHLENBQVIsR0FBWUEsRUFBbkIsRUFBdUJtSSxLQUFLLElBQUkwZ0IsTUFBaEMsQ0FBVjtBQUNEOztBQUNELFFBQUlELE9BQU8sR0FBRy9tQixhQUFhLENBQUNOLEtBQUQsRUFBUXZCLEVBQVIsRUFBWThCLE1BQVosQ0FBM0I7QUFDQSxRQUFJZ25CLEtBQUssR0FBR2xuQixTQUFaO0FBQ0EsUUFBSW9KLEdBQUcsR0FBRzJkLE9BQU8sQ0FBQzNvQixFQUFELEVBQUs0b0IsT0FBTCxFQUFjOW1CLE1BQU0sSUFBSSxRQUF4QixDQUFqQjs7QUFDQSxRQUFJZ25CLEtBQUssSUFBSSxJQUFiLEVBQW1CO0FBQUU5ZCxTQUFHLENBQUM4ZCxLQUFKLEdBQVlILE9BQU8sQ0FBQzNvQixFQUFELEVBQUs4b0IsS0FBTCxFQUFZaG5CLE1BQU0sSUFBSSxRQUF0QixDQUFuQjtBQUFxRDs7QUFDMUUsV0FBT2tKLEdBQVA7QUFDRCxHQXBtRmtCLENBc21GbkI7QUFDQTs7O0FBQ0EsV0FBUytkLGNBQVQsQ0FBd0JuakIsRUFBeEIsRUFBNEJySCxHQUE1QixFQUFpQztBQUMvQixRQUFJMkosSUFBSSxHQUFHLENBQVg7QUFDQTNKLE9BQUcsR0FBRytRLFFBQU8sQ0FBQzFKLEVBQUUsQ0FBQ3dILEdBQUosRUFBUzdPLEdBQVQsQ0FBYjs7QUFDQSxRQUFJLENBQUNxSCxFQUFFLENBQUN1RSxPQUFILENBQVcyWixZQUFoQixFQUE4QjtBQUFFNWIsVUFBSSxHQUFHZ2UsU0FBUyxDQUFDdGdCLEVBQUUsQ0FBQ29NLE9BQUosQ0FBVCxHQUF3QnpULEdBQUcsQ0FBQ3lCLEVBQW5DO0FBQXdDOztBQUN4RSxRQUFJOFksT0FBTyxHQUFHM0wsT0FBTyxDQUFDdkgsRUFBRSxDQUFDd0gsR0FBSixFQUFTN08sR0FBRyxDQUFDcUcsSUFBYixDQUFyQjtBQUNBLFFBQUl3ZixHQUFHLEdBQUd2TCxhQUFZLENBQUNDLE9BQUQsQ0FBWixHQUF3QnlKLFVBQVUsQ0FBQzNjLEVBQUUsQ0FBQ29NLE9BQUosQ0FBNUM7QUFDQSxXQUFPO0FBQUM5SixVQUFJLEVBQUVBLElBQVA7QUFBYUMsV0FBSyxFQUFFRCxJQUFwQjtBQUEwQmtjLFNBQUcsRUFBRUEsR0FBL0I7QUFBb0NELFlBQU0sRUFBRUMsR0FBRyxHQUFHdEwsT0FBTyxDQUFDN0s7QUFBMUQsS0FBUDtBQUNELEdBL21Ga0IsQ0FpbkZuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFdBQVMrYSxXQUFULENBQXFCcGtCLElBQXJCLEVBQTJCNUUsRUFBM0IsRUFBK0I4QixNQUEvQixFQUF1Q21uQixPQUF2QyxFQUFnREMsSUFBaEQsRUFBc0Q7QUFDcEQsUUFBSTNxQixHQUFHLEdBQUd1USxHQUFHLENBQUNsSyxJQUFELEVBQU81RSxFQUFQLEVBQVc4QixNQUFYLENBQWI7QUFDQXZELE9BQUcsQ0FBQzJxQixJQUFKLEdBQVdBLElBQVg7O0FBQ0EsUUFBSUQsT0FBSixFQUFhO0FBQUUxcUIsU0FBRyxDQUFDMHFCLE9BQUosR0FBY0EsT0FBZDtBQUF3Qjs7QUFDdkMsV0FBTzFxQixHQUFQO0FBQ0QsR0E1bkZrQixDQThuRm5CO0FBQ0E7OztBQUNBLFdBQVM0cUIsV0FBVCxDQUFvQnZqQixFQUFwQixFQUF3QnNKLENBQXhCLEVBQTJCa2EsQ0FBM0IsRUFBOEI7QUFDNUIsUUFBSWhjLEdBQUcsR0FBR3hILEVBQUUsQ0FBQ3dILEdBQWI7QUFDQWdjLEtBQUMsSUFBSXhqQixFQUFFLENBQUNvTSxPQUFILENBQVdnVyxVQUFoQjs7QUFDQSxRQUFJb0IsQ0FBQyxHQUFHLENBQVIsRUFBVztBQUFFLGFBQU9KLFdBQVcsQ0FBQzViLEdBQUcsQ0FBQ0MsS0FBTCxFQUFZLENBQVosRUFBZSxJQUFmLEVBQXFCLENBQUMsQ0FBdEIsRUFBeUIsQ0FBQyxDQUExQixDQUFsQjtBQUFnRDs7QUFDN0QsUUFBSWlMLEtBQUssR0FBR2pLLGFBQVksQ0FBQ2pCLEdBQUQsRUFBTWdjLENBQU4sQ0FBeEI7QUFBQSxRQUFrQzdaLElBQUksR0FBR25DLEdBQUcsQ0FBQ0MsS0FBSixHQUFZRCxHQUFHLENBQUNFLElBQWhCLEdBQXVCLENBQWhFOztBQUNBLFFBQUlnTCxLQUFLLEdBQUcvSSxJQUFaLEVBQ0U7QUFBRSxhQUFPeVosV0FBVyxDQUFDNWIsR0FBRyxDQUFDQyxLQUFKLEdBQVlELEdBQUcsQ0FBQ0UsSUFBaEIsR0FBdUIsQ0FBeEIsRUFBMkJILE9BQU8sQ0FBQ0MsR0FBRCxFQUFNbUMsSUFBTixDQUFQLENBQW1CMUssSUFBbkIsQ0FBd0J6TSxNQUFuRCxFQUEyRCxJQUEzRCxFQUFpRSxDQUFqRSxFQUFvRSxDQUFwRSxDQUFsQjtBQUEwRjs7QUFDOUYsUUFBSThXLENBQUMsR0FBRyxDQUFSLEVBQVc7QUFBRUEsT0FBQyxHQUFHLENBQUo7QUFBUTs7QUFFckIsUUFBSTRKLE9BQU8sR0FBRzNMLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNa0wsS0FBTixDQUFyQjs7QUFDQSxhQUFTO0FBQ1AsVUFBSTlXLEtBQUssR0FBRzZuQixlQUFlLENBQUN6akIsRUFBRCxFQUFLa1QsT0FBTCxFQUFjUixLQUFkLEVBQXFCcEosQ0FBckIsRUFBd0JrYSxDQUF4QixDQUEzQjtBQUNBLFVBQUl4UixTQUFTLEdBQUdHLG1CQUFtQixDQUFDZSxPQUFELEVBQVV0WCxLQUFLLENBQUN4QixFQUFOLElBQVl3QixLQUFLLENBQUMwbkIsSUFBTixHQUFhLENBQWIsSUFBa0IxbkIsS0FBSyxDQUFDeW5CLE9BQU4sR0FBZ0IsQ0FBbEMsR0FBc0MsQ0FBdEMsR0FBMEMsQ0FBdEQsQ0FBVixDQUFuQzs7QUFDQSxVQUFJLENBQUNyUixTQUFMLEVBQWdCO0FBQUUsZUFBT3BXLEtBQVA7QUFBYzs7QUFDaEMsVUFBSThuQixRQUFRLEdBQUcxUixTQUFTLENBQUNuQixJQUFWLENBQWUsQ0FBZixDQUFmOztBQUNBLFVBQUk2UyxRQUFRLENBQUMxa0IsSUFBVCxJQUFpQjBULEtBQXJCLEVBQTRCO0FBQUUsZUFBT2dSLFFBQVA7QUFBaUI7O0FBQy9DeFEsYUFBTyxHQUFHM0wsT0FBTyxDQUFDQyxHQUFELEVBQU1rTCxLQUFLLEdBQUdnUixRQUFRLENBQUMxa0IsSUFBdkIsQ0FBakI7QUFDRDtBQUNGOztBQUVELFdBQVMya0IsaUJBQVQsQ0FBMkIzakIsRUFBM0IsRUFBK0JrVCxPQUEvQixFQUF3QzJQLGVBQXhDLEVBQXlEVyxDQUF6RCxFQUE0RDtBQUMxREEsS0FBQyxJQUFJeEIsZUFBZSxDQUFDOU8sT0FBRCxDQUFwQjtBQUNBLFFBQUluZixHQUFHLEdBQUdtZixPQUFPLENBQUNqVSxJQUFSLENBQWF6TSxNQUF2QjtBQUNBLFFBQUlveEIsS0FBSyxHQUFHMW9CLFNBQVMsQ0FBQyxVQUFVZCxFQUFWLEVBQWM7QUFBRSxhQUFPMGtCLG1CQUFtQixDQUFDOWUsRUFBRCxFQUFLNmlCLGVBQUwsRUFBc0J6b0IsRUFBRSxHQUFHLENBQTNCLENBQW5CLENBQWlEbWtCLE1BQWpELElBQTJEaUYsQ0FBbEU7QUFBc0UsS0FBdkYsRUFBeUZ6dkIsR0FBekYsRUFBOEYsQ0FBOUYsQ0FBckI7QUFDQUEsT0FBRyxHQUFHbUgsU0FBUyxDQUFDLFVBQVVkLEVBQVYsRUFBYztBQUFFLGFBQU8wa0IsbUJBQW1CLENBQUM5ZSxFQUFELEVBQUs2aUIsZUFBTCxFQUFzQnpvQixFQUF0QixDQUFuQixDQUE2Q29rQixHQUE3QyxHQUFtRGdGLENBQTFEO0FBQThELEtBQS9FLEVBQWlGSSxLQUFqRixFQUF3Rjd2QixHQUF4RixDQUFmO0FBQ0EsV0FBTztBQUFDNnZCLFdBQUssRUFBRUEsS0FBUjtBQUFlN3ZCLFNBQUcsRUFBRUE7QUFBcEIsS0FBUDtBQUNEOztBQUVELFdBQVM4dkIscUJBQVQsQ0FBK0I3akIsRUFBL0IsRUFBbUNrVCxPQUFuQyxFQUE0QzJQLGVBQTVDLEVBQTZEcnNCLE1BQTdELEVBQXFFO0FBQ25FLFFBQUksQ0FBQ3FzQixlQUFMLEVBQXNCO0FBQUVBLHFCQUFlLEdBQUc5RCxxQkFBcUIsQ0FBQy9lLEVBQUQsRUFBS2tULE9BQUwsQ0FBdkM7QUFBdUQ7O0FBQy9FLFFBQUk0USxTQUFTLEdBQUc3QixlQUFlLENBQUNqaUIsRUFBRCxFQUFLa1QsT0FBTCxFQUFjNEwsbUJBQW1CLENBQUM5ZSxFQUFELEVBQUs2aUIsZUFBTCxFQUFzQnJzQixNQUF0QixDQUFqQyxFQUFnRSxNQUFoRSxDQUFmLENBQXVGZ29CLEdBQXZHO0FBQ0EsV0FBT21GLGlCQUFpQixDQUFDM2pCLEVBQUQsRUFBS2tULE9BQUwsRUFBYzJQLGVBQWQsRUFBK0JpQixTQUEvQixDQUF4QjtBQUNELEdBaHFGa0IsQ0FrcUZuQjtBQUNBOzs7QUFDQSxXQUFTQyxVQUFULENBQW9CQyxHQUFwQixFQUF5QjFhLENBQXpCLEVBQTRCa2EsQ0FBNUIsRUFBK0JsaEIsSUFBL0IsRUFBcUM7QUFDbkMsV0FBTzBoQixHQUFHLENBQUN6RixNQUFKLElBQWNpRixDQUFkLEdBQWtCLEtBQWxCLEdBQTBCUSxHQUFHLENBQUN4RixHQUFKLEdBQVVnRixDQUFWLEdBQWMsSUFBZCxHQUFxQixDQUFDbGhCLElBQUksR0FBRzBoQixHQUFHLENBQUMxaEIsSUFBUCxHQUFjMGhCLEdBQUcsQ0FBQ3poQixLQUF2QixJQUFnQytHLENBQXRGO0FBQ0Q7O0FBRUQsV0FBU21hLGVBQVQsQ0FBeUJ6akIsRUFBekIsRUFBNkJrVCxPQUE3QixFQUFzQzNLLE1BQXRDLEVBQThDZSxDQUE5QyxFQUFpRGthLENBQWpELEVBQW9EO0FBQ2xEO0FBQ0FBLEtBQUMsSUFBSXZRLGFBQVksQ0FBQ0MsT0FBRCxDQUFqQjtBQUNBLFFBQUkyUCxlQUFlLEdBQUc5RCxxQkFBcUIsQ0FBQy9lLEVBQUQsRUFBS2tULE9BQUwsQ0FBM0MsQ0FIa0QsQ0FJbEQ7QUFDQTs7QUFDQSxRQUFJZ0osWUFBWSxHQUFHOEYsZUFBZSxDQUFDOU8sT0FBRCxDQUFsQztBQUNBLFFBQUkwUSxLQUFLLEdBQUcsQ0FBWjtBQUFBLFFBQWU3dkIsR0FBRyxHQUFHbWYsT0FBTyxDQUFDalUsSUFBUixDQUFhek0sTUFBbEM7QUFBQSxRQUEwQ3l4QixHQUFHLEdBQUcsSUFBaEQ7QUFFQSxRQUFJdG9CLEtBQUssR0FBR29ELFFBQVEsQ0FBQ21VLE9BQUQsRUFBVWxULEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT3pLLFNBQWpCLENBQXBCLENBVGtELENBVWxEO0FBQ0E7O0FBQ0EsUUFBSXBCLEtBQUosRUFBVztBQUNULFVBQUlFLElBQUksR0FBRyxDQUFDbUUsRUFBRSxDQUFDdUUsT0FBSCxDQUFXMlosWUFBWCxHQUEwQmdHLHFCQUExQixHQUFrREMsY0FBbkQsRUFDR25rQixFQURILEVBQ09rVCxPQURQLEVBQ2dCM0ssTUFEaEIsRUFDd0JzYSxlQUR4QixFQUN5Q2xuQixLQUR6QyxFQUNnRDJOLENBRGhELEVBQ21Ea2EsQ0FEbkQsQ0FBWDtBQUVBUyxTQUFHLEdBQUdwb0IsSUFBSSxDQUFDRSxLQUFMLElBQWMsQ0FBcEIsQ0FIUyxDQUlUO0FBQ0E7QUFDQTtBQUNBOztBQUNBNm5CLFdBQUssR0FBR0ssR0FBRyxHQUFHcG9CLElBQUksQ0FBQ1QsSUFBUixHQUFlUyxJQUFJLENBQUNSLEVBQUwsR0FBVSxDQUFwQztBQUNBdEgsU0FBRyxHQUFHa3dCLEdBQUcsR0FBR3BvQixJQUFJLENBQUNSLEVBQVIsR0FBYVEsSUFBSSxDQUFDVCxJQUFMLEdBQVksQ0FBbEM7QUFDRCxLQXRCaUQsQ0F3QmxEO0FBQ0E7QUFDQTs7O0FBQ0EsUUFBSWdwQixRQUFRLEdBQUcsSUFBZjtBQUFBLFFBQXFCQyxTQUFTLEdBQUcsSUFBakM7QUFDQSxRQUFJanFCLEVBQUUsR0FBR2MsU0FBUyxDQUFDLFVBQVVkLEVBQVYsRUFBYztBQUMvQixVQUFJNHBCLEdBQUcsR0FBR2xGLG1CQUFtQixDQUFDOWUsRUFBRCxFQUFLNmlCLGVBQUwsRUFBc0J6b0IsRUFBdEIsQ0FBN0I7QUFDQTRwQixTQUFHLENBQUN4RixHQUFKLElBQVd0QyxZQUFYO0FBQXlCOEgsU0FBRyxDQUFDekYsTUFBSixJQUFjckMsWUFBZDs7QUFDekIsVUFBSSxDQUFDNkgsVUFBVSxDQUFDQyxHQUFELEVBQU0xYSxDQUFOLEVBQVNrYSxDQUFULEVBQVksS0FBWixDQUFmLEVBQW1DO0FBQUUsZUFBTyxLQUFQO0FBQWM7O0FBQ25ELFVBQUlRLEdBQUcsQ0FBQ3hGLEdBQUosSUFBV2dGLENBQVgsSUFBZ0JRLEdBQUcsQ0FBQzFoQixJQUFKLElBQVlnSCxDQUFoQyxFQUFtQztBQUNqQzhhLGdCQUFRLEdBQUdocUIsRUFBWDtBQUNBaXFCLGlCQUFTLEdBQUdMLEdBQVo7QUFDRDs7QUFDRCxhQUFPLElBQVA7QUFDRCxLQVRpQixFQVNmSixLQVRlLEVBU1I3dkIsR0FUUSxDQUFsQjtBQVdBLFFBQUl1d0IsS0FBSjtBQUFBLFFBQVdwb0IsTUFBWDtBQUFBLFFBQW1CbW5CLE9BQU8sR0FBRyxLQUE3QixDQXZDa0QsQ0F3Q2xEOztBQUNBLFFBQUlnQixTQUFKLEVBQWU7QUFDYjtBQUNBLFVBQUlFLE1BQU0sR0FBR2piLENBQUMsR0FBRythLFNBQVMsQ0FBQy9oQixJQUFkLEdBQXFCK2hCLFNBQVMsQ0FBQzloQixLQUFWLEdBQWtCK0csQ0FBcEQ7QUFBQSxVQUF1RGtiLE9BQU8sR0FBR0QsTUFBTSxJQUFJTixHQUEzRTtBQUNBN3BCLFFBQUUsR0FBR2dxQixRQUFRLElBQUlJLE9BQU8sR0FBRyxDQUFILEdBQU8sQ0FBbEIsQ0FBYjtBQUNBdG9CLFlBQU0sR0FBR3NvQixPQUFPLEdBQUcsT0FBSCxHQUFhLFFBQTdCO0FBQ0FGLFdBQUssR0FBR0MsTUFBTSxHQUFHRixTQUFTLENBQUMvaEIsSUFBYixHQUFvQitoQixTQUFTLENBQUM5aEIsS0FBNUM7QUFDRCxLQU5ELE1BTU87QUFDTDtBQUNBLFVBQUksQ0FBQzBoQixHQUFELEtBQVM3cEIsRUFBRSxJQUFJckcsR0FBTixJQUFhcUcsRUFBRSxJQUFJd3BCLEtBQTVCLENBQUosRUFBd0M7QUFBRXhwQixVQUFFO0FBQUssT0FGNUMsQ0FHTDtBQUNBO0FBQ0E7OztBQUNBOEIsWUFBTSxHQUFHOUIsRUFBRSxJQUFJLENBQU4sR0FBVSxPQUFWLEdBQW9CQSxFQUFFLElBQUk4WSxPQUFPLENBQUNqVSxJQUFSLENBQWF6TSxNQUFuQixHQUE0QixRQUE1QixHQUMxQnNzQixtQkFBbUIsQ0FBQzllLEVBQUQsRUFBSzZpQixlQUFMLEVBQXNCem9CLEVBQUUsSUFBSTZwQixHQUFHLEdBQUcsQ0FBSCxHQUFPLENBQWQsQ0FBeEIsQ0FBbkIsQ0FBNkQxRixNQUE3RCxHQUFzRXJDLFlBQXRFLElBQXNGc0gsQ0FBdkYsSUFBNkZTLEdBQTdGLEdBQ0EsT0FEQSxHQUNVLFFBRlosQ0FOSyxDQVNMO0FBQ0E7O0FBQ0EsVUFBSXpCLE1BQU0sR0FBR0ksYUFBWSxDQUFDNWlCLEVBQUQsRUFBS2tKLEdBQUcsQ0FBQ1gsTUFBRCxFQUFTbk8sRUFBVCxFQUFhOEIsTUFBYixDQUFSLEVBQThCLE1BQTlCLEVBQXNDZ1gsT0FBdEMsRUFBK0MyUCxlQUEvQyxDQUF6Qjs7QUFDQXlCLFdBQUssR0FBRzlCLE1BQU0sQ0FBQ2xnQixJQUFmO0FBQ0ErZ0IsYUFBTyxHQUFHRyxDQUFDLEdBQUdoQixNQUFNLENBQUNoRSxHQUFYLEdBQWlCLENBQUMsQ0FBbEIsR0FBc0JnRixDQUFDLElBQUloQixNQUFNLENBQUNqRSxNQUFaLEdBQXFCLENBQXJCLEdBQXlCLENBQXpEO0FBQ0Q7O0FBRURua0IsTUFBRSxHQUFHVSxrQkFBa0IsQ0FBQ29ZLE9BQU8sQ0FBQ2pVLElBQVQsRUFBZTdFLEVBQWYsRUFBbUIsQ0FBbkIsQ0FBdkI7QUFDQSxXQUFPZ3BCLFdBQVcsQ0FBQzdhLE1BQUQsRUFBU25PLEVBQVQsRUFBYThCLE1BQWIsRUFBcUJtbkIsT0FBckIsRUFBOEIvWixDQUFDLEdBQUdnYixLQUFsQyxDQUFsQjtBQUNEOztBQUVELFdBQVNILGNBQVQsQ0FBd0Jua0IsRUFBeEIsRUFBNEJrVCxPQUE1QixFQUFxQzNLLE1BQXJDLEVBQTZDc2EsZUFBN0MsRUFBOERsbkIsS0FBOUQsRUFBcUUyTixDQUFyRSxFQUF3RWthLENBQXhFLEVBQTJFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBSWp4QixLQUFLLEdBQUcySSxTQUFTLENBQUMsVUFBVXpILENBQVYsRUFBYTtBQUNqQyxVQUFJb0ksSUFBSSxHQUFHRixLQUFLLENBQUNsSSxDQUFELENBQWhCO0FBQUEsVUFBcUJ3d0IsR0FBRyxHQUFHcG9CLElBQUksQ0FBQ0UsS0FBTCxJQUFjLENBQXpDO0FBQ0EsYUFBT2dvQixVQUFVLENBQUNuQixhQUFZLENBQUM1aUIsRUFBRCxFQUFLa0osR0FBRyxDQUFDWCxNQUFELEVBQVMwYixHQUFHLEdBQUdwb0IsSUFBSSxDQUFDUixFQUFSLEdBQWFRLElBQUksQ0FBQ1QsSUFBOUIsRUFBb0M2b0IsR0FBRyxHQUFHLFFBQUgsR0FBYyxPQUFyRCxDQUFSLEVBQ0MsTUFERCxFQUNTL1EsT0FEVCxFQUNrQjJQLGVBRGxCLENBQWIsRUFDaUR2WixDQURqRCxFQUNvRGthLENBRHBELEVBQ3VELElBRHZELENBQWpCO0FBRUQsS0FKb0IsRUFJbEIsQ0FKa0IsRUFJZjduQixLQUFLLENBQUNuSixNQUFOLEdBQWUsQ0FKQSxDQUFyQjtBQUtBLFFBQUlxSixJQUFJLEdBQUdGLEtBQUssQ0FBQ3BKLEtBQUQsQ0FBaEIsQ0FWeUUsQ0FXekU7QUFDQTtBQUNBOztBQUNBLFFBQUlBLEtBQUssR0FBRyxDQUFaLEVBQWU7QUFDYixVQUFJMHhCLEdBQUcsR0FBR3BvQixJQUFJLENBQUNFLEtBQUwsSUFBYyxDQUF4Qjs7QUFDQSxVQUFJakksS0FBSyxHQUFHOHVCLGFBQVksQ0FBQzVpQixFQUFELEVBQUtrSixHQUFHLENBQUNYLE1BQUQsRUFBUzBiLEdBQUcsR0FBR3BvQixJQUFJLENBQUNULElBQVIsR0FBZVMsSUFBSSxDQUFDUixFQUFoQyxFQUFvQzRvQixHQUFHLEdBQUcsT0FBSCxHQUFhLFFBQXBELENBQVIsRUFDQyxNQURELEVBQ1MvUSxPQURULEVBQ2tCMlAsZUFEbEIsQ0FBeEI7O0FBRUEsVUFBSWtCLFVBQVUsQ0FBQ2p3QixLQUFELEVBQVF3VixDQUFSLEVBQVdrYSxDQUFYLEVBQWMsSUFBZCxDQUFWLElBQWlDMXZCLEtBQUssQ0FBQzBxQixHQUFOLEdBQVlnRixDQUFqRCxFQUNFO0FBQUUzbkIsWUFBSSxHQUFHRixLQUFLLENBQUNwSixLQUFLLEdBQUcsQ0FBVCxDQUFaO0FBQTBCO0FBQy9COztBQUNELFdBQU9zSixJQUFQO0FBQ0Q7O0FBRUQsV0FBU3FvQixxQkFBVCxDQUErQmxrQixFQUEvQixFQUFtQ2tULE9BQW5DLEVBQTRDdVIsT0FBNUMsRUFBcUQ1QixlQUFyRCxFQUFzRWxuQixLQUF0RSxFQUE2RTJOLENBQTdFLEVBQWdGa2EsQ0FBaEYsRUFBbUY7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFJa0IsR0FBRyxHQUFHZixpQkFBaUIsQ0FBQzNqQixFQUFELEVBQUtrVCxPQUFMLEVBQWMyUCxlQUFkLEVBQStCVyxDQUEvQixDQUEzQjtBQUNBLFFBQUlJLEtBQUssR0FBR2MsR0FBRyxDQUFDZCxLQUFoQjtBQUNBLFFBQUk3dkIsR0FBRyxHQUFHMndCLEdBQUcsQ0FBQzN3QixHQUFkOztBQUNBLFFBQUksS0FBSzlELElBQUwsQ0FBVWlqQixPQUFPLENBQUNqVSxJQUFSLENBQWFoRSxNQUFiLENBQW9CbEgsR0FBRyxHQUFHLENBQTFCLENBQVYsQ0FBSixFQUE2QztBQUFFQSxTQUFHO0FBQUs7O0FBQ3ZELFFBQUk4SCxJQUFJLEdBQUcsSUFBWDtBQUFBLFFBQWlCOG9CLFdBQVcsR0FBRyxJQUEvQjs7QUFDQSxTQUFLLElBQUlseEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2tJLEtBQUssQ0FBQ25KLE1BQTFCLEVBQWtDaUIsQ0FBQyxFQUFuQyxFQUF1QztBQUNyQyxVQUFJcWQsQ0FBQyxHQUFHblYsS0FBSyxDQUFDbEksQ0FBRCxDQUFiOztBQUNBLFVBQUlxZCxDQUFDLENBQUMxVixJQUFGLElBQVVySCxHQUFWLElBQWlCK2MsQ0FBQyxDQUFDelYsRUFBRixJQUFRdW9CLEtBQTdCLEVBQW9DO0FBQUU7QUFBVTs7QUFDaEQsVUFBSUssR0FBRyxHQUFHblQsQ0FBQyxDQUFDL1UsS0FBRixJQUFXLENBQXJCO0FBQ0EsVUFBSTZvQixJQUFJLEdBQUc5RixtQkFBbUIsQ0FBQzllLEVBQUQsRUFBSzZpQixlQUFMLEVBQXNCb0IsR0FBRyxHQUFHbnJCLElBQUksQ0FBQ0MsR0FBTCxDQUFTaEYsR0FBVCxFQUFjK2MsQ0FBQyxDQUFDelYsRUFBaEIsSUFBc0IsQ0FBekIsR0FBNkJ2QyxJQUFJLENBQUNnRCxHQUFMLENBQVM4bkIsS0FBVCxFQUFnQjlTLENBQUMsQ0FBQzFWLElBQWxCLENBQXRELENBQW5CLENBQWtHbUgsS0FBN0csQ0FKcUMsQ0FLckM7QUFDQTs7QUFDQSxVQUFJc2lCLElBQUksR0FBR0QsSUFBSSxHQUFHdGIsQ0FBUCxHQUFXQSxDQUFDLEdBQUdzYixJQUFKLEdBQVcsR0FBdEIsR0FBNEJBLElBQUksR0FBR3RiLENBQTlDOztBQUNBLFVBQUksQ0FBQ3pOLElBQUQsSUFBUzhvQixXQUFXLEdBQUdFLElBQTNCLEVBQWlDO0FBQy9CaHBCLFlBQUksR0FBR2lWLENBQVA7QUFDQTZULG1CQUFXLEdBQUdFLElBQWQ7QUFDRDtBQUNGOztBQUNELFFBQUksQ0FBQ2hwQixJQUFMLEVBQVc7QUFBRUEsVUFBSSxHQUFHRixLQUFLLENBQUNBLEtBQUssQ0FBQ25KLE1BQU4sR0FBZSxDQUFoQixDQUFaO0FBQWlDLEtBMUJtQyxDQTJCakY7OztBQUNBLFFBQUlxSixJQUFJLENBQUNULElBQUwsR0FBWXdvQixLQUFoQixFQUF1QjtBQUFFL25CLFVBQUksR0FBRztBQUFDVCxZQUFJLEVBQUV3b0IsS0FBUDtBQUFjdm9CLFVBQUUsRUFBRVEsSUFBSSxDQUFDUixFQUF2QjtBQUEyQlUsYUFBSyxFQUFFRixJQUFJLENBQUNFO0FBQXZDLE9BQVA7QUFBdUQ7O0FBQ2hGLFFBQUlGLElBQUksQ0FBQ1IsRUFBTCxHQUFVdEgsR0FBZCxFQUFtQjtBQUFFOEgsVUFBSSxHQUFHO0FBQUNULFlBQUksRUFBRVMsSUFBSSxDQUFDVCxJQUFaO0FBQWtCQyxVQUFFLEVBQUV0SCxHQUF0QjtBQUEyQmdJLGFBQUssRUFBRUYsSUFBSSxDQUFDRTtBQUF2QyxPQUFQO0FBQXVEOztBQUM1RSxXQUFPRixJQUFQO0FBQ0Q7O0FBRUQsTUFBSWlwQixXQUFKLENBcHlGbUIsQ0FxeUZuQjs7QUFDQSxXQUFTQyxVQUFULENBQW9CM1ksT0FBcEIsRUFBNkI7QUFDM0IsUUFBSUEsT0FBTyxDQUFDa1YsZ0JBQVIsSUFBNEIsSUFBaEMsRUFBc0M7QUFBRSxhQUFPbFYsT0FBTyxDQUFDa1YsZ0JBQWY7QUFBaUM7O0FBQ3pFLFFBQUl3RCxXQUFXLElBQUksSUFBbkIsRUFBeUI7QUFDdkJBLGlCQUFXLEdBQUc1eEIsR0FBRyxDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMsc0JBQWQsQ0FBakIsQ0FEdUIsQ0FFdkI7QUFDQTs7QUFDQSxXQUFLLElBQUlPLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsRUFBcEIsRUFBd0IsRUFBRUEsQ0FBMUIsRUFBNkI7QUFDM0JxeEIsbUJBQVcsQ0FBQzd4QixXQUFaLENBQXdCekMsUUFBUSxDQUFDZ0QsY0FBVCxDQUF3QixHQUF4QixDQUF4QjtBQUNBc3hCLG1CQUFXLENBQUM3eEIsV0FBWixDQUF3QkMsR0FBRyxDQUFDLElBQUQsQ0FBM0I7QUFDRDs7QUFDRDR4QixpQkFBVyxDQUFDN3hCLFdBQVosQ0FBd0J6QyxRQUFRLENBQUNnRCxjQUFULENBQXdCLEdBQXhCLENBQXhCO0FBQ0Q7O0FBQ0RULHdCQUFvQixDQUFDcVosT0FBTyxDQUFDdkssT0FBVCxFQUFrQmlqQixXQUFsQixDQUFwQjtBQUNBLFFBQUl6YyxNQUFNLEdBQUd5YyxXQUFXLENBQUNoakIsWUFBWixHQUEyQixFQUF4Qzs7QUFDQSxRQUFJdUcsTUFBTSxHQUFHLENBQWIsRUFBZ0I7QUFBRStELGFBQU8sQ0FBQ2tWLGdCQUFSLEdBQTJCalosTUFBM0I7QUFBb0M7O0FBQ3RENVYsa0JBQWMsQ0FBQzJaLE9BQU8sQ0FBQ3ZLLE9BQVQsQ0FBZDtBQUNBLFdBQU93RyxNQUFNLElBQUksQ0FBakI7QUFDRCxHQXZ6RmtCLENBeXpGbkI7OztBQUNBLFdBQVNpWSxTQUFULENBQW1CbFUsT0FBbkIsRUFBNEI7QUFDMUIsUUFBSUEsT0FBTyxDQUFDaVYsZUFBUixJQUEyQixJQUEvQixFQUFxQztBQUFFLGFBQU9qVixPQUFPLENBQUNpVixlQUFmO0FBQWdDOztBQUN2RSxRQUFJMkQsTUFBTSxHQUFHOXhCLEdBQUcsQ0FBQyxNQUFELEVBQVMsWUFBVCxDQUFoQjtBQUNBLFFBQUltaEIsR0FBRyxHQUFHbmhCLEdBQUcsQ0FBQyxLQUFELEVBQVEsQ0FBQzh4QixNQUFELENBQVIsRUFBa0Isc0JBQWxCLENBQWI7QUFDQWp5Qix3QkFBb0IsQ0FBQ3FaLE9BQU8sQ0FBQ3ZLLE9BQVQsRUFBa0J3UyxHQUFsQixDQUFwQjtBQUNBLFFBQUkySixJQUFJLEdBQUdnSCxNQUFNLENBQUM1aUIscUJBQVAsRUFBWDtBQUFBLFFBQTJDd1osS0FBSyxHQUFHLENBQUNvQyxJQUFJLENBQUN6YixLQUFMLEdBQWF5YixJQUFJLENBQUMxYixJQUFuQixJQUEyQixFQUE5RTs7QUFDQSxRQUFJc1osS0FBSyxHQUFHLENBQVosRUFBZTtBQUFFeFAsYUFBTyxDQUFDaVYsZUFBUixHQUEwQnpGLEtBQTFCO0FBQWtDOztBQUNuRCxXQUFPQSxLQUFLLElBQUksRUFBaEI7QUFDRCxHQWwwRmtCLENBbzBGbkI7QUFDQTs7O0FBQ0EsV0FBU3NELGFBQVQsQ0FBdUJsZixFQUF2QixFQUEyQjtBQUN6QixRQUFJcVQsQ0FBQyxHQUFHclQsRUFBRSxDQUFDb00sT0FBWDtBQUFBLFFBQW9COUosSUFBSSxHQUFHLEVBQTNCO0FBQUEsUUFBK0JzWixLQUFLLEdBQUcsRUFBdkM7QUFDQSxRQUFJbEIsVUFBVSxHQUFHckgsQ0FBQyxDQUFDK0ksT0FBRixDQUFVNkksVUFBM0I7O0FBQ0EsU0FBSyxJQUFJL3RCLENBQUMsR0FBR21jLENBQUMsQ0FBQytJLE9BQUYsQ0FBVXRwQixVQUFsQixFQUE4QlcsQ0FBQyxHQUFHLENBQXZDLEVBQTBDeUQsQ0FBMUMsRUFBNkNBLENBQUMsR0FBR0EsQ0FBQyxDQUFDK2pCLFdBQU4sRUFBbUIsRUFBRXhuQixDQUFsRSxFQUFxRTtBQUNuRSxVQUFJNkQsRUFBRSxHQUFHMEksRUFBRSxDQUFDb00sT0FBSCxDQUFXeU8sV0FBWCxDQUF1QnBuQixDQUF2QixFQUEwQnJCLFNBQW5DO0FBQ0FrUSxVQUFJLENBQUNoTCxFQUFELENBQUosR0FBV0osQ0FBQyxDQUFDZ3VCLFVBQUYsR0FBZWh1QixDQUFDLENBQUMrdEIsVUFBakIsR0FBOEJ2SyxVQUF6QztBQUNBa0IsV0FBSyxDQUFDdGtCLEVBQUQsQ0FBTCxHQUFZSixDQUFDLENBQUNvbEIsV0FBZDtBQUNEOztBQUNELFdBQU87QUFBQ25DLGNBQVEsRUFBRWdMLG9CQUFvQixDQUFDOVIsQ0FBRCxDQUEvQjtBQUNDK0csc0JBQWdCLEVBQUUvRyxDQUFDLENBQUMrSSxPQUFGLENBQVVyYSxXQUQ3QjtBQUVDMlksZ0JBQVUsRUFBRXBZLElBRmI7QUFHQ3dZLGlCQUFXLEVBQUVjLEtBSGQ7QUFJQ0Msa0JBQVksRUFBRXhJLENBQUMsQ0FBQ2dKLE9BQUYsQ0FBVUM7QUFKekIsS0FBUDtBQUtELEdBbjFGa0IsQ0FxMUZuQjtBQUNBO0FBQ0E7OztBQUNBLFdBQVM2SSxvQkFBVCxDQUE4Qi9ZLE9BQTlCLEVBQXVDO0FBQ3JDLFdBQU9BLE9BQU8sQ0FBQ3NSLFFBQVIsQ0FBaUJ0YixxQkFBakIsR0FBeUNFLElBQXpDLEdBQWdEOEosT0FBTyxDQUFDcVEsS0FBUixDQUFjcmEscUJBQWQsR0FBc0NFLElBQTdGO0FBQ0QsR0ExMUZrQixDQTQxRm5CO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU29SLGNBQVQsQ0FBd0IxVCxFQUF4QixFQUE0QjtBQUMxQixRQUFJb2xCLEVBQUUsR0FBR0wsVUFBVSxDQUFDL2tCLEVBQUUsQ0FBQ29NLE9BQUosQ0FBbkI7QUFBQSxRQUFpQzZSLFFBQVEsR0FBR2plLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVzJaLFlBQXZEO0FBQ0EsUUFBSW1ILE9BQU8sR0FBR3BILFFBQVEsSUFBSW5sQixJQUFJLENBQUNnRCxHQUFMLENBQVMsQ0FBVCxFQUFZa0UsRUFBRSxDQUFDb00sT0FBSCxDQUFXc1IsUUFBWCxDQUFvQnBCLFdBQXBCLEdBQWtDZ0UsU0FBUyxDQUFDdGdCLEVBQUUsQ0FBQ29NLE9BQUosQ0FBM0MsR0FBMEQsQ0FBdEUsQ0FBMUI7QUFDQSxXQUFPLFVBQVVwTixJQUFWLEVBQWdCO0FBQ3JCLFVBQUk4VCxZQUFZLENBQUM5UyxFQUFFLENBQUN3SCxHQUFKLEVBQVN4SSxJQUFULENBQWhCLEVBQWdDO0FBQUUsZUFBTyxDQUFQO0FBQVU7O0FBRTVDLFVBQUlzbUIsYUFBYSxHQUFHLENBQXBCOztBQUNBLFVBQUl0bUIsSUFBSSxDQUFDc2MsT0FBVCxFQUFrQjtBQUFFLGFBQUssSUFBSTduQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdUwsSUFBSSxDQUFDc2MsT0FBTCxDQUFhOW9CLE1BQWpDLEVBQXlDaUIsQ0FBQyxFQUExQyxFQUE4QztBQUNoRSxjQUFJdUwsSUFBSSxDQUFDc2MsT0FBTCxDQUFhN25CLENBQWIsRUFBZ0I0VSxNQUFwQixFQUE0QjtBQUFFaWQseUJBQWEsSUFBSXRtQixJQUFJLENBQUNzYyxPQUFMLENBQWE3bkIsQ0FBYixFQUFnQjRVLE1BQWpDO0FBQTBDO0FBQ3pFO0FBQUU7O0FBRUgsVUFBSTRWLFFBQUosRUFDRTtBQUFFLGVBQU9xSCxhQUFhLEdBQUcsQ0FBQ3hzQixJQUFJLENBQUMwQyxJQUFMLENBQVV3RCxJQUFJLENBQUNDLElBQUwsQ0FBVXpNLE1BQVYsR0FBbUI2eUIsT0FBN0IsS0FBeUMsQ0FBMUMsSUFBK0NELEVBQXRFO0FBQTBFLE9BRDlFLE1BR0U7QUFBRSxlQUFPRSxhQUFhLEdBQUdGLEVBQXZCO0FBQTJCO0FBQ2hDLEtBWkQ7QUFhRDs7QUFFRCxXQUFTRyxtQkFBVCxDQUE2QnZsQixFQUE3QixFQUFpQztBQUMvQixRQUFJd0gsR0FBRyxHQUFHeEgsRUFBRSxDQUFDd0gsR0FBYjtBQUFBLFFBQWtCZ2UsR0FBRyxHQUFHOVIsY0FBYyxDQUFDMVQsRUFBRCxDQUF0QztBQUNBd0gsT0FBRyxDQUFDVSxJQUFKLENBQVMsVUFBVWxKLElBQVYsRUFBZ0I7QUFDdkIsVUFBSTRVLFNBQVMsR0FBRzRSLEdBQUcsQ0FBQ3htQixJQUFELENBQW5COztBQUNBLFVBQUk0VSxTQUFTLElBQUk1VSxJQUFJLENBQUNxSixNQUF0QixFQUE4QjtBQUFFRCx3QkFBZ0IsQ0FBQ3BKLElBQUQsRUFBTzRVLFNBQVAsQ0FBaEI7QUFBb0M7QUFDckUsS0FIRDtBQUlELEdBdjNGa0IsQ0F5M0ZuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFTNlIsWUFBVCxDQUFzQnpsQixFQUF0QixFQUEwQnROLENBQTFCLEVBQTZCZ3pCLE9BQTdCLEVBQXNDQyxPQUF0QyxFQUErQztBQUM3QyxRQUFJdlosT0FBTyxHQUFHcE0sRUFBRSxDQUFDb00sT0FBakI7O0FBQ0EsUUFBSSxDQUFDc1osT0FBRCxJQUFZdmtCLFFBQVEsQ0FBQ3pPLENBQUQsQ0FBUixDQUFZOHBCLFlBQVosQ0FBeUIsZ0JBQXpCLEtBQThDLE1BQTlELEVBQXNFO0FBQUUsYUFBTyxJQUFQO0FBQWE7O0FBRXJGLFFBQUlsVCxDQUFKO0FBQUEsUUFBT2thLENBQVA7QUFBQSxRQUFVb0MsS0FBSyxHQUFHeFosT0FBTyxDQUFDd1EsU0FBUixDQUFrQnhhLHFCQUFsQixFQUFsQixDQUo2QyxDQUs3Qzs7QUFDQSxRQUFJO0FBQUVrSCxPQUFDLEdBQUc1VyxDQUFDLENBQUNtekIsT0FBRixHQUFZRCxLQUFLLENBQUN0akIsSUFBdEI7QUFBNEJraEIsT0FBQyxHQUFHOXdCLENBQUMsQ0FBQ296QixPQUFGLEdBQVlGLEtBQUssQ0FBQ3BILEdBQXRCO0FBQTRCLEtBQTlELENBQ0EsT0FBT3VILEdBQVAsRUFBWTtBQUFFLGFBQU8sSUFBUDtBQUFhOztBQUMzQixRQUFJdkQsTUFBTSxHQUFHZSxXQUFVLENBQUN2akIsRUFBRCxFQUFLc0osQ0FBTCxFQUFRa2EsQ0FBUixDQUF2QjtBQUFBLFFBQW1DeGtCLElBQW5DOztBQUNBLFFBQUkybUIsT0FBTyxJQUFJbkQsTUFBTSxDQUFDYyxJQUFQLEdBQWMsQ0FBekIsSUFBOEIsQ0FBQ3RrQixJQUFJLEdBQUd1SSxPQUFPLENBQUN2SCxFQUFFLENBQUN3SCxHQUFKLEVBQVNnYixNQUFNLENBQUN4akIsSUFBaEIsQ0FBUCxDQUE2QkMsSUFBckMsRUFBMkN6TSxNQUEzQyxJQUFxRGd3QixNQUFNLENBQUNwb0IsRUFBOUYsRUFBa0c7QUFDaEcsVUFBSTRyQixPQUFPLEdBQUdwdkIsV0FBVyxDQUFDb0ksSUFBRCxFQUFPQSxJQUFJLENBQUN4TSxNQUFaLEVBQW9Cd04sRUFBRSxDQUFDdUUsT0FBSCxDQUFXek4sT0FBL0IsQ0FBWCxHQUFxRGtJLElBQUksQ0FBQ3hNLE1BQXhFO0FBQ0Fnd0IsWUFBTSxHQUFHdFosR0FBRyxDQUFDc1osTUFBTSxDQUFDeGpCLElBQVIsRUFBY2xHLElBQUksQ0FBQ2dELEdBQUwsQ0FBUyxDQUFULEVBQVloRCxJQUFJLENBQUNtdEIsS0FBTCxDQUFXLENBQUMzYyxDQUFDLEdBQUd5VCxRQUFRLENBQUMvYyxFQUFFLENBQUNvTSxPQUFKLENBQVIsQ0FBcUI5SixJQUExQixJQUFrQ2dlLFNBQVMsQ0FBQ3RnQixFQUFFLENBQUNvTSxPQUFKLENBQXRELElBQXNFNFosT0FBbEYsQ0FBZCxDQUFaO0FBQ0Q7O0FBQ0QsV0FBT3hELE1BQVA7QUFDRCxHQTU0RmtCLENBODRGbkI7QUFDQTs7O0FBQ0EsV0FBU3ZELGFBQVQsQ0FBdUJqZixFQUF2QixFQUEyQjlJLENBQTNCLEVBQThCO0FBQzVCLFFBQUlBLENBQUMsSUFBSThJLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV0ksTUFBcEIsRUFBNEI7QUFBRSxhQUFPLElBQVA7QUFBYTs7QUFDM0N0VixLQUFDLElBQUk4SSxFQUFFLENBQUNvTSxPQUFILENBQVdHLFFBQWhCOztBQUNBLFFBQUlyVixDQUFDLEdBQUcsQ0FBUixFQUFXO0FBQUUsYUFBTyxJQUFQO0FBQWE7O0FBQzFCLFFBQUl5Z0IsSUFBSSxHQUFHM1gsRUFBRSxDQUFDb00sT0FBSCxDQUFXdUwsSUFBdEI7O0FBQ0EsU0FBSyxJQUFJbGtCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdra0IsSUFBSSxDQUFDbmxCLE1BQXpCLEVBQWlDaUIsQ0FBQyxFQUFsQyxFQUFzQztBQUNwQ3lELE9BQUMsSUFBSXlnQixJQUFJLENBQUNsa0IsQ0FBRCxDQUFKLENBQVFpVSxJQUFiOztBQUNBLFVBQUl4USxDQUFDLEdBQUcsQ0FBUixFQUFXO0FBQUUsZUFBT3pELENBQVA7QUFBVTtBQUN4QjtBQUNGLEdBejVGa0IsQ0EyNUZuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFdBQVN5eUIsU0FBVCxDQUFtQmxtQixFQUFuQixFQUF1QjVFLElBQXZCLEVBQTZCQyxFQUE3QixFQUFpQzhxQixPQUFqQyxFQUEwQztBQUN4QyxRQUFJL3FCLElBQUksSUFBSSxJQUFaLEVBQWtCO0FBQUVBLFVBQUksR0FBRzRFLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT0MsS0FBZDtBQUFzQjs7QUFDMUMsUUFBSXBNLEVBQUUsSUFBSSxJQUFWLEVBQWdCO0FBQUVBLFFBQUUsR0FBRzJFLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT0MsS0FBUCxHQUFlekgsRUFBRSxDQUFDd0gsR0FBSCxDQUFPRSxJQUEzQjtBQUFrQzs7QUFDcEQsUUFBSSxDQUFDeWUsT0FBTCxFQUFjO0FBQUVBLGFBQU8sR0FBRyxDQUFWO0FBQWM7O0FBRTlCLFFBQUkvWixPQUFPLEdBQUdwTSxFQUFFLENBQUNvTSxPQUFqQjs7QUFDQSxRQUFJK1osT0FBTyxJQUFJOXFCLEVBQUUsR0FBRytRLE9BQU8sQ0FBQ0ksTUFBeEIsS0FDQ0osT0FBTyxDQUFDZ2EsaUJBQVIsSUFBNkIsSUFBN0IsSUFBcUNoYSxPQUFPLENBQUNnYSxpQkFBUixHQUE0QmhyQixJQURsRSxDQUFKLEVBRUU7QUFBRWdSLGFBQU8sQ0FBQ2dhLGlCQUFSLEdBQTRCaHJCLElBQTVCO0FBQW1DOztBQUV2QzRFLE1BQUUsQ0FBQ1EsS0FBSCxDQUFTNmxCLFdBQVQsR0FBdUIsSUFBdkI7O0FBRUEsUUFBSWpyQixJQUFJLElBQUlnUixPQUFPLENBQUNJLE1BQXBCLEVBQTRCO0FBQUU7QUFDNUIsVUFBSXlCLGlCQUFpQixJQUFJd0UsWUFBWSxDQUFDelMsRUFBRSxDQUFDd0gsR0FBSixFQUFTcE0sSUFBVCxDQUFaLEdBQTZCZ1IsT0FBTyxDQUFDSSxNQUE5RCxFQUNFO0FBQUU4WixpQkFBUyxDQUFDdG1CLEVBQUQsQ0FBVDtBQUFnQjtBQUNyQixLQUhELE1BR08sSUFBSTNFLEVBQUUsSUFBSStRLE9BQU8sQ0FBQ0csUUFBbEIsRUFBNEI7QUFBRTtBQUNuQyxVQUFJMEIsaUJBQWlCLElBQUkyRSxlQUFlLENBQUM1UyxFQUFFLENBQUN3SCxHQUFKLEVBQVNuTSxFQUFFLEdBQUc4cUIsT0FBZCxDQUFmLEdBQXdDL1osT0FBTyxDQUFDRyxRQUF6RSxFQUFtRjtBQUNqRitaLGlCQUFTLENBQUN0bUIsRUFBRCxDQUFUO0FBQ0QsT0FGRCxNQUVPO0FBQ0xvTSxlQUFPLENBQUNHLFFBQVIsSUFBb0I0WixPQUFwQjtBQUNBL1osZUFBTyxDQUFDSSxNQUFSLElBQWtCMlosT0FBbEI7QUFDRDtBQUNGLEtBUE0sTUFPQSxJQUFJL3FCLElBQUksSUFBSWdSLE9BQU8sQ0FBQ0csUUFBaEIsSUFBNEJsUixFQUFFLElBQUkrUSxPQUFPLENBQUNJLE1BQTlDLEVBQXNEO0FBQUU7QUFDN0Q4WixlQUFTLENBQUN0bUIsRUFBRCxDQUFUO0FBQ0QsS0FGTSxNQUVBLElBQUk1RSxJQUFJLElBQUlnUixPQUFPLENBQUNHLFFBQXBCLEVBQThCO0FBQUU7QUFDckMsVUFBSWdhLEdBQUcsR0FBR0MsZ0JBQWdCLENBQUN4bUIsRUFBRCxFQUFLM0UsRUFBTCxFQUFTQSxFQUFFLEdBQUc4cUIsT0FBZCxFQUF1QixDQUF2QixDQUExQjs7QUFDQSxVQUFJSSxHQUFKLEVBQVM7QUFDUG5hLGVBQU8sQ0FBQ3VMLElBQVIsR0FBZXZMLE9BQU8sQ0FBQ3VMLElBQVIsQ0FBYXJsQixLQUFiLENBQW1CaTBCLEdBQUcsQ0FBQ2gwQixLQUF2QixDQUFmO0FBQ0E2WixlQUFPLENBQUNHLFFBQVIsR0FBbUJnYSxHQUFHLENBQUM3VCxLQUF2QjtBQUNBdEcsZUFBTyxDQUFDSSxNQUFSLElBQWtCMlosT0FBbEI7QUFDRCxPQUpELE1BSU87QUFDTEcsaUJBQVMsQ0FBQ3RtQixFQUFELENBQVQ7QUFDRDtBQUNGLEtBVE0sTUFTQSxJQUFJM0UsRUFBRSxJQUFJK1EsT0FBTyxDQUFDSSxNQUFsQixFQUEwQjtBQUFFO0FBQ2pDLFVBQUlpYSxLQUFLLEdBQUdELGdCQUFnQixDQUFDeG1CLEVBQUQsRUFBSzVFLElBQUwsRUFBV0EsSUFBWCxFQUFpQixDQUFDLENBQWxCLENBQTVCOztBQUNBLFVBQUlxckIsS0FBSixFQUFXO0FBQ1RyYSxlQUFPLENBQUN1TCxJQUFSLEdBQWV2TCxPQUFPLENBQUN1TCxJQUFSLENBQWFybEIsS0FBYixDQUFtQixDQUFuQixFQUFzQm0wQixLQUFLLENBQUNsMEIsS0FBNUIsQ0FBZjtBQUNBNlosZUFBTyxDQUFDSSxNQUFSLEdBQWlCaWEsS0FBSyxDQUFDL1QsS0FBdkI7QUFDRCxPQUhELE1BR087QUFDTDRULGlCQUFTLENBQUN0bUIsRUFBRCxDQUFUO0FBQ0Q7QUFDRixLQVJNLE1BUUE7QUFBRTtBQUNQLFVBQUkwbUIsTUFBTSxHQUFHRixnQkFBZ0IsQ0FBQ3htQixFQUFELEVBQUs1RSxJQUFMLEVBQVdBLElBQVgsRUFBaUIsQ0FBQyxDQUFsQixDQUE3QjtBQUNBLFVBQUl1ckIsTUFBTSxHQUFHSCxnQkFBZ0IsQ0FBQ3htQixFQUFELEVBQUszRSxFQUFMLEVBQVNBLEVBQUUsR0FBRzhxQixPQUFkLEVBQXVCLENBQXZCLENBQTdCOztBQUNBLFVBQUlPLE1BQU0sSUFBSUMsTUFBZCxFQUFzQjtBQUNwQnZhLGVBQU8sQ0FBQ3VMLElBQVIsR0FBZXZMLE9BQU8sQ0FBQ3VMLElBQVIsQ0FBYXJsQixLQUFiLENBQW1CLENBQW5CLEVBQXNCbzBCLE1BQU0sQ0FBQ24wQixLQUE3QixFQUNaaU4sTUFEWSxDQUNMaVksY0FBYyxDQUFDelgsRUFBRCxFQUFLMG1CLE1BQU0sQ0FBQ2hVLEtBQVosRUFBbUJpVSxNQUFNLENBQUNqVSxLQUExQixDQURULEVBRVpsVCxNQUZZLENBRUw0TSxPQUFPLENBQUN1TCxJQUFSLENBQWFybEIsS0FBYixDQUFtQnEwQixNQUFNLENBQUNwMEIsS0FBMUIsQ0FGSyxDQUFmO0FBR0E2WixlQUFPLENBQUNJLE1BQVIsSUFBa0IyWixPQUFsQjtBQUNELE9BTEQsTUFLTztBQUNMRyxpQkFBUyxDQUFDdG1CLEVBQUQsQ0FBVDtBQUNEO0FBQ0Y7O0FBRUQsUUFBSTRaLEdBQUcsR0FBR3hOLE9BQU8sQ0FBQzBJLGdCQUFsQjs7QUFDQSxRQUFJOEUsR0FBSixFQUFTO0FBQ1AsVUFBSXZlLEVBQUUsR0FBR3VlLEdBQUcsQ0FBQ2xILEtBQWIsRUFDRTtBQUFFa0gsV0FBRyxDQUFDbEgsS0FBSixJQUFheVQsT0FBYjtBQUF1QixPQUQzQixNQUVLLElBQUkvcUIsSUFBSSxHQUFHd2UsR0FBRyxDQUFDbEgsS0FBSixHQUFZa0gsR0FBRyxDQUFDbFMsSUFBM0IsRUFDSDtBQUFFMEUsZUFBTyxDQUFDMEksZ0JBQVIsR0FBMkIsSUFBM0I7QUFBa0M7QUFDdkM7QUFDRixHQTk5RmtCLENBZytGbkI7QUFDQTs7O0FBQ0EsV0FBUzhSLGFBQVQsQ0FBdUI1bUIsRUFBdkIsRUFBMkJoQixJQUEzQixFQUFpQzNCLElBQWpDLEVBQXVDO0FBQ3JDMkMsTUFBRSxDQUFDUSxLQUFILENBQVM2bEIsV0FBVCxHQUF1QixJQUF2QjtBQUNBLFFBQUlqYSxPQUFPLEdBQUdwTSxFQUFFLENBQUNvTSxPQUFqQjtBQUFBLFFBQTBCd04sR0FBRyxHQUFHNVosRUFBRSxDQUFDb00sT0FBSCxDQUFXMEksZ0JBQTNDOztBQUNBLFFBQUk4RSxHQUFHLElBQUk1YSxJQUFJLElBQUk0YSxHQUFHLENBQUNsSCxLQUFuQixJQUE0QjFULElBQUksR0FBRzRhLEdBQUcsQ0FBQ2xILEtBQUosR0FBWWtILEdBQUcsQ0FBQ2xTLElBQXZELEVBQ0U7QUFBRTBFLGFBQU8sQ0FBQzBJLGdCQUFSLEdBQTJCLElBQTNCO0FBQWtDOztBQUV0QyxRQUFJOVYsSUFBSSxHQUFHb04sT0FBTyxDQUFDRyxRQUFmLElBQTJCdk4sSUFBSSxJQUFJb04sT0FBTyxDQUFDSSxNQUEvQyxFQUF1RDtBQUFFO0FBQVE7O0FBQ2pFLFFBQUkySCxRQUFRLEdBQUcvSCxPQUFPLENBQUN1TCxJQUFSLENBQWFzSCxhQUFhLENBQUNqZixFQUFELEVBQUtoQixJQUFMLENBQTFCLENBQWY7O0FBQ0EsUUFBSW1WLFFBQVEsQ0FBQ2ppQixJQUFULElBQWlCLElBQXJCLEVBQTJCO0FBQUU7QUFBUTs7QUFDckMsUUFBSWtILEdBQUcsR0FBRythLFFBQVEsQ0FBQzRFLE9BQVQsS0FBcUI1RSxRQUFRLENBQUM0RSxPQUFULEdBQW1CLEVBQXhDLENBQVY7O0FBQ0EsUUFBSTNoQixPQUFPLENBQUNnQyxHQUFELEVBQU1pRSxJQUFOLENBQVAsSUFBc0IsQ0FBQyxDQUEzQixFQUE4QjtBQUFFakUsU0FBRyxDQUFDRixJQUFKLENBQVNtRSxJQUFUO0FBQWlCO0FBQ2xELEdBNytGa0IsQ0ErK0ZuQjs7O0FBQ0EsV0FBU2lwQixTQUFULENBQW1CdG1CLEVBQW5CLEVBQXVCO0FBQ3JCQSxNQUFFLENBQUNvTSxPQUFILENBQVdHLFFBQVgsR0FBc0J2TSxFQUFFLENBQUNvTSxPQUFILENBQVdJLE1BQVgsR0FBb0J4TSxFQUFFLENBQUN3SCxHQUFILENBQU9DLEtBQWpEO0FBQ0F6SCxNQUFFLENBQUNvTSxPQUFILENBQVd1TCxJQUFYLEdBQWtCLEVBQWxCO0FBQ0EzWCxNQUFFLENBQUNvTSxPQUFILENBQVdnVyxVQUFYLEdBQXdCLENBQXhCO0FBQ0Q7O0FBRUQsV0FBU29FLGdCQUFULENBQTBCeG1CLEVBQTFCLEVBQThCNm1CLElBQTlCLEVBQW9DQyxJQUFwQyxFQUEwQzlyQixHQUExQyxFQUErQztBQUM3QyxRQUFJekksS0FBSyxHQUFHMHNCLGFBQWEsQ0FBQ2pmLEVBQUQsRUFBSzZtQixJQUFMLENBQXpCO0FBQUEsUUFBcUN2ZSxJQUFyQztBQUFBLFFBQTJDcVAsSUFBSSxHQUFHM1gsRUFBRSxDQUFDb00sT0FBSCxDQUFXdUwsSUFBN0Q7O0FBQ0EsUUFBSSxDQUFDMUosaUJBQUQsSUFBc0I2WSxJQUFJLElBQUk5bUIsRUFBRSxDQUFDd0gsR0FBSCxDQUFPQyxLQUFQLEdBQWV6SCxFQUFFLENBQUN3SCxHQUFILENBQU9FLElBQXhELEVBQ0U7QUFBRSxhQUFPO0FBQUNuVixhQUFLLEVBQUVBLEtBQVI7QUFBZW1nQixhQUFLLEVBQUVvVTtBQUF0QixPQUFQO0FBQW9DOztBQUN4QyxRQUFJNXZCLENBQUMsR0FBRzhJLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV0csUUFBbkI7O0FBQ0EsU0FBSyxJQUFJOVksQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2xCLEtBQXBCLEVBQTJCa0IsQ0FBQyxFQUE1QixFQUNFO0FBQUV5RCxPQUFDLElBQUl5Z0IsSUFBSSxDQUFDbGtCLENBQUQsQ0FBSixDQUFRaVUsSUFBYjtBQUFvQjs7QUFDeEIsUUFBSXhRLENBQUMsSUFBSTJ2QixJQUFULEVBQWU7QUFDYixVQUFJN3JCLEdBQUcsR0FBRyxDQUFWLEVBQWE7QUFDWCxZQUFJekksS0FBSyxJQUFJb2xCLElBQUksQ0FBQ25sQixNQUFMLEdBQWMsQ0FBM0IsRUFBOEI7QUFBRSxpQkFBTyxJQUFQO0FBQWE7O0FBQzdDOFYsWUFBSSxHQUFJcFIsQ0FBQyxHQUFHeWdCLElBQUksQ0FBQ3BsQixLQUFELENBQUosQ0FBWW1WLElBQWpCLEdBQXlCbWYsSUFBaEM7QUFDQXQwQixhQUFLO0FBQ04sT0FKRCxNQUlPO0FBQ0wrVixZQUFJLEdBQUdwUixDQUFDLEdBQUcydkIsSUFBWDtBQUNEOztBQUNEQSxVQUFJLElBQUl2ZSxJQUFSO0FBQWN3ZSxVQUFJLElBQUl4ZSxJQUFSO0FBQ2Y7O0FBQ0QsV0FBT21LLFlBQVksQ0FBQ3pTLEVBQUUsQ0FBQ3dILEdBQUosRUFBU3NmLElBQVQsQ0FBWixJQUE4QkEsSUFBckMsRUFBMkM7QUFDekMsVUFBSXYwQixLQUFLLEtBQUt5SSxHQUFHLEdBQUcsQ0FBTixHQUFVLENBQVYsR0FBYzJjLElBQUksQ0FBQ25sQixNQUFMLEdBQWMsQ0FBakMsQ0FBVCxFQUE4QztBQUFFLGVBQU8sSUFBUDtBQUFhOztBQUM3RHMwQixVQUFJLElBQUk5ckIsR0FBRyxHQUFHMmMsSUFBSSxDQUFDcGxCLEtBQUssSUFBSXlJLEdBQUcsR0FBRyxDQUFOLEdBQVUsQ0FBVixHQUFjLENBQWxCLENBQU4sQ0FBSixDQUFnQzBNLElBQTlDO0FBQ0FuVixXQUFLLElBQUl5SSxHQUFUO0FBQ0Q7O0FBQ0QsV0FBTztBQUFDekksV0FBSyxFQUFFQSxLQUFSO0FBQWVtZ0IsV0FBSyxFQUFFb1U7QUFBdEIsS0FBUDtBQUNELEdBN2dHa0IsQ0ErZ0duQjtBQUNBOzs7QUFDQSxXQUFTQyxVQUFULENBQW9CL21CLEVBQXBCLEVBQXdCNUUsSUFBeEIsRUFBOEJDLEVBQTlCLEVBQWtDO0FBQ2hDLFFBQUkrUSxPQUFPLEdBQUdwTSxFQUFFLENBQUNvTSxPQUFqQjtBQUFBLFFBQTBCdUwsSUFBSSxHQUFHdkwsT0FBTyxDQUFDdUwsSUFBekM7O0FBQ0EsUUFBSUEsSUFBSSxDQUFDbmxCLE1BQUwsSUFBZSxDQUFmLElBQW9CNEksSUFBSSxJQUFJZ1IsT0FBTyxDQUFDSSxNQUFwQyxJQUE4Q25SLEVBQUUsSUFBSStRLE9BQU8sQ0FBQ0csUUFBaEUsRUFBMEU7QUFDeEVILGFBQU8sQ0FBQ3VMLElBQVIsR0FBZUYsY0FBYyxDQUFDelgsRUFBRCxFQUFLNUUsSUFBTCxFQUFXQyxFQUFYLENBQTdCO0FBQ0ErUSxhQUFPLENBQUNHLFFBQVIsR0FBbUJuUixJQUFuQjtBQUNELEtBSEQsTUFHTztBQUNMLFVBQUlnUixPQUFPLENBQUNHLFFBQVIsR0FBbUJuUixJQUF2QixFQUNFO0FBQUVnUixlQUFPLENBQUN1TCxJQUFSLEdBQWVGLGNBQWMsQ0FBQ3pYLEVBQUQsRUFBSzVFLElBQUwsRUFBV2dSLE9BQU8sQ0FBQ0csUUFBbkIsQ0FBZCxDQUEyQy9NLE1BQTNDLENBQWtENE0sT0FBTyxDQUFDdUwsSUFBMUQsQ0FBZjtBQUFpRixPQURyRixNQUVLLElBQUl2TCxPQUFPLENBQUNHLFFBQVIsR0FBbUJuUixJQUF2QixFQUNIO0FBQUVnUixlQUFPLENBQUN1TCxJQUFSLEdBQWV2TCxPQUFPLENBQUN1TCxJQUFSLENBQWFybEIsS0FBYixDQUFtQjJzQixhQUFhLENBQUNqZixFQUFELEVBQUs1RSxJQUFMLENBQWhDLENBQWY7QUFBNkQ7O0FBQ2pFZ1IsYUFBTyxDQUFDRyxRQUFSLEdBQW1CblIsSUFBbkI7O0FBQ0EsVUFBSWdSLE9BQU8sQ0FBQ0ksTUFBUixHQUFpQm5SLEVBQXJCLEVBQ0U7QUFBRStRLGVBQU8sQ0FBQ3VMLElBQVIsR0FBZXZMLE9BQU8sQ0FBQ3VMLElBQVIsQ0FBYW5ZLE1BQWIsQ0FBb0JpWSxjQUFjLENBQUN6WCxFQUFELEVBQUtvTSxPQUFPLENBQUNJLE1BQWIsRUFBcUJuUixFQUFyQixDQUFsQyxDQUFmO0FBQTZFLE9BRGpGLE1BRUssSUFBSStRLE9BQU8sQ0FBQ0ksTUFBUixHQUFpQm5SLEVBQXJCLEVBQ0g7QUFBRStRLGVBQU8sQ0FBQ3VMLElBQVIsR0FBZXZMLE9BQU8sQ0FBQ3VMLElBQVIsQ0FBYXJsQixLQUFiLENBQW1CLENBQW5CLEVBQXNCMnNCLGFBQWEsQ0FBQ2pmLEVBQUQsRUFBSzNFLEVBQUwsQ0FBbkMsQ0FBZjtBQUE4RDtBQUNuRTs7QUFDRCtRLFdBQU8sQ0FBQ0ksTUFBUixHQUFpQm5SLEVBQWpCO0FBQ0QsR0FsaUdrQixDQW9pR25CO0FBQ0E7OztBQUNBLFdBQVMyckIsY0FBVCxDQUF3QmhuQixFQUF4QixFQUE0QjtBQUMxQixRQUFJMlgsSUFBSSxHQUFHM1gsRUFBRSxDQUFDb00sT0FBSCxDQUFXdUwsSUFBdEI7QUFBQSxRQUE0QnNQLEtBQUssR0FBRyxDQUFwQzs7QUFDQSxTQUFLLElBQUl4ekIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2trQixJQUFJLENBQUNubEIsTUFBekIsRUFBaUNpQixDQUFDLEVBQWxDLEVBQXNDO0FBQ3BDLFVBQUkwZ0IsUUFBUSxHQUFHd0QsSUFBSSxDQUFDbGtCLENBQUQsQ0FBbkI7O0FBQ0EsVUFBSSxDQUFDMGdCLFFBQVEsQ0FBQ3FELE1BQVYsS0FBcUIsQ0FBQ3JELFFBQVEsQ0FBQ2ppQixJQUFWLElBQWtCaWlCLFFBQVEsQ0FBQzRFLE9BQWhELENBQUosRUFBOEQ7QUFBRSxVQUFFa08sS0FBRjtBQUFVO0FBQzNFOztBQUNELFdBQU9BLEtBQVA7QUFDRDs7QUFFRCxXQUFTQyxlQUFULENBQXlCbG5CLEVBQXpCLEVBQTZCO0FBQzNCQSxNQUFFLENBQUNvTSxPQUFILENBQVdzSyxLQUFYLENBQWlCeVEsYUFBakIsQ0FBK0JubkIsRUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQjBRLGdCQUFqQixFQUEvQjtBQUNEOztBQUVELFdBQVNBLGdCQUFULENBQTBCcG5CLEVBQTFCLEVBQThCcW5CLE9BQTlCLEVBQXVDO0FBQ3JDLFFBQUtBLE9BQU8sS0FBSyxLQUFLLENBQXRCLEVBQTBCQSxPQUFPLEdBQUcsSUFBVjtBQUUxQixRQUFJN2YsR0FBRyxHQUFHeEgsRUFBRSxDQUFDd0gsR0FBYjtBQUFBLFFBQWtCL0UsTUFBTSxHQUFHLEVBQTNCO0FBQ0EsUUFBSTZrQixXQUFXLEdBQUc3a0IsTUFBTSxDQUFDOGtCLE9BQVAsR0FBaUIvMkIsUUFBUSxDQUFDc2xCLHNCQUFULEVBQW5DO0FBQ0EsUUFBSTBSLFdBQVcsR0FBRy9rQixNQUFNLENBQUNTLFNBQVAsR0FBbUIxUyxRQUFRLENBQUNzbEIsc0JBQVQsRUFBckM7O0FBRUEsU0FBSyxJQUFJcmlCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcrVCxHQUFHLENBQUNpZ0IsR0FBSixDQUFRQyxNQUFSLENBQWVsMUIsTUFBbkMsRUFBMkNpQixDQUFDLEVBQTVDLEVBQWdEO0FBQzlDLFVBQUksQ0FBQzR6QixPQUFELElBQVk1ekIsQ0FBQyxJQUFJK1QsR0FBRyxDQUFDaWdCLEdBQUosQ0FBUUUsU0FBN0IsRUFBd0M7QUFBRTtBQUFVOztBQUNwRCxVQUFJL3pCLEtBQUssR0FBRzRULEdBQUcsQ0FBQ2lnQixHQUFKLENBQVFDLE1BQVIsQ0FBZWowQixDQUFmLENBQVo7O0FBQ0EsVUFBSUcsS0FBSyxDQUFDd0gsSUFBTixHQUFhNEQsSUFBYixJQUFxQmdCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV0ksTUFBaEMsSUFBMEM1WSxLQUFLLENBQUN5SCxFQUFOLEdBQVcyRCxJQUFYLEdBQWtCZ0IsRUFBRSxDQUFDb00sT0FBSCxDQUFXRyxRQUEzRSxFQUFxRjtBQUFFO0FBQVU7O0FBQ2pHLFVBQUl5RixTQUFTLEdBQUdwZSxLQUFLLENBQUNnMEIsS0FBTixFQUFoQjs7QUFDQSxVQUFJNVYsU0FBUyxJQUFJaFMsRUFBRSxDQUFDdUUsT0FBSCxDQUFXc2pCLHVCQUE1QixFQUNFO0FBQUVDLDJCQUFtQixDQUFDOW5CLEVBQUQsRUFBS3BNLEtBQUssQ0FBQ20wQixJQUFYLEVBQWlCVCxXQUFqQixDQUFuQjtBQUFtRDs7QUFDdkQsVUFBSSxDQUFDdFYsU0FBTCxFQUNFO0FBQUVnVywwQkFBa0IsQ0FBQ2hvQixFQUFELEVBQUtwTSxLQUFMLEVBQVk0ekIsV0FBWixDQUFsQjtBQUE2QztBQUNsRDs7QUFDRCxXQUFPL2tCLE1BQVA7QUFDRCxHQXJrR2tCLENBdWtHbkI7OztBQUNBLFdBQVNxbEIsbUJBQVQsQ0FBNkI5bkIsRUFBN0IsRUFBaUMrbkIsSUFBakMsRUFBdUMzYSxNQUF2QyxFQUErQztBQUM3QyxRQUFJelUsR0FBRyxHQUFHaXFCLGFBQVksQ0FBQzVpQixFQUFELEVBQUsrbkIsSUFBTCxFQUFXLEtBQVgsRUFBa0IsSUFBbEIsRUFBd0IsSUFBeEIsRUFBOEIsQ0FBQy9uQixFQUFFLENBQUN1RSxPQUFILENBQVdrYyx5QkFBMUMsQ0FBdEI7O0FBRUEsUUFBSXdILE1BQU0sR0FBRzdhLE1BQU0sQ0FBQ25hLFdBQVAsQ0FBbUJDLEdBQUcsQ0FBQyxLQUFELEVBQVEsTUFBUixFQUFrQixtQkFBbEIsQ0FBdEIsQ0FBYjtBQUNBKzBCLFVBQU0sQ0FBQzUwQixLQUFQLENBQWFpUCxJQUFiLEdBQW9CM0osR0FBRyxDQUFDMkosSUFBSixHQUFXLElBQS9CO0FBQ0EybEIsVUFBTSxDQUFDNTBCLEtBQVAsQ0FBYW1yQixHQUFiLEdBQW1CN2xCLEdBQUcsQ0FBQzZsQixHQUFKLEdBQVUsSUFBN0I7QUFDQXlKLFVBQU0sQ0FBQzUwQixLQUFQLENBQWFnVixNQUFiLEdBQXNCdlAsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTLENBQVQsRUFBWW5ELEdBQUcsQ0FBQzRsQixNQUFKLEdBQWE1bEIsR0FBRyxDQUFDNmxCLEdBQTdCLElBQW9DeGUsRUFBRSxDQUFDdUUsT0FBSCxDQUFXMmpCLFlBQS9DLEdBQThELElBQXBGOztBQUVBLFFBQUl2dkIsR0FBRyxDQUFDdXFCLEtBQVIsRUFBZTtBQUNiO0FBQ0EsVUFBSWlGLFdBQVcsR0FBRy9hLE1BQU0sQ0FBQ25hLFdBQVAsQ0FBbUJDLEdBQUcsQ0FBQyxLQUFELEVBQVEsTUFBUixFQUFrQiw4Q0FBbEIsQ0FBdEIsQ0FBbEI7QUFDQWkxQixpQkFBVyxDQUFDOTBCLEtBQVosQ0FBa0IrWSxPQUFsQixHQUE0QixFQUE1QjtBQUNBK2IsaUJBQVcsQ0FBQzkwQixLQUFaLENBQWtCaVAsSUFBbEIsR0FBeUIzSixHQUFHLENBQUN1cUIsS0FBSixDQUFVNWdCLElBQVYsR0FBaUIsSUFBMUM7QUFDQTZsQixpQkFBVyxDQUFDOTBCLEtBQVosQ0FBa0JtckIsR0FBbEIsR0FBd0I3bEIsR0FBRyxDQUFDdXFCLEtBQUosQ0FBVTFFLEdBQVYsR0FBZ0IsSUFBeEM7QUFDQTJKLGlCQUFXLENBQUM5MEIsS0FBWixDQUFrQmdWLE1BQWxCLEdBQTJCLENBQUMxUCxHQUFHLENBQUN1cUIsS0FBSixDQUFVM0UsTUFBVixHQUFtQjVsQixHQUFHLENBQUN1cUIsS0FBSixDQUFVMUUsR0FBOUIsSUFBcUMsR0FBckMsR0FBMkMsSUFBdEU7QUFDRDtBQUNGOztBQUVELFdBQVM0SixTQUFULENBQW1CaHpCLENBQW5CLEVBQXNCQyxDQUF0QixFQUF5QjtBQUFFLFdBQU9ELENBQUMsQ0FBQ29wQixHQUFGLEdBQVFucEIsQ0FBQyxDQUFDbXBCLEdBQVYsSUFBaUJwcEIsQ0FBQyxDQUFDa04sSUFBRixHQUFTak4sQ0FBQyxDQUFDaU4sSUFBbkM7QUFBeUMsR0ExbEdqRCxDQTRsR25COzs7QUFDQSxXQUFTMGxCLGtCQUFULENBQTRCaG9CLEVBQTVCLEVBQWdDcE0sS0FBaEMsRUFBdUN3WixNQUF2QyxFQUErQztBQUM3QyxRQUFJaEIsT0FBTyxHQUFHcE0sRUFBRSxDQUFDb00sT0FBakI7QUFBQSxRQUEwQjVFLEdBQUcsR0FBR3hILEVBQUUsQ0FBQ3dILEdBQW5DO0FBQ0EsUUFBSTZnQixRQUFRLEdBQUc3M0IsUUFBUSxDQUFDc2xCLHNCQUFULEVBQWY7QUFDQSxRQUFJd1MsT0FBTyxHQUFHdkwsUUFBUSxDQUFDL2MsRUFBRSxDQUFDb00sT0FBSixDQUF0QjtBQUFBLFFBQW9DbWMsUUFBUSxHQUFHRCxPQUFPLENBQUNobUIsSUFBdkQ7QUFDQSxRQUFJa21CLFNBQVMsR0FBRzF2QixJQUFJLENBQUNnRCxHQUFMLENBQVNzUSxPQUFPLENBQUNxYyxVQUFqQixFQUE2QmhMLFlBQVksQ0FBQ3pkLEVBQUQsQ0FBWixHQUFtQm9NLE9BQU8sQ0FBQ3FRLEtBQVIsQ0FBY3lJLFVBQTlELElBQTRFb0QsT0FBTyxDQUFDL2xCLEtBQXBHO0FBQ0EsUUFBSW1tQixNQUFNLEdBQUdsaEIsR0FBRyxDQUFDekssU0FBSixJQUFpQixLQUE5Qjs7QUFFQSxhQUFTNHJCLEdBQVQsQ0FBYXJtQixJQUFiLEVBQW1Ca2MsR0FBbkIsRUFBd0I1QyxLQUF4QixFQUErQjJDLE1BQS9CLEVBQXVDO0FBQ3JDLFVBQUlDLEdBQUcsR0FBRyxDQUFWLEVBQWE7QUFBRUEsV0FBRyxHQUFHLENBQU47QUFBVTs7QUFDekJBLFNBQUcsR0FBRzFsQixJQUFJLENBQUNtdEIsS0FBTCxDQUFXekgsR0FBWCxDQUFOO0FBQ0FELFlBQU0sR0FBR3psQixJQUFJLENBQUNtdEIsS0FBTCxDQUFXMUgsTUFBWCxDQUFUO0FBQ0E4SixjQUFRLENBQUNwMUIsV0FBVCxDQUFxQkMsR0FBRyxDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMscUJBQWQsRUFBc0MsK0JBQStCb1AsSUFBL0IsR0FBc0MseUNBQXRDLEdBQWtGa2MsR0FBbEYsR0FBd0YsYUFBeEYsSUFBeUc1QyxLQUFLLElBQUksSUFBVCxHQUFnQjRNLFNBQVMsR0FBR2xtQixJQUE1QixHQUFtQ3NaLEtBQTVJLElBQXFKLDRDQUFySixJQUFxTTJDLE1BQU0sR0FBR0MsR0FBOU0sSUFBcU4sSUFBM1AsQ0FBeEI7QUFDRDs7QUFFRCxhQUFTb0ssV0FBVCxDQUFxQjVwQixJQUFyQixFQUEyQjZwQixPQUEzQixFQUFvQ0MsS0FBcEMsRUFBMkM7QUFDekMsVUFBSTVWLE9BQU8sR0FBRzNMLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNeEksSUFBTixDQUFyQjtBQUNBLFVBQUkrcEIsT0FBTyxHQUFHN1YsT0FBTyxDQUFDalUsSUFBUixDQUFhek0sTUFBM0I7QUFDQSxVQUFJc0IsS0FBSixFQUFXQyxHQUFYOztBQUNBLGVBQVN5dUIsTUFBVCxDQUFnQnBvQixFQUFoQixFQUFvQnlrQixJQUFwQixFQUEwQjtBQUN4QixlQUFPOEQsV0FBVSxDQUFDM2lCLEVBQUQsRUFBS2tKLEdBQUcsQ0FBQ2xLLElBQUQsRUFBTzVFLEVBQVAsQ0FBUixFQUFvQixLQUFwQixFQUEyQjhZLE9BQTNCLEVBQW9DMkwsSUFBcEMsQ0FBakI7QUFDRDs7QUFFRCxlQUFTbUssS0FBVCxDQUFlcndCLEdBQWYsRUFBb0JxQyxHQUFwQixFQUF5Qml1QixJQUF6QixFQUErQjtBQUM3QixZQUFJQyxNQUFNLEdBQUdyRixxQkFBcUIsQ0FBQzdqQixFQUFELEVBQUtrVCxPQUFMLEVBQWMsSUFBZCxFQUFvQnZhLEdBQXBCLENBQWxDO0FBQ0EsWUFBSWpDLElBQUksR0FBSXNFLEdBQUcsSUFBSSxLQUFSLEtBQW1CaXVCLElBQUksSUFBSSxPQUEzQixJQUFzQyxNQUF0QyxHQUErQyxPQUExRDtBQUNBLFlBQUk3dUIsRUFBRSxHQUFHNnVCLElBQUksSUFBSSxPQUFSLEdBQWtCQyxNQUFNLENBQUN0RixLQUF6QixHQUFpQ3NGLE1BQU0sQ0FBQ24xQixHQUFQLElBQWMsS0FBSzlELElBQUwsQ0FBVWlqQixPQUFPLENBQUNqVSxJQUFSLENBQWFoRSxNQUFiLENBQW9CaXVCLE1BQU0sQ0FBQ24xQixHQUFQLEdBQWEsQ0FBakMsQ0FBVixJQUFpRCxDQUFqRCxHQUFxRCxDQUFuRSxDQUExQztBQUNBLGVBQU95dUIsTUFBTSxDQUFDcG9CLEVBQUQsRUFBSzFELElBQUwsQ0FBTixDQUFpQkEsSUFBakIsQ0FBUDtBQUNEOztBQUVELFVBQUlpRixLQUFLLEdBQUdvRCxRQUFRLENBQUNtVSxPQUFELEVBQVUxTCxHQUFHLENBQUN6SyxTQUFkLENBQXBCO0FBQ0FyQix5QkFBbUIsQ0FBQ0MsS0FBRCxFQUFRa3RCLE9BQU8sSUFBSSxDQUFuQixFQUFzQkMsS0FBSyxJQUFJLElBQVQsR0FBZ0JDLE9BQWhCLEdBQTBCRCxLQUFoRCxFQUF1RCxVQUFVMXRCLElBQVYsRUFBZ0JDLEVBQWhCLEVBQW9CTCxHQUFwQixFQUF5QnZILENBQXpCLEVBQTRCO0FBQ3BHLFlBQUl3d0IsR0FBRyxHQUFHanBCLEdBQUcsSUFBSSxLQUFqQjtBQUNBLFlBQUltdUIsT0FBTyxHQUFHM0csTUFBTSxDQUFDcG5CLElBQUQsRUFBTzZvQixHQUFHLEdBQUcsTUFBSCxHQUFZLE9BQXRCLENBQXBCO0FBQ0EsWUFBSW1GLEtBQUssR0FBRzVHLE1BQU0sQ0FBQ25uQixFQUFFLEdBQUcsQ0FBTixFQUFTNG9CLEdBQUcsR0FBRyxPQUFILEdBQWEsTUFBekIsQ0FBbEI7QUFFQSxZQUFJb0YsU0FBUyxHQUFHUixPQUFPLElBQUksSUFBWCxJQUFtQnp0QixJQUFJLElBQUksQ0FBM0M7QUFBQSxZQUE4Q2t1QixPQUFPLEdBQUdSLEtBQUssSUFBSSxJQUFULElBQWlCenRCLEVBQUUsSUFBSTB0QixPQUEvRTtBQUNBLFlBQUl0aEIsS0FBSyxHQUFHaFUsQ0FBQyxJQUFJLENBQWpCO0FBQUEsWUFBb0JrVyxJQUFJLEdBQUcsQ0FBQ2hPLEtBQUQsSUFBVWxJLENBQUMsSUFBSWtJLEtBQUssQ0FBQ25KLE1BQU4sR0FBZSxDQUF6RDs7QUFDQSxZQUFJNDJCLEtBQUssQ0FBQzVLLEdBQU4sR0FBWTJLLE9BQU8sQ0FBQzNLLEdBQXBCLElBQTJCLENBQS9CLEVBQWtDO0FBQUU7QUFDbEMsY0FBSStLLFFBQVEsR0FBRyxDQUFDYixNQUFNLEdBQUdXLFNBQUgsR0FBZUMsT0FBdEIsS0FBa0M3aEIsS0FBakQ7QUFDQSxjQUFJK2hCLFNBQVMsR0FBRyxDQUFDZCxNQUFNLEdBQUdZLE9BQUgsR0FBYUQsU0FBcEIsS0FBa0MxZixJQUFsRDtBQUNBLGNBQUlySCxJQUFJLEdBQUdpbkIsUUFBUSxHQUFHaEIsUUFBSCxHQUFjLENBQUN0RSxHQUFHLEdBQUdrRixPQUFILEdBQWFDLEtBQWpCLEVBQXdCOW1CLElBQXpEO0FBQ0EsY0FBSUMsS0FBSyxHQUFHaW5CLFNBQVMsR0FBR2hCLFNBQUgsR0FBZSxDQUFDdkUsR0FBRyxHQUFHbUYsS0FBSCxHQUFXRCxPQUFmLEVBQXdCNW1CLEtBQTVEO0FBQ0FvbUIsYUFBRyxDQUFDcm1CLElBQUQsRUFBTzZtQixPQUFPLENBQUMzSyxHQUFmLEVBQW9CamMsS0FBSyxHQUFHRCxJQUE1QixFQUFrQzZtQixPQUFPLENBQUM1SyxNQUExQyxDQUFIO0FBQ0QsU0FORCxNQU1PO0FBQUU7QUFDUCxjQUFJa0wsT0FBSixFQUFhQyxRQUFiLEVBQXVCQyxPQUF2QixFQUFnQ0MsUUFBaEM7O0FBQ0EsY0FBSTNGLEdBQUosRUFBUztBQUNQd0YsbUJBQU8sR0FBR2YsTUFBTSxJQUFJVyxTQUFWLElBQXVCNWhCLEtBQXZCLEdBQStCOGdCLFFBQS9CLEdBQTBDWSxPQUFPLENBQUM3bUIsSUFBNUQ7QUFDQW9uQixvQkFBUSxHQUFHaEIsTUFBTSxHQUFHRixTQUFILEdBQWVRLEtBQUssQ0FBQzV0QixJQUFELEVBQU9KLEdBQVAsRUFBWSxRQUFaLENBQXJDO0FBQ0EydUIsbUJBQU8sR0FBR2pCLE1BQU0sR0FBR0gsUUFBSCxHQUFjUyxLQUFLLENBQUMzdEIsRUFBRCxFQUFLTCxHQUFMLEVBQVUsT0FBVixDQUFuQztBQUNBNHVCLG9CQUFRLEdBQUdsQixNQUFNLElBQUlZLE9BQVYsSUFBcUIzZixJQUFyQixHQUE0QjZlLFNBQTVCLEdBQXdDWSxLQUFLLENBQUM3bUIsS0FBekQ7QUFDRCxXQUxELE1BS087QUFDTGtuQixtQkFBTyxHQUFHLENBQUNmLE1BQUQsR0FBVUgsUUFBVixHQUFxQlMsS0FBSyxDQUFDNXRCLElBQUQsRUFBT0osR0FBUCxFQUFZLFFBQVosQ0FBcEM7QUFDQTB1QixvQkFBUSxHQUFHLENBQUNoQixNQUFELElBQVdXLFNBQVgsSUFBd0I1aEIsS0FBeEIsR0FBZ0MrZ0IsU0FBaEMsR0FBNENXLE9BQU8sQ0FBQzVtQixLQUEvRDtBQUNBb25CLG1CQUFPLEdBQUcsQ0FBQ2pCLE1BQUQsSUFBV1ksT0FBWCxJQUFzQjNmLElBQXRCLEdBQTZCNGUsUUFBN0IsR0FBd0NhLEtBQUssQ0FBQzltQixJQUF4RDtBQUNBc25CLG9CQUFRLEdBQUcsQ0FBQ2xCLE1BQUQsR0FBVUYsU0FBVixHQUFzQlEsS0FBSyxDQUFDM3RCLEVBQUQsRUFBS0wsR0FBTCxFQUFVLE9BQVYsQ0FBdEM7QUFDRDs7QUFDRDJ0QixhQUFHLENBQUNjLE9BQUQsRUFBVU4sT0FBTyxDQUFDM0ssR0FBbEIsRUFBdUJrTCxRQUFRLEdBQUdELE9BQWxDLEVBQTJDTixPQUFPLENBQUM1SyxNQUFuRCxDQUFIOztBQUNBLGNBQUk0SyxPQUFPLENBQUM1SyxNQUFSLEdBQWlCNkssS0FBSyxDQUFDNUssR0FBM0IsRUFBZ0M7QUFBRW1LLGVBQUcsQ0FBQ0osUUFBRCxFQUFXWSxPQUFPLENBQUM1SyxNQUFuQixFQUEyQixJQUEzQixFQUFpQzZLLEtBQUssQ0FBQzVLLEdBQXZDLENBQUg7QUFBaUQ7O0FBQ25GbUssYUFBRyxDQUFDZ0IsT0FBRCxFQUFVUCxLQUFLLENBQUM1SyxHQUFoQixFQUFxQm9MLFFBQVEsR0FBR0QsT0FBaEMsRUFBeUNQLEtBQUssQ0FBQzdLLE1BQS9DLENBQUg7QUFDRDs7QUFFRCxZQUFJLENBQUN6cUIsS0FBRCxJQUFVczBCLFNBQVMsQ0FBQ2UsT0FBRCxFQUFVcjFCLEtBQVYsQ0FBVCxHQUE0QixDQUExQyxFQUE2QztBQUFFQSxlQUFLLEdBQUdxMUIsT0FBUjtBQUFrQjs7QUFDakUsWUFBSWYsU0FBUyxDQUFDZ0IsS0FBRCxFQUFRdDFCLEtBQVIsQ0FBVCxHQUEwQixDQUE5QixFQUFpQztBQUFFQSxlQUFLLEdBQUdzMUIsS0FBUjtBQUFnQjs7QUFDbkQsWUFBSSxDQUFDcjFCLEdBQUQsSUFBUXEwQixTQUFTLENBQUNlLE9BQUQsRUFBVXAxQixHQUFWLENBQVQsR0FBMEIsQ0FBdEMsRUFBeUM7QUFBRUEsYUFBRyxHQUFHbzFCLE9BQU47QUFBZ0I7O0FBQzNELFlBQUlmLFNBQVMsQ0FBQ2dCLEtBQUQsRUFBUXIxQixHQUFSLENBQVQsR0FBd0IsQ0FBNUIsRUFBK0I7QUFBRUEsYUFBRyxHQUFHcTFCLEtBQU47QUFBYztBQUNoRCxPQW5Da0IsQ0FBbkI7QUFvQ0EsYUFBTztBQUFDdDFCLGFBQUssRUFBRUEsS0FBUjtBQUFlQyxXQUFHLEVBQUVBO0FBQXBCLE9BQVA7QUFDRDs7QUFFRCxRQUFJODFCLEtBQUssR0FBR2oyQixLQUFLLENBQUN3SCxJQUFOLEVBQVo7QUFBQSxRQUEwQjB1QixHQUFHLEdBQUdsMkIsS0FBSyxDQUFDeUgsRUFBTixFQUFoQzs7QUFDQSxRQUFJd3VCLEtBQUssQ0FBQzdxQixJQUFOLElBQWM4cUIsR0FBRyxDQUFDOXFCLElBQXRCLEVBQTRCO0FBQzFCNHBCLGlCQUFXLENBQUNpQixLQUFLLENBQUM3cUIsSUFBUCxFQUFhNnFCLEtBQUssQ0FBQ3p2QixFQUFuQixFQUF1QjB2QixHQUFHLENBQUMxdkIsRUFBM0IsQ0FBWDtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUkydkIsUUFBUSxHQUFHeGlCLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNcWlCLEtBQUssQ0FBQzdxQixJQUFaLENBQXRCO0FBQUEsVUFBeUNnckIsTUFBTSxHQUFHemlCLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNc2lCLEdBQUcsQ0FBQzlxQixJQUFWLENBQXpEO0FBQ0EsVUFBSWlyQixXQUFXLEdBQUc1WCxVQUFVLENBQUMwWCxRQUFELENBQVYsSUFBd0IxWCxVQUFVLENBQUMyWCxNQUFELENBQXBEO0FBQ0EsVUFBSUUsT0FBTyxHQUFHdEIsV0FBVyxDQUFDaUIsS0FBSyxDQUFDN3FCLElBQVAsRUFBYTZxQixLQUFLLENBQUN6dkIsRUFBbkIsRUFBdUI2dkIsV0FBVyxHQUFHRixRQUFRLENBQUM5cUIsSUFBVCxDQUFjek0sTUFBZCxHQUF1QixDQUExQixHQUE4QixJQUFoRSxDQUFYLENBQWlGdUIsR0FBL0Y7QUFDQSxVQUFJbzJCLFVBQVUsR0FBR3ZCLFdBQVcsQ0FBQ2tCLEdBQUcsQ0FBQzlxQixJQUFMLEVBQVdpckIsV0FBVyxHQUFHLENBQUgsR0FBTyxJQUE3QixFQUFtQ0gsR0FBRyxDQUFDMXZCLEVBQXZDLENBQVgsQ0FBc0R0RyxLQUF2RTs7QUFDQSxVQUFJbTJCLFdBQUosRUFBaUI7QUFDZixZQUFJQyxPQUFPLENBQUMxTCxHQUFSLEdBQWMyTCxVQUFVLENBQUMzTCxHQUFYLEdBQWlCLENBQW5DLEVBQXNDO0FBQ3BDbUssYUFBRyxDQUFDdUIsT0FBTyxDQUFDM25CLEtBQVQsRUFBZ0IybkIsT0FBTyxDQUFDMUwsR0FBeEIsRUFBNkIsSUFBN0IsRUFBbUMwTCxPQUFPLENBQUMzTCxNQUEzQyxDQUFIO0FBQ0FvSyxhQUFHLENBQUNKLFFBQUQsRUFBVzRCLFVBQVUsQ0FBQzNMLEdBQXRCLEVBQTJCMkwsVUFBVSxDQUFDN25CLElBQXRDLEVBQTRDNm5CLFVBQVUsQ0FBQzVMLE1BQXZELENBQUg7QUFDRCxTQUhELE1BR087QUFDTG9LLGFBQUcsQ0FBQ3VCLE9BQU8sQ0FBQzNuQixLQUFULEVBQWdCMm5CLE9BQU8sQ0FBQzFMLEdBQXhCLEVBQTZCMkwsVUFBVSxDQUFDN25CLElBQVgsR0FBa0I0bkIsT0FBTyxDQUFDM25CLEtBQXZELEVBQThEMm5CLE9BQU8sQ0FBQzNMLE1BQXRFLENBQUg7QUFDRDtBQUNGOztBQUNELFVBQUkyTCxPQUFPLENBQUMzTCxNQUFSLEdBQWlCNEwsVUFBVSxDQUFDM0wsR0FBaEMsRUFDRTtBQUFFbUssV0FBRyxDQUFDSixRQUFELEVBQVcyQixPQUFPLENBQUMzTCxNQUFuQixFQUEyQixJQUEzQixFQUFpQzRMLFVBQVUsQ0FBQzNMLEdBQTVDLENBQUg7QUFBc0Q7QUFDM0Q7O0FBRURwUixVQUFNLENBQUNuYSxXQUFQLENBQW1CbzFCLFFBQW5CO0FBQ0QsR0F2ckdrQixDQXlyR25COzs7QUFDQSxXQUFTK0IsWUFBVCxDQUFzQnBxQixFQUF0QixFQUEwQjtBQUN4QixRQUFJLENBQUNBLEVBQUUsQ0FBQ2tGLEtBQUgsQ0FBU21sQixPQUFkLEVBQXVCO0FBQUU7QUFBUTs7QUFDakMsUUFBSWplLE9BQU8sR0FBR3BNLEVBQUUsQ0FBQ29NLE9BQWpCO0FBQ0FrZSxpQkFBYSxDQUFDbGUsT0FBTyxDQUFDbWUsT0FBVCxDQUFiO0FBQ0EsUUFBSXByQixFQUFFLEdBQUcsSUFBVDtBQUNBaU4sV0FBTyxDQUFDb2UsU0FBUixDQUFrQm4zQixLQUFsQixDQUF3Qm8zQixVQUF4QixHQUFxQyxFQUFyQzs7QUFDQSxRQUFJenFCLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBV21tQixlQUFYLEdBQTZCLENBQWpDLEVBQ0U7QUFBRXRlLGFBQU8sQ0FBQ21lLE9BQVIsR0FBa0JJLFdBQVcsQ0FBQyxZQUFZO0FBQzFDLFlBQUksQ0FBQzNxQixFQUFFLENBQUM0cUIsUUFBSCxFQUFMLEVBQW9CO0FBQUVDLGdCQUFNLENBQUM3cUIsRUFBRCxDQUFOO0FBQWE7O0FBQ25Db00sZUFBTyxDQUFDb2UsU0FBUixDQUFrQm4zQixLQUFsQixDQUF3Qm8zQixVQUF4QixHQUFxQyxDQUFDdHJCLEVBQUUsR0FBRyxDQUFDQSxFQUFQLElBQWEsRUFBYixHQUFrQixRQUF2RDtBQUNELE9BSDhCLEVBRzVCYSxFQUFFLENBQUN1RSxPQUFILENBQVdtbUIsZUFIaUIsQ0FBN0I7QUFHK0IsS0FKbkMsTUFLSyxJQUFJMXFCLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBV21tQixlQUFYLEdBQTZCLENBQWpDLEVBQ0g7QUFBRXRlLGFBQU8sQ0FBQ29lLFNBQVIsQ0FBa0JuM0IsS0FBbEIsQ0FBd0JvM0IsVUFBeEIsR0FBcUMsUUFBckM7QUFBZ0Q7QUFDckQ7O0FBRUQsV0FBU0ssV0FBVCxDQUFxQjlxQixFQUFyQixFQUF5QjtBQUN2QixRQUFJLENBQUNBLEVBQUUsQ0FBQzRxQixRQUFILEVBQUwsRUFBb0I7QUFDbEI1cUIsUUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQnFVLEtBQWpCOztBQUNBLFVBQUksQ0FBQy9xQixFQUFFLENBQUNrRixLQUFILENBQVNtbEIsT0FBZCxFQUF1QjtBQUFFVyxlQUFPLENBQUNockIsRUFBRCxDQUFQO0FBQWM7QUFDeEM7QUFDRjs7QUFFRCxXQUFTaXJCLGNBQVQsQ0FBd0JqckIsRUFBeEIsRUFBNEI7QUFDMUJBLE1BQUUsQ0FBQ2tGLEtBQUgsQ0FBU2dtQixpQkFBVCxHQUE2QixJQUE3QjtBQUNBdHpCLGNBQVUsQ0FBQyxZQUFZO0FBQUUsVUFBSW9JLEVBQUUsQ0FBQ2tGLEtBQUgsQ0FBU2dtQixpQkFBYixFQUFnQztBQUN2RGxyQixVQUFFLENBQUNrRixLQUFILENBQVNnbUIsaUJBQVQsR0FBNkIsS0FBN0I7O0FBQ0EsWUFBSWxyQixFQUFFLENBQUNrRixLQUFILENBQVNtbEIsT0FBYixFQUFzQjtBQUFFUSxnQkFBTSxDQUFDN3FCLEVBQUQsQ0FBTjtBQUFhO0FBQ3RDO0FBQUUsS0FITyxFQUdMLEdBSEssQ0FBVjtBQUlEOztBQUVELFdBQVNnckIsT0FBVCxDQUFpQmhyQixFQUFqQixFQUFxQnROLENBQXJCLEVBQXdCO0FBQ3RCLFFBQUlzTixFQUFFLENBQUNrRixLQUFILENBQVNnbUIsaUJBQVQsSUFBOEIsQ0FBQ2xyQixFQUFFLENBQUNrRixLQUFILENBQVNpbUIsWUFBNUMsRUFBMEQ7QUFBRW5yQixRQUFFLENBQUNrRixLQUFILENBQVNnbUIsaUJBQVQsR0FBNkIsS0FBN0I7QUFBcUM7O0FBRWpHLFFBQUlsckIsRUFBRSxDQUFDdUUsT0FBSCxDQUFXbU0sUUFBWCxJQUF1QixVQUEzQixFQUF1QztBQUFFO0FBQVE7O0FBQ2pELFFBQUksQ0FBQzFRLEVBQUUsQ0FBQ2tGLEtBQUgsQ0FBU21sQixPQUFkLEVBQXVCO0FBQ3JCeHFCLFlBQU0sQ0FBQ0csRUFBRCxFQUFLLE9BQUwsRUFBY0EsRUFBZCxFQUFrQnROLENBQWxCLENBQU47QUFDQXNOLFFBQUUsQ0FBQ2tGLEtBQUgsQ0FBU21sQixPQUFULEdBQW1CLElBQW5CO0FBQ0FuMUIsY0FBUSxDQUFDOEssRUFBRSxDQUFDb00sT0FBSCxDQUFXaVEsT0FBWixFQUFxQixvQkFBckIsQ0FBUixDQUhxQixDQUlyQjtBQUNBO0FBQ0E7O0FBQ0EsVUFBSSxDQUFDcmMsRUFBRSxDQUFDUSxLQUFKLElBQWFSLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV2dmLGlCQUFYLElBQWdDcHJCLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT2lnQixHQUF4RCxFQUE2RDtBQUMzRHpuQixVQUFFLENBQUNvTSxPQUFILENBQVdzSyxLQUFYLENBQWlCMlUsS0FBakI7O0FBQ0EsWUFBSTM2QixNQUFKLEVBQVk7QUFBRWtILG9CQUFVLENBQUMsWUFBWTtBQUFFLG1CQUFPb0ksRUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQjJVLEtBQWpCLENBQXVCLElBQXZCLENBQVA7QUFBc0MsV0FBckQsRUFBdUQsRUFBdkQsQ0FBVjtBQUF1RSxTQUYxQixDQUUyQjs7QUFDdkY7O0FBQ0RyckIsUUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQjRVLGFBQWpCO0FBQ0Q7O0FBQ0RsQixnQkFBWSxDQUFDcHFCLEVBQUQsQ0FBWjtBQUNEOztBQUNELFdBQVM2cUIsTUFBVCxDQUFnQjdxQixFQUFoQixFQUFvQnROLENBQXBCLEVBQXVCO0FBQ3JCLFFBQUlzTixFQUFFLENBQUNrRixLQUFILENBQVNnbUIsaUJBQWIsRUFBZ0M7QUFBRTtBQUFROztBQUUxQyxRQUFJbHJCLEVBQUUsQ0FBQ2tGLEtBQUgsQ0FBU21sQixPQUFiLEVBQXNCO0FBQ3BCeHFCLFlBQU0sQ0FBQ0csRUFBRCxFQUFLLE1BQUwsRUFBYUEsRUFBYixFQUFpQnROLENBQWpCLENBQU47QUFDQXNOLFFBQUUsQ0FBQ2tGLEtBQUgsQ0FBU21sQixPQUFULEdBQW1CLEtBQW5CO0FBQ0FwNEIsYUFBTyxDQUFDK04sRUFBRSxDQUFDb00sT0FBSCxDQUFXaVEsT0FBWixFQUFxQixvQkFBckIsQ0FBUDtBQUNEOztBQUNEaU8saUJBQWEsQ0FBQ3RxQixFQUFFLENBQUNvTSxPQUFILENBQVdtZSxPQUFaLENBQWI7QUFDQTN5QixjQUFVLENBQUMsWUFBWTtBQUFFLFVBQUksQ0FBQ29JLEVBQUUsQ0FBQ2tGLEtBQUgsQ0FBU21sQixPQUFkLEVBQXVCO0FBQUVycUIsVUFBRSxDQUFDb00sT0FBSCxDQUFXbWYsS0FBWCxHQUFtQixLQUFuQjtBQUEyQjtBQUFFLEtBQXJFLEVBQXVFLEdBQXZFLENBQVY7QUFDRCxHQXJ2R2tCLENBdXZHbkI7QUFDQTs7O0FBQ0EsV0FBU0MsdUJBQVQsQ0FBaUN4ckIsRUFBakMsRUFBcUM7QUFDbkMsUUFBSW9NLE9BQU8sR0FBR3BNLEVBQUUsQ0FBQ29NLE9BQWpCO0FBQ0EsUUFBSXFmLFVBQVUsR0FBR3JmLE9BQU8sQ0FBQ3NmLE9BQVIsQ0FBZ0I3TyxTQUFqQzs7QUFDQSxTQUFLLElBQUlwcEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzJZLE9BQU8sQ0FBQ3VMLElBQVIsQ0FBYW5sQixNQUFqQyxFQUF5Q2lCLENBQUMsRUFBMUMsRUFBOEM7QUFDNUMsVUFBSTBJLEdBQUcsR0FBR2lRLE9BQU8sQ0FBQ3VMLElBQVIsQ0FBYWxrQixDQUFiLENBQVY7QUFBQSxVQUEyQndxQixRQUFRLEdBQUdqZSxFQUFFLENBQUN1RSxPQUFILENBQVcyWixZQUFqRDtBQUNBLFVBQUk3VixNQUFNLEdBQUksS0FBSyxDQUFuQjtBQUFBLFVBQXVCdVQsS0FBSyxHQUFHLENBQS9COztBQUNBLFVBQUl6ZixHQUFHLENBQUNxYixNQUFSLEVBQWdCO0FBQUU7QUFBVTs7QUFDNUIsVUFBSWxuQixFQUFFLElBQUlDLFVBQVUsR0FBRyxDQUF2QixFQUEwQjtBQUN4QixZQUFJaXdCLEdBQUcsR0FBR3JrQixHQUFHLENBQUNqSyxJQUFKLENBQVMycUIsU0FBVCxHQUFxQjFnQixHQUFHLENBQUNqSyxJQUFKLENBQVM0UCxZQUF4QztBQUNBdUcsY0FBTSxHQUFHbVksR0FBRyxHQUFHaUwsVUFBZjtBQUNBQSxrQkFBVSxHQUFHakwsR0FBYjtBQUNELE9BSkQsTUFJTztBQUNMLFlBQUl3RCxHQUFHLEdBQUc3bkIsR0FBRyxDQUFDakssSUFBSixDQUFTa1EscUJBQVQsRUFBVjtBQUNBaUcsY0FBTSxHQUFHMmIsR0FBRyxDQUFDekYsTUFBSixHQUFheUYsR0FBRyxDQUFDeEYsR0FBMUIsQ0FGSyxDQUdMO0FBQ0E7O0FBQ0EsWUFBSSxDQUFDUCxRQUFELElBQWE5aEIsR0FBRyxDQUFDOEMsSUFBSixDQUFTbk0sVUFBMUIsRUFDRTtBQUFFOG9CLGVBQUssR0FBR3pmLEdBQUcsQ0FBQzhDLElBQUosQ0FBU25NLFVBQVQsQ0FBb0JzUCxxQkFBcEIsR0FBNENHLEtBQTVDLEdBQW9EeWhCLEdBQUcsQ0FBQzFoQixJQUF4RCxHQUErRCxDQUF2RTtBQUEyRTtBQUNoRjs7QUFDRCxVQUFJZ0csSUFBSSxHQUFHbk0sR0FBRyxDQUFDNkMsSUFBSixDQUFTcUosTUFBVCxHQUFrQkEsTUFBN0I7O0FBQ0EsVUFBSUMsSUFBSSxHQUFHLElBQVAsSUFBZUEsSUFBSSxHQUFHLENBQUMsSUFBM0IsRUFBaUM7QUFDL0JGLHdCQUFnQixDQUFDak0sR0FBRyxDQUFDNkMsSUFBTCxFQUFXcUosTUFBWCxDQUFoQjtBQUNBc2pCLDBCQUFrQixDQUFDeHZCLEdBQUcsQ0FBQzZDLElBQUwsQ0FBbEI7O0FBQ0EsWUFBSTdDLEdBQUcsQ0FBQ3NZLElBQVIsRUFBYztBQUFFLGVBQUssSUFBSTNXLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUczQixHQUFHLENBQUNzWSxJQUFKLENBQVNqaUIsTUFBN0IsRUFBcUNzTCxDQUFDLEVBQXRDLEVBQ2Q7QUFBRTZ0Qiw4QkFBa0IsQ0FBQ3h2QixHQUFHLENBQUNzWSxJQUFKLENBQVMzVyxDQUFULENBQUQsQ0FBbEI7QUFBa0M7QUFBRTtBQUN6Qzs7QUFDRCxVQUFJOGQsS0FBSyxHQUFHNWIsRUFBRSxDQUFDb00sT0FBSCxDQUFXcWMsVUFBdkIsRUFBbUM7QUFDakMsWUFBSW1ELE9BQU8sR0FBRzl5QixJQUFJLENBQUMwQyxJQUFMLENBQVVvZ0IsS0FBSyxHQUFHMEUsU0FBUyxDQUFDdGdCLEVBQUUsQ0FBQ29NLE9BQUosQ0FBM0IsQ0FBZDs7QUFDQSxZQUFJd2YsT0FBTyxHQUFHNXJCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV21ILGFBQXpCLEVBQXdDO0FBQ3RDdlQsWUFBRSxDQUFDb00sT0FBSCxDQUFXbUgsYUFBWCxHQUEyQnFZLE9BQTNCO0FBQ0E1ckIsWUFBRSxDQUFDb00sT0FBSCxDQUFXa0gsT0FBWCxHQUFxQm5YLEdBQUcsQ0FBQzZDLElBQXpCO0FBQ0FnQixZQUFFLENBQUNvTSxPQUFILENBQVdvSCxjQUFYLEdBQTRCLElBQTVCO0FBQ0Q7QUFDRjtBQUNGO0FBQ0YsR0E1eEdrQixDQTh4R25CO0FBQ0E7OztBQUNBLFdBQVNtWSxrQkFBVCxDQUE0QjNzQixJQUE1QixFQUFrQztBQUNoQyxRQUFJQSxJQUFJLENBQUNzYyxPQUFULEVBQWtCO0FBQUUsV0FBSyxJQUFJN25CLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1TCxJQUFJLENBQUNzYyxPQUFMLENBQWE5b0IsTUFBakMsRUFBeUMsRUFBRWlCLENBQTNDLEVBQThDO0FBQ2hFLFlBQUlvNEIsQ0FBQyxHQUFHN3NCLElBQUksQ0FBQ3NjLE9BQUwsQ0FBYTduQixDQUFiLENBQVI7QUFBQSxZQUF5QlQsTUFBTSxHQUFHNjRCLENBQUMsQ0FBQzM1QixJQUFGLENBQU9xQyxVQUF6Qzs7QUFDQSxZQUFJdkIsTUFBSixFQUFZO0FBQUU2NEIsV0FBQyxDQUFDeGpCLE1BQUYsR0FBV3JWLE1BQU0sQ0FBQzhPLFlBQWxCO0FBQWlDO0FBQ2hEO0FBQUU7QUFDSixHQXJ5R2tCLENBdXlHbkI7QUFDQTtBQUNBOzs7QUFDQSxXQUFTZ3FCLFlBQVQsQ0FBc0IxZixPQUF0QixFQUErQjVFLEdBQS9CLEVBQW9DdWtCLFFBQXBDLEVBQThDO0FBQzVDLFFBQUl2TixHQUFHLEdBQUd1TixRQUFRLElBQUlBLFFBQVEsQ0FBQ3ZOLEdBQVQsSUFBZ0IsSUFBNUIsR0FBbUMxbEIsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTLENBQVQsRUFBWWl3QixRQUFRLENBQUN2TixHQUFyQixDQUFuQyxHQUErRHBTLE9BQU8sQ0FBQ3NSLFFBQVIsQ0FBaUJxRSxTQUExRjtBQUNBdkQsT0FBRyxHQUFHMWxCLElBQUksQ0FBQzJDLEtBQUwsQ0FBVytpQixHQUFHLEdBQUc3QixVQUFVLENBQUN2USxPQUFELENBQTNCLENBQU47QUFDQSxRQUFJbVMsTUFBTSxHQUFHd04sUUFBUSxJQUFJQSxRQUFRLENBQUN4TixNQUFULElBQW1CLElBQS9CLEdBQXNDd04sUUFBUSxDQUFDeE4sTUFBL0MsR0FBd0RDLEdBQUcsR0FBR3BTLE9BQU8sQ0FBQ2lRLE9BQVIsQ0FBZ0J3QixZQUEzRjs7QUFFQSxRQUFJemlCLElBQUksR0FBR3FOLGFBQVksQ0FBQ2pCLEdBQUQsRUFBTWdYLEdBQU4sQ0FBdkI7QUFBQSxRQUFtQ25qQixFQUFFLEdBQUdvTixhQUFZLENBQUNqQixHQUFELEVBQU0rVyxNQUFOLENBQXBELENBTDRDLENBTTVDO0FBQ0E7OztBQUNBLFFBQUl3TixRQUFRLElBQUlBLFFBQVEsQ0FBQ0MsTUFBekIsRUFBaUM7QUFDL0IsVUFBSUMsVUFBVSxHQUFHRixRQUFRLENBQUNDLE1BQVQsQ0FBZ0I1d0IsSUFBaEIsQ0FBcUI0RCxJQUF0QztBQUFBLFVBQTRDa3RCLFFBQVEsR0FBR0gsUUFBUSxDQUFDQyxNQUFULENBQWdCM3dCLEVBQWhCLENBQW1CMkQsSUFBMUU7O0FBQ0EsVUFBSWl0QixVQUFVLEdBQUc3d0IsSUFBakIsRUFBdUI7QUFDckJBLFlBQUksR0FBRzZ3QixVQUFQO0FBQ0E1d0IsVUFBRSxHQUFHb04sYUFBWSxDQUFDakIsR0FBRCxFQUFNeUwsYUFBWSxDQUFDMUwsT0FBTyxDQUFDQyxHQUFELEVBQU15a0IsVUFBTixDQUFSLENBQVosR0FBeUM3ZixPQUFPLENBQUNpUSxPQUFSLENBQWdCd0IsWUFBL0QsQ0FBakI7QUFDRCxPQUhELE1BR08sSUFBSS9rQixJQUFJLENBQUNDLEdBQUwsQ0FBU216QixRQUFULEVBQW1CMWtCLEdBQUcsQ0FBQ3FMLFFBQUosRUFBbkIsS0FBc0N4WCxFQUExQyxFQUE4QztBQUNuREQsWUFBSSxHQUFHcU4sYUFBWSxDQUFDakIsR0FBRCxFQUFNeUwsYUFBWSxDQUFDMUwsT0FBTyxDQUFDQyxHQUFELEVBQU0wa0IsUUFBTixDQUFSLENBQVosR0FBdUM5ZixPQUFPLENBQUNpUSxPQUFSLENBQWdCd0IsWUFBN0QsQ0FBbkI7QUFDQXhpQixVQUFFLEdBQUc2d0IsUUFBTDtBQUNEO0FBQ0Y7O0FBQ0QsV0FBTztBQUFDOXdCLFVBQUksRUFBRUEsSUFBUDtBQUFhQyxRQUFFLEVBQUV2QyxJQUFJLENBQUNnRCxHQUFMLENBQVNULEVBQVQsRUFBYUQsSUFBSSxHQUFHLENBQXBCO0FBQWpCLEtBQVA7QUFDRCxHQTd6R2tCLENBK3pHbkI7QUFFQTtBQUNBOzs7QUFDQSxXQUFTK3dCLGlCQUFULENBQTJCbnNCLEVBQTNCLEVBQStCZ2UsSUFBL0IsRUFBcUM7QUFDbkMsUUFBSWplLGNBQWMsQ0FBQ0MsRUFBRCxFQUFLLHNCQUFMLENBQWxCLEVBQWdEO0FBQUU7QUFBUTs7QUFFMUQsUUFBSW9NLE9BQU8sR0FBR3BNLEVBQUUsQ0FBQ29NLE9BQWpCO0FBQUEsUUFBMEI0WCxHQUFHLEdBQUc1WCxPQUFPLENBQUNxUSxLQUFSLENBQWNyYSxxQkFBZCxFQUFoQztBQUFBLFFBQXVFZ3FCLFFBQVEsR0FBRyxJQUFsRjs7QUFDQSxRQUFJcE8sSUFBSSxDQUFDUSxHQUFMLEdBQVd3RixHQUFHLENBQUN4RixHQUFmLEdBQXFCLENBQXpCLEVBQTRCO0FBQUU0TixjQUFRLEdBQUcsSUFBWDtBQUFrQixLQUFoRCxNQUNLLElBQUlwTyxJQUFJLENBQUNPLE1BQUwsR0FBY3lGLEdBQUcsQ0FBQ3hGLEdBQWxCLElBQXlCMWIsTUFBTSxDQUFDdXBCLFdBQVAsSUFBc0I3N0IsUUFBUSxDQUFDa3hCLGVBQVQsQ0FBeUI3RCxZQUF4RSxDQUFKLEVBQTJGO0FBQUV1TyxjQUFRLEdBQUcsS0FBWDtBQUFtQjs7QUFDckgsUUFBSUEsUUFBUSxJQUFJLElBQVosSUFBb0IsQ0FBQ243QixPQUF6QixFQUFrQztBQUNoQyxVQUFJcTdCLFVBQVUsR0FBR3A1QixHQUFHLENBQUMsS0FBRCxFQUFRLFFBQVIsRUFBa0IsSUFBbEIsRUFBeUIseURBQXlEOHFCLElBQUksQ0FBQ1EsR0FBTCxHQUFXcFMsT0FBTyxDQUFDZ1csVUFBbkIsR0FBZ0N6RixVQUFVLENBQUMzYyxFQUFFLENBQUNvTSxPQUFKLENBQW5HLElBQW1ILHdDQUFuSCxJQUErSjRSLElBQUksQ0FBQ08sTUFBTCxHQUFjUCxJQUFJLENBQUNRLEdBQW5CLEdBQXlCakIsU0FBUyxDQUFDdmQsRUFBRCxDQUFsQyxHQUF5Q29NLE9BQU8sQ0FBQzBSLFNBQWhOLElBQTZOLHNDQUE3TixHQUF1UUUsSUFBSSxDQUFDMWIsSUFBNVEsR0FBb1IsYUFBcFIsR0FBcVN4SixJQUFJLENBQUNnRCxHQUFMLENBQVMsQ0FBVCxFQUFZa2lCLElBQUksQ0FBQ3piLEtBQUwsR0FBYXliLElBQUksQ0FBQzFiLElBQTlCLENBQXJTLEdBQTRVLEtBQXJXLENBQXBCO0FBQ0F0QyxRQUFFLENBQUNvTSxPQUFILENBQVd3USxTQUFYLENBQXFCM3BCLFdBQXJCLENBQWlDcTVCLFVBQWpDO0FBQ0FBLGdCQUFVLENBQUNDLGNBQVgsQ0FBMEJILFFBQTFCO0FBQ0Fwc0IsUUFBRSxDQUFDb00sT0FBSCxDQUFXd1EsU0FBWCxDQUFxQi9wQixXQUFyQixDQUFpQ3k1QixVQUFqQztBQUNEO0FBQ0YsR0EvMEdrQixDQWkxR25CO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU0UsaUJBQVQsQ0FBMkJ4c0IsRUFBM0IsRUFBK0JySCxHQUEvQixFQUFvQzVFLEdBQXBDLEVBQXlDMDRCLE1BQXpDLEVBQWlEO0FBQy9DLFFBQUlBLE1BQU0sSUFBSSxJQUFkLEVBQW9CO0FBQUVBLFlBQU0sR0FBRyxDQUFUO0FBQWE7O0FBQ25DLFFBQUl6TyxJQUFKOztBQUNBLFFBQUksQ0FBQ2hlLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVzJaLFlBQVosSUFBNEJ2bEIsR0FBRyxJQUFJNUUsR0FBdkMsRUFBNEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E0RSxTQUFHLEdBQUdBLEdBQUcsQ0FBQ3lCLEVBQUosR0FBUzhPLEdBQUcsQ0FBQ3ZRLEdBQUcsQ0FBQ3FHLElBQUwsRUFBV3JHLEdBQUcsQ0FBQ3VELE1BQUosSUFBYyxRQUFkLEdBQXlCdkQsR0FBRyxDQUFDeUIsRUFBSixHQUFTLENBQWxDLEdBQXNDekIsR0FBRyxDQUFDeUIsRUFBckQsRUFBeUQsT0FBekQsQ0FBWixHQUFnRnpCLEdBQXRGO0FBQ0E1RSxTQUFHLEdBQUc0RSxHQUFHLENBQUN1RCxNQUFKLElBQWMsUUFBZCxHQUF5QmdOLEdBQUcsQ0FBQ3ZRLEdBQUcsQ0FBQ3FHLElBQUwsRUFBV3JHLEdBQUcsQ0FBQ3lCLEVBQUosR0FBUyxDQUFwQixFQUF1QixRQUF2QixDQUE1QixHQUErRHpCLEdBQXJFO0FBQ0Q7O0FBQ0QsU0FBSyxJQUFJK3pCLEtBQUssR0FBRyxDQUFqQixFQUFvQkEsS0FBSyxHQUFHLENBQTVCLEVBQStCQSxLQUFLLEVBQXBDLEVBQXdDO0FBQ3RDLFVBQUlDLE9BQU8sR0FBRyxLQUFkOztBQUNBLFVBQUluSyxNQUFNLEdBQUdJLGFBQVksQ0FBQzVpQixFQUFELEVBQUtySCxHQUFMLENBQXpCOztBQUNBLFVBQUlpMEIsU0FBUyxHQUFHLENBQUM3NEIsR0FBRCxJQUFRQSxHQUFHLElBQUk0RSxHQUFmLEdBQXFCNnBCLE1BQXJCLEdBQThCSSxhQUFZLENBQUM1aUIsRUFBRCxFQUFLak0sR0FBTCxDQUExRDtBQUNBaXFCLFVBQUksR0FBRztBQUFDMWIsWUFBSSxFQUFFeEosSUFBSSxDQUFDQyxHQUFMLENBQVN5cEIsTUFBTSxDQUFDbGdCLElBQWhCLEVBQXNCc3FCLFNBQVMsQ0FBQ3RxQixJQUFoQyxDQUFQO0FBQ0NrYyxXQUFHLEVBQUUxbEIsSUFBSSxDQUFDQyxHQUFMLENBQVN5cEIsTUFBTSxDQUFDaEUsR0FBaEIsRUFBcUJvTyxTQUFTLENBQUNwTyxHQUEvQixJQUFzQ2lPLE1BRDVDO0FBRUNscUIsYUFBSyxFQUFFekosSUFBSSxDQUFDZ0QsR0FBTCxDQUFTMG1CLE1BQU0sQ0FBQ2xnQixJQUFoQixFQUFzQnNxQixTQUFTLENBQUN0cUIsSUFBaEMsQ0FGUjtBQUdDaWMsY0FBTSxFQUFFemxCLElBQUksQ0FBQ2dELEdBQUwsQ0FBUzBtQixNQUFNLENBQUNqRSxNQUFoQixFQUF3QnFPLFNBQVMsQ0FBQ3JPLE1BQWxDLElBQTRDa087QUFIckQsT0FBUDtBQUlBLFVBQUlJLFNBQVMsR0FBR0Msa0JBQWtCLENBQUM5c0IsRUFBRCxFQUFLZ2UsSUFBTCxDQUFsQztBQUNBLFVBQUkrTyxRQUFRLEdBQUcvc0IsRUFBRSxDQUFDd0gsR0FBSCxDQUFPdWEsU0FBdEI7QUFBQSxVQUFpQ2lMLFNBQVMsR0FBR2h0QixFQUFFLENBQUN3SCxHQUFILENBQU9tYSxVQUFwRDs7QUFDQSxVQUFJa0wsU0FBUyxDQUFDOUssU0FBVixJQUF1QixJQUEzQixFQUFpQztBQUMvQmtMLHVCQUFlLENBQUNqdEIsRUFBRCxFQUFLNnNCLFNBQVMsQ0FBQzlLLFNBQWYsQ0FBZjs7QUFDQSxZQUFJanBCLElBQUksQ0FBQzZLLEdBQUwsQ0FBUzNELEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT3VhLFNBQVAsR0FBbUJnTCxRQUE1QixJQUF3QyxDQUE1QyxFQUErQztBQUFFSixpQkFBTyxHQUFHLElBQVY7QUFBaUI7QUFDbkU7O0FBQ0QsVUFBSUUsU0FBUyxDQUFDbEwsVUFBVixJQUF3QixJQUE1QixFQUFrQztBQUNoQ3VMLHFCQUFhLENBQUNsdEIsRUFBRCxFQUFLNnNCLFNBQVMsQ0FBQ2xMLFVBQWYsQ0FBYjs7QUFDQSxZQUFJN29CLElBQUksQ0FBQzZLLEdBQUwsQ0FBUzNELEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT21hLFVBQVAsR0FBb0JxTCxTQUE3QixJQUEwQyxDQUE5QyxFQUFpRDtBQUFFTCxpQkFBTyxHQUFHLElBQVY7QUFBaUI7QUFDckU7O0FBQ0QsVUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFBRTtBQUFPO0FBQ3hCOztBQUNELFdBQU8zTyxJQUFQO0FBQ0QsR0FuM0drQixDQXEzR25COzs7QUFDQSxXQUFTdU8sY0FBVCxDQUF3QnZzQixFQUF4QixFQUE0QmdlLElBQTVCLEVBQWtDO0FBQ2hDLFFBQUk2TyxTQUFTLEdBQUdDLGtCQUFrQixDQUFDOXNCLEVBQUQsRUFBS2dlLElBQUwsQ0FBbEM7O0FBQ0EsUUFBSTZPLFNBQVMsQ0FBQzlLLFNBQVYsSUFBdUIsSUFBM0IsRUFBaUM7QUFBRWtMLHFCQUFlLENBQUNqdEIsRUFBRCxFQUFLNnNCLFNBQVMsQ0FBQzlLLFNBQWYsQ0FBZjtBQUEyQzs7QUFDOUUsUUFBSThLLFNBQVMsQ0FBQ2xMLFVBQVYsSUFBd0IsSUFBNUIsRUFBa0M7QUFBRXVMLG1CQUFhLENBQUNsdEIsRUFBRCxFQUFLNnNCLFNBQVMsQ0FBQ2xMLFVBQWYsQ0FBYjtBQUEwQztBQUMvRSxHQTEzR2tCLENBNDNHbkI7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFdBQVNtTCxrQkFBVCxDQUE0QjlzQixFQUE1QixFQUFnQ2dlLElBQWhDLEVBQXNDO0FBQ3BDLFFBQUk1UixPQUFPLEdBQUdwTSxFQUFFLENBQUNvTSxPQUFqQjtBQUFBLFFBQTBCK2dCLFVBQVUsR0FBR3BJLFVBQVUsQ0FBQy9rQixFQUFFLENBQUNvTSxPQUFKLENBQWpEOztBQUNBLFFBQUk0UixJQUFJLENBQUNRLEdBQUwsR0FBVyxDQUFmLEVBQWtCO0FBQUVSLFVBQUksQ0FBQ1EsR0FBTCxHQUFXLENBQVg7QUFBZTs7QUFDbkMsUUFBSTRPLFNBQVMsR0FBR3B0QixFQUFFLENBQUNRLEtBQUgsSUFBWVIsRUFBRSxDQUFDUSxLQUFILENBQVN1aEIsU0FBVCxJQUFzQixJQUFsQyxHQUF5Qy9oQixFQUFFLENBQUNRLEtBQUgsQ0FBU3VoQixTQUFsRCxHQUE4RDNWLE9BQU8sQ0FBQ3NSLFFBQVIsQ0FBaUJxRSxTQUEvRjtBQUNBLFFBQUlyQixNQUFNLEdBQUc5QyxhQUFhLENBQUM1ZCxFQUFELENBQTFCO0FBQUEsUUFBZ0N5QyxNQUFNLEdBQUcsRUFBekM7O0FBQ0EsUUFBSXViLElBQUksQ0FBQ08sTUFBTCxHQUFjUCxJQUFJLENBQUNRLEdBQW5CLEdBQXlCa0MsTUFBN0IsRUFBcUM7QUFBRTFDLFVBQUksQ0FBQ08sTUFBTCxHQUFjUCxJQUFJLENBQUNRLEdBQUwsR0FBV2tDLE1BQXpCO0FBQWtDOztBQUN6RSxRQUFJMk0sU0FBUyxHQUFHcnRCLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT2EsTUFBUCxHQUFnQnlVLFdBQVcsQ0FBQzFRLE9BQUQsQ0FBM0M7QUFDQSxRQUFJa2hCLEtBQUssR0FBR3RQLElBQUksQ0FBQ1EsR0FBTCxHQUFXMk8sVUFBdkI7QUFBQSxRQUFtQ0ksUUFBUSxHQUFHdlAsSUFBSSxDQUFDTyxNQUFMLEdBQWM4TyxTQUFTLEdBQUdGLFVBQXhFOztBQUNBLFFBQUluUCxJQUFJLENBQUNRLEdBQUwsR0FBVzRPLFNBQWYsRUFBMEI7QUFDeEIzcUIsWUFBTSxDQUFDc2YsU0FBUCxHQUFtQnVMLEtBQUssR0FBRyxDQUFILEdBQU90UCxJQUFJLENBQUNRLEdBQXBDO0FBQ0QsS0FGRCxNQUVPLElBQUlSLElBQUksQ0FBQ08sTUFBTCxHQUFjNk8sU0FBUyxHQUFHMU0sTUFBOUIsRUFBc0M7QUFDM0MsVUFBSThNLE1BQU0sR0FBRzEwQixJQUFJLENBQUNDLEdBQUwsQ0FBU2lsQixJQUFJLENBQUNRLEdBQWQsRUFBbUIsQ0FBQytPLFFBQVEsR0FBR0YsU0FBSCxHQUFlclAsSUFBSSxDQUFDTyxNQUE3QixJQUF1Q21DLE1BQTFELENBQWI7O0FBQ0EsVUFBSThNLE1BQU0sSUFBSUosU0FBZCxFQUF5QjtBQUFFM3FCLGNBQU0sQ0FBQ3NmLFNBQVAsR0FBbUJ5TCxNQUFuQjtBQUE0QjtBQUN4RDs7QUFFRCxRQUFJQyxXQUFXLEdBQUd6dEIsRUFBRSxDQUFDdUUsT0FBSCxDQUFXMlYsV0FBWCxHQUF5QixDQUF6QixHQUE2QjlOLE9BQU8sQ0FBQ2dRLE9BQVIsQ0FBZ0JyYSxXQUEvRDtBQUNBLFFBQUkyckIsVUFBVSxHQUFHMXRCLEVBQUUsQ0FBQ1EsS0FBSCxJQUFZUixFQUFFLENBQUNRLEtBQUgsQ0FBU21oQixVQUFULElBQXVCLElBQW5DLEdBQTBDM2hCLEVBQUUsQ0FBQ1EsS0FBSCxDQUFTbWhCLFVBQW5ELEdBQWdFdlYsT0FBTyxDQUFDc1IsUUFBUixDQUFpQmlFLFVBQWpCLEdBQThCOEwsV0FBL0c7QUFDQSxRQUFJRSxPQUFPLEdBQUdsUSxZQUFZLENBQUN6ZCxFQUFELENBQVosR0FBbUJvTSxPQUFPLENBQUNnUSxPQUFSLENBQWdCcmEsV0FBakQ7QUFDQSxRQUFJNnJCLE9BQU8sR0FBRzVQLElBQUksQ0FBQ3piLEtBQUwsR0FBYXliLElBQUksQ0FBQzFiLElBQWxCLEdBQXlCcXJCLE9BQXZDOztBQUNBLFFBQUlDLE9BQUosRUFBYTtBQUFFNVAsVUFBSSxDQUFDemIsS0FBTCxHQUFheWIsSUFBSSxDQUFDMWIsSUFBTCxHQUFZcXJCLE9BQXpCO0FBQW1DOztBQUNsRCxRQUFJM1AsSUFBSSxDQUFDMWIsSUFBTCxHQUFZLEVBQWhCLEVBQ0U7QUFBRUcsWUFBTSxDQUFDa2YsVUFBUCxHQUFvQixDQUFwQjtBQUF3QixLQUQ1QixNQUVLLElBQUkzRCxJQUFJLENBQUMxYixJQUFMLEdBQVlvckIsVUFBaEIsRUFDSDtBQUFFanJCLFlBQU0sQ0FBQ2tmLFVBQVAsR0FBb0I3b0IsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTLENBQVQsRUFBWWtpQixJQUFJLENBQUMxYixJQUFMLEdBQVltckIsV0FBWixJQUEyQkcsT0FBTyxHQUFHLENBQUgsR0FBTyxFQUF6QyxDQUFaLENBQXBCO0FBQWdGLEtBRC9FLE1BRUEsSUFBSTVQLElBQUksQ0FBQ3piLEtBQUwsR0FBYW9yQixPQUFPLEdBQUdELFVBQVYsR0FBdUIsQ0FBeEMsRUFDSDtBQUFFanJCLFlBQU0sQ0FBQ2tmLFVBQVAsR0FBb0IzRCxJQUFJLENBQUN6YixLQUFMLElBQWNxckIsT0FBTyxHQUFHLENBQUgsR0FBTyxFQUE1QixJQUFrQ0QsT0FBdEQ7QUFBZ0U7O0FBQ3BFLFdBQU9sckIsTUFBUDtBQUNELEdBMzVHa0IsQ0E2NUduQjtBQUNBOzs7QUFDQSxXQUFTb3JCLGNBQVQsQ0FBd0I3dEIsRUFBeEIsRUFBNEJ3ZSxHQUE1QixFQUFpQztBQUMvQixRQUFJQSxHQUFHLElBQUksSUFBWCxFQUFpQjtBQUFFO0FBQVE7O0FBQzNCc1Asc0JBQWtCLENBQUM5dEIsRUFBRCxDQUFsQjtBQUNBQSxNQUFFLENBQUNRLEtBQUgsQ0FBU3VoQixTQUFULEdBQXFCLENBQUMvaEIsRUFBRSxDQUFDUSxLQUFILENBQVN1aEIsU0FBVCxJQUFzQixJQUF0QixHQUE2Qi9oQixFQUFFLENBQUN3SCxHQUFILENBQU91YSxTQUFwQyxHQUFnRC9oQixFQUFFLENBQUNRLEtBQUgsQ0FBU3VoQixTQUExRCxJQUF1RXZELEdBQTVGO0FBQ0QsR0FuNkdrQixDQXE2R25CO0FBQ0E7OztBQUNBLFdBQVN1UCxtQkFBVCxDQUE2Qi90QixFQUE3QixFQUFpQztBQUMvQjh0QixzQkFBa0IsQ0FBQzl0QixFQUFELENBQWxCO0FBQ0EsUUFBSTdELEdBQUcsR0FBRzZELEVBQUUsQ0FBQ2d1QixTQUFILEVBQVY7QUFDQWh1QixNQUFFLENBQUNRLEtBQUgsQ0FBU3l0QixXQUFULEdBQXVCO0FBQUM3eUIsVUFBSSxFQUFFZSxHQUFQO0FBQVlkLFFBQUUsRUFBRWMsR0FBaEI7QUFBcUJzd0IsWUFBTSxFQUFFenNCLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVzJwQjtBQUF4QyxLQUF2QjtBQUNEOztBQUVELFdBQVNDLGNBQVQsQ0FBd0JudUIsRUFBeEIsRUFBNEJzSixDQUE1QixFQUErQmthLENBQS9CLEVBQWtDO0FBQ2hDLFFBQUlsYSxDQUFDLElBQUksSUFBTCxJQUFha2EsQ0FBQyxJQUFJLElBQXRCLEVBQTRCO0FBQUVzSyx3QkFBa0IsQ0FBQzl0QixFQUFELENBQWxCO0FBQXlCOztBQUN2RCxRQUFJc0osQ0FBQyxJQUFJLElBQVQsRUFBZTtBQUFFdEosUUFBRSxDQUFDUSxLQUFILENBQVNtaEIsVUFBVCxHQUFzQnJZLENBQXRCO0FBQTBCOztBQUMzQyxRQUFJa2EsQ0FBQyxJQUFJLElBQVQsRUFBZTtBQUFFeGpCLFFBQUUsQ0FBQ1EsS0FBSCxDQUFTdWhCLFNBQVQsR0FBcUJ5QixDQUFyQjtBQUF5QjtBQUMzQzs7QUFFRCxXQUFTNEssYUFBVCxDQUF1QnB1QixFQUF2QixFQUEyQnBNLEtBQTNCLEVBQWtDO0FBQ2hDazZCLHNCQUFrQixDQUFDOXRCLEVBQUQsQ0FBbEI7QUFDQUEsTUFBRSxDQUFDUSxLQUFILENBQVN5dEIsV0FBVCxHQUF1QnI2QixLQUF2QjtBQUNELEdBdDdHa0IsQ0F3N0duQjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU2s2QixrQkFBVCxDQUE0Qjl0QixFQUE1QixFQUFnQztBQUM5QixRQUFJcE0sS0FBSyxHQUFHb00sRUFBRSxDQUFDUSxLQUFILENBQVN5dEIsV0FBckI7O0FBQ0EsUUFBSXI2QixLQUFKLEVBQVc7QUFDVG9NLFFBQUUsQ0FBQ1EsS0FBSCxDQUFTeXRCLFdBQVQsR0FBdUIsSUFBdkI7QUFDQSxVQUFJN3lCLElBQUksR0FBRytuQixjQUFjLENBQUNuakIsRUFBRCxFQUFLcE0sS0FBSyxDQUFDd0gsSUFBWCxDQUF6QjtBQUFBLFVBQTJDQyxFQUFFLEdBQUc4bkIsY0FBYyxDQUFDbmpCLEVBQUQsRUFBS3BNLEtBQUssQ0FBQ3lILEVBQVgsQ0FBOUQ7QUFDQWd6Qix5QkFBbUIsQ0FBQ3J1QixFQUFELEVBQUs1RSxJQUFMLEVBQVdDLEVBQVgsRUFBZXpILEtBQUssQ0FBQzY0QixNQUFyQixDQUFuQjtBQUNEO0FBQ0Y7O0FBRUQsV0FBUzRCLG1CQUFULENBQTZCcnVCLEVBQTdCLEVBQWlDNUUsSUFBakMsRUFBdUNDLEVBQXZDLEVBQTJDb3hCLE1BQTNDLEVBQW1EO0FBQ2pELFFBQUk2QixJQUFJLEdBQUd4QixrQkFBa0IsQ0FBQzlzQixFQUFELEVBQUs7QUFDaENzQyxVQUFJLEVBQUV4SixJQUFJLENBQUNDLEdBQUwsQ0FBU3FDLElBQUksQ0FBQ2tILElBQWQsRUFBb0JqSCxFQUFFLENBQUNpSCxJQUF2QixDQUQwQjtBQUVoQ2tjLFNBQUcsRUFBRTFsQixJQUFJLENBQUNDLEdBQUwsQ0FBU3FDLElBQUksQ0FBQ29qQixHQUFkLEVBQW1CbmpCLEVBQUUsQ0FBQ21qQixHQUF0QixJQUE2QmlPLE1BRkY7QUFHaENscUIsV0FBSyxFQUFFekosSUFBSSxDQUFDZ0QsR0FBTCxDQUFTVixJQUFJLENBQUNtSCxLQUFkLEVBQXFCbEgsRUFBRSxDQUFDa0gsS0FBeEIsQ0FIeUI7QUFJaENnYyxZQUFNLEVBQUV6bEIsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTVixJQUFJLENBQUNtakIsTUFBZCxFQUFzQmxqQixFQUFFLENBQUNrakIsTUFBekIsSUFBbUNrTztBQUpYLEtBQUwsQ0FBN0I7QUFNQTBCLGtCQUFjLENBQUNudUIsRUFBRCxFQUFLc3VCLElBQUksQ0FBQzNNLFVBQVYsRUFBc0IyTSxJQUFJLENBQUN2TSxTQUEzQixDQUFkO0FBQ0QsR0E3OEdrQixDQSs4R25CO0FBQ0E7OztBQUNBLFdBQVNrTCxlQUFULENBQXlCanRCLEVBQXpCLEVBQTZCb0YsR0FBN0IsRUFBa0M7QUFDaEMsUUFBSXRNLElBQUksQ0FBQzZLLEdBQUwsQ0FBUzNELEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT3VhLFNBQVAsR0FBbUIzYyxHQUE1QixJQUFtQyxDQUF2QyxFQUEwQztBQUFFO0FBQVE7O0FBQ3BELFFBQUksQ0FBQ3BWLEtBQUwsRUFBWTtBQUFFdStCLHlCQUFtQixDQUFDdnVCLEVBQUQsRUFBSztBQUFDd2UsV0FBRyxFQUFFcFo7QUFBTixPQUFMLENBQW5CO0FBQXNDOztBQUNwRG9wQixnQkFBWSxDQUFDeHVCLEVBQUQsRUFBS29GLEdBQUwsRUFBVSxJQUFWLENBQVo7O0FBQ0EsUUFBSXBWLEtBQUosRUFBVztBQUFFdStCLHlCQUFtQixDQUFDdnVCLEVBQUQsQ0FBbkI7QUFBMEI7O0FBQ3ZDeXVCLGVBQVcsQ0FBQ3p1QixFQUFELEVBQUssR0FBTCxDQUFYO0FBQ0Q7O0FBRUQsV0FBU3d1QixZQUFULENBQXNCeHVCLEVBQXRCLEVBQTBCb0YsR0FBMUIsRUFBK0JzcEIsV0FBL0IsRUFBNEM7QUFDMUN0cEIsT0FBRyxHQUFHdE0sSUFBSSxDQUFDZ0QsR0FBTCxDQUFTLENBQVQsRUFBWWhELElBQUksQ0FBQ0MsR0FBTCxDQUFTaUgsRUFBRSxDQUFDb00sT0FBSCxDQUFXc1IsUUFBWCxDQUFvQmlSLFlBQXBCLEdBQW1DM3VCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NSLFFBQVgsQ0FBb0JHLFlBQWhFLEVBQThFelksR0FBOUUsQ0FBWixDQUFOOztBQUNBLFFBQUlwRixFQUFFLENBQUNvTSxPQUFILENBQVdzUixRQUFYLENBQW9CcUUsU0FBcEIsSUFBaUMzYyxHQUFqQyxJQUF3QyxDQUFDc3BCLFdBQTdDLEVBQTBEO0FBQUU7QUFBUTs7QUFDcEUxdUIsTUFBRSxDQUFDd0gsR0FBSCxDQUFPdWEsU0FBUCxHQUFtQjNjLEdBQW5CO0FBQ0FwRixNQUFFLENBQUNvTSxPQUFILENBQVd3aUIsVUFBWCxDQUFzQkosWUFBdEIsQ0FBbUNwcEIsR0FBbkM7O0FBQ0EsUUFBSXBGLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NSLFFBQVgsQ0FBb0JxRSxTQUFwQixJQUFpQzNjLEdBQXJDLEVBQTBDO0FBQUVwRixRQUFFLENBQUNvTSxPQUFILENBQVdzUixRQUFYLENBQW9CcUUsU0FBcEIsR0FBZ0MzYyxHQUFoQztBQUFzQztBQUNuRixHQS85R2tCLENBaStHbkI7QUFDQTs7O0FBQ0EsV0FBUzhuQixhQUFULENBQXVCbHRCLEVBQXZCLEVBQTJCb0YsR0FBM0IsRUFBZ0N5cEIsVUFBaEMsRUFBNENILFdBQTVDLEVBQXlEO0FBQ3ZEdHBCLE9BQUcsR0FBR3RNLElBQUksQ0FBQ2dELEdBQUwsQ0FBUyxDQUFULEVBQVloRCxJQUFJLENBQUNDLEdBQUwsQ0FBU3FNLEdBQVQsRUFBY3BGLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NSLFFBQVgsQ0FBb0JvUixXQUFwQixHQUFrQzl1QixFQUFFLENBQUNvTSxPQUFILENBQVdzUixRQUFYLENBQW9CcEIsV0FBcEUsQ0FBWixDQUFOOztBQUNBLFFBQUksQ0FBQ3VTLFVBQVUsR0FBR3pwQixHQUFHLElBQUlwRixFQUFFLENBQUN3SCxHQUFILENBQU9tYSxVQUFqQixHQUE4QjdvQixJQUFJLENBQUM2SyxHQUFMLENBQVMzRCxFQUFFLENBQUN3SCxHQUFILENBQU9tYSxVQUFQLEdBQW9CdmMsR0FBN0IsSUFBb0MsQ0FBN0UsS0FBbUYsQ0FBQ3NwQixXQUF4RixFQUFxRztBQUFFO0FBQVE7O0FBQy9HMXVCLE1BQUUsQ0FBQ3dILEdBQUgsQ0FBT21hLFVBQVAsR0FBb0J2YyxHQUFwQjtBQUNBMnBCLHFCQUFpQixDQUFDL3VCLEVBQUQsQ0FBakI7O0FBQ0EsUUFBSUEsRUFBRSxDQUFDb00sT0FBSCxDQUFXc1IsUUFBWCxDQUFvQmlFLFVBQXBCLElBQWtDdmMsR0FBdEMsRUFBMkM7QUFBRXBGLFFBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NSLFFBQVgsQ0FBb0JpRSxVQUFwQixHQUFpQ3ZjLEdBQWpDO0FBQXVDOztBQUNwRnBGLE1BQUUsQ0FBQ29NLE9BQUgsQ0FBV3dpQixVQUFYLENBQXNCMUIsYUFBdEIsQ0FBb0M5bkIsR0FBcEM7QUFDRCxHQTErR2tCLENBNCtHbkI7QUFFQTtBQUNBOzs7QUFDQSxXQUFTNHBCLG9CQUFULENBQThCaHZCLEVBQTlCLEVBQWtDO0FBQ2hDLFFBQUlxVCxDQUFDLEdBQUdyVCxFQUFFLENBQUNvTSxPQUFYO0FBQUEsUUFBb0I2aUIsT0FBTyxHQUFHNWIsQ0FBQyxDQUFDK0ksT0FBRixDQUFVcmEsV0FBeEM7QUFDQSxRQUFJbXRCLElBQUksR0FBR3AyQixJQUFJLENBQUNtdEIsS0FBTCxDQUFXam1CLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT2EsTUFBUCxHQUFnQnlVLFdBQVcsQ0FBQzljLEVBQUUsQ0FBQ29NLE9BQUosQ0FBdEMsQ0FBWDtBQUNBLFdBQU87QUFDTHlSLGtCQUFZLEVBQUV4SyxDQUFDLENBQUNxSyxRQUFGLENBQVdHLFlBRHBCO0FBRUxzUixnQkFBVSxFQUFFOWIsQ0FBQyxDQUFDZ0osT0FBRixDQUFVd0IsWUFGakI7QUFHTGlSLGlCQUFXLEVBQUV6YixDQUFDLENBQUNxSyxRQUFGLENBQVdvUixXQUhuQjtBQUdnQ3hTLGlCQUFXLEVBQUVqSixDQUFDLENBQUNxSyxRQUFGLENBQVdwQixXQUh4RDtBQUlMOFMsZUFBUyxFQUFFL2IsQ0FBQyxDQUFDZ0osT0FBRixDQUFVQyxXQUpoQjtBQUtMK1MsYUFBTyxFQUFFcnZCLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVzJWLFdBQVgsR0FBeUIrVSxPQUF6QixHQUFtQyxDQUx2QztBQU1MSyxlQUFTLEVBQUVKLElBTk47QUFPTFAsa0JBQVksRUFBRU8sSUFBSSxHQUFHM1IsU0FBUyxDQUFDdmQsRUFBRCxDQUFoQixHQUF1QnFULENBQUMsQ0FBQ3lLLFNBUGxDO0FBUUxOLG9CQUFjLEVBQUVuSyxDQUFDLENBQUNtSyxjQVJiO0FBU0wxQyxpQkFBVyxFQUFFbVU7QUFUUixLQUFQO0FBV0Q7O0FBRUQsTUFBSU0sZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQixDQUFTcFAsS0FBVCxFQUFnQjluQixNQUFoQixFQUF3QjJILEVBQXhCLEVBQTRCO0FBQ2pELFNBQUtBLEVBQUwsR0FBVUEsRUFBVjtBQUNBLFFBQUl3dkIsSUFBSSxHQUFHLEtBQUtBLElBQUwsR0FBWXQ4QixHQUFHLENBQUMsS0FBRCxFQUFRLENBQUNBLEdBQUcsQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjLElBQWQsRUFBb0IsZ0JBQXBCLENBQUosQ0FBUixFQUFvRCx1QkFBcEQsQ0FBMUI7QUFDQSxRQUFJdThCLEtBQUssR0FBRyxLQUFLQSxLQUFMLEdBQWF2OEIsR0FBRyxDQUFDLEtBQUQsRUFBUSxDQUFDQSxHQUFHLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYyxJQUFkLEVBQW9CLCtCQUFwQixDQUFKLENBQVIsRUFBbUUsdUJBQW5FLENBQTVCO0FBQ0FzOEIsUUFBSSxDQUFDRSxRQUFMLEdBQWdCRCxLQUFLLENBQUNDLFFBQU4sR0FBaUIsQ0FBQyxDQUFsQztBQUNBdlAsU0FBSyxDQUFDcVAsSUFBRCxDQUFMO0FBQWFyUCxTQUFLLENBQUNzUCxLQUFELENBQUw7QUFFYnR3QixNQUFFLENBQUNxd0IsSUFBRCxFQUFPLFFBQVAsRUFBaUIsWUFBWTtBQUM3QixVQUFJQSxJQUFJLENBQUMzUixZQUFULEVBQXVCO0FBQUV4bEIsY0FBTSxDQUFDbTNCLElBQUksQ0FBQ3pOLFNBQU4sRUFBaUIsVUFBakIsQ0FBTjtBQUFxQztBQUMvRCxLQUZDLENBQUY7QUFHQTVpQixNQUFFLENBQUNzd0IsS0FBRCxFQUFRLFFBQVIsRUFBa0IsWUFBWTtBQUM5QixVQUFJQSxLQUFLLENBQUNuVCxXQUFWLEVBQXVCO0FBQUVqa0IsY0FBTSxDQUFDbzNCLEtBQUssQ0FBQzlOLFVBQVAsRUFBbUIsWUFBbkIsQ0FBTjtBQUF5QztBQUNuRSxLQUZDLENBQUY7QUFJQSxTQUFLZ08sZ0JBQUwsR0FBd0IsS0FBeEIsQ0FkaUQsQ0FlakQ7O0FBQ0EsUUFBSXIvQixFQUFFLElBQUlDLFVBQVUsR0FBRyxDQUF2QixFQUEwQjtBQUFFLFdBQUtrL0IsS0FBTCxDQUFXcDhCLEtBQVgsQ0FBaUJ1OEIsU0FBakIsR0FBNkIsS0FBS0osSUFBTCxDQUFVbjhCLEtBQVYsQ0FBZ0J3OEIsUUFBaEIsR0FBMkIsTUFBeEQ7QUFBaUU7QUFDOUYsR0FqQkQ7O0FBbUJBTixrQkFBZ0IsQ0FBQ3I1QixTQUFqQixDQUEyQjQ1QixNQUEzQixHQUFvQyxVQUFVanVCLE9BQVYsRUFBbUI7QUFDckQsUUFBSWt1QixNQUFNLEdBQUdsdUIsT0FBTyxDQUFDaXRCLFdBQVIsR0FBc0JqdEIsT0FBTyxDQUFDeWEsV0FBUixHQUFzQixDQUF6RDtBQUNBLFFBQUkwVCxNQUFNLEdBQUdudUIsT0FBTyxDQUFDOHNCLFlBQVIsR0FBdUI5c0IsT0FBTyxDQUFDZ2MsWUFBUixHQUF1QixDQUEzRDtBQUNBLFFBQUlvUyxNQUFNLEdBQUdwdUIsT0FBTyxDQUFDMmIsY0FBckI7O0FBRUEsUUFBSXdTLE1BQUosRUFBWTtBQUNWLFdBQUtSLElBQUwsQ0FBVW44QixLQUFWLENBQWdCK1ksT0FBaEIsR0FBMEIsT0FBMUI7QUFDQSxXQUFLb2pCLElBQUwsQ0FBVW44QixLQUFWLENBQWdCa3JCLE1BQWhCLEdBQXlCd1IsTUFBTSxHQUFHRSxNQUFNLEdBQUcsSUFBWixHQUFtQixHQUFsRDtBQUNBLFVBQUlDLFdBQVcsR0FBR3J1QixPQUFPLENBQUNzdEIsVUFBUixJQUFzQlksTUFBTSxHQUFHRSxNQUFILEdBQVksQ0FBeEMsQ0FBbEIsQ0FIVSxDQUlWOztBQUNBLFdBQUtULElBQUwsQ0FBVTE4QixVQUFWLENBQXFCTyxLQUFyQixDQUEyQmdWLE1BQTNCLEdBQ0V2UCxJQUFJLENBQUNnRCxHQUFMLENBQVMsQ0FBVCxFQUFZK0YsT0FBTyxDQUFDOHNCLFlBQVIsR0FBdUI5c0IsT0FBTyxDQUFDZ2MsWUFBL0IsR0FBOENxUyxXQUExRCxJQUF5RSxJQUQzRTtBQUVELEtBUEQsTUFPTztBQUNMLFdBQUtWLElBQUwsQ0FBVW44QixLQUFWLENBQWdCK1ksT0FBaEIsR0FBMEIsRUFBMUI7QUFDQSxXQUFLb2pCLElBQUwsQ0FBVTE4QixVQUFWLENBQXFCTyxLQUFyQixDQUEyQmdWLE1BQTNCLEdBQW9DLEdBQXBDO0FBQ0Q7O0FBRUQsUUFBSTBuQixNQUFKLEVBQVk7QUFDVixXQUFLTixLQUFMLENBQVdwOEIsS0FBWCxDQUFpQitZLE9BQWpCLEdBQTJCLE9BQTNCO0FBQ0EsV0FBS3FqQixLQUFMLENBQVdwOEIsS0FBWCxDQUFpQmtQLEtBQWpCLEdBQXlCeXRCLE1BQU0sR0FBR0MsTUFBTSxHQUFHLElBQVosR0FBbUIsR0FBbEQ7QUFDQSxXQUFLUixLQUFMLENBQVdwOEIsS0FBWCxDQUFpQmlQLElBQWpCLEdBQXdCVCxPQUFPLENBQUN3dEIsT0FBUixHQUFrQixJQUExQztBQUNBLFVBQUljLFVBQVUsR0FBR3R1QixPQUFPLENBQUN1dEIsU0FBUixHQUFvQnZ0QixPQUFPLENBQUN3dEIsT0FBNUIsSUFBdUNXLE1BQU0sR0FBR0MsTUFBSCxHQUFZLENBQXpELENBQWpCO0FBQ0EsV0FBS1IsS0FBTCxDQUFXMzhCLFVBQVgsQ0FBc0JPLEtBQXRCLENBQTRCdW9CLEtBQTVCLEdBQ0U5aUIsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTLENBQVQsRUFBWStGLE9BQU8sQ0FBQ2l0QixXQUFSLEdBQXNCanRCLE9BQU8sQ0FBQ3lhLFdBQTlCLEdBQTRDNlQsVUFBeEQsSUFBc0UsSUFEeEU7QUFFRCxLQVBELE1BT087QUFDTCxXQUFLVixLQUFMLENBQVdwOEIsS0FBWCxDQUFpQitZLE9BQWpCLEdBQTJCLEVBQTNCO0FBQ0EsV0FBS3FqQixLQUFMLENBQVczOEIsVUFBWCxDQUFzQk8sS0FBdEIsQ0FBNEJ1b0IsS0FBNUIsR0FBb0MsR0FBcEM7QUFDRDs7QUFFRCxRQUFJLENBQUMsS0FBSytULGdCQUFOLElBQTBCOXRCLE9BQU8sQ0FBQ2djLFlBQVIsR0FBdUIsQ0FBckQsRUFBd0Q7QUFDdEQsVUFBSW9TLE1BQU0sSUFBSSxDQUFkLEVBQWlCO0FBQUUsYUFBS0csYUFBTDtBQUF1Qjs7QUFDMUMsV0FBS1QsZ0JBQUwsR0FBd0IsSUFBeEI7QUFDRDs7QUFFRCxXQUFPO0FBQUNwdEIsV0FBSyxFQUFFeXRCLE1BQU0sR0FBR0MsTUFBSCxHQUFZLENBQTFCO0FBQTZCMVIsWUFBTSxFQUFFd1IsTUFBTSxHQUFHRSxNQUFILEdBQVk7QUFBdkQsS0FBUDtBQUNELEdBbkNEOztBQXFDQVYsa0JBQWdCLENBQUNyNUIsU0FBakIsQ0FBMkJnM0IsYUFBM0IsR0FBMkMsVUFBVXYwQixHQUFWLEVBQWU7QUFDeEQsUUFBSSxLQUFLODJCLEtBQUwsQ0FBVzlOLFVBQVgsSUFBeUJocEIsR0FBN0IsRUFBa0M7QUFBRSxXQUFLODJCLEtBQUwsQ0FBVzlOLFVBQVgsR0FBd0JocEIsR0FBeEI7QUFBOEI7O0FBQ2xFLFFBQUksS0FBSzAzQixZQUFULEVBQXVCO0FBQUUsV0FBS0Msa0JBQUwsQ0FBd0IsS0FBS2IsS0FBN0IsRUFBb0MsS0FBS1ksWUFBekMsRUFBdUQsT0FBdkQ7QUFBa0U7QUFDNUYsR0FIRDs7QUFLQWQsa0JBQWdCLENBQUNyNUIsU0FBakIsQ0FBMkJzNEIsWUFBM0IsR0FBMEMsVUFBVTcxQixHQUFWLEVBQWU7QUFDdkQsUUFBSSxLQUFLNjJCLElBQUwsQ0FBVXpOLFNBQVYsSUFBdUJwcEIsR0FBM0IsRUFBZ0M7QUFBRSxXQUFLNjJCLElBQUwsQ0FBVXpOLFNBQVYsR0FBc0JwcEIsR0FBdEI7QUFBNEI7O0FBQzlELFFBQUksS0FBSzQzQixXQUFULEVBQXNCO0FBQUUsV0FBS0Qsa0JBQUwsQ0FBd0IsS0FBS2QsSUFBN0IsRUFBbUMsS0FBS2UsV0FBeEMsRUFBcUQsTUFBckQ7QUFBK0Q7QUFDeEYsR0FIRDs7QUFLQWhCLGtCQUFnQixDQUFDcjVCLFNBQWpCLENBQTJCazZCLGFBQTNCLEdBQTJDLFlBQVk7QUFDckQsUUFBSXZFLENBQUMsR0FBR3Y2QixHQUFHLElBQUksQ0FBQ04sa0JBQVIsR0FBNkIsTUFBN0IsR0FBc0MsTUFBOUM7QUFDQSxTQUFLeStCLEtBQUwsQ0FBV3A4QixLQUFYLENBQWlCZ1YsTUFBakIsR0FBMEIsS0FBS21uQixJQUFMLENBQVVuOEIsS0FBVixDQUFnQnVvQixLQUFoQixHQUF3QmlRLENBQWxEO0FBQ0EsU0FBSzRELEtBQUwsQ0FBV3A4QixLQUFYLENBQWlCbTlCLGFBQWpCLEdBQWlDLEtBQUtoQixJQUFMLENBQVVuOEIsS0FBVixDQUFnQm05QixhQUFoQixHQUFnQyxNQUFqRTtBQUNBLFNBQUtILFlBQUwsR0FBb0IsSUFBSWg1QixPQUFKLEVBQXBCO0FBQ0EsU0FBS2s1QixXQUFMLEdBQW1CLElBQUlsNUIsT0FBSixFQUFuQjtBQUNELEdBTkQ7O0FBUUFrNEIsa0JBQWdCLENBQUNyNUIsU0FBakIsQ0FBMkJvNkIsa0JBQTNCLEdBQWdELFVBQVVHLEdBQVYsRUFBZUMsS0FBZixFQUFzQnJ6QixJQUF0QixFQUE0QjtBQUMxRW96QixPQUFHLENBQUNwOUIsS0FBSixDQUFVbTlCLGFBQVYsR0FBMEIsTUFBMUI7O0FBQ0EsYUFBU0csWUFBVCxHQUF3QjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJM00sR0FBRyxHQUFHeU0sR0FBRyxDQUFDcnVCLHFCQUFKLEVBQVY7QUFDQSxVQUFJbFAsR0FBRyxHQUFHbUssSUFBSSxJQUFJLE1BQVIsR0FBaUI3TSxRQUFRLENBQUNvZ0MsZ0JBQVQsQ0FBMEI1TSxHQUFHLENBQUN6aEIsS0FBSixHQUFZLENBQXRDLEVBQXlDLENBQUN5aEIsR0FBRyxDQUFDeEYsR0FBSixHQUFVd0YsR0FBRyxDQUFDekYsTUFBZixJQUF5QixDQUFsRSxDQUFqQixHQUNKL3RCLFFBQVEsQ0FBQ29nQyxnQkFBVCxDQUEwQixDQUFDNU0sR0FBRyxDQUFDemhCLEtBQUosR0FBWXloQixHQUFHLENBQUMxaEIsSUFBakIsSUFBeUIsQ0FBbkQsRUFBc0QwaEIsR0FBRyxDQUFDekYsTUFBSixHQUFhLENBQW5FLENBRE47O0FBRUEsVUFBSXJyQixHQUFHLElBQUl1OUIsR0FBWCxFQUFnQjtBQUFFQSxXQUFHLENBQUNwOUIsS0FBSixDQUFVbTlCLGFBQVYsR0FBMEIsTUFBMUI7QUFBbUMsT0FBckQsTUFDSztBQUFFRSxhQUFLLENBQUM3NEIsR0FBTixDQUFVLElBQVYsRUFBZ0I4NEIsWUFBaEI7QUFBZ0M7QUFDeEM7O0FBQ0RELFNBQUssQ0FBQzc0QixHQUFOLENBQVUsSUFBVixFQUFnQjg0QixZQUFoQjtBQUNELEdBaEJEOztBQWtCQXBCLGtCQUFnQixDQUFDcjVCLFNBQWpCLENBQTJCMjZCLEtBQTNCLEdBQW1DLFlBQVk7QUFDN0MsUUFBSTc5QixNQUFNLEdBQUcsS0FBS3k4QixLQUFMLENBQVdsN0IsVUFBeEI7QUFDQXZCLFVBQU0sQ0FBQ0gsV0FBUCxDQUFtQixLQUFLNDhCLEtBQXhCO0FBQ0F6OEIsVUFBTSxDQUFDSCxXQUFQLENBQW1CLEtBQUsyOEIsSUFBeEI7QUFDRCxHQUpEOztBQU1BLE1BQUlzQixjQUFjLEdBQUcsU0FBakJBLGNBQWlCLEdBQVksQ0FBRSxDQUFuQzs7QUFFQUEsZ0JBQWMsQ0FBQzU2QixTQUFmLENBQXlCNDVCLE1BQXpCLEdBQWtDLFlBQVk7QUFBRSxXQUFPO0FBQUN2UixZQUFNLEVBQUUsQ0FBVDtBQUFZaGMsV0FBSyxFQUFFO0FBQW5CLEtBQVA7QUFBOEIsR0FBOUU7O0FBQ0F1dUIsZ0JBQWMsQ0FBQzU2QixTQUFmLENBQXlCZzNCLGFBQXpCLEdBQXlDLFlBQVksQ0FBRSxDQUF2RDs7QUFDQTRELGdCQUFjLENBQUM1NkIsU0FBZixDQUF5QnM0QixZQUF6QixHQUF3QyxZQUFZLENBQUUsQ0FBdEQ7O0FBQ0FzQyxnQkFBYyxDQUFDNTZCLFNBQWYsQ0FBeUIyNkIsS0FBekIsR0FBaUMsWUFBWSxDQUFFLENBQS9DOztBQUVBLFdBQVNFLGdCQUFULENBQTBCL3dCLEVBQTFCLEVBQThCNkIsT0FBOUIsRUFBdUM7QUFDckMsUUFBSSxDQUFDQSxPQUFMLEVBQWM7QUFBRUEsYUFBTyxHQUFHbXRCLG9CQUFvQixDQUFDaHZCLEVBQUQsQ0FBOUI7QUFBcUM7O0FBQ3JELFFBQUlneEIsVUFBVSxHQUFHaHhCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3VSLFFBQTVCO0FBQUEsUUFBc0NzVCxXQUFXLEdBQUdqeEIsRUFBRSxDQUFDb00sT0FBSCxDQUFXMFIsU0FBL0Q7QUFDQW9ULHlCQUFxQixDQUFDbHhCLEVBQUQsRUFBSzZCLE9BQUwsQ0FBckI7O0FBQ0EsU0FBSyxJQUFJcE8sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxDQUFKLElBQVN1OUIsVUFBVSxJQUFJaHhCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3VSLFFBQWxDLElBQThDc1QsV0FBVyxJQUFJanhCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBVzBSLFNBQXhGLEVBQW1HcnFCLENBQUMsRUFBcEcsRUFBd0c7QUFDdEcsVUFBSXU5QixVQUFVLElBQUloeEIsRUFBRSxDQUFDb00sT0FBSCxDQUFXdVIsUUFBekIsSUFBcUMzZCxFQUFFLENBQUN1RSxPQUFILENBQVcyWixZQUFwRCxFQUNFO0FBQUVzTiwrQkFBdUIsQ0FBQ3hyQixFQUFELENBQXZCO0FBQThCOztBQUNsQ2t4QiwyQkFBcUIsQ0FBQ2x4QixFQUFELEVBQUtndkIsb0JBQW9CLENBQUNodkIsRUFBRCxDQUF6QixDQUFyQjtBQUNBZ3hCLGdCQUFVLEdBQUdoeEIsRUFBRSxDQUFDb00sT0FBSCxDQUFXdVIsUUFBeEI7QUFBa0NzVCxpQkFBVyxHQUFHanhCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBVzBSLFNBQXpCO0FBQ25DO0FBQ0YsR0FubkhrQixDQXFuSG5CO0FBQ0E7OztBQUNBLFdBQVNvVCxxQkFBVCxDQUErQmx4QixFQUEvQixFQUFtQzZCLE9BQW5DLEVBQTRDO0FBQzFDLFFBQUl3UixDQUFDLEdBQUdyVCxFQUFFLENBQUNvTSxPQUFYO0FBQ0EsUUFBSStrQixLQUFLLEdBQUc5ZCxDQUFDLENBQUN1YixVQUFGLENBQWFrQixNQUFiLENBQW9CanVCLE9BQXBCLENBQVo7QUFFQXdSLEtBQUMsQ0FBQ29KLEtBQUYsQ0FBUXBwQixLQUFSLENBQWNncUIsWUFBZCxHQUE2QixDQUFDaEssQ0FBQyxDQUFDc0ssUUFBRixHQUFhd1QsS0FBSyxDQUFDNXVCLEtBQXBCLElBQTZCLElBQTFEO0FBQ0E4USxLQUFDLENBQUNvSixLQUFGLENBQVFwcEIsS0FBUixDQUFjKzlCLGFBQWQsR0FBOEIsQ0FBQy9kLENBQUMsQ0FBQ3lLLFNBQUYsR0FBY3FULEtBQUssQ0FBQzVTLE1BQXJCLElBQStCLElBQTdEO0FBQ0FsTCxLQUFDLENBQUNnZSxZQUFGLENBQWVoK0IsS0FBZixDQUFxQmkrQixZQUFyQixHQUFvQ0gsS0FBSyxDQUFDNVMsTUFBTixHQUFlLHNCQUFuRDs7QUFFQSxRQUFJNFMsS0FBSyxDQUFDNXVCLEtBQU4sSUFBZTR1QixLQUFLLENBQUM1UyxNQUF6QixFQUFpQztBQUMvQmxMLE9BQUMsQ0FBQ2tlLGVBQUYsQ0FBa0JsK0IsS0FBbEIsQ0FBd0IrWSxPQUF4QixHQUFrQyxPQUFsQztBQUNBaUgsT0FBQyxDQUFDa2UsZUFBRixDQUFrQmwrQixLQUFsQixDQUF3QmdWLE1BQXhCLEdBQWlDOG9CLEtBQUssQ0FBQzVTLE1BQU4sR0FBZSxJQUFoRDtBQUNBbEwsT0FBQyxDQUFDa2UsZUFBRixDQUFrQmwrQixLQUFsQixDQUF3QnVvQixLQUF4QixHQUFnQ3VWLEtBQUssQ0FBQzV1QixLQUFOLEdBQWMsSUFBOUM7QUFDRCxLQUpELE1BSU87QUFBRThRLE9BQUMsQ0FBQ2tlLGVBQUYsQ0FBa0JsK0IsS0FBbEIsQ0FBd0IrWSxPQUF4QixHQUFrQyxFQUFsQztBQUF1Qzs7QUFDaEQsUUFBSStrQixLQUFLLENBQUM1UyxNQUFOLElBQWdCdmUsRUFBRSxDQUFDdUUsT0FBSCxDQUFXaXRCLDBCQUEzQixJQUF5RHh4QixFQUFFLENBQUN1RSxPQUFILENBQVcyVixXQUF4RSxFQUFxRjtBQUNuRjdHLE9BQUMsQ0FBQ29lLFlBQUYsQ0FBZXArQixLQUFmLENBQXFCK1ksT0FBckIsR0FBK0IsT0FBL0I7QUFDQWlILE9BQUMsQ0FBQ29lLFlBQUYsQ0FBZXArQixLQUFmLENBQXFCZ1YsTUFBckIsR0FBOEI4b0IsS0FBSyxDQUFDNVMsTUFBTixHQUFlLElBQTdDO0FBQ0FsTCxPQUFDLENBQUNvZSxZQUFGLENBQWVwK0IsS0FBZixDQUFxQnVvQixLQUFyQixHQUE2Qi9aLE9BQU8sQ0FBQ2laLFdBQVIsR0FBc0IsSUFBbkQ7QUFDRCxLQUpELE1BSU87QUFBRXpILE9BQUMsQ0FBQ29lLFlBQUYsQ0FBZXArQixLQUFmLENBQXFCK1ksT0FBckIsR0FBK0IsRUFBL0I7QUFBb0M7QUFDOUM7O0FBRUQsTUFBSXNsQixjQUFjLEdBQUc7QUFBQyxjQUFVbkMsZ0JBQVg7QUFBNkIsWUFBUXVCO0FBQXJDLEdBQXJCOztBQUVBLFdBQVNhLGNBQVQsQ0FBd0IzeEIsRUFBeEIsRUFBNEI7QUFDMUIsUUFBSUEsRUFBRSxDQUFDb00sT0FBSCxDQUFXd2lCLFVBQWYsRUFBMkI7QUFDekI1dUIsUUFBRSxDQUFDb00sT0FBSCxDQUFXd2lCLFVBQVgsQ0FBc0JpQyxLQUF0Qjs7QUFDQSxVQUFJN3dCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3dpQixVQUFYLENBQXNCMTVCLFFBQTFCLEVBQ0U7QUFBRWpELGVBQU8sQ0FBQytOLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV2lRLE9BQVosRUFBcUJyYyxFQUFFLENBQUNvTSxPQUFILENBQVd3aUIsVUFBWCxDQUFzQjE1QixRQUEzQyxDQUFQO0FBQThEO0FBQ25FOztBQUVEOEssTUFBRSxDQUFDb00sT0FBSCxDQUFXd2lCLFVBQVgsR0FBd0IsSUFBSThDLGNBQWMsQ0FBQzF4QixFQUFFLENBQUN1RSxPQUFILENBQVdxdEIsY0FBWixDQUFsQixDQUE4QyxVQUFVMS9CLElBQVYsRUFBZ0I7QUFDcEY4TixRQUFFLENBQUNvTSxPQUFILENBQVdpUSxPQUFYLENBQW1CM0MsWUFBbkIsQ0FBZ0N4bkIsSUFBaEMsRUFBc0M4TixFQUFFLENBQUNvTSxPQUFILENBQVdtbEIsZUFBakQsRUFEb0YsQ0FFcEY7O0FBQ0FweUIsUUFBRSxDQUFDak4sSUFBRCxFQUFPLFdBQVAsRUFBb0IsWUFBWTtBQUNoQyxZQUFJOE4sRUFBRSxDQUFDa0YsS0FBSCxDQUFTbWxCLE9BQWIsRUFBc0I7QUFBRXp5QixvQkFBVSxDQUFDLFlBQVk7QUFBRSxtQkFBT29JLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NLLEtBQVgsQ0FBaUJxVSxLQUFqQixFQUFQO0FBQWtDLFdBQWpELEVBQW1ELENBQW5ELENBQVY7QUFBa0U7QUFDM0YsT0FGQyxDQUFGO0FBR0E3NEIsVUFBSSxDQUFDeUIsWUFBTCxDQUFrQixnQkFBbEIsRUFBb0MsTUFBcEM7QUFDRCxLQVB1QixFQU9yQixVQUFVZ0YsR0FBVixFQUFlazVCLElBQWYsRUFBcUI7QUFDdEIsVUFBSUEsSUFBSSxJQUFJLFlBQVosRUFBMEI7QUFBRTNFLHFCQUFhLENBQUNsdEIsRUFBRCxFQUFLckgsR0FBTCxDQUFiO0FBQXlCLE9BQXJELE1BQ0s7QUFBRXMwQix1QkFBZSxDQUFDanRCLEVBQUQsRUFBS3JILEdBQUwsQ0FBZjtBQUEyQjtBQUNuQyxLQVZ1QixFQVVyQnFILEVBVnFCLENBQXhCOztBQVdBLFFBQUlBLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3dpQixVQUFYLENBQXNCMTVCLFFBQTFCLEVBQ0U7QUFBRUEsY0FBUSxDQUFDOEssRUFBRSxDQUFDb00sT0FBSCxDQUFXaVEsT0FBWixFQUFxQnJjLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3dpQixVQUFYLENBQXNCMTVCLFFBQTNDLENBQVI7QUFBK0Q7QUFDcEUsR0FqcUhrQixDQW1xSG5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBLE1BQUk0OEIsUUFBUSxHQUFHLENBQWYsQ0F6cUhtQixDQTBxSG5COztBQUNBLFdBQVNDLGVBQVQsQ0FBd0IveEIsRUFBeEIsRUFBNEI7QUFDMUJBLE1BQUUsQ0FBQ1EsS0FBSCxHQUFXO0FBQ1RSLFFBQUUsRUFBRUEsRUFESztBQUVUcW1CLGlCQUFXLEVBQUUsS0FGSjtBQUVnQjtBQUN6QjRLLGlCQUFXLEVBQUVqeEIsRUFBRSxDQUFDd0gsR0FBSCxDQUFPYSxNQUhYO0FBR21CO0FBQzVCOFcsaUJBQVcsRUFBRSxLQUpKO0FBSWdCO0FBQ3pCNlMsaUJBQVcsRUFBRSxDQUxKO0FBS2E7QUFDdEJDLFlBQU0sRUFBRSxLQU5DO0FBTWdCO0FBQ3pCQyxnQkFBVSxFQUFFLElBUEg7QUFPZ0I7QUFDekJ6eEIsNEJBQXNCLEVBQUUsSUFSZjtBQVFxQjtBQUM5QjRYLDBCQUFvQixFQUFFLENBVGI7QUFTZ0I7QUFDekI4WixzQkFBZ0IsRUFBRSxLQVZUO0FBVWdCO0FBQ3pCQyxtQkFBYSxFQUFFLEtBWE47QUFXZ0I7QUFDekJ6USxnQkFBVSxFQUFFLElBWkg7QUFZU0ksZUFBUyxFQUFFLElBWnBCO0FBWTBCO0FBQ25Da00saUJBQVcsRUFBRSxJQWJKO0FBYWdCO0FBQ3pCbEQsV0FBSyxFQUFFLEtBZEU7QUFlVHp6QixRQUFFLEVBQUUsRUFBRXc2QixRQWZHLENBZWdCOztBQWZoQixLQUFYO0FBaUJBamEsaUJBQWEsQ0FBQzdYLEVBQUUsQ0FBQ1EsS0FBSixDQUFiO0FBQ0QsR0E5ckhrQixDQWdzSG5COzs7QUFDQSxXQUFTNnhCLGFBQVQsQ0FBc0JyeUIsRUFBdEIsRUFBMEI7QUFDeEIsUUFBSThYLEVBQUUsR0FBRzlYLEVBQUUsQ0FBQ1EsS0FBWjs7QUFDQSxRQUFJc1gsRUFBSixFQUFRO0FBQUVRLHFCQUFlLENBQUNSLEVBQUQsRUFBSyxVQUFVSyxLQUFWLEVBQWlCO0FBQzdDLGFBQUssSUFBSTFrQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMGtCLEtBQUssQ0FBQ0osR0FBTixDQUFVdmxCLE1BQTlCLEVBQXNDaUIsQ0FBQyxFQUF2QyxFQUNFO0FBQUUwa0IsZUFBSyxDQUFDSixHQUFOLENBQVV0a0IsQ0FBVixFQUFhdU0sRUFBYixDQUFnQlEsS0FBaEIsR0FBd0IsSUFBeEI7QUFBK0I7O0FBQ25DOHhCLHFCQUFhLENBQUNuYSxLQUFELENBQWI7QUFDRCxPQUp3QixDQUFmO0FBSUw7QUFDTixHQXhzSGtCLENBMHNIbkI7QUFDQTs7O0FBQ0EsV0FBU21hLGFBQVQsQ0FBdUJuYSxLQUF2QixFQUE4QjtBQUM1QixRQUFJSixHQUFHLEdBQUdJLEtBQUssQ0FBQ0osR0FBaEI7O0FBQ0EsU0FBSyxJQUFJdGtCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdza0IsR0FBRyxDQUFDdmxCLE1BQXhCLEVBQWdDaUIsQ0FBQyxFQUFqQyxFQUFxQztBQUNuQztBQUFFOCtCLHFCQUFlLENBQUN4YSxHQUFHLENBQUN0a0IsQ0FBRCxDQUFKLENBQWY7QUFBMEI7O0FBQzlCLFNBQUssSUFBSTBKLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUc0YSxHQUFHLENBQUN2bEIsTUFBNUIsRUFBb0MySyxHQUFHLEVBQXZDLEVBQTJDO0FBQ3pDO0FBQUVxMUIscUJBQWUsQ0FBQ3phLEdBQUcsQ0FBQzVhLEdBQUQsQ0FBSixDQUFmO0FBQTRCOztBQUNoQyxTQUFLLElBQUlHLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUd5YSxHQUFHLENBQUN2bEIsTUFBNUIsRUFBb0M4SyxHQUFHLEVBQXZDLEVBQTJDO0FBQ3pDO0FBQUVtMUIscUJBQWUsQ0FBQzFhLEdBQUcsQ0FBQ3phLEdBQUQsQ0FBSixDQUFmO0FBQTRCOztBQUNoQyxTQUFLLElBQUlFLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUd1YSxHQUFHLENBQUN2bEIsTUFBNUIsRUFBb0NnTCxHQUFHLEVBQXZDLEVBQTJDO0FBQ3pDO0FBQUVrMUIscUJBQWUsQ0FBQzNhLEdBQUcsQ0FBQ3ZhLEdBQUQsQ0FBSixDQUFmO0FBQTRCOztBQUNoQyxTQUFLLElBQUlHLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUdvYSxHQUFHLENBQUN2bEIsTUFBNUIsRUFBb0NtTCxHQUFHLEVBQXZDLEVBQTJDO0FBQ3pDO0FBQUVnMUIseUJBQW1CLENBQUM1YSxHQUFHLENBQUNwYSxHQUFELENBQUosQ0FBbkI7QUFBZ0M7QUFDckM7O0FBRUQsV0FBUzQwQixlQUFULENBQXlCemEsRUFBekIsRUFBNkI7QUFDM0IsUUFBSTlYLEVBQUUsR0FBRzhYLEVBQUUsQ0FBQzlYLEVBQVo7QUFBQSxRQUFnQm9NLE9BQU8sR0FBR3BNLEVBQUUsQ0FBQ29NLE9BQTdCO0FBQ0F3bUIsdUJBQW1CLENBQUM1eUIsRUFBRCxDQUFuQjs7QUFDQSxRQUFJOFgsRUFBRSxDQUFDc2EsYUFBUCxFQUFzQjtBQUFFaGYsaUJBQVcsQ0FBQ3BULEVBQUQsQ0FBWDtBQUFrQjs7QUFFMUM4WCxNQUFFLENBQUMrYSxVQUFILEdBQWdCL2EsRUFBRSxDQUFDdU8sV0FBSCxJQUFrQnZPLEVBQUUsQ0FBQ3FILFdBQXJCLElBQW9DckgsRUFBRSxDQUFDaUssU0FBSCxJQUFnQixJQUFwRCxJQUNkakssRUFBRSxDQUFDbVcsV0FBSCxLQUFtQm5XLEVBQUUsQ0FBQ21XLFdBQUgsQ0FBZTd5QixJQUFmLENBQW9CNEQsSUFBcEIsR0FBMkJvTixPQUFPLENBQUNHLFFBQW5DLElBQ0F1TCxFQUFFLENBQUNtVyxXQUFILENBQWU1eUIsRUFBZixDQUFrQjJELElBQWxCLElBQTBCb04sT0FBTyxDQUFDSSxNQURyRCxDQURjLElBR2RKLE9BQU8sQ0FBQ29ILGNBQVIsSUFBMEJ4VCxFQUFFLENBQUN1RSxPQUFILENBQVcyWixZQUh2QztBQUlBcEcsTUFBRSxDQUFDZ1ksTUFBSCxHQUFZaFksRUFBRSxDQUFDK2EsVUFBSCxJQUNWLElBQUlDLGFBQUosQ0FBa0I5eUIsRUFBbEIsRUFBc0I4WCxFQUFFLENBQUMrYSxVQUFILElBQWlCO0FBQUNyVSxTQUFHLEVBQUUxRyxFQUFFLENBQUNpSyxTQUFUO0FBQW9CaUssWUFBTSxFQUFFbFUsRUFBRSxDQUFDbVc7QUFBL0IsS0FBdkMsRUFBb0ZuVyxFQUFFLENBQUNxSCxXQUF2RixDQURGO0FBRUQ7O0FBRUQsV0FBU3FULGVBQVQsQ0FBeUIxYSxFQUF6QixFQUE2QjtBQUMzQkEsTUFBRSxDQUFDaWIsY0FBSCxHQUFvQmpiLEVBQUUsQ0FBQythLFVBQUgsSUFBaUJHLHFCQUFxQixDQUFDbGIsRUFBRSxDQUFDOVgsRUFBSixFQUFROFgsRUFBRSxDQUFDZ1ksTUFBWCxDQUExRDtBQUNEOztBQUVELFdBQVMyQyxlQUFULENBQXlCM2EsRUFBekIsRUFBNkI7QUFDM0IsUUFBSTlYLEVBQUUsR0FBRzhYLEVBQUUsQ0FBQzlYLEVBQVo7QUFBQSxRQUFnQm9NLE9BQU8sR0FBR3BNLEVBQUUsQ0FBQ29NLE9BQTdCOztBQUNBLFFBQUkwTCxFQUFFLENBQUNpYixjQUFQLEVBQXVCO0FBQUV2SCw2QkFBdUIsQ0FBQ3hyQixFQUFELENBQXZCO0FBQThCOztBQUV2RDhYLE1BQUUsQ0FBQ21iLFVBQUgsR0FBZ0JqRSxvQkFBb0IsQ0FBQ2h2QixFQUFELENBQXBDLENBSjJCLENBTTNCO0FBQ0E7QUFDQTs7QUFDQSxRQUFJb00sT0FBTyxDQUFDb0gsY0FBUixJQUEwQixDQUFDeFQsRUFBRSxDQUFDdUUsT0FBSCxDQUFXMlosWUFBMUMsRUFBd0Q7QUFDdERwRyxRQUFFLENBQUNvYixhQUFILEdBQW1CdFUsV0FBVyxDQUFDNWUsRUFBRCxFQUFLb00sT0FBTyxDQUFDa0gsT0FBYixFQUFzQmxILE9BQU8sQ0FBQ2tILE9BQVIsQ0FBZ0JyVSxJQUFoQixDQUFxQnpNLE1BQTNDLENBQVgsQ0FBOEQ4UCxJQUE5RCxHQUFxRSxDQUF4RjtBQUNBdEMsUUFBRSxDQUFDb00sT0FBSCxDQUFXcWMsVUFBWCxHQUF3QjNRLEVBQUUsQ0FBQ29iLGFBQTNCO0FBQ0FwYixRQUFFLENBQUNtYixVQUFILENBQWNuRSxXQUFkLEdBQ0VoMkIsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTc1EsT0FBTyxDQUFDc1IsUUFBUixDQUFpQnBCLFdBQTFCLEVBQXVDbFEsT0FBTyxDQUFDcVEsS0FBUixDQUFjeUksVUFBZCxHQUEyQnBOLEVBQUUsQ0FBQ29iLGFBQTlCLEdBQThDM1YsU0FBUyxDQUFDdmQsRUFBRCxDQUF2RCxHQUE4REEsRUFBRSxDQUFDb00sT0FBSCxDQUFXdVIsUUFBaEgsQ0FERjtBQUVBN0YsUUFBRSxDQUFDcWIsYUFBSCxHQUFtQnI2QixJQUFJLENBQUNnRCxHQUFMLENBQVMsQ0FBVCxFQUFZc1EsT0FBTyxDQUFDcVEsS0FBUixDQUFjeUksVUFBZCxHQUEyQnBOLEVBQUUsQ0FBQ29iLGFBQTlCLEdBQThDelYsWUFBWSxDQUFDemQsRUFBRCxDQUF0RSxDQUFuQjtBQUNEOztBQUVELFFBQUk4WCxFQUFFLENBQUNpYixjQUFILElBQXFCamIsRUFBRSxDQUFDcWEsZ0JBQTVCLEVBQ0U7QUFBRXJhLFFBQUUsQ0FBQ3NiLGlCQUFILEdBQXVCaG5CLE9BQU8sQ0FBQ3NLLEtBQVIsQ0FBYzBRLGdCQUFkLEVBQXZCO0FBQTBEO0FBQy9EOztBQUVELFdBQVNzTCxlQUFULENBQXlCNWEsRUFBekIsRUFBNkI7QUFDM0IsUUFBSTlYLEVBQUUsR0FBRzhYLEVBQUUsQ0FBQzlYLEVBQVo7O0FBRUEsUUFBSThYLEVBQUUsQ0FBQ29iLGFBQUgsSUFBb0IsSUFBeEIsRUFBOEI7QUFDNUJsekIsUUFBRSxDQUFDb00sT0FBSCxDQUFXcVEsS0FBWCxDQUFpQnBwQixLQUFqQixDQUF1Qnc4QixRQUF2QixHQUFrQy9YLEVBQUUsQ0FBQ29iLGFBQUgsR0FBbUIsSUFBckQ7O0FBQ0EsVUFBSXBiLEVBQUUsQ0FBQ3FiLGFBQUgsR0FBbUJuekIsRUFBRSxDQUFDd0gsR0FBSCxDQUFPbWEsVUFBOUIsRUFDRTtBQUFFdUwscUJBQWEsQ0FBQ2x0QixFQUFELEVBQUtsSCxJQUFJLENBQUNDLEdBQUwsQ0FBU2lILEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NSLFFBQVgsQ0FBb0JpRSxVQUE3QixFQUF5QzdKLEVBQUUsQ0FBQ3FiLGFBQTVDLENBQUwsRUFBaUUsSUFBakUsQ0FBYjtBQUFzRjs7QUFDMUZuekIsUUFBRSxDQUFDb00sT0FBSCxDQUFXb0gsY0FBWCxHQUE0QixLQUE1QjtBQUNEOztBQUVELFFBQUk2ZixTQUFTLEdBQUd2YixFQUFFLENBQUNpVCxLQUFILElBQVlqVCxFQUFFLENBQUNpVCxLQUFILElBQVloMkIsU0FBUyxFQUFqRDs7QUFDQSxRQUFJK2lCLEVBQUUsQ0FBQ3NiLGlCQUFQLEVBQ0U7QUFBRXB6QixRQUFFLENBQUNvTSxPQUFILENBQVdzSyxLQUFYLENBQWlCeVEsYUFBakIsQ0FBK0JyUCxFQUFFLENBQUNzYixpQkFBbEMsRUFBcURDLFNBQXJEO0FBQWtFOztBQUN0RSxRQUFJdmIsRUFBRSxDQUFDaWIsY0FBSCxJQUFxQmpiLEVBQUUsQ0FBQ21aLFdBQUgsSUFBa0JqeEIsRUFBRSxDQUFDd0gsR0FBSCxDQUFPYSxNQUFsRCxFQUNFO0FBQUUwb0Isc0JBQWdCLENBQUMvd0IsRUFBRCxFQUFLOFgsRUFBRSxDQUFDbWIsVUFBUixDQUFoQjtBQUFzQzs7QUFDMUMsUUFBSW5iLEVBQUUsQ0FBQ2liLGNBQVAsRUFDRTtBQUFFTyx1QkFBaUIsQ0FBQ3R6QixFQUFELEVBQUs4WCxFQUFFLENBQUNtYixVQUFSLENBQWpCO0FBQXVDOztBQUUzQyxRQUFJbmIsRUFBRSxDQUFDcWEsZ0JBQVAsRUFBeUI7QUFBRS9ILGtCQUFZLENBQUNwcUIsRUFBRCxDQUFaO0FBQW1COztBQUU5QyxRQUFJQSxFQUFFLENBQUNrRixLQUFILENBQVNtbEIsT0FBVCxJQUFvQnZTLEVBQUUsQ0FBQ2thLFdBQTNCLEVBQ0U7QUFBRWh5QixRQUFFLENBQUNvTSxPQUFILENBQVdzSyxLQUFYLENBQWlCMlUsS0FBakIsQ0FBdUJ2VCxFQUFFLENBQUNtYSxNQUExQjtBQUFvQzs7QUFDeEMsUUFBSW9CLFNBQUosRUFBZTtBQUFFdkksaUJBQVcsQ0FBQ2hULEVBQUUsQ0FBQzlYLEVBQUosQ0FBWDtBQUFxQjtBQUN2Qzs7QUFFRCxXQUFTMnlCLG1CQUFULENBQTZCN2EsRUFBN0IsRUFBaUM7QUFDL0IsUUFBSTlYLEVBQUUsR0FBRzhYLEVBQUUsQ0FBQzlYLEVBQVo7QUFBQSxRQUFnQm9NLE9BQU8sR0FBR3BNLEVBQUUsQ0FBQ29NLE9BQTdCO0FBQUEsUUFBc0M1RSxHQUFHLEdBQUd4SCxFQUFFLENBQUN3SCxHQUEvQzs7QUFFQSxRQUFJc1EsRUFBRSxDQUFDaWIsY0FBUCxFQUF1QjtBQUFFUSx1QkFBaUIsQ0FBQ3Z6QixFQUFELEVBQUs4WCxFQUFFLENBQUNnWSxNQUFSLENBQWpCO0FBQW1DLEtBSDdCLENBSy9COzs7QUFDQSxRQUFJMWpCLE9BQU8sQ0FBQ29uQixXQUFSLElBQXVCLElBQXZCLEtBQWdDMWIsRUFBRSxDQUFDaUssU0FBSCxJQUFnQixJQUFoQixJQUF3QmpLLEVBQUUsQ0FBQzZKLFVBQUgsSUFBaUIsSUFBekMsSUFBaUQ3SixFQUFFLENBQUNtVyxXQUFwRixDQUFKLEVBQ0U7QUFBRTdoQixhQUFPLENBQUNvbkIsV0FBUixHQUFzQnBuQixPQUFPLENBQUNxbkIsV0FBUixHQUFzQixJQUE1QztBQUFtRCxLQVB4QixDQVMvQjs7O0FBQ0EsUUFBSTNiLEVBQUUsQ0FBQ2lLLFNBQUgsSUFBZ0IsSUFBcEIsRUFBMEI7QUFBRXlNLGtCQUFZLENBQUN4dUIsRUFBRCxFQUFLOFgsRUFBRSxDQUFDaUssU0FBUixFQUFtQmpLLEVBQUUsQ0FBQzRXLFdBQXRCLENBQVo7QUFBaUQ7O0FBRTdFLFFBQUk1VyxFQUFFLENBQUM2SixVQUFILElBQWlCLElBQXJCLEVBQTJCO0FBQUV1TCxtQkFBYSxDQUFDbHRCLEVBQUQsRUFBSzhYLEVBQUUsQ0FBQzZKLFVBQVIsRUFBb0IsSUFBcEIsRUFBMEIsSUFBMUIsQ0FBYjtBQUErQyxLQVo3QyxDQWEvQjs7O0FBQ0EsUUFBSTdKLEVBQUUsQ0FBQ21XLFdBQVAsRUFBb0I7QUFDbEIsVUFBSWpRLElBQUksR0FBR3dPLGlCQUFpQixDQUFDeHNCLEVBQUQsRUFBSzBKLFFBQU8sQ0FBQ2xDLEdBQUQsRUFBTXNRLEVBQUUsQ0FBQ21XLFdBQUgsQ0FBZTd5QixJQUFyQixDQUFaLEVBQ0NzTyxRQUFPLENBQUNsQyxHQUFELEVBQU1zUSxFQUFFLENBQUNtVyxXQUFILENBQWU1eUIsRUFBckIsQ0FEUixFQUNrQ3ljLEVBQUUsQ0FBQ21XLFdBQUgsQ0FBZXhCLE1BRGpELENBQTVCO0FBRUFOLHVCQUFpQixDQUFDbnNCLEVBQUQsRUFBS2dlLElBQUwsQ0FBakI7QUFDRCxLQWxCOEIsQ0FvQi9CO0FBQ0E7OztBQUNBLFFBQUl4RyxNQUFNLEdBQUdNLEVBQUUsQ0FBQzRiLGtCQUFoQjtBQUFBLFFBQW9DQyxRQUFRLEdBQUc3YixFQUFFLENBQUM4YixvQkFBbEQ7O0FBQ0EsUUFBSXBjLE1BQUosRUFBWTtBQUFFLFdBQUssSUFBSS9qQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHK2pCLE1BQU0sQ0FBQ2hsQixNQUEzQixFQUFtQyxFQUFFaUIsQ0FBckMsRUFDWjtBQUFFLFlBQUksQ0FBQytqQixNQUFNLENBQUMvakIsQ0FBRCxDQUFOLENBQVVvVSxLQUFWLENBQWdCclYsTUFBckIsRUFBNkI7QUFBRXFOLGdCQUFNLENBQUMyWCxNQUFNLENBQUMvakIsQ0FBRCxDQUFQLEVBQVksTUFBWixDQUFOO0FBQTRCO0FBQUU7QUFBRTs7QUFDbkUsUUFBSWtnQyxRQUFKLEVBQWM7QUFBRSxXQUFLLElBQUl4MkIsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBR3cyQixRQUFRLENBQUNuaEMsTUFBakMsRUFBeUMsRUFBRTJLLEdBQTNDLEVBQ2Q7QUFBRSxZQUFJdzJCLFFBQVEsQ0FBQ3gyQixHQUFELENBQVIsQ0FBYzBLLEtBQWQsQ0FBb0JyVixNQUF4QixFQUFnQztBQUFFcU4sZ0JBQU0sQ0FBQzh6QixRQUFRLENBQUN4MkIsR0FBRCxDQUFULEVBQWdCLFFBQWhCLENBQU47QUFBa0M7QUFBRTtBQUFFOztBQUU1RSxRQUFJaVAsT0FBTyxDQUFDaVEsT0FBUixDQUFnQnZhLFlBQXBCLEVBQ0U7QUFBRTBGLFNBQUcsQ0FBQ3VhLFNBQUosR0FBZ0IvaEIsRUFBRSxDQUFDb00sT0FBSCxDQUFXc1IsUUFBWCxDQUFvQnFFLFNBQXBDO0FBQWdELEtBN0JyQixDQStCL0I7OztBQUNBLFFBQUlqSyxFQUFFLENBQUNvYSxVQUFQLEVBQ0U7QUFBRXJ5QixZQUFNLENBQUNHLEVBQUQsRUFBSyxTQUFMLEVBQWdCQSxFQUFoQixFQUFvQjhYLEVBQUUsQ0FBQ29hLFVBQXZCLENBQU47QUFBMkM7O0FBQy9DLFFBQUlwYSxFQUFFLENBQUNnWSxNQUFQLEVBQ0U7QUFBRWhZLFFBQUUsQ0FBQ2dZLE1BQUgsQ0FBVStELE1BQVY7QUFBcUI7QUFDMUIsR0E3ekhrQixDQSt6SG5COzs7QUFDQSxXQUFTQyxPQUFULENBQWlCOXpCLEVBQWpCLEVBQXFCakssQ0FBckIsRUFBd0I7QUFDdEIsUUFBSWlLLEVBQUUsQ0FBQ1EsS0FBUCxFQUFjO0FBQUUsYUFBT3pLLENBQUMsRUFBUjtBQUFZOztBQUM1Qmc4QixtQkFBYyxDQUFDL3hCLEVBQUQsQ0FBZDs7QUFDQSxRQUFJO0FBQUUsYUFBT2pLLENBQUMsRUFBUjtBQUFZLEtBQWxCLFNBQ1E7QUFBRXM4QixtQkFBWSxDQUFDcnlCLEVBQUQsQ0FBWjtBQUFtQjtBQUM5QixHQXIwSGtCLENBczBIbkI7OztBQUNBLFdBQVMrekIsU0FBVCxDQUFtQi96QixFQUFuQixFQUF1QmpLLENBQXZCLEVBQTBCO0FBQ3hCLFdBQU8sWUFBVztBQUNoQixVQUFJaUssRUFBRSxDQUFDUSxLQUFQLEVBQWM7QUFBRSxlQUFPekssQ0FBQyxDQUFDTSxLQUFGLENBQVEySixFQUFSLEVBQVk1SixTQUFaLENBQVA7QUFBK0I7O0FBQy9DMjdCLHFCQUFjLENBQUMveEIsRUFBRCxDQUFkOztBQUNBLFVBQUk7QUFBRSxlQUFPakssQ0FBQyxDQUFDTSxLQUFGLENBQVEySixFQUFSLEVBQVk1SixTQUFaLENBQVA7QUFBK0IsT0FBckMsU0FDUTtBQUFFaThCLHFCQUFZLENBQUNyeUIsRUFBRCxDQUFaO0FBQW1CO0FBQzlCLEtBTEQ7QUFNRCxHQTkwSGtCLENBKzBIbkI7QUFDQTs7O0FBQ0EsV0FBU2cwQixRQUFULENBQWtCaitCLENBQWxCLEVBQXFCO0FBQ25CLFdBQU8sWUFBVztBQUNoQixVQUFJLEtBQUt5SyxLQUFULEVBQWdCO0FBQUUsZUFBT3pLLENBQUMsQ0FBQ00sS0FBRixDQUFRLElBQVIsRUFBY0QsU0FBZCxDQUFQO0FBQWlDOztBQUNuRDI3QixxQkFBYyxDQUFDLElBQUQsQ0FBZDs7QUFDQSxVQUFJO0FBQUUsZUFBT2g4QixDQUFDLENBQUNNLEtBQUYsQ0FBUSxJQUFSLEVBQWNELFNBQWQsQ0FBUDtBQUFpQyxPQUF2QyxTQUNRO0FBQUVpOEIscUJBQVksQ0FBQyxJQUFELENBQVo7QUFBcUI7QUFDaEMsS0FMRDtBQU1EOztBQUNELFdBQVM0QixXQUFULENBQXFCbCtCLENBQXJCLEVBQXdCO0FBQ3RCLFdBQU8sWUFBVztBQUNoQixVQUFJaUssRUFBRSxHQUFHLEtBQUtBLEVBQWQ7O0FBQ0EsVUFBSSxDQUFDQSxFQUFELElBQU9BLEVBQUUsQ0FBQ1EsS0FBZCxFQUFxQjtBQUFFLGVBQU96SyxDQUFDLENBQUNNLEtBQUYsQ0FBUSxJQUFSLEVBQWNELFNBQWQsQ0FBUDtBQUFpQzs7QUFDeEQyN0IscUJBQWMsQ0FBQy94QixFQUFELENBQWQ7O0FBQ0EsVUFBSTtBQUFFLGVBQU9qSyxDQUFDLENBQUNNLEtBQUYsQ0FBUSxJQUFSLEVBQWNELFNBQWQsQ0FBUDtBQUFpQyxPQUF2QyxTQUNRO0FBQUVpOEIscUJBQVksQ0FBQ3J5QixFQUFELENBQVo7QUFBbUI7QUFDOUIsS0FORDtBQU9ELEdBajJIa0IsQ0FtMkhuQjs7O0FBRUEsV0FBU3l1QixXQUFULENBQXFCenVCLEVBQXJCLEVBQXlCekksSUFBekIsRUFBK0I7QUFDN0IsUUFBSXlJLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT3lFLGlCQUFQLEdBQTJCak0sRUFBRSxDQUFDb00sT0FBSCxDQUFXSSxNQUExQyxFQUNFO0FBQUV4TSxRQUFFLENBQUNrRixLQUFILENBQVNndkIsU0FBVCxDQUFtQnI4QixHQUFuQixDQUF1Qk4sSUFBdkIsRUFBNkJ6QixJQUFJLENBQUNxK0IsZUFBRCxFQUFrQm4wQixFQUFsQixDQUFqQztBQUEwRDtBQUMvRDs7QUFFRCxXQUFTbTBCLGVBQVQsQ0FBeUJuMEIsRUFBekIsRUFBNkI7QUFDM0IsUUFBSXdILEdBQUcsR0FBR3hILEVBQUUsQ0FBQ3dILEdBQWI7O0FBQ0EsUUFBSUEsR0FBRyxDQUFDeUUsaUJBQUosSUFBeUJqTSxFQUFFLENBQUNvTSxPQUFILENBQVdJLE1BQXhDLEVBQWdEO0FBQUU7QUFBUTs7QUFDMUQsUUFBSXpZLEdBQUcsR0FBRyxDQUFDLElBQUk0RCxJQUFKLEVBQUQsR0FBWXFJLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVzZ2QixRQUFqQztBQUNBLFFBQUkxcEIsT0FBTyxHQUFHa0IsZ0JBQWdCLENBQUM1TCxFQUFELEVBQUt3SCxHQUFHLENBQUN5RSxpQkFBVCxDQUE5QjtBQUNBLFFBQUlvb0IsWUFBWSxHQUFHLEVBQW5CO0FBRUE3c0IsT0FBRyxDQUFDVSxJQUFKLENBQVN3QyxPQUFPLENBQUMxTCxJQUFqQixFQUF1QmxHLElBQUksQ0FBQ0MsR0FBTCxDQUFTeU8sR0FBRyxDQUFDQyxLQUFKLEdBQVlELEdBQUcsQ0FBQ0UsSUFBekIsRUFBK0IxSCxFQUFFLENBQUNvTSxPQUFILENBQVdJLE1BQVgsR0FBb0IsR0FBbkQsQ0FBdkIsRUFBZ0YsVUFBVXhOLElBQVYsRUFBZ0I7QUFDOUYsVUFBSTBMLE9BQU8sQ0FBQzFMLElBQVIsSUFBZ0JnQixFQUFFLENBQUNvTSxPQUFILENBQVdHLFFBQS9CLEVBQXlDO0FBQUU7QUFDekMsWUFBSStuQixTQUFTLEdBQUd0MUIsSUFBSSxDQUFDc00sTUFBckI7QUFDQSxZQUFJTyxVQUFVLEdBQUc3TSxJQUFJLENBQUNDLElBQUwsQ0FBVXpNLE1BQVYsR0FBbUJ3TixFQUFFLENBQUN1RSxPQUFILENBQVd1SCxrQkFBOUIsR0FBbUQ3RyxTQUFTLENBQUN1QyxHQUFHLENBQUN4RCxJQUFMLEVBQVcwRyxPQUFPLENBQUN4RixLQUFuQixDQUE1RCxHQUF3RixJQUF6RztBQUNBLFlBQUlxdkIsV0FBVyxHQUFHOXBCLGFBQWEsQ0FBQ3pLLEVBQUQsRUFBS2hCLElBQUwsRUFBVzBMLE9BQVgsRUFBb0IsSUFBcEIsQ0FBL0I7O0FBQ0EsWUFBSW1CLFVBQUosRUFBZ0I7QUFBRW5CLGlCQUFPLENBQUN4RixLQUFSLEdBQWdCMkcsVUFBaEI7QUFBNkI7O0FBQy9DN00sWUFBSSxDQUFDc00sTUFBTCxHQUFjaXBCLFdBQVcsQ0FBQ2pwQixNQUExQjtBQUNBLFlBQUlrcEIsTUFBTSxHQUFHeDFCLElBQUksQ0FBQ2dOLFlBQWxCO0FBQUEsWUFBZ0N5b0IsTUFBTSxHQUFHRixXQUFXLENBQUNocEIsT0FBckQ7O0FBQ0EsWUFBSWtwQixNQUFKLEVBQVk7QUFBRXoxQixjQUFJLENBQUNnTixZQUFMLEdBQW9CeW9CLE1BQXBCO0FBQTZCLFNBQTNDLE1BQ0ssSUFBSUQsTUFBSixFQUFZO0FBQUV4MUIsY0FBSSxDQUFDZ04sWUFBTCxHQUFvQixJQUFwQjtBQUEyQjs7QUFDOUMsWUFBSTBvQixRQUFRLEdBQUcsQ0FBQ0osU0FBRCxJQUFjQSxTQUFTLENBQUM5aEMsTUFBVixJQUFvQndNLElBQUksQ0FBQ3NNLE1BQUwsQ0FBWTlZLE1BQTlDLElBQ2JnaUMsTUFBTSxJQUFJQyxNQUFWLEtBQXFCLENBQUNELE1BQUQsSUFBVyxDQUFDQyxNQUFaLElBQXNCRCxNQUFNLENBQUNocEIsT0FBUCxJQUFrQmlwQixNQUFNLENBQUNqcEIsT0FBL0MsSUFBMERncEIsTUFBTSxDQUFDL29CLFNBQVAsSUFBb0JncEIsTUFBTSxDQUFDaHBCLFNBQTFHLENBREY7O0FBRUEsYUFBSyxJQUFJaFksQ0FBQyxHQUFHLENBQWIsRUFBZ0IsQ0FBQ2loQyxRQUFELElBQWFqaEMsQ0FBQyxHQUFHNmdDLFNBQVMsQ0FBQzloQyxNQUEzQyxFQUFtRCxFQUFFaUIsQ0FBckQsRUFBd0Q7QUFBRWloQyxrQkFBUSxHQUFHSixTQUFTLENBQUM3Z0MsQ0FBRCxDQUFULElBQWdCdUwsSUFBSSxDQUFDc00sTUFBTCxDQUFZN1gsQ0FBWixDQUEzQjtBQUE0Qzs7QUFDdEcsWUFBSWloQyxRQUFKLEVBQWM7QUFBRUwsc0JBQVksQ0FBQ243QixJQUFiLENBQWtCd1IsT0FBTyxDQUFDMUwsSUFBMUI7QUFBa0M7O0FBQ2xEQSxZQUFJLENBQUMrTSxVQUFMLEdBQWtCckIsT0FBTyxDQUFDSCxJQUFSLEVBQWxCO0FBQ0FHLGVBQU8sQ0FBQ04sUUFBUjtBQUNELE9BZkQsTUFlTztBQUNMLFlBQUlwTCxJQUFJLENBQUNDLElBQUwsQ0FBVXpNLE1BQVYsSUFBb0J3TixFQUFFLENBQUN1RSxPQUFILENBQVd1SCxrQkFBbkMsRUFDRTtBQUFFUSxxQkFBVyxDQUFDdE0sRUFBRCxFQUFLaEIsSUFBSSxDQUFDQyxJQUFWLEVBQWdCeUwsT0FBaEIsQ0FBWDtBQUFzQzs7QUFDMUMxTCxZQUFJLENBQUMrTSxVQUFMLEdBQWtCckIsT0FBTyxDQUFDMUwsSUFBUixHQUFlLENBQWYsSUFBb0IsQ0FBcEIsR0FBd0IwTCxPQUFPLENBQUNILElBQVIsRUFBeEIsR0FBeUMsSUFBM0Q7QUFDQUcsZUFBTyxDQUFDTixRQUFSO0FBQ0Q7O0FBQ0QsVUFBSSxDQUFDLElBQUl6UyxJQUFKLEVBQUQsR0FBWTVELEdBQWhCLEVBQXFCO0FBQ25CMDZCLG1CQUFXLENBQUN6dUIsRUFBRCxFQUFLQSxFQUFFLENBQUN1RSxPQUFILENBQVdvd0IsU0FBaEIsQ0FBWDtBQUNBLGVBQU8sSUFBUDtBQUNEO0FBQ0YsS0ExQkQ7QUEyQkFudEIsT0FBRyxDQUFDeUUsaUJBQUosR0FBd0J2QixPQUFPLENBQUMxTCxJQUFoQztBQUNBd0ksT0FBRyxDQUFDMEUsWUFBSixHQUFtQnBULElBQUksQ0FBQ2dELEdBQUwsQ0FBUzBMLEdBQUcsQ0FBQzBFLFlBQWIsRUFBMkJ4QixPQUFPLENBQUMxTCxJQUFuQyxDQUFuQjs7QUFDQSxRQUFJcTFCLFlBQVksQ0FBQzdoQyxNQUFqQixFQUF5QjtBQUFFc2hDLGFBQU8sQ0FBQzl6QixFQUFELEVBQUssWUFBWTtBQUNqRCxhQUFLLElBQUl2TSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHNGdDLFlBQVksQ0FBQzdoQyxNQUFqQyxFQUF5Q2lCLENBQUMsRUFBMUMsRUFDRTtBQUFFbXpCLHVCQUFhLENBQUM1bUIsRUFBRCxFQUFLcTBCLFlBQVksQ0FBQzVnQyxDQUFELENBQWpCLEVBQXNCLE1BQXRCLENBQWI7QUFBNkM7QUFDbEQsT0FIaUMsQ0FBUDtBQUd0QjtBQUNOLEdBbDVIa0IsQ0FvNUhuQjs7O0FBRUEsTUFBSXEvQixhQUFhLEdBQUcsU0FBaEJBLGFBQWdCLENBQVM5eUIsRUFBVCxFQUFhK3JCLFFBQWIsRUFBdUI2SSxLQUF2QixFQUE4QjtBQUNoRCxRQUFJeG9CLE9BQU8sR0FBR3BNLEVBQUUsQ0FBQ29NLE9BQWpCO0FBRUEsU0FBSzJmLFFBQUwsR0FBZ0JBLFFBQWhCLENBSGdELENBSWhEOztBQUNBLFNBQUs4SSxPQUFMLEdBQWUvSSxZQUFZLENBQUMxZixPQUFELEVBQVVwTSxFQUFFLENBQUN3SCxHQUFiLEVBQWtCdWtCLFFBQWxCLENBQTNCO0FBQ0EsU0FBSytJLGNBQUwsR0FBc0IsQ0FBQzFvQixPQUFPLENBQUNpUSxPQUFSLENBQWdCdGEsV0FBdkM7QUFDQSxTQUFLZ3pCLGFBQUwsR0FBcUIzb0IsT0FBTyxDQUFDaVEsT0FBUixDQUFnQndCLFlBQXJDO0FBQ0EsU0FBS2hDLFlBQUwsR0FBb0J6UCxPQUFPLENBQUNpUSxPQUFSLENBQWdCQyxXQUFwQztBQUNBLFNBQUswWSxlQUFMLEdBQXVCdlgsWUFBWSxDQUFDemQsRUFBRCxDQUFuQztBQUNBLFNBQUs0MEIsS0FBTCxHQUFhQSxLQUFiO0FBQ0EsU0FBSzliLElBQUwsR0FBWW9HLGFBQWEsQ0FBQ2xmLEVBQUQsQ0FBekI7QUFDQSxTQUFLaTFCLE1BQUwsR0FBYyxFQUFkO0FBQ0QsR0FiRDs7QUFlQW5DLGVBQWEsQ0FBQzU4QixTQUFkLENBQXdCMkosTUFBeEIsR0FBaUMsVUFBVVQsT0FBVixFQUFtQi9CLElBQW5CLEVBQXlCO0FBQ3hELFFBQUlxRCxVQUFVLENBQUN0QixPQUFELEVBQVUvQixJQUFWLENBQWQsRUFDRTtBQUFFLFdBQUs0M0IsTUFBTCxDQUFZLzdCLElBQVosQ0FBaUI5QyxTQUFqQjtBQUE4QjtBQUNuQyxHQUhEOztBQUlBMDhCLGVBQWEsQ0FBQzU4QixTQUFkLENBQXdCMjlCLE1BQXhCLEdBQWlDLFlBQVk7QUFDM0MsU0FBSyxJQUFJcGdDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS3doQyxNQUFMLENBQVl6aUMsTUFBaEMsRUFBd0NpQixDQUFDLEVBQXpDLEVBQ0U7QUFBRW9NLFlBQU0sQ0FBQ3hKLEtBQVAsQ0FBYSxJQUFiLEVBQW1CLEtBQUs0K0IsTUFBTCxDQUFZeGhDLENBQVosQ0FBbkI7QUFBcUM7QUFDMUMsR0FIRDs7QUFLQSxXQUFTbS9CLG1CQUFULENBQTZCNXlCLEVBQTdCLEVBQWlDO0FBQy9CLFFBQUlvTSxPQUFPLEdBQUdwTSxFQUFFLENBQUNvTSxPQUFqQjs7QUFDQSxRQUFJLENBQUNBLE9BQU8sQ0FBQzhvQixpQkFBVCxJQUE4QjlvQixPQUFPLENBQUNzUixRQUFSLENBQWlCM2IsV0FBbkQsRUFBZ0U7QUFDOURxSyxhQUFPLENBQUNvUixjQUFSLEdBQXlCcFIsT0FBTyxDQUFDc1IsUUFBUixDQUFpQjNiLFdBQWpCLEdBQStCcUssT0FBTyxDQUFDc1IsUUFBUixDQUFpQnBCLFdBQXpFO0FBQ0FsUSxhQUFPLENBQUNpbEIsWUFBUixDQUFxQmgrQixLQUFyQixDQUEyQmdWLE1BQTNCLEdBQW9Da1YsU0FBUyxDQUFDdmQsRUFBRCxDQUFULEdBQWdCLElBQXBEO0FBQ0FvTSxhQUFPLENBQUNxUSxLQUFSLENBQWNwcEIsS0FBZCxDQUFvQjhoQyxZQUFwQixHQUFtQyxDQUFDL29CLE9BQU8sQ0FBQ29SLGNBQVQsR0FBMEIsSUFBN0Q7QUFDQXBSLGFBQU8sQ0FBQ3FRLEtBQVIsQ0FBY3BwQixLQUFkLENBQW9CK2hDLGdCQUFwQixHQUF1QzdYLFNBQVMsQ0FBQ3ZkLEVBQUQsQ0FBVCxHQUFnQixJQUF2RDtBQUNBb00sYUFBTyxDQUFDOG9CLGlCQUFSLEdBQTRCLElBQTVCO0FBQ0Q7QUFDRjs7QUFFRCxXQUFTRyxpQkFBVCxDQUEyQnIxQixFQUEzQixFQUErQjtBQUM3QixRQUFJQSxFQUFFLENBQUM0cUIsUUFBSCxFQUFKLEVBQW1CO0FBQUUsYUFBTyxJQUFQO0FBQWE7O0FBQ2xDLFFBQUkwSyxNQUFNLEdBQUd2Z0MsU0FBUyxFQUF0Qjs7QUFDQSxRQUFJLENBQUN1Z0MsTUFBRCxJQUFXLENBQUMzZ0MsUUFBUSxDQUFDcUwsRUFBRSxDQUFDb00sT0FBSCxDQUFXc2YsT0FBWixFQUFxQjRKLE1BQXJCLENBQXhCLEVBQXNEO0FBQUUsYUFBTyxJQUFQO0FBQWE7O0FBQ3JFLFFBQUk3eUIsTUFBTSxHQUFHO0FBQUMxTixlQUFTLEVBQUV1Z0M7QUFBWixLQUFiOztBQUNBLFFBQUl4eUIsTUFBTSxDQUFDQyxZQUFYLEVBQXlCO0FBQ3ZCLFVBQUkwa0IsR0FBRyxHQUFHM2tCLE1BQU0sQ0FBQ0MsWUFBUCxFQUFWOztBQUNBLFVBQUkwa0IsR0FBRyxDQUFDOE4sVUFBSixJQUFrQjlOLEdBQUcsQ0FBQytOLE1BQXRCLElBQWdDN2dDLFFBQVEsQ0FBQ3FMLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NmLE9BQVosRUFBcUJqRSxHQUFHLENBQUM4TixVQUF6QixDQUE1QyxFQUFrRjtBQUNoRjl5QixjQUFNLENBQUM4eUIsVUFBUCxHQUFvQjlOLEdBQUcsQ0FBQzhOLFVBQXhCO0FBQ0E5eUIsY0FBTSxDQUFDZ3pCLFlBQVAsR0FBc0JoTyxHQUFHLENBQUNnTyxZQUExQjtBQUNBaHpCLGNBQU0sQ0FBQ2l6QixTQUFQLEdBQW1Cak8sR0FBRyxDQUFDaU8sU0FBdkI7QUFDQWp6QixjQUFNLENBQUNrekIsV0FBUCxHQUFxQmxPLEdBQUcsQ0FBQ2tPLFdBQXpCO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPbHpCLE1BQVA7QUFDRDs7QUFFRCxXQUFTbXpCLGdCQUFULENBQTBCQyxRQUExQixFQUFvQztBQUNsQyxRQUFJLENBQUNBLFFBQUQsSUFBYSxDQUFDQSxRQUFRLENBQUM5Z0MsU0FBdkIsSUFBb0M4Z0MsUUFBUSxDQUFDOWdDLFNBQVQsSUFBc0JBLFNBQVMsRUFBdkUsRUFBMkU7QUFBRTtBQUFROztBQUNyRjhnQyxZQUFRLENBQUM5Z0MsU0FBVCxDQUFtQmcyQixLQUFuQjs7QUFDQSxRQUFJLENBQUMscUJBQXFCOTZCLElBQXJCLENBQTBCNGxDLFFBQVEsQ0FBQzlnQyxTQUFULENBQW1CK2dDLFFBQTdDLENBQUQsSUFDQUQsUUFBUSxDQUFDTixVQURULElBQ3VCNWdDLFFBQVEsQ0FBQ25FLFFBQVEsQ0FBQzRELElBQVYsRUFBZ0J5aEMsUUFBUSxDQUFDTixVQUF6QixDQUQvQixJQUN1RTVnQyxRQUFRLENBQUNuRSxRQUFRLENBQUM0RCxJQUFWLEVBQWdCeWhDLFFBQVEsQ0FBQ0gsU0FBekIsQ0FEbkYsRUFDd0g7QUFDdEgsVUFBSWpPLEdBQUcsR0FBRzNrQixNQUFNLENBQUNDLFlBQVAsRUFBVjtBQUFBLFVBQWlDblAsS0FBSyxHQUFHcEQsUUFBUSxDQUFDcUQsV0FBVCxFQUF6QztBQUNBRCxXQUFLLENBQUNNLE1BQU4sQ0FBYTJoQyxRQUFRLENBQUNOLFVBQXRCLEVBQWtDTSxRQUFRLENBQUNKLFlBQTNDO0FBQ0E3aEMsV0FBSyxDQUFDWSxRQUFOLENBQWUsS0FBZjtBQUNBaXpCLFNBQUcsQ0FBQ3NPLGVBQUo7QUFDQXRPLFNBQUcsQ0FBQ3VPLFFBQUosQ0FBYXBpQyxLQUFiO0FBQ0E2ekIsU0FBRyxDQUFDK04sTUFBSixDQUFXSyxRQUFRLENBQUNILFNBQXBCLEVBQStCRyxRQUFRLENBQUNGLFdBQXhDO0FBQ0Q7QUFDRixHQXQ5SGtCLENBdzlIbkI7QUFDQTtBQUNBOzs7QUFDQSxXQUFTM0MscUJBQVQsQ0FBK0JoekIsRUFBL0IsRUFBbUM4dkIsTUFBbkMsRUFBMkM7QUFDekMsUUFBSTFqQixPQUFPLEdBQUdwTSxFQUFFLENBQUNvTSxPQUFqQjtBQUFBLFFBQTBCNUUsR0FBRyxHQUFHeEgsRUFBRSxDQUFDd0gsR0FBbkM7O0FBRUEsUUFBSXNvQixNQUFNLENBQUNnRixjQUFYLEVBQTJCO0FBQ3pCeE8sZUFBUyxDQUFDdG1CLEVBQUQsQ0FBVDtBQUNBLGFBQU8sS0FBUDtBQUNELEtBTndDLENBUXpDOzs7QUFDQSxRQUFJLENBQUM4dkIsTUFBTSxDQUFDOEUsS0FBUixJQUNBOUUsTUFBTSxDQUFDK0UsT0FBUCxDQUFlejVCLElBQWYsSUFBdUJnUixPQUFPLENBQUNHLFFBRC9CLElBQzJDdWpCLE1BQU0sQ0FBQytFLE9BQVAsQ0FBZXg1QixFQUFmLElBQXFCK1EsT0FBTyxDQUFDSSxNQUR4RSxLQUVDSixPQUFPLENBQUNnYSxpQkFBUixJQUE2QixJQUE3QixJQUFxQ2hhLE9BQU8sQ0FBQ2dhLGlCQUFSLElBQTZCaGEsT0FBTyxDQUFDSSxNQUYzRSxLQUdBSixPQUFPLENBQUM2cEIsWUFBUixJQUF3QjdwQixPQUFPLENBQUN1TCxJQUhoQyxJQUd3Q3FQLGNBQWMsQ0FBQ2huQixFQUFELENBQWQsSUFBc0IsQ0FIbEUsRUFJRTtBQUFFLGFBQU8sS0FBUDtBQUFjOztBQUVsQixRQUFJazJCLDBCQUEwQixDQUFDbDJCLEVBQUQsQ0FBOUIsRUFBb0M7QUFDbENzbUIsZUFBUyxDQUFDdG1CLEVBQUQsQ0FBVDtBQUNBOHZCLFlBQU0sQ0FBQ2hYLElBQVAsR0FBY29HLGFBQWEsQ0FBQ2xmLEVBQUQsQ0FBM0I7QUFDRCxLQWxCd0MsQ0FvQnpDOzs7QUFDQSxRQUFJak0sR0FBRyxHQUFHeVQsR0FBRyxDQUFDQyxLQUFKLEdBQVlELEdBQUcsQ0FBQ0UsSUFBMUI7QUFDQSxRQUFJdE0sSUFBSSxHQUFHdEMsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTZzBCLE1BQU0sQ0FBQytFLE9BQVAsQ0FBZXo1QixJQUFmLEdBQXNCNEUsRUFBRSxDQUFDdUUsT0FBSCxDQUFXNHhCLGNBQTFDLEVBQTBEM3VCLEdBQUcsQ0FBQ0MsS0FBOUQsQ0FBWDtBQUNBLFFBQUlwTSxFQUFFLEdBQUd2QyxJQUFJLENBQUNDLEdBQUwsQ0FBU2hGLEdBQVQsRUFBYys3QixNQUFNLENBQUMrRSxPQUFQLENBQWV4NUIsRUFBZixHQUFvQjJFLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVzR4QixjQUE3QyxDQUFUOztBQUNBLFFBQUkvcEIsT0FBTyxDQUFDRyxRQUFSLEdBQW1CblIsSUFBbkIsSUFBMkJBLElBQUksR0FBR2dSLE9BQU8sQ0FBQ0csUUFBZixHQUEwQixFQUF6RCxFQUE2RDtBQUFFblIsVUFBSSxHQUFHdEMsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTMEwsR0FBRyxDQUFDQyxLQUFiLEVBQW9CMkUsT0FBTyxDQUFDRyxRQUE1QixDQUFQO0FBQStDOztBQUM5RyxRQUFJSCxPQUFPLENBQUNJLE1BQVIsR0FBaUJuUixFQUFqQixJQUF1QitRLE9BQU8sQ0FBQ0ksTUFBUixHQUFpQm5SLEVBQWpCLEdBQXNCLEVBQWpELEVBQXFEO0FBQUVBLFFBQUUsR0FBR3ZDLElBQUksQ0FBQ0MsR0FBTCxDQUFTaEYsR0FBVCxFQUFjcVksT0FBTyxDQUFDSSxNQUF0QixDQUFMO0FBQXFDOztBQUM1RixRQUFJeUIsaUJBQUosRUFBdUI7QUFDckI3UyxVQUFJLEdBQUdxWCxZQUFZLENBQUN6UyxFQUFFLENBQUN3SCxHQUFKLEVBQVNwTSxJQUFULENBQW5CO0FBQ0FDLFFBQUUsR0FBR3VYLGVBQWUsQ0FBQzVTLEVBQUUsQ0FBQ3dILEdBQUosRUFBU25NLEVBQVQsQ0FBcEI7QUFDRDs7QUFFRCxRQUFJKzZCLFNBQVMsR0FBR2g3QixJQUFJLElBQUlnUixPQUFPLENBQUNHLFFBQWhCLElBQTRCbFIsRUFBRSxJQUFJK1EsT0FBTyxDQUFDSSxNQUExQyxJQUNkSixPQUFPLENBQUNpcUIsY0FBUixJQUEwQnZHLE1BQU0sQ0FBQ2lGLGFBRG5CLElBQ29DM29CLE9BQU8sQ0FBQ2txQixhQUFSLElBQXlCeEcsTUFBTSxDQUFDalUsWUFEcEY7QUFFQWtMLGNBQVUsQ0FBQy9tQixFQUFELEVBQUs1RSxJQUFMLEVBQVdDLEVBQVgsQ0FBVjtBQUVBK1EsV0FBTyxDQUFDZ1csVUFBUixHQUFxQm5QLGFBQVksQ0FBQzFMLE9BQU8sQ0FBQ3ZILEVBQUUsQ0FBQ3dILEdBQUosRUFBUzRFLE9BQU8sQ0FBQ0csUUFBakIsQ0FBUixDQUFqQyxDQW5DeUMsQ0FvQ3pDOztBQUNBdk0sTUFBRSxDQUFDb00sT0FBSCxDQUFXc1EsS0FBWCxDQUFpQnJwQixLQUFqQixDQUF1Qm1yQixHQUF2QixHQUE2QnBTLE9BQU8sQ0FBQ2dXLFVBQVIsR0FBcUIsSUFBbEQ7QUFFQSxRQUFJbVUsUUFBUSxHQUFHdlAsY0FBYyxDQUFDaG5CLEVBQUQsQ0FBN0I7O0FBQ0EsUUFBSSxDQUFDbzJCLFNBQUQsSUFBY0csUUFBUSxJQUFJLENBQTFCLElBQStCLENBQUN6RyxNQUFNLENBQUM4RSxLQUF2QyxJQUFnRHhvQixPQUFPLENBQUM2cEIsWUFBUixJQUF3QjdwQixPQUFPLENBQUN1TCxJQUFoRixLQUNDdkwsT0FBTyxDQUFDZ2EsaUJBQVIsSUFBNkIsSUFBN0IsSUFBcUNoYSxPQUFPLENBQUNnYSxpQkFBUixJQUE2QmhhLE9BQU8sQ0FBQ0ksTUFEM0UsQ0FBSixFQUVFO0FBQUUsYUFBTyxLQUFQO0FBQWMsS0ExQ3VCLENBNEN6QztBQUNBOzs7QUFDQSxRQUFJZ3FCLFdBQVcsR0FBR25CLGlCQUFpQixDQUFDcjFCLEVBQUQsQ0FBbkM7O0FBQ0EsUUFBSXUyQixRQUFRLEdBQUcsQ0FBZixFQUFrQjtBQUFFbnFCLGFBQU8sQ0FBQ3NmLE9BQVIsQ0FBZ0JyNEIsS0FBaEIsQ0FBc0IrWSxPQUF0QixHQUFnQyxNQUFoQztBQUF5Qzs7QUFDN0RxcUIsZ0JBQVksQ0FBQ3oyQixFQUFELEVBQUtvTSxPQUFPLENBQUNnYSxpQkFBYixFQUFnQzBKLE1BQU0sQ0FBQ2hYLElBQXZDLENBQVo7O0FBQ0EsUUFBSXlkLFFBQVEsR0FBRyxDQUFmLEVBQWtCO0FBQUVucUIsYUFBTyxDQUFDc2YsT0FBUixDQUFnQnI0QixLQUFoQixDQUFzQitZLE9BQXRCLEdBQWdDLEVBQWhDO0FBQXFDOztBQUN6REEsV0FBTyxDQUFDNnBCLFlBQVIsR0FBdUI3cEIsT0FBTyxDQUFDdUwsSUFBL0IsQ0FsRHlDLENBbUR6QztBQUNBOztBQUNBaWUsb0JBQWdCLENBQUNZLFdBQUQsQ0FBaEIsQ0FyRHlDLENBdUR6QztBQUNBOztBQUNBL2pDLGtCQUFjLENBQUMyWixPQUFPLENBQUNvZSxTQUFULENBQWQ7QUFDQS8zQixrQkFBYyxDQUFDMlosT0FBTyxDQUFDc3FCLFlBQVQsQ0FBZDtBQUNBdHFCLFdBQU8sQ0FBQ2dRLE9BQVIsQ0FBZ0Ivb0IsS0FBaEIsQ0FBc0JnVixNQUF0QixHQUErQitELE9BQU8sQ0FBQ3FRLEtBQVIsQ0FBY3BwQixLQUFkLENBQW9CdThCLFNBQXBCLEdBQWdDLENBQS9EOztBQUVBLFFBQUl3RyxTQUFKLEVBQWU7QUFDYmhxQixhQUFPLENBQUNpcUIsY0FBUixHQUF5QnZHLE1BQU0sQ0FBQ2lGLGFBQWhDO0FBQ0Ezb0IsYUFBTyxDQUFDa3FCLGFBQVIsR0FBd0J4RyxNQUFNLENBQUNqVSxZQUEvQjtBQUNBNFMsaUJBQVcsQ0FBQ3p1QixFQUFELEVBQUssR0FBTCxDQUFYO0FBQ0Q7O0FBRURvTSxXQUFPLENBQUNnYSxpQkFBUixHQUE0QixJQUE1QjtBQUVBLFdBQU8sSUFBUDtBQUNEOztBQUVELFdBQVNtTixpQkFBVCxDQUEyQnZ6QixFQUEzQixFQUErQjh2QixNQUEvQixFQUF1QztBQUNyQyxRQUFJL0QsUUFBUSxHQUFHK0QsTUFBTSxDQUFDL0QsUUFBdEI7O0FBRUEsU0FBSyxJQUFJdGtCLEtBQUssR0FBRyxJQUFqQixHQUF3QkEsS0FBSyxHQUFHLEtBQWhDLEVBQXVDO0FBQ3JDLFVBQUksQ0FBQ0EsS0FBRCxJQUFVLENBQUN6SCxFQUFFLENBQUN1RSxPQUFILENBQVcyWixZQUF0QixJQUFzQzRSLE1BQU0sQ0FBQ2tGLGVBQVAsSUFBMEJ2WCxZQUFZLENBQUN6ZCxFQUFELENBQWhGLEVBQXNGO0FBQ3BGO0FBQ0EsWUFBSStyQixRQUFRLElBQUlBLFFBQVEsQ0FBQ3ZOLEdBQVQsSUFBZ0IsSUFBaEMsRUFDRTtBQUFFdU4sa0JBQVEsR0FBRztBQUFDdk4sZUFBRyxFQUFFMWxCLElBQUksQ0FBQ0MsR0FBTCxDQUFTaUgsRUFBRSxDQUFDd0gsR0FBSCxDQUFPYSxNQUFQLEdBQWdCeVUsV0FBVyxDQUFDOWMsRUFBRSxDQUFDb00sT0FBSixDQUEzQixHQUEwQ3dSLGFBQWEsQ0FBQzVkLEVBQUQsQ0FBaEUsRUFBc0UrckIsUUFBUSxDQUFDdk4sR0FBL0U7QUFBTixXQUFYO0FBQXdHLFNBSHhCLENBSXBGO0FBQ0E7OztBQUNBc1IsY0FBTSxDQUFDK0UsT0FBUCxHQUFpQi9JLFlBQVksQ0FBQzlyQixFQUFFLENBQUNvTSxPQUFKLEVBQWFwTSxFQUFFLENBQUN3SCxHQUFoQixFQUFxQnVrQixRQUFyQixDQUE3Qjs7QUFDQSxZQUFJK0QsTUFBTSxDQUFDK0UsT0FBUCxDQUFlejVCLElBQWYsSUFBdUI0RSxFQUFFLENBQUNvTSxPQUFILENBQVdHLFFBQWxDLElBQThDdWpCLE1BQU0sQ0FBQytFLE9BQVAsQ0FBZXg1QixFQUFmLElBQXFCMkUsRUFBRSxDQUFDb00sT0FBSCxDQUFXSSxNQUFsRixFQUNFO0FBQUU7QUFBTztBQUNaLE9BVEQsTUFTTyxJQUFJL0UsS0FBSixFQUFXO0FBQ2hCcW9CLGNBQU0sQ0FBQytFLE9BQVAsR0FBaUIvSSxZQUFZLENBQUM5ckIsRUFBRSxDQUFDb00sT0FBSixFQUFhcE0sRUFBRSxDQUFDd0gsR0FBaEIsRUFBcUJ1a0IsUUFBckIsQ0FBN0I7QUFDRDs7QUFDRCxVQUFJLENBQUNpSCxxQkFBcUIsQ0FBQ2h6QixFQUFELEVBQUs4dkIsTUFBTCxDQUExQixFQUF3QztBQUFFO0FBQU87O0FBQ2pEdEUsNkJBQXVCLENBQUN4ckIsRUFBRCxDQUF2QjtBQUNBLFVBQUlpekIsVUFBVSxHQUFHakUsb0JBQW9CLENBQUNodkIsRUFBRCxDQUFyQztBQUNBa25CLHFCQUFlLENBQUNsbkIsRUFBRCxDQUFmO0FBQ0Erd0Isc0JBQWdCLENBQUMvd0IsRUFBRCxFQUFLaXpCLFVBQUwsQ0FBaEI7QUFDQUssdUJBQWlCLENBQUN0ekIsRUFBRCxFQUFLaXpCLFVBQUwsQ0FBakI7QUFDQW5ELFlBQU0sQ0FBQzhFLEtBQVAsR0FBZSxLQUFmO0FBQ0Q7O0FBRUQ5RSxVQUFNLENBQUNqd0IsTUFBUCxDQUFjRyxFQUFkLEVBQWtCLFFBQWxCLEVBQTRCQSxFQUE1Qjs7QUFDQSxRQUFJQSxFQUFFLENBQUNvTSxPQUFILENBQVdHLFFBQVgsSUFBdUJ2TSxFQUFFLENBQUNvTSxPQUFILENBQVd1cUIsZ0JBQWxDLElBQXNEMzJCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV0ksTUFBWCxJQUFxQnhNLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3dxQixjQUExRixFQUEwRztBQUN4RzlHLFlBQU0sQ0FBQ2p3QixNQUFQLENBQWNHLEVBQWQsRUFBa0IsZ0JBQWxCLEVBQW9DQSxFQUFwQyxFQUF3Q0EsRUFBRSxDQUFDb00sT0FBSCxDQUFXRyxRQUFuRCxFQUE2RHZNLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV0ksTUFBeEU7QUFDQXhNLFFBQUUsQ0FBQ29NLE9BQUgsQ0FBV3VxQixnQkFBWCxHQUE4QjMyQixFQUFFLENBQUNvTSxPQUFILENBQVdHLFFBQXpDO0FBQW1Edk0sUUFBRSxDQUFDb00sT0FBSCxDQUFXd3FCLGNBQVgsR0FBNEI1MkIsRUFBRSxDQUFDb00sT0FBSCxDQUFXSSxNQUF2QztBQUNwRDtBQUNGOztBQUVELFdBQVMraEIsbUJBQVQsQ0FBNkJ2dUIsRUFBN0IsRUFBaUMrckIsUUFBakMsRUFBMkM7QUFDekMsUUFBSStELE1BQU0sR0FBRyxJQUFJZ0QsYUFBSixDQUFrQjl5QixFQUFsQixFQUFzQityQixRQUF0QixDQUFiOztBQUNBLFFBQUlpSCxxQkFBcUIsQ0FBQ2h6QixFQUFELEVBQUs4dkIsTUFBTCxDQUF6QixFQUF1QztBQUNyQ3RFLDZCQUF1QixDQUFDeHJCLEVBQUQsQ0FBdkI7QUFDQXV6Qix1QkFBaUIsQ0FBQ3Z6QixFQUFELEVBQUs4dkIsTUFBTCxDQUFqQjtBQUNBLFVBQUltRCxVQUFVLEdBQUdqRSxvQkFBb0IsQ0FBQ2h2QixFQUFELENBQXJDO0FBQ0FrbkIscUJBQWUsQ0FBQ2xuQixFQUFELENBQWY7QUFDQSt3QixzQkFBZ0IsQ0FBQy93QixFQUFELEVBQUtpekIsVUFBTCxDQUFoQjtBQUNBSyx1QkFBaUIsQ0FBQ3R6QixFQUFELEVBQUtpekIsVUFBTCxDQUFqQjtBQUNBbkQsWUFBTSxDQUFDK0QsTUFBUDtBQUNEO0FBQ0YsR0E5a0lrQixDQWdsSW5CO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFTNEMsWUFBVCxDQUFzQnoyQixFQUF0QixFQUEwQjYyQixpQkFBMUIsRUFBNkMvZCxJQUE3QyxFQUFtRDtBQUNqRCxRQUFJMU0sT0FBTyxHQUFHcE0sRUFBRSxDQUFDb00sT0FBakI7QUFBQSxRQUEwQmtPLFdBQVcsR0FBR3RhLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVytWLFdBQW5EO0FBQ0EsUUFBSXdjLFNBQVMsR0FBRzFxQixPQUFPLENBQUNzZixPQUF4QjtBQUFBLFFBQWlDdnZCLEdBQUcsR0FBRzI2QixTQUFTLENBQUNoa0MsVUFBakQ7O0FBRUEsYUFBU2lrQyxFQUFULENBQVk3a0MsSUFBWixFQUFrQjtBQUNoQixVQUFJaVUsSUFBSSxHQUFHalUsSUFBSSxDQUFDK29CLFdBQWhCLENBRGdCLENBRWhCOztBQUNBLFVBQUl2cUIsTUFBTSxJQUFJWSxHQUFWLElBQWlCME8sRUFBRSxDQUFDb00sT0FBSCxDQUFXNHFCLGtCQUFYLElBQWlDOWtDLElBQXRELEVBQ0U7QUFBRUEsWUFBSSxDQUFDbUIsS0FBTCxDQUFXK1ksT0FBWCxHQUFxQixNQUFyQjtBQUE4QixPQURsQyxNQUdFO0FBQUVsYSxZQUFJLENBQUNxQyxVQUFMLENBQWdCMUIsV0FBaEIsQ0FBNEJYLElBQTVCO0FBQW9DOztBQUN4QyxhQUFPaVUsSUFBUDtBQUNEOztBQUVELFFBQUl3UixJQUFJLEdBQUd2TCxPQUFPLENBQUN1TCxJQUFuQjtBQUFBLFFBQXlCakYsS0FBSyxHQUFHdEcsT0FBTyxDQUFDRyxRQUF6QyxDQWRpRCxDQWVqRDtBQUNBOztBQUNBLFNBQUssSUFBSTlZLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdra0IsSUFBSSxDQUFDbmxCLE1BQXpCLEVBQWlDaUIsQ0FBQyxFQUFsQyxFQUFzQztBQUNwQyxVQUFJMGdCLFFBQVEsR0FBR3dELElBQUksQ0FBQ2xrQixDQUFELENBQW5CO0FBQ0EsVUFBSTBnQixRQUFRLENBQUNxRCxNQUFiLEVBQXFCLENBQXJCLEtBQTRCLElBQUksQ0FBQ3JELFFBQVEsQ0FBQ2ppQixJQUFWLElBQWtCaWlCLFFBQVEsQ0FBQ2ppQixJQUFULENBQWNxQyxVQUFkLElBQTRCdWlDLFNBQWxELEVBQTZEO0FBQUU7QUFDekYsWUFBSTVrQyxJQUFJLEdBQUdpcEIsZ0JBQWdCLENBQUNuYixFQUFELEVBQUttVSxRQUFMLEVBQWV6QixLQUFmLEVBQXNCb0csSUFBdEIsQ0FBM0I7QUFDQWdlLGlCQUFTLENBQUNwZCxZQUFWLENBQXVCeG5CLElBQXZCLEVBQTZCaUssR0FBN0I7QUFDRCxPQUgyQixNQUdyQjtBQUFFO0FBQ1AsZUFBT0EsR0FBRyxJQUFJZ1ksUUFBUSxDQUFDamlCLElBQXZCLEVBQTZCO0FBQUVpSyxhQUFHLEdBQUc0NkIsRUFBRSxDQUFDNTZCLEdBQUQsQ0FBUjtBQUFnQjs7QUFDL0MsWUFBSTg2QixZQUFZLEdBQUczYyxXQUFXLElBQUl1YyxpQkFBaUIsSUFBSSxJQUFwQyxJQUNqQkEsaUJBQWlCLElBQUlua0IsS0FESixJQUNheUIsUUFBUSxDQUFDc0csVUFEekM7O0FBRUEsWUFBSXRHLFFBQVEsQ0FBQzRFLE9BQWIsRUFBc0I7QUFDcEIsY0FBSTNoQixPQUFPLENBQUMrYyxRQUFRLENBQUM0RSxPQUFWLEVBQW1CLFFBQW5CLENBQVAsR0FBc0MsQ0FBQyxDQUEzQyxFQUE4QztBQUFFa2Usd0JBQVksR0FBRyxLQUFmO0FBQXVCOztBQUN2RXBlLDhCQUFvQixDQUFDN1ksRUFBRCxFQUFLbVUsUUFBTCxFQUFlekIsS0FBZixFQUFzQm9HLElBQXRCLENBQXBCO0FBQ0Q7O0FBQ0QsWUFBSW1lLFlBQUosRUFBa0I7QUFDaEJ4a0Msd0JBQWMsQ0FBQzBoQixRQUFRLENBQUNzRyxVQUFWLENBQWQ7QUFDQXRHLGtCQUFRLENBQUNzRyxVQUFULENBQW9CeG5CLFdBQXBCLENBQWdDekMsUUFBUSxDQUFDZ0QsY0FBVCxDQUF3QnNWLGFBQWEsQ0FBQzlJLEVBQUUsQ0FBQ3VFLE9BQUosRUFBYW1PLEtBQWIsQ0FBckMsQ0FBaEM7QUFDRDs7QUFDRHZXLFdBQUcsR0FBR2dZLFFBQVEsQ0FBQ2ppQixJQUFULENBQWMrb0IsV0FBcEI7QUFDRDtBQUNEdkksV0FBSyxJQUFJeUIsUUFBUSxDQUFDek0sSUFBbEI7QUFDRDs7QUFDRCxXQUFPdkwsR0FBUCxFQUFZO0FBQUVBLFNBQUcsR0FBRzQ2QixFQUFFLENBQUM1NkIsR0FBRCxDQUFSO0FBQWdCO0FBQy9COztBQUVELFdBQVMrNkIsaUJBQVQsQ0FBMkI5cUIsT0FBM0IsRUFBb0M7QUFDbEMsUUFBSXdQLEtBQUssR0FBR3hQLE9BQU8sQ0FBQ2dRLE9BQVIsQ0FBZ0JyYSxXQUE1QjtBQUNBcUssV0FBTyxDQUFDcVEsS0FBUixDQUFjcHBCLEtBQWQsQ0FBb0I0b0IsVUFBcEIsR0FBaUNMLEtBQUssR0FBRyxJQUF6QztBQUNEOztBQUVELFdBQVMwWCxpQkFBVCxDQUEyQnR6QixFQUEzQixFQUErQjZCLE9BQS9CLEVBQXdDO0FBQ3RDN0IsTUFBRSxDQUFDb00sT0FBSCxDQUFXcVEsS0FBWCxDQUFpQnBwQixLQUFqQixDQUF1QnU4QixTQUF2QixHQUFtQy90QixPQUFPLENBQUN5dEIsU0FBUixHQUFvQixJQUF2RDtBQUNBdHZCLE1BQUUsQ0FBQ29NLE9BQUgsQ0FBV2lsQixZQUFYLENBQXdCaCtCLEtBQXhCLENBQThCbXJCLEdBQTlCLEdBQW9DM2MsT0FBTyxDQUFDeXRCLFNBQVIsR0FBb0IsSUFBeEQ7QUFDQXR2QixNQUFFLENBQUNvTSxPQUFILENBQVdnUSxPQUFYLENBQW1CL29CLEtBQW5CLENBQXlCZ1YsTUFBekIsR0FBbUN4RyxPQUFPLENBQUN5dEIsU0FBUixHQUFvQnR2QixFQUFFLENBQUNvTSxPQUFILENBQVcwUixTQUEvQixHQUEyQ1AsU0FBUyxDQUFDdmQsRUFBRCxDQUFyRCxHQUE2RCxJQUEvRjtBQUNELEdBdG9Ja0IsQ0F3b0luQjtBQUNBOzs7QUFDQSxXQUFTK3VCLGlCQUFULENBQTJCL3VCLEVBQTNCLEVBQStCO0FBQzdCLFFBQUlvTSxPQUFPLEdBQUdwTSxFQUFFLENBQUNvTSxPQUFqQjtBQUFBLFFBQTBCdUwsSUFBSSxHQUFHdkwsT0FBTyxDQUFDdUwsSUFBekM7O0FBQ0EsUUFBSSxDQUFDdkwsT0FBTyxDQUFDK3FCLFlBQVQsS0FBMEIsQ0FBQy9xQixPQUFPLENBQUNnUSxPQUFSLENBQWdCdHBCLFVBQWpCLElBQStCLENBQUNrTixFQUFFLENBQUN1RSxPQUFILENBQVcyVixXQUFyRSxDQUFKLEVBQXVGO0FBQUU7QUFBUTs7QUFDakcsUUFBSWtkLElBQUksR0FBR2pTLG9CQUFvQixDQUFDL1ksT0FBRCxDQUFwQixHQUFnQ0EsT0FBTyxDQUFDc1IsUUFBUixDQUFpQmlFLFVBQWpELEdBQThEM2hCLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT21hLFVBQWhGO0FBQ0EsUUFBSXNOLE9BQU8sR0FBRzdpQixPQUFPLENBQUNnUSxPQUFSLENBQWdCcmEsV0FBOUI7QUFBQSxRQUEyQ08sSUFBSSxHQUFHODBCLElBQUksR0FBRyxJQUF6RDs7QUFDQSxTQUFLLElBQUkzakMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2trQixJQUFJLENBQUNubEIsTUFBekIsRUFBaUNpQixDQUFDLEVBQWxDLEVBQXNDO0FBQUUsVUFBSSxDQUFDa2tCLElBQUksQ0FBQ2xrQixDQUFELENBQUosQ0FBUStqQixNQUFiLEVBQXFCO0FBQzNELFlBQUl4WCxFQUFFLENBQUN1RSxPQUFILENBQVcyVixXQUFmLEVBQTRCO0FBQzFCLGNBQUl2QyxJQUFJLENBQUNsa0IsQ0FBRCxDQUFKLENBQVFzbUIsTUFBWixFQUNFO0FBQUVwQyxnQkFBSSxDQUFDbGtCLENBQUQsQ0FBSixDQUFRc21CLE1BQVIsQ0FBZTFtQixLQUFmLENBQXFCaVAsSUFBckIsR0FBNEJBLElBQTVCO0FBQW1DOztBQUN2QyxjQUFJcVYsSUFBSSxDQUFDbGtCLENBQUQsQ0FBSixDQUFRdW1CLGdCQUFaLEVBQ0U7QUFBRXJDLGdCQUFJLENBQUNsa0IsQ0FBRCxDQUFKLENBQVF1bUIsZ0JBQVIsQ0FBeUIzbUIsS0FBekIsQ0FBK0JpUCxJQUEvQixHQUFzQ0EsSUFBdEM7QUFBNkM7QUFDbEQ7O0FBQ0QsWUFBSSswQixLQUFLLEdBQUcxZixJQUFJLENBQUNsa0IsQ0FBRCxDQUFKLENBQVFzbkIsU0FBcEI7O0FBQ0EsWUFBSXNjLEtBQUosRUFBVztBQUFFLGVBQUssSUFBSXY1QixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdTVCLEtBQUssQ0FBQzdrQyxNQUExQixFQUFrQ3NMLENBQUMsRUFBbkMsRUFDWDtBQUFFdTVCLGlCQUFLLENBQUN2NUIsQ0FBRCxDQUFMLENBQVN6SyxLQUFULENBQWVpUCxJQUFmLEdBQXNCQSxJQUF0QjtBQUE2QjtBQUFFO0FBQ3BDO0FBQUU7O0FBQ0gsUUFBSXRDLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVzJWLFdBQWYsRUFDRTtBQUFFOU4sYUFBTyxDQUFDZ1EsT0FBUixDQUFnQi9vQixLQUFoQixDQUFzQmlQLElBQXRCLEdBQThCODBCLElBQUksR0FBR25JLE9BQVIsR0FBbUIsSUFBaEQ7QUFBdUQ7QUFDNUQsR0E1cElrQixDQThwSW5CO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU2lILDBCQUFULENBQW9DbDJCLEVBQXBDLEVBQXdDO0FBQ3RDLFFBQUksQ0FBQ0EsRUFBRSxDQUFDdUUsT0FBSCxDQUFXK1YsV0FBaEIsRUFBNkI7QUFBRSxhQUFPLEtBQVA7QUFBYzs7QUFDN0MsUUFBSTlTLEdBQUcsR0FBR3hILEVBQUUsQ0FBQ3dILEdBQWI7QUFBQSxRQUFrQm1DLElBQUksR0FBR2IsYUFBYSxDQUFDOUksRUFBRSxDQUFDdUUsT0FBSixFQUFhaUQsR0FBRyxDQUFDQyxLQUFKLEdBQVlELEdBQUcsQ0FBQ0UsSUFBaEIsR0FBdUIsQ0FBcEMsQ0FBdEM7QUFBQSxRQUE4RTBFLE9BQU8sR0FBR3BNLEVBQUUsQ0FBQ29NLE9BQTNGOztBQUNBLFFBQUl6QyxJQUFJLENBQUNuWCxNQUFMLElBQWU0WixPQUFPLENBQUNtVixZQUEzQixFQUF5QztBQUN2QyxVQUFJdHhCLElBQUksR0FBR21jLE9BQU8sQ0FBQ3ZLLE9BQVIsQ0FBZ0I1TyxXQUFoQixDQUE0QkMsR0FBRyxDQUFDLEtBQUQsRUFBUSxDQUFDQSxHQUFHLENBQUMsS0FBRCxFQUFReVcsSUFBUixDQUFKLENBQVIsRUFDQyw2Q0FERCxDQUEvQixDQUFYO0FBRUEsVUFBSTJ0QixNQUFNLEdBQUdybkMsSUFBSSxDQUFDNkMsVUFBTCxDQUFnQmlQLFdBQTdCO0FBQUEsVUFBMEN1bUIsT0FBTyxHQUFHcjRCLElBQUksQ0FBQzhSLFdBQUwsR0FBbUJ1MUIsTUFBdkU7QUFDQWxyQixhQUFPLENBQUNtckIsVUFBUixDQUFtQmxrQyxLQUFuQixDQUF5QnVvQixLQUF6QixHQUFpQyxFQUFqQztBQUNBeFAsYUFBTyxDQUFDdU8saUJBQVIsR0FBNEI3aEIsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTdzdCLE1BQVQsRUFBaUJsckIsT0FBTyxDQUFDbXJCLFVBQVIsQ0FBbUJ4MUIsV0FBbkIsR0FBaUN1bUIsT0FBbEQsSUFBNkQsQ0FBekY7QUFDQWxjLGFBQU8sQ0FBQ29yQixZQUFSLEdBQXVCcHJCLE9BQU8sQ0FBQ3VPLGlCQUFSLEdBQTRCMk4sT0FBbkQ7QUFDQWxjLGFBQU8sQ0FBQ21WLFlBQVIsR0FBdUJuVixPQUFPLENBQUN1TyxpQkFBUixHQUE0QmhSLElBQUksQ0FBQ25YLE1BQWpDLEdBQTBDLENBQUMsQ0FBbEU7QUFDQTRaLGFBQU8sQ0FBQ21yQixVQUFSLENBQW1CbGtDLEtBQW5CLENBQXlCdW9CLEtBQXpCLEdBQWlDeFAsT0FBTyxDQUFDb3JCLFlBQVIsR0FBdUIsSUFBeEQ7QUFDQU4sdUJBQWlCLENBQUNsM0IsRUFBRSxDQUFDb00sT0FBSixDQUFqQjtBQUNBLGFBQU8sSUFBUDtBQUNEOztBQUNELFdBQU8sS0FBUDtBQUNEOztBQUVELFdBQVNxckIsVUFBVCxDQUFvQnJiLE9BQXBCLEVBQTZCOUIsV0FBN0IsRUFBMEM7QUFDeEMsUUFBSTdYLE1BQU0sR0FBRyxFQUFiO0FBQUEsUUFBaUJpMUIsY0FBYyxHQUFHLEtBQWxDOztBQUNBLFNBQUssSUFBSWprQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMm9CLE9BQU8sQ0FBQzVwQixNQUE1QixFQUFvQ2lCLENBQUMsRUFBckMsRUFBeUM7QUFDdkMsVUFBSXNRLElBQUksR0FBR3FZLE9BQU8sQ0FBQzNvQixDQUFELENBQWxCO0FBQUEsVUFBdUJKLEtBQUssR0FBRyxJQUEvQjs7QUFDQSxVQUFJLE9BQU8wUSxJQUFQLElBQWUsUUFBbkIsRUFBNkI7QUFBRTFRLGFBQUssR0FBRzBRLElBQUksQ0FBQzFRLEtBQWI7QUFBb0IwUSxZQUFJLEdBQUdBLElBQUksQ0FBQzNSLFNBQVo7QUFBd0I7O0FBQzNFLFVBQUkyUixJQUFJLElBQUksd0JBQVosRUFBc0M7QUFDcEMsWUFBSSxDQUFDdVcsV0FBTCxFQUFrQjtBQUFFO0FBQVUsU0FBOUIsTUFDSztBQUFFb2Qsd0JBQWMsR0FBRyxJQUFqQjtBQUF3QjtBQUNoQzs7QUFDRGoxQixZQUFNLENBQUN2SixJQUFQLENBQVk7QUFBQzlHLGlCQUFTLEVBQUUyUixJQUFaO0FBQWtCMVEsYUFBSyxFQUFFQTtBQUF6QixPQUFaO0FBQ0Q7O0FBQ0QsUUFBSWluQixXQUFXLElBQUksQ0FBQ29kLGNBQXBCLEVBQW9DO0FBQUVqMUIsWUFBTSxDQUFDdkosSUFBUCxDQUFZO0FBQUM5RyxpQkFBUyxFQUFFLHdCQUFaO0FBQXNDaUIsYUFBSyxFQUFFO0FBQTdDLE9BQVo7QUFBa0U7O0FBQ3hHLFdBQU9vUCxNQUFQO0FBQ0QsR0Foc0lrQixDQWtzSW5CO0FBQ0E7OztBQUNBLFdBQVNrMUIsYUFBVCxDQUF1QnZyQixPQUF2QixFQUFnQztBQUM5QixRQUFJZ1EsT0FBTyxHQUFHaFEsT0FBTyxDQUFDZ1EsT0FBdEI7QUFBQSxRQUErQndiLEtBQUssR0FBR3hyQixPQUFPLENBQUN5TyxXQUEvQztBQUNBcG9CLGtCQUFjLENBQUMycEIsT0FBRCxDQUFkO0FBQ0FoUSxXQUFPLENBQUNtckIsVUFBUixHQUFxQixJQUFyQjs7QUFDQSxTQUFLLElBQUk5akMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR21rQyxLQUFLLENBQUNwbEMsTUFBMUIsRUFBa0MsRUFBRWlCLENBQXBDLEVBQXVDO0FBQ3JDLFVBQUlpeEIsR0FBRyxHQUFHa1QsS0FBSyxDQUFDbmtDLENBQUQsQ0FBZjtBQUNBLFVBQUlyQixTQUFTLEdBQUdzeUIsR0FBRyxDQUFDdHlCLFNBQXBCO0FBQ0EsVUFBSWlCLEtBQUssR0FBR3F4QixHQUFHLENBQUNyeEIsS0FBaEI7QUFDQSxVQUFJd2tDLElBQUksR0FBR3piLE9BQU8sQ0FBQ25wQixXQUFSLENBQW9CQyxHQUFHLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYyx1QkFBdUJkLFNBQXJDLENBQXZCLENBQVg7O0FBQ0EsVUFBSWlCLEtBQUosRUFBVztBQUFFd2tDLFlBQUksQ0FBQ3hrQyxLQUFMLENBQVdFLE9BQVgsR0FBcUJGLEtBQXJCO0FBQTZCOztBQUMxQyxVQUFJakIsU0FBUyxJQUFJLHdCQUFqQixFQUEyQztBQUN6Q2dhLGVBQU8sQ0FBQ21yQixVQUFSLEdBQXFCTSxJQUFyQjtBQUNBQSxZQUFJLENBQUN4a0MsS0FBTCxDQUFXdW9CLEtBQVgsR0FBbUIsQ0FBQ3hQLE9BQU8sQ0FBQ29yQixZQUFSLElBQXdCLENBQXpCLElBQThCLElBQWpEO0FBQ0Q7QUFDRjs7QUFDRHBiLFdBQU8sQ0FBQy9vQixLQUFSLENBQWMrWSxPQUFkLEdBQXdCd3JCLEtBQUssQ0FBQ3BsQyxNQUFOLEdBQWUsRUFBZixHQUFvQixNQUE1QztBQUNBMGtDLHFCQUFpQixDQUFDOXFCLE9BQUQsQ0FBakI7QUFDRDs7QUFFRCxXQUFTMHJCLGFBQVQsQ0FBdUI5M0IsRUFBdkIsRUFBMkI7QUFDekIyM0IsaUJBQWEsQ0FBQzMzQixFQUFFLENBQUNvTSxPQUFKLENBQWI7QUFDQThaLGFBQVMsQ0FBQ2xtQixFQUFELENBQVQ7QUFDQSt1QixxQkFBaUIsQ0FBQy91QixFQUFELENBQWpCO0FBQ0QsR0EzdElrQixDQTZ0SW5CO0FBQ0E7QUFDQTs7O0FBRUEsV0FBUyszQixPQUFULENBQWlCNVgsS0FBakIsRUFBd0IzWSxHQUF4QixFQUE2QmtQLEtBQTdCLEVBQW9DblMsT0FBcEMsRUFBNkM7QUFDM0MsUUFBSThPLENBQUMsR0FBRyxJQUFSO0FBQ0EsU0FBS3FELEtBQUwsR0FBYUEsS0FBYixDQUYyQyxDQUkzQzs7QUFDQXJELEtBQUMsQ0FBQ2tlLGVBQUYsR0FBb0JyK0IsR0FBRyxDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMsNkJBQWQsQ0FBdkI7QUFDQW1nQixLQUFDLENBQUNrZSxlQUFGLENBQWtCNTlCLFlBQWxCLENBQStCLGdCQUEvQixFQUFpRCxNQUFqRCxFQU4yQyxDQU8zQztBQUNBOztBQUNBMGYsS0FBQyxDQUFDb2UsWUFBRixHQUFpQnYrQixHQUFHLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYywwQkFBZCxDQUFwQjtBQUNBbWdCLEtBQUMsQ0FBQ29lLFlBQUYsQ0FBZTk5QixZQUFmLENBQTRCLGdCQUE1QixFQUE4QyxNQUE5QyxFQVYyQyxDQVczQzs7QUFDQTBmLEtBQUMsQ0FBQ3FZLE9BQUYsR0FBWWg0QixJQUFJLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYyxpQkFBZCxDQUFoQixDQVoyQyxDQWEzQzs7QUFDQTJmLEtBQUMsQ0FBQ3FqQixZQUFGLEdBQWlCeGpDLEdBQUcsQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjLElBQWQsRUFBb0IsZ0NBQXBCLENBQXBCO0FBQ0FtZ0IsS0FBQyxDQUFDbVgsU0FBRixHQUFjdDNCLEdBQUcsQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjLG9CQUFkLENBQWpCLENBZjJDLENBZ0IzQzs7QUFDQW1nQixLQUFDLENBQUN4UixPQUFGLEdBQVkzTyxHQUFHLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYyxvQkFBZCxDQUFmLENBakIyQyxDQWtCM0M7O0FBQ0FtZ0IsS0FBQyxDQUFDc0wsV0FBRixHQUFnQnpyQixHQUFHLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYyxvQkFBZCxDQUFuQixDQW5CMkMsQ0FvQjNDOztBQUNBbWdCLEtBQUMsQ0FBQ3VKLFNBQUYsR0FBY2xwQixJQUFJLENBQUMsS0FBRCxFQUFRLENBQUMyZixDQUFDLENBQUN4UixPQUFILEVBQVl3UixDQUFDLENBQUNzTCxXQUFkLEVBQTJCdEwsQ0FBQyxDQUFDcWpCLFlBQTdCLEVBQTJDcmpCLENBQUMsQ0FBQ21YLFNBQTdDLEVBQXdEblgsQ0FBQyxDQUFDcVksT0FBMUQsQ0FBUixFQUNBLElBREEsRUFDTSxtQ0FETixDQUFsQjtBQUVBLFFBQUk3akIsS0FBSyxHQUFHblUsSUFBSSxDQUFDLEtBQUQsRUFBUSxDQUFDMmYsQ0FBQyxDQUFDdUosU0FBSCxDQUFSLEVBQXVCLGtCQUF2QixDQUFoQixDQXZCMkMsQ0F3QjNDOztBQUNBdkosS0FBQyxDQUFDcUosS0FBRixHQUFVeHBCLEdBQUcsQ0FBQyxLQUFELEVBQVEsQ0FBQzJVLEtBQUQsQ0FBUixFQUFpQixJQUFqQixFQUF1QixvQkFBdkIsQ0FBYixDQXpCMkMsQ0EwQjNDOztBQUNBd0wsS0FBQyxDQUFDb0osS0FBRixHQUFVdnBCLEdBQUcsQ0FBQyxLQUFELEVBQVEsQ0FBQ21nQixDQUFDLENBQUNxSixLQUFILENBQVIsRUFBbUIsa0JBQW5CLENBQWI7QUFDQXJKLEtBQUMsQ0FBQ29WLFVBQUYsR0FBZSxJQUFmLENBNUIyQyxDQTZCM0M7QUFDQTtBQUNBOztBQUNBcFYsS0FBQyxDQUFDZ2UsWUFBRixHQUFpQm4rQixHQUFHLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYyxJQUFkLEVBQW9CLGlDQUFpQytFLFdBQWpDLEdBQStDLGlCQUFuRSxDQUFwQixDQWhDMkMsQ0FpQzNDOztBQUNBb2IsS0FBQyxDQUFDK0ksT0FBRixHQUFZbHBCLEdBQUcsQ0FBQyxLQUFELEVBQVEsSUFBUixFQUFjLG9CQUFkLENBQWY7QUFDQW1nQixLQUFDLENBQUNra0IsVUFBRixHQUFlLElBQWYsQ0FuQzJDLENBb0MzQzs7QUFDQWxrQixLQUFDLENBQUNxSyxRQUFGLEdBQWF4cUIsR0FBRyxDQUFDLEtBQUQsRUFBUSxDQUFDbWdCLENBQUMsQ0FBQ29KLEtBQUgsRUFBVXBKLENBQUMsQ0FBQ2dlLFlBQVosRUFBMEJoZSxDQUFDLENBQUMrSSxPQUE1QixDQUFSLEVBQThDLG1CQUE5QyxDQUFoQjtBQUNBL0ksS0FBQyxDQUFDcUssUUFBRixDQUFXL3BCLFlBQVgsQ0FBd0IsVUFBeEIsRUFBb0MsSUFBcEMsRUF0QzJDLENBdUMzQzs7QUFDQTBmLEtBQUMsQ0FBQ2dKLE9BQUYsR0FBWW5wQixHQUFHLENBQUMsS0FBRCxFQUFRLENBQUNtZ0IsQ0FBQyxDQUFDa2UsZUFBSCxFQUFvQmxlLENBQUMsQ0FBQ29lLFlBQXRCLEVBQW9DcGUsQ0FBQyxDQUFDcUssUUFBdEMsQ0FBUixFQUF5RCxZQUF6RCxDQUFmLENBeEMyQyxDQTBDM0M7O0FBQ0EsUUFBSXB0QixFQUFFLElBQUlDLFVBQVUsR0FBRyxDQUF2QixFQUEwQjtBQUFFOGlCLE9BQUMsQ0FBQytJLE9BQUYsQ0FBVS9vQixLQUFWLENBQWdCaW1CLE1BQWhCLEdBQXlCLENBQUMsQ0FBMUI7QUFBNkJqRyxPQUFDLENBQUNxSyxRQUFGLENBQVdycUIsS0FBWCxDQUFpQmdxQixZQUFqQixHQUFnQyxDQUFoQztBQUFvQzs7QUFDN0YsUUFBSSxDQUFDM3NCLE1BQUQsSUFBVyxFQUFFVixLQUFLLElBQUlxQixNQUFYLENBQWYsRUFBbUM7QUFBRWdpQixPQUFDLENBQUNxSyxRQUFGLENBQVdzYSxTQUFYLEdBQXVCLElBQXZCO0FBQThCOztBQUVuRSxRQUFJN1gsS0FBSixFQUFXO0FBQ1QsVUFBSUEsS0FBSyxDQUFDbHRCLFdBQVYsRUFBdUI7QUFBRWt0QixhQUFLLENBQUNsdEIsV0FBTixDQUFrQm9nQixDQUFDLENBQUNnSixPQUFwQjtBQUErQixPQUF4RCxNQUNLO0FBQUU4RCxhQUFLLENBQUM5TSxDQUFDLENBQUNnSixPQUFILENBQUw7QUFBbUI7QUFDM0IsS0FqRDBDLENBbUQzQzs7O0FBQ0FoSixLQUFDLENBQUM5RyxRQUFGLEdBQWE4RyxDQUFDLENBQUM3RyxNQUFGLEdBQVdoRixHQUFHLENBQUNDLEtBQTVCO0FBQ0E0TCxLQUFDLENBQUNzakIsZ0JBQUYsR0FBcUJ0akIsQ0FBQyxDQUFDdWpCLGNBQUYsR0FBbUJwdkIsR0FBRyxDQUFDQyxLQUE1QyxDQXJEMkMsQ0FzRDNDOztBQUNBNEwsS0FBQyxDQUFDc0UsSUFBRixHQUFTLEVBQVQ7QUFDQXRFLEtBQUMsQ0FBQzRpQixZQUFGLEdBQWlCLElBQWpCLENBeEQyQyxDQXlEM0M7QUFDQTs7QUFDQTVpQixLQUFDLENBQUN5QixnQkFBRixHQUFxQixJQUFyQixDQTNEMkMsQ0E0RDNDOztBQUNBekIsS0FBQyxDQUFDK08sVUFBRixHQUFlLENBQWY7QUFDQS9PLEtBQUMsQ0FBQ2dqQixjQUFGLEdBQW1CaGpCLENBQUMsQ0FBQ2lqQixhQUFGLEdBQWtCLENBQXJDO0FBQ0FqakIsS0FBQyxDQUFDK1MsaUJBQUYsR0FBc0IsSUFBdEI7QUFFQS9TLEtBQUMsQ0FBQ21LLGNBQUYsR0FBbUJuSyxDQUFDLENBQUN5SyxTQUFGLEdBQWN6SyxDQUFDLENBQUNzSyxRQUFGLEdBQWEsQ0FBOUM7QUFDQXRLLEtBQUMsQ0FBQzZoQixpQkFBRixHQUFzQixLQUF0QixDQWxFMkMsQ0FvRTNDO0FBQ0E7O0FBQ0E3aEIsS0FBQyxDQUFDbWtCLFlBQUYsR0FBaUJua0IsQ0FBQyxDQUFDc0gsaUJBQUYsR0FBc0J0SCxDQUFDLENBQUNrTyxZQUFGLEdBQWlCLElBQXhELENBdEUyQyxDQXVFM0M7QUFDQTtBQUNBOztBQUNBbE8sS0FBQyxDQUFDOGpCLFlBQUYsR0FBaUIsS0FBakI7QUFFQTlqQixLQUFDLENBQUNnTyxlQUFGLEdBQW9CaE8sQ0FBQyxDQUFDaU8sZ0JBQUYsR0FBcUJqTyxDQUFDLENBQUMySixjQUFGLEdBQW1CLElBQTVELENBNUUyQyxDQThFM0M7QUFDQTs7QUFDQTNKLEtBQUMsQ0FBQ0MsT0FBRixHQUFZLElBQVo7QUFDQUQsS0FBQyxDQUFDRSxhQUFGLEdBQWtCLENBQWxCO0FBQ0FGLEtBQUMsQ0FBQ0csY0FBRixHQUFtQixLQUFuQixDQWxGMkMsQ0FvRjNDOztBQUNBSCxLQUFDLENBQUM0a0IsT0FBRixHQUFZNWtCLENBQUMsQ0FBQzZrQixPQUFGLEdBQVk3a0IsQ0FBQyxDQUFDbWdCLFdBQUYsR0FBZ0JuZ0IsQ0FBQyxDQUFDb2dCLFdBQUYsR0FBZ0IsSUFBeEQsQ0FyRjJDLENBdUYzQzs7QUFDQXBnQixLQUFDLENBQUNrWSxLQUFGLEdBQVUsS0FBVixDQXhGMkMsQ0EwRjNDO0FBQ0E7O0FBQ0FsWSxLQUFDLENBQUMrWCxpQkFBRixHQUFzQixJQUF0QjtBQUVBL1gsS0FBQyxDQUFDOGtCLFdBQUYsR0FBZ0IsSUFBaEI7QUFFQTlrQixLQUFDLENBQUN3SCxXQUFGLEdBQWdCNGMsVUFBVSxDQUFDbHpCLE9BQU8sQ0FBQzZYLE9BQVQsRUFBa0I3WCxPQUFPLENBQUMrVixXQUExQixDQUExQjtBQUNBcWQsaUJBQWEsQ0FBQ3RrQixDQUFELENBQWI7QUFFQXFELFNBQUssQ0FBQzBoQixJQUFOLENBQVcva0IsQ0FBWDtBQUNELEdBcjBJa0IsQ0F1MEluQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUEsTUFBSWdsQixZQUFZLEdBQUcsQ0FBbkI7QUFBQSxNQUFzQkMsa0JBQWtCLEdBQUcsSUFBM0MsQ0FsMUltQixDQW0xSW5CO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE1BQUlob0MsRUFBSixFQUFRO0FBQUVnb0Msc0JBQWtCLEdBQUcsQ0FBQyxHQUF0QjtBQUE0QixHQUF0QyxNQUNLLElBQUl0b0MsS0FBSixFQUFXO0FBQUVzb0Msc0JBQWtCLEdBQUcsRUFBckI7QUFBMEIsR0FBdkMsTUFDQSxJQUFJMW5DLE1BQUosRUFBWTtBQUFFMG5DLHNCQUFrQixHQUFHLENBQUMsRUFBdEI7QUFBMkIsR0FBekMsTUFDQSxJQUFJeG5DLE1BQUosRUFBWTtBQUFFd25DLHNCQUFrQixHQUFHLENBQUMsQ0FBRCxHQUFHLENBQXhCO0FBQTRCOztBQUUvQyxXQUFTQyxlQUFULENBQXlCN2xDLENBQXpCLEVBQTRCO0FBQzFCLFFBQUk4bEMsRUFBRSxHQUFHOWxDLENBQUMsQ0FBQytsQyxXQUFYO0FBQUEsUUFBd0JDLEVBQUUsR0FBR2htQyxDQUFDLENBQUNpbUMsV0FBL0I7O0FBQ0EsUUFBSUgsRUFBRSxJQUFJLElBQU4sSUFBYzlsQyxDQUFDLENBQUNrbUMsTUFBaEIsSUFBMEJsbUMsQ0FBQyxDQUFDbS9CLElBQUYsSUFBVW4vQixDQUFDLENBQUNtbUMsZUFBMUMsRUFBMkQ7QUFBRUwsUUFBRSxHQUFHOWxDLENBQUMsQ0FBQ2ttQyxNQUFQO0FBQWdCOztBQUM3RSxRQUFJRixFQUFFLElBQUksSUFBTixJQUFjaG1DLENBQUMsQ0FBQ2ttQyxNQUFoQixJQUEwQmxtQyxDQUFDLENBQUNtL0IsSUFBRixJQUFVbi9CLENBQUMsQ0FBQ29tQyxhQUExQyxFQUF5RDtBQUFFSixRQUFFLEdBQUdobUMsQ0FBQyxDQUFDa21DLE1BQVA7QUFBZ0IsS0FBM0UsTUFDSyxJQUFJRixFQUFFLElBQUksSUFBVixFQUFnQjtBQUFFQSxRQUFFLEdBQUdobUMsQ0FBQyxDQUFDcW1DLFVBQVA7QUFBb0I7O0FBQzNDLFdBQU87QUFBQ3p2QixPQUFDLEVBQUVrdkIsRUFBSjtBQUFRaFYsT0FBQyxFQUFFa1Y7QUFBWCxLQUFQO0FBQ0Q7O0FBQ0QsV0FBU00sZ0JBQVQsQ0FBMEJ0bUMsQ0FBMUIsRUFBNkI7QUFDM0IsUUFBSXVtQyxLQUFLLEdBQUdWLGVBQWUsQ0FBQzdsQyxDQUFELENBQTNCO0FBQ0F1bUMsU0FBSyxDQUFDM3ZCLENBQU4sSUFBV2d2QixrQkFBWDtBQUNBVyxTQUFLLENBQUN6VixDQUFOLElBQVc4VSxrQkFBWDtBQUNBLFdBQU9XLEtBQVA7QUFDRDs7QUFFRCxXQUFTQyxhQUFULENBQXVCbDVCLEVBQXZCLEVBQTJCdE4sQ0FBM0IsRUFBOEI7QUFDNUIsUUFBSXVtQyxLQUFLLEdBQUdWLGVBQWUsQ0FBQzdsQyxDQUFELENBQTNCO0FBQUEsUUFBZ0M4bEMsRUFBRSxHQUFHUyxLQUFLLENBQUMzdkIsQ0FBM0M7QUFBQSxRQUE4Q292QixFQUFFLEdBQUdPLEtBQUssQ0FBQ3pWLENBQXpEO0FBRUEsUUFBSXBYLE9BQU8sR0FBR3BNLEVBQUUsQ0FBQ29NLE9BQWpCO0FBQUEsUUFBMEIvVCxNQUFNLEdBQUcrVCxPQUFPLENBQUNzUixRQUEzQyxDQUg0QixDQUk1Qjs7QUFDQSxRQUFJeWIsVUFBVSxHQUFHOWdDLE1BQU0sQ0FBQ3kyQixXQUFQLEdBQXFCejJCLE1BQU0sQ0FBQ2lrQixXQUE3QztBQUNBLFFBQUk4YyxVQUFVLEdBQUcvZ0MsTUFBTSxDQUFDczJCLFlBQVAsR0FBc0J0MkIsTUFBTSxDQUFDd2xCLFlBQTlDOztBQUNBLFFBQUksRUFBRTJhLEVBQUUsSUFBSVcsVUFBTixJQUFvQlQsRUFBRSxJQUFJVSxVQUE1QixDQUFKLEVBQTZDO0FBQUU7QUFBUSxLQVAzQixDQVM1QjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsUUFBSVYsRUFBRSxJQUFJcG5DLEdBQU4sSUFBYVosTUFBakIsRUFBeUI7QUFDdkJpWSxXQUFLLEVBQUUsS0FBSyxJQUFJeE0sR0FBRyxHQUFHekosQ0FBQyxDQUFDOEQsTUFBWixFQUFvQm1oQixJQUFJLEdBQUd2TCxPQUFPLENBQUN1TCxJQUF4QyxFQUE4Q3hiLEdBQUcsSUFBSTlELE1BQXJELEVBQTZEOEQsR0FBRyxHQUFHQSxHQUFHLENBQUM1SCxVQUF2RSxFQUFtRjtBQUN4RixhQUFLLElBQUlkLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdra0IsSUFBSSxDQUFDbmxCLE1BQXpCLEVBQWlDaUIsQ0FBQyxFQUFsQyxFQUFzQztBQUNwQyxjQUFJa2tCLElBQUksQ0FBQ2xrQixDQUFELENBQUosQ0FBUXZCLElBQVIsSUFBZ0JpSyxHQUFwQixFQUF5QjtBQUN2QjZELGNBQUUsQ0FBQ29NLE9BQUgsQ0FBVzRxQixrQkFBWCxHQUFnQzc2QixHQUFoQztBQUNBLGtCQUFNd00sS0FBTjtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEtBdEIyQixDQXdCNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxRQUFJNnZCLEVBQUUsSUFBSSxDQUFDeG9DLEtBQVAsSUFBZ0IsQ0FBQ2EsTUFBakIsSUFBMkJ5bkMsa0JBQWtCLElBQUksSUFBckQsRUFBMkQ7QUFDekQsVUFBSUksRUFBRSxJQUFJVSxVQUFWLEVBQ0U7QUFBRW5NLHVCQUFlLENBQUNqdEIsRUFBRCxFQUFLbEgsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTLENBQVQsRUFBWXpELE1BQU0sQ0FBQzBwQixTQUFQLEdBQW1CMlcsRUFBRSxHQUFHSixrQkFBcEMsQ0FBTCxDQUFmO0FBQStFOztBQUNuRnBMLG1CQUFhLENBQUNsdEIsRUFBRCxFQUFLbEgsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTLENBQVQsRUFBWXpELE1BQU0sQ0FBQ3NwQixVQUFQLEdBQW9CNlcsRUFBRSxHQUFHRixrQkFBckMsQ0FBTCxDQUFiLENBSHlELENBSXpEO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFVBQUksQ0FBQ0ksRUFBRCxJQUFRQSxFQUFFLElBQUlVLFVBQWxCLEVBQ0U7QUFBRXY0Qix3QkFBZ0IsQ0FBQ25PLENBQUQsQ0FBaEI7QUFBc0I7O0FBQzFCMFosYUFBTyxDQUFDb25CLFdBQVIsR0FBc0IsSUFBdEIsQ0FWeUQsQ0FVN0I7O0FBQzVCO0FBQ0QsS0ExQzJCLENBNEM1QjtBQUNBOzs7QUFDQSxRQUFJa0YsRUFBRSxJQUFJSixrQkFBa0IsSUFBSSxJQUFoQyxFQUFzQztBQUNwQyxVQUFJZSxNQUFNLEdBQUdYLEVBQUUsR0FBR0osa0JBQWxCO0FBQ0EsVUFBSTlaLEdBQUcsR0FBR3hlLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT3VhLFNBQWpCO0FBQUEsVUFBNEJ2QixHQUFHLEdBQUdoQyxHQUFHLEdBQUdwUyxPQUFPLENBQUNpUSxPQUFSLENBQWdCd0IsWUFBeEQ7O0FBQ0EsVUFBSXdiLE1BQU0sR0FBRyxDQUFiLEVBQWdCO0FBQUU3YSxXQUFHLEdBQUcxbEIsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTLENBQVQsRUFBWTBpQixHQUFHLEdBQUc2YSxNQUFOLEdBQWUsRUFBM0IsQ0FBTjtBQUF1QyxPQUF6RCxNQUNLO0FBQUU3WSxXQUFHLEdBQUcxbkIsSUFBSSxDQUFDQyxHQUFMLENBQVNpSCxFQUFFLENBQUN3SCxHQUFILENBQU9hLE1BQWhCLEVBQXdCbVksR0FBRyxHQUFHNlksTUFBTixHQUFlLEVBQXZDLENBQU47QUFBbUQ7O0FBQzFEOUsseUJBQW1CLENBQUN2dUIsRUFBRCxFQUFLO0FBQUN3ZSxXQUFHLEVBQUVBLEdBQU47QUFBV0QsY0FBTSxFQUFFaUM7QUFBbkIsT0FBTCxDQUFuQjtBQUNEOztBQUVELFFBQUk2WCxZQUFZLEdBQUcsRUFBbkIsRUFBdUI7QUFDckIsVUFBSWpzQixPQUFPLENBQUNvbkIsV0FBUixJQUF1QixJQUEzQixFQUFpQztBQUMvQnBuQixlQUFPLENBQUNvbkIsV0FBUixHQUFzQm43QixNQUFNLENBQUNzcEIsVUFBN0I7QUFBeUN2VixlQUFPLENBQUNxbkIsV0FBUixHQUFzQnA3QixNQUFNLENBQUMwcEIsU0FBN0I7QUFDekMzVixlQUFPLENBQUM2ckIsT0FBUixHQUFrQk8sRUFBbEI7QUFBc0Jwc0IsZUFBTyxDQUFDOHJCLE9BQVIsR0FBa0JRLEVBQWxCO0FBQ3RCOWdDLGtCQUFVLENBQUMsWUFBWTtBQUNyQixjQUFJd1UsT0FBTyxDQUFDb25CLFdBQVIsSUFBdUIsSUFBM0IsRUFBaUM7QUFBRTtBQUFROztBQUMzQyxjQUFJOEYsTUFBTSxHQUFHamhDLE1BQU0sQ0FBQ3NwQixVQUFQLEdBQW9CdlYsT0FBTyxDQUFDb25CLFdBQXpDO0FBQ0EsY0FBSStGLE1BQU0sR0FBR2xoQyxNQUFNLENBQUMwcEIsU0FBUCxHQUFtQjNWLE9BQU8sQ0FBQ3FuQixXQUF4QztBQUNBLGNBQUkrRixNQUFNLEdBQUlELE1BQU0sSUFBSW50QixPQUFPLENBQUM4ckIsT0FBbEIsSUFBNkJxQixNQUFNLEdBQUdudEIsT0FBTyxDQUFDOHJCLE9BQS9DLElBQ1ZvQixNQUFNLElBQUlsdEIsT0FBTyxDQUFDNnJCLE9BQWxCLElBQTZCcUIsTUFBTSxHQUFHbHRCLE9BQU8sQ0FBQzZyQixPQURqRDtBQUVBN3JCLGlCQUFPLENBQUNvbkIsV0FBUixHQUFzQnBuQixPQUFPLENBQUNxbkIsV0FBUixHQUFzQixJQUE1Qzs7QUFDQSxjQUFJLENBQUMrRixNQUFMLEVBQWE7QUFBRTtBQUFROztBQUN2QmxCLDRCQUFrQixHQUFHLENBQUNBLGtCQUFrQixHQUFHRCxZQUFyQixHQUFvQ21CLE1BQXJDLEtBQWdEbkIsWUFBWSxHQUFHLENBQS9ELENBQXJCO0FBQ0EsWUFBRUEsWUFBRjtBQUNELFNBVlMsRUFVUCxHQVZPLENBQVY7QUFXRCxPQWRELE1BY087QUFDTGpzQixlQUFPLENBQUM2ckIsT0FBUixJQUFtQk8sRUFBbkI7QUFBdUJwc0IsZUFBTyxDQUFDOHJCLE9BQVIsSUFBbUJRLEVBQW5CO0FBQ3hCO0FBQ0Y7QUFDRixHQW43SWtCLENBcTdJbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBSWUsU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBUy9SLE1BQVQsRUFBaUJDLFNBQWpCLEVBQTRCO0FBQzFDLFNBQUtELE1BQUwsR0FBY0EsTUFBZDtBQUNBLFNBQUtDLFNBQUwsR0FBaUJBLFNBQWpCO0FBQ0QsR0FIRDs7QUFLQThSLFdBQVMsQ0FBQ3ZqQyxTQUFWLENBQW9CbXhCLE9BQXBCLEdBQThCLFlBQVk7QUFBRSxXQUFPLEtBQUtLLE1BQUwsQ0FBWSxLQUFLQyxTQUFqQixDQUFQO0FBQW9DLEdBQWhGOztBQUVBOFIsV0FBUyxDQUFDdmpDLFNBQVYsQ0FBb0J3akMsTUFBcEIsR0FBNkIsVUFBVXhXLEtBQVYsRUFBaUI7QUFDNUMsUUFBSUEsS0FBSyxJQUFJLElBQWIsRUFBbUI7QUFBRSxhQUFPLElBQVA7QUFBYTs7QUFDbEMsUUFBSUEsS0FBSyxDQUFDeUUsU0FBTixJQUFtQixLQUFLQSxTQUF4QixJQUFxQ3pFLEtBQUssQ0FBQ3dFLE1BQU4sQ0FBYWwxQixNQUFiLElBQXVCLEtBQUtrMUIsTUFBTCxDQUFZbDFCLE1BQTVFLEVBQW9GO0FBQUUsYUFBTyxLQUFQO0FBQWM7O0FBQ3BHLFNBQUssSUFBSWlCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS2kwQixNQUFMLENBQVlsMUIsTUFBaEMsRUFBd0NpQixDQUFDLEVBQXpDLEVBQTZDO0FBQzNDLFVBQUlrbUMsSUFBSSxHQUFHLEtBQUtqUyxNQUFMLENBQVlqMEIsQ0FBWixDQUFYO0FBQUEsVUFBMkJtbUMsS0FBSyxHQUFHMVcsS0FBSyxDQUFDd0UsTUFBTixDQUFhajBCLENBQWIsQ0FBbkM7O0FBQ0EsVUFBSSxDQUFDMlYsY0FBYyxDQUFDdXdCLElBQUksQ0FBQzNVLE1BQU4sRUFBYzRVLEtBQUssQ0FBQzVVLE1BQXBCLENBQWYsSUFBOEMsQ0FBQzViLGNBQWMsQ0FBQ3V3QixJQUFJLENBQUM1UixJQUFOLEVBQVk2UixLQUFLLENBQUM3UixJQUFsQixDQUFqRSxFQUEwRjtBQUFFLGVBQU8sS0FBUDtBQUFjO0FBQzNHOztBQUNELFdBQU8sSUFBUDtBQUNELEdBUkQ7O0FBVUEwUixXQUFTLENBQUN2akMsU0FBVixDQUFvQjJqQyxRQUFwQixHQUErQixZQUFZO0FBQ3pDLFFBQUl2Z0MsR0FBRyxHQUFHLEVBQVY7O0FBQ0EsU0FBSyxJQUFJN0YsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLaTBCLE1BQUwsQ0FBWWwxQixNQUFoQyxFQUF3Q2lCLENBQUMsRUFBekMsRUFDRTtBQUFFNkYsU0FBRyxDQUFDN0YsQ0FBRCxDQUFILEdBQVMsSUFBSXFtQyxLQUFKLENBQVV6d0IsT0FBTyxDQUFDLEtBQUtxZSxNQUFMLENBQVlqMEIsQ0FBWixFQUFldXhCLE1BQWhCLENBQWpCLEVBQTBDM2IsT0FBTyxDQUFDLEtBQUtxZSxNQUFMLENBQVlqMEIsQ0FBWixFQUFlczBCLElBQWhCLENBQWpELENBQVQ7QUFBbUY7O0FBQ3ZGLFdBQU8sSUFBSTBSLFNBQUosQ0FBY25nQyxHQUFkLEVBQW1CLEtBQUtxdUIsU0FBeEIsQ0FBUDtBQUNELEdBTEQ7O0FBT0E4UixXQUFTLENBQUN2akMsU0FBVixDQUFvQjZqQyxpQkFBcEIsR0FBd0MsWUFBWTtBQUNsRCxTQUFLLElBQUl0bUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLaTBCLE1BQUwsQ0FBWWwxQixNQUFoQyxFQUF3Q2lCLENBQUMsRUFBekMsRUFDRTtBQUFFLFVBQUksQ0FBQyxLQUFLaTBCLE1BQUwsQ0FBWWowQixDQUFaLEVBQWVtMEIsS0FBZixFQUFMLEVBQTZCO0FBQUUsZUFBTyxJQUFQO0FBQWE7QUFBRTs7QUFDbEQsV0FBTyxLQUFQO0FBQ0QsR0FKRDs7QUFNQTZSLFdBQVMsQ0FBQ3ZqQyxTQUFWLENBQW9CdkIsUUFBcEIsR0FBK0IsVUFBVWdFLEdBQVYsRUFBZTVFLEdBQWYsRUFBb0I7QUFDakQsUUFBSSxDQUFDQSxHQUFMLEVBQVU7QUFBRUEsU0FBRyxHQUFHNEUsR0FBTjtBQUFZOztBQUN4QixTQUFLLElBQUlsRixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtpMEIsTUFBTCxDQUFZbDFCLE1BQWhDLEVBQXdDaUIsQ0FBQyxFQUF6QyxFQUE2QztBQUMzQyxVQUFJRyxLQUFLLEdBQUcsS0FBSzh6QixNQUFMLENBQVlqMEIsQ0FBWixDQUFaOztBQUNBLFVBQUkwVixHQUFHLENBQUNwVixHQUFELEVBQU1ILEtBQUssQ0FBQ3dILElBQU4sRUFBTixDQUFILElBQTBCLENBQTFCLElBQStCK04sR0FBRyxDQUFDeFEsR0FBRCxFQUFNL0UsS0FBSyxDQUFDeUgsRUFBTixFQUFOLENBQUgsSUFBd0IsQ0FBM0QsRUFDRTtBQUFFLGVBQU81SCxDQUFQO0FBQVU7QUFDZjs7QUFDRCxXQUFPLENBQUMsQ0FBUjtBQUNELEdBUkQ7O0FBVUEsTUFBSXFtQyxLQUFLLEdBQUcsU0FBUkEsS0FBUSxDQUFTOVUsTUFBVCxFQUFpQitDLElBQWpCLEVBQXVCO0FBQ2pDLFNBQUsvQyxNQUFMLEdBQWNBLE1BQWQ7QUFBc0IsU0FBSytDLElBQUwsR0FBWUEsSUFBWjtBQUN2QixHQUZEOztBQUlBK1IsT0FBSyxDQUFDNWpDLFNBQU4sQ0FBZ0JrRixJQUFoQixHQUF1QixZQUFZO0FBQUUsV0FBT29PLE1BQU0sQ0FBQyxLQUFLd2IsTUFBTixFQUFjLEtBQUsrQyxJQUFuQixDQUFiO0FBQXVDLEdBQTVFOztBQUNBK1IsT0FBSyxDQUFDNWpDLFNBQU4sQ0FBZ0JtRixFQUFoQixHQUFxQixZQUFZO0FBQUUsV0FBT2tPLE1BQU0sQ0FBQyxLQUFLeWIsTUFBTixFQUFjLEtBQUsrQyxJQUFuQixDQUFiO0FBQXVDLEdBQTFFOztBQUNBK1IsT0FBSyxDQUFDNWpDLFNBQU4sQ0FBZ0IweEIsS0FBaEIsR0FBd0IsWUFBWTtBQUFFLFdBQU8sS0FBS0csSUFBTCxDQUFVL29CLElBQVYsSUFBa0IsS0FBS2dtQixNQUFMLENBQVlobUIsSUFBOUIsSUFBc0MsS0FBSytvQixJQUFMLENBQVUzdEIsRUFBVixJQUFnQixLQUFLNHFCLE1BQUwsQ0FBWTVxQixFQUF6RTtBQUE2RSxHQUFuSCxDQXgrSW1CLENBMCtJbkI7QUFDQTtBQUNBOzs7QUFDQSxXQUFTNC9CLGtCQUFULENBQTRCaDZCLEVBQTVCLEVBQWdDMG5CLE1BQWhDLEVBQXdDQyxTQUF4QyxFQUFtRDtBQUNqRCxRQUFJc1MsUUFBUSxHQUFHajZCLEVBQUUsSUFBSUEsRUFBRSxDQUFDdUUsT0FBSCxDQUFXMjFCLGtCQUFoQztBQUNBLFFBQUlDLElBQUksR0FBR3pTLE1BQU0sQ0FBQ0MsU0FBRCxDQUFqQjtBQUNBRCxVQUFNLENBQUMwUyxJQUFQLENBQVksVUFBVWhsQyxDQUFWLEVBQWFDLENBQWIsRUFBZ0I7QUFBRSxhQUFPOFQsR0FBRyxDQUFDL1QsQ0FBQyxDQUFDZ0csSUFBRixFQUFELEVBQVcvRixDQUFDLENBQUMrRixJQUFGLEVBQVgsQ0FBVjtBQUFpQyxLQUEvRDtBQUNBdXNCLGFBQVMsR0FBR3Z3QixPQUFPLENBQUNzd0IsTUFBRCxFQUFTeVMsSUFBVCxDQUFuQjs7QUFDQSxTQUFLLElBQUkxbUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2kwQixNQUFNLENBQUNsMUIsTUFBM0IsRUFBbUNpQixDQUFDLEVBQXBDLEVBQXdDO0FBQ3RDLFVBQUkwSSxHQUFHLEdBQUd1ckIsTUFBTSxDQUFDajBCLENBQUQsQ0FBaEI7QUFBQSxVQUFxQjJKLElBQUksR0FBR3NxQixNQUFNLENBQUNqMEIsQ0FBQyxHQUFHLENBQUwsQ0FBbEM7QUFDQSxVQUFJNlUsSUFBSSxHQUFHYSxHQUFHLENBQUMvTCxJQUFJLENBQUMvQixFQUFMLEVBQUQsRUFBWWMsR0FBRyxDQUFDZixJQUFKLEVBQVosQ0FBZDs7QUFDQSxVQUFJNitCLFFBQVEsSUFBSSxDQUFDOTlCLEdBQUcsQ0FBQ3lyQixLQUFKLEVBQWIsR0FBMkJ0ZixJQUFJLEdBQUcsQ0FBbEMsR0FBc0NBLElBQUksSUFBSSxDQUFsRCxFQUFxRDtBQUNuRCxZQUFJbE4sSUFBSSxHQUFHb08sTUFBTSxDQUFDcE0sSUFBSSxDQUFDaEMsSUFBTCxFQUFELEVBQWNlLEdBQUcsQ0FBQ2YsSUFBSixFQUFkLENBQWpCO0FBQUEsWUFBNENDLEVBQUUsR0FBR2tPLE1BQU0sQ0FBQ25NLElBQUksQ0FBQy9CLEVBQUwsRUFBRCxFQUFZYyxHQUFHLENBQUNkLEVBQUosRUFBWixDQUF2RDtBQUNBLFlBQUlnL0IsR0FBRyxHQUFHajlCLElBQUksQ0FBQ3dxQixLQUFMLEtBQWV6ckIsR0FBRyxDQUFDZixJQUFKLE1BQWNlLEdBQUcsQ0FBQzRyQixJQUFqQyxHQUF3QzNxQixJQUFJLENBQUNoQyxJQUFMLE1BQWVnQyxJQUFJLENBQUMycUIsSUFBdEU7O0FBQ0EsWUFBSXQwQixDQUFDLElBQUlrMEIsU0FBVCxFQUFvQjtBQUFFLFlBQUVBLFNBQUY7QUFBYzs7QUFDcENELGNBQU0sQ0FBQ2h1QixNQUFQLENBQWMsRUFBRWpHLENBQWhCLEVBQW1CLENBQW5CLEVBQXNCLElBQUlxbUMsS0FBSixDQUFVTyxHQUFHLEdBQUdoL0IsRUFBSCxHQUFRRCxJQUFyQixFQUEyQmkvQixHQUFHLEdBQUdqL0IsSUFBSCxHQUFVQyxFQUF4QyxDQUF0QjtBQUNEO0FBQ0Y7O0FBQ0QsV0FBTyxJQUFJbytCLFNBQUosQ0FBYy9SLE1BQWQsRUFBc0JDLFNBQXRCLENBQVA7QUFDRDs7QUFFRCxXQUFTMlMsZUFBVCxDQUF5QnRWLE1BQXpCLEVBQWlDK0MsSUFBakMsRUFBdUM7QUFDckMsV0FBTyxJQUFJMFIsU0FBSixDQUFjLENBQUMsSUFBSUssS0FBSixDQUFVOVUsTUFBVixFQUFrQitDLElBQUksSUFBSS9DLE1BQTFCLENBQUQsQ0FBZCxFQUFtRCxDQUFuRCxDQUFQO0FBQ0QsR0FqZ0prQixDQW1nSm5CO0FBQ0E7OztBQUNBLFdBQVN1VixTQUFULENBQW1CN3FCLE1BQW5CLEVBQTJCO0FBQ3pCLFFBQUksQ0FBQ0EsTUFBTSxDQUFDelEsSUFBWixFQUFrQjtBQUFFLGFBQU95USxNQUFNLENBQUNyVSxFQUFkO0FBQWtCOztBQUN0QyxXQUFPNk4sR0FBRyxDQUFDd0csTUFBTSxDQUFDdFUsSUFBUCxDQUFZNEQsSUFBWixHQUFtQjBRLE1BQU0sQ0FBQ3pRLElBQVAsQ0FBWXpNLE1BQS9CLEdBQXdDLENBQXpDLEVBQ0MyRyxHQUFHLENBQUN1VyxNQUFNLENBQUN6USxJQUFSLENBQUgsQ0FBaUJ6TSxNQUFqQixJQUEyQmtkLE1BQU0sQ0FBQ3pRLElBQVAsQ0FBWXpNLE1BQVosSUFBc0IsQ0FBdEIsR0FBMEJrZCxNQUFNLENBQUN0VSxJQUFQLENBQVloQixFQUF0QyxHQUEyQyxDQUF0RSxDQURELENBQVY7QUFFRCxHQXpnSmtCLENBMmdKbkI7QUFDQTs7O0FBQ0EsV0FBU29nQyxlQUFULENBQXlCN2hDLEdBQXpCLEVBQThCK1csTUFBOUIsRUFBc0M7QUFDcEMsUUFBSXZHLEdBQUcsQ0FBQ3hRLEdBQUQsRUFBTStXLE1BQU0sQ0FBQ3RVLElBQWIsQ0FBSCxHQUF3QixDQUE1QixFQUErQjtBQUFFLGFBQU96QyxHQUFQO0FBQVk7O0FBQzdDLFFBQUl3USxHQUFHLENBQUN4USxHQUFELEVBQU0rVyxNQUFNLENBQUNyVSxFQUFiLENBQUgsSUFBdUIsQ0FBM0IsRUFBOEI7QUFBRSxhQUFPay9CLFNBQVMsQ0FBQzdxQixNQUFELENBQWhCO0FBQTBCOztBQUUxRCxRQUFJMVEsSUFBSSxHQUFHckcsR0FBRyxDQUFDcUcsSUFBSixHQUFXMFEsTUFBTSxDQUFDelEsSUFBUCxDQUFZek0sTUFBdkIsSUFBaUNrZCxNQUFNLENBQUNyVSxFQUFQLENBQVUyRCxJQUFWLEdBQWlCMFEsTUFBTSxDQUFDdFUsSUFBUCxDQUFZNEQsSUFBOUQsSUFBc0UsQ0FBakY7QUFBQSxRQUFvRjVFLEVBQUUsR0FBR3pCLEdBQUcsQ0FBQ3lCLEVBQTdGOztBQUNBLFFBQUl6QixHQUFHLENBQUNxRyxJQUFKLElBQVkwUSxNQUFNLENBQUNyVSxFQUFQLENBQVUyRCxJQUExQixFQUFnQztBQUFFNUUsUUFBRSxJQUFJbWdDLFNBQVMsQ0FBQzdxQixNQUFELENBQVQsQ0FBa0J0VixFQUFsQixHQUF1QnNWLE1BQU0sQ0FBQ3JVLEVBQVAsQ0FBVWpCLEVBQXZDO0FBQTRDOztBQUM5RSxXQUFPOE8sR0FBRyxDQUFDbEssSUFBRCxFQUFPNUUsRUFBUCxDQUFWO0FBQ0Q7O0FBRUQsV0FBU3FnQyxxQkFBVCxDQUErQmp6QixHQUEvQixFQUFvQ2tJLE1BQXBDLEVBQTRDO0FBQzFDLFFBQUlwVyxHQUFHLEdBQUcsRUFBVjs7QUFDQSxTQUFLLElBQUk3RixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHK1QsR0FBRyxDQUFDaWdCLEdBQUosQ0FBUUMsTUFBUixDQUFlbDFCLE1BQW5DLEVBQTJDaUIsQ0FBQyxFQUE1QyxFQUFnRDtBQUM5QyxVQUFJRyxLQUFLLEdBQUc0VCxHQUFHLENBQUNpZ0IsR0FBSixDQUFRQyxNQUFSLENBQWVqMEIsQ0FBZixDQUFaO0FBQ0E2RixTQUFHLENBQUNKLElBQUosQ0FBUyxJQUFJNGdDLEtBQUosQ0FBVVUsZUFBZSxDQUFDNW1DLEtBQUssQ0FBQ294QixNQUFQLEVBQWV0VixNQUFmLENBQXpCLEVBQ1U4cUIsZUFBZSxDQUFDNW1DLEtBQUssQ0FBQ20wQixJQUFQLEVBQWFyWSxNQUFiLENBRHpCLENBQVQ7QUFFRDs7QUFDRCxXQUFPc3FCLGtCQUFrQixDQUFDeHlCLEdBQUcsQ0FBQ3hILEVBQUwsRUFBUzFHLEdBQVQsRUFBY2tPLEdBQUcsQ0FBQ2lnQixHQUFKLENBQVFFLFNBQXRCLENBQXpCO0FBQ0Q7O0FBRUQsV0FBUytTLFNBQVQsQ0FBbUIvaEMsR0FBbkIsRUFBd0JtVyxHQUF4QixFQUE2QkcsRUFBN0IsRUFBaUM7QUFDL0IsUUFBSXRXLEdBQUcsQ0FBQ3FHLElBQUosSUFBWThQLEdBQUcsQ0FBQzlQLElBQXBCLEVBQ0U7QUFBRSxhQUFPa0ssR0FBRyxDQUFDK0YsRUFBRSxDQUFDalEsSUFBSixFQUFVckcsR0FBRyxDQUFDeUIsRUFBSixHQUFTMFUsR0FBRyxDQUFDMVUsRUFBYixHQUFrQjZVLEVBQUUsQ0FBQzdVLEVBQS9CLENBQVY7QUFBOEMsS0FEbEQsTUFHRTtBQUFFLGFBQU84TyxHQUFHLENBQUMrRixFQUFFLENBQUNqUSxJQUFILElBQVdyRyxHQUFHLENBQUNxRyxJQUFKLEdBQVc4UCxHQUFHLENBQUM5UCxJQUExQixDQUFELEVBQWtDckcsR0FBRyxDQUFDeUIsRUFBdEMsQ0FBVjtBQUFxRDtBQUMxRCxHQXJpSmtCLENBdWlKbkI7QUFDQTs7O0FBQ0EsV0FBU3VnQyxrQkFBVCxDQUE0Qm56QixHQUE1QixFQUFpQ3VSLE9BQWpDLEVBQTBDNmhCLElBQTFDLEVBQWdEO0FBQzlDLFFBQUl0aEMsR0FBRyxHQUFHLEVBQVY7QUFDQSxRQUFJdWhDLE9BQU8sR0FBRzN4QixHQUFHLENBQUMxQixHQUFHLENBQUNDLEtBQUwsRUFBWSxDQUFaLENBQWpCO0FBQUEsUUFBaUNxekIsT0FBTyxHQUFHRCxPQUEzQzs7QUFDQSxTQUFLLElBQUlwbkMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3NsQixPQUFPLENBQUN2bUIsTUFBNUIsRUFBb0NpQixDQUFDLEVBQXJDLEVBQXlDO0FBQ3ZDLFVBQUlpYyxNQUFNLEdBQUdxSixPQUFPLENBQUN0bEIsQ0FBRCxDQUFwQjtBQUNBLFVBQUkySCxJQUFJLEdBQUdzL0IsU0FBUyxDQUFDaHJCLE1BQU0sQ0FBQ3RVLElBQVIsRUFBY3kvQixPQUFkLEVBQXVCQyxPQUF2QixDQUFwQjtBQUNBLFVBQUl6L0IsRUFBRSxHQUFHcS9CLFNBQVMsQ0FBQ0gsU0FBUyxDQUFDN3FCLE1BQUQsQ0FBVixFQUFvQm1yQixPQUFwQixFQUE2QkMsT0FBN0IsQ0FBbEI7QUFDQUQsYUFBTyxHQUFHbnJCLE1BQU0sQ0FBQ3JVLEVBQWpCO0FBQ0F5L0IsYUFBTyxHQUFHei9CLEVBQVY7O0FBQ0EsVUFBSXUvQixJQUFJLElBQUksUUFBWixFQUFzQjtBQUNwQixZQUFJaG5DLEtBQUssR0FBRzRULEdBQUcsQ0FBQ2lnQixHQUFKLENBQVFDLE1BQVIsQ0FBZWowQixDQUFmLENBQVo7QUFBQSxZQUErQjRtQyxHQUFHLEdBQUdseEIsR0FBRyxDQUFDdlYsS0FBSyxDQUFDbTBCLElBQVAsRUFBYW4wQixLQUFLLENBQUNveEIsTUFBbkIsQ0FBSCxHQUFnQyxDQUFyRTtBQUNBMXJCLFdBQUcsQ0FBQzdGLENBQUQsQ0FBSCxHQUFTLElBQUlxbUMsS0FBSixDQUFVTyxHQUFHLEdBQUdoL0IsRUFBSCxHQUFRRCxJQUFyQixFQUEyQmkvQixHQUFHLEdBQUdqL0IsSUFBSCxHQUFVQyxFQUF4QyxDQUFUO0FBQ0QsT0FIRCxNQUdPO0FBQ0wvQixXQUFHLENBQUM3RixDQUFELENBQUgsR0FBUyxJQUFJcW1DLEtBQUosQ0FBVTErQixJQUFWLEVBQWdCQSxJQUFoQixDQUFUO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPLElBQUlxK0IsU0FBSixDQUFjbmdDLEdBQWQsRUFBbUJrTyxHQUFHLENBQUNpZ0IsR0FBSixDQUFRRSxTQUEzQixDQUFQO0FBQ0QsR0ExakprQixDQTRqSm5COzs7QUFFQSxXQUFTb1QsUUFBVCxDQUFrQi82QixFQUFsQixFQUFzQjtBQUNwQkEsTUFBRSxDQUFDd0gsR0FBSCxDQUFPeEQsSUFBUCxHQUFjTSxPQUFPLENBQUN0RSxFQUFFLENBQUN1RSxPQUFKLEVBQWF2RSxFQUFFLENBQUN3SCxHQUFILENBQU93ekIsVUFBcEIsQ0FBckI7QUFDQUMsa0JBQWMsQ0FBQ2o3QixFQUFELENBQWQ7QUFDRDs7QUFFRCxXQUFTaTdCLGNBQVQsQ0FBd0JqN0IsRUFBeEIsRUFBNEI7QUFDMUJBLE1BQUUsQ0FBQ3dILEdBQUgsQ0FBT1UsSUFBUCxDQUFZLFVBQVVsSixJQUFWLEVBQWdCO0FBQzFCLFVBQUlBLElBQUksQ0FBQytNLFVBQVQsRUFBcUI7QUFBRS9NLFlBQUksQ0FBQytNLFVBQUwsR0FBa0IsSUFBbEI7QUFBeUI7O0FBQ2hELFVBQUkvTSxJQUFJLENBQUNzTSxNQUFULEVBQWlCO0FBQUV0TSxZQUFJLENBQUNzTSxNQUFMLEdBQWMsSUFBZDtBQUFxQjtBQUN6QyxLQUhEO0FBSUF0TCxNQUFFLENBQUN3SCxHQUFILENBQU8wRSxZQUFQLEdBQXNCbE0sRUFBRSxDQUFDd0gsR0FBSCxDQUFPeUUsaUJBQVAsR0FBMkJqTSxFQUFFLENBQUN3SCxHQUFILENBQU9DLEtBQXhEO0FBQ0FnbkIsZUFBVyxDQUFDenVCLEVBQUQsRUFBSyxHQUFMLENBQVg7QUFDQUEsTUFBRSxDQUFDa0YsS0FBSCxDQUFTMkYsT0FBVDs7QUFDQSxRQUFJN0ssRUFBRSxDQUFDUSxLQUFQLEVBQWM7QUFBRTBsQixlQUFTLENBQUNsbUIsRUFBRCxDQUFUO0FBQWdCO0FBQ2pDLEdBNWtKa0IsQ0E4a0puQjtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU2s3QixpQkFBVCxDQUEyQjF6QixHQUEzQixFQUFnQ2tJLE1BQWhDLEVBQXdDO0FBQ3RDLFdBQU9BLE1BQU0sQ0FBQ3RVLElBQVAsQ0FBWWhCLEVBQVosSUFBa0IsQ0FBbEIsSUFBdUJzVixNQUFNLENBQUNyVSxFQUFQLENBQVVqQixFQUFWLElBQWdCLENBQXZDLElBQTRDakIsR0FBRyxDQUFDdVcsTUFBTSxDQUFDelEsSUFBUixDQUFILElBQW9CLEVBQWhFLEtBQ0osQ0FBQ3VJLEdBQUcsQ0FBQ3hILEVBQUwsSUFBV3dILEdBQUcsQ0FBQ3hILEVBQUosQ0FBT3VFLE9BQVAsQ0FBZTQyQixxQkFEdEIsQ0FBUDtBQUVELEdBdGxKa0IsQ0F3bEpuQjs7O0FBQ0EsV0FBU0MsU0FBVCxDQUFtQjV6QixHQUFuQixFQUF3QmtJLE1BQXhCLEVBQWdDZixXQUFoQyxFQUE2QytFLGNBQTdDLEVBQTZEO0FBQzNELGFBQVMybkIsUUFBVCxDQUFrQm5rQyxDQUFsQixFQUFxQjtBQUFDLGFBQU95WCxXQUFXLEdBQUdBLFdBQVcsQ0FBQ3pYLENBQUQsQ0FBZCxHQUFvQixJQUF0QztBQUEyQzs7QUFDakUsYUFBUzQ0QixNQUFULENBQWdCOXdCLElBQWhCLEVBQXNCQyxJQUF0QixFQUE0QnNQLEtBQTVCLEVBQW1DO0FBQ2pDb0YsZ0JBQVUsQ0FBQzNVLElBQUQsRUFBT0MsSUFBUCxFQUFhc1AsS0FBYixFQUFvQm1GLGNBQXBCLENBQVY7QUFDQStFLGlCQUFXLENBQUN6WixJQUFELEVBQU8sUUFBUCxFQUFpQkEsSUFBakIsRUFBdUIwUSxNQUF2QixDQUFYO0FBQ0Q7O0FBQ0QsYUFBUzRyQixRQUFULENBQWtCeG5DLEtBQWxCLEVBQXlCQyxHQUF6QixFQUE4QjtBQUM1QixVQUFJME8sTUFBTSxHQUFHLEVBQWI7O0FBQ0EsV0FBSyxJQUFJaFAsQ0FBQyxHQUFHSyxLQUFiLEVBQW9CTCxDQUFDLEdBQUdNLEdBQXhCLEVBQTZCLEVBQUVOLENBQS9CLEVBQ0U7QUFBRWdQLGNBQU0sQ0FBQ3ZKLElBQVAsQ0FBWSxJQUFJdWEsSUFBSixDQUFTeFUsSUFBSSxDQUFDeEwsQ0FBRCxDQUFiLEVBQWtCNG5DLFFBQVEsQ0FBQzVuQyxDQUFELENBQTFCLEVBQStCaWdCLGNBQS9CLENBQVo7QUFBOEQ7O0FBQ2xFLGFBQU9qUixNQUFQO0FBQ0Q7O0FBRUQsUUFBSXJILElBQUksR0FBR3NVLE1BQU0sQ0FBQ3RVLElBQWxCO0FBQUEsUUFBd0JDLEVBQUUsR0FBR3FVLE1BQU0sQ0FBQ3JVLEVBQXBDO0FBQUEsUUFBd0M0RCxJQUFJLEdBQUd5USxNQUFNLENBQUN6USxJQUF0RDtBQUNBLFFBQUlzOEIsU0FBUyxHQUFHaDBCLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNcE0sSUFBSSxDQUFDNEQsSUFBWCxDQUF2QjtBQUFBLFFBQXlDNlQsUUFBUSxHQUFHdEwsT0FBTyxDQUFDQyxHQUFELEVBQU1uTSxFQUFFLENBQUMyRCxJQUFULENBQTNEO0FBQ0EsUUFBSXc4QixRQUFRLEdBQUdyaUMsR0FBRyxDQUFDOEYsSUFBRCxDQUFsQjtBQUFBLFFBQTBCdzhCLFNBQVMsR0FBR0osUUFBUSxDQUFDcDhCLElBQUksQ0FBQ3pNLE1BQUwsR0FBYyxDQUFmLENBQTlDO0FBQUEsUUFBaUVrcEMsTUFBTSxHQUFHcmdDLEVBQUUsQ0FBQzJELElBQUgsR0FBVTVELElBQUksQ0FBQzRELElBQXpGLENBZjJELENBaUIzRDs7QUFDQSxRQUFJMFEsTUFBTSxDQUFDQyxJQUFYLEVBQWlCO0FBQ2ZuSSxTQUFHLENBQUNtMEIsTUFBSixDQUFXLENBQVgsRUFBY0wsUUFBUSxDQUFDLENBQUQsRUFBSXI4QixJQUFJLENBQUN6TSxNQUFULENBQXRCO0FBQ0FnVixTQUFHLENBQUNvMEIsTUFBSixDQUFXMzhCLElBQUksQ0FBQ3pNLE1BQWhCLEVBQXdCZ1YsR0FBRyxDQUFDRSxJQUFKLEdBQVd6SSxJQUFJLENBQUN6TSxNQUF4QztBQUNELEtBSEQsTUFHTyxJQUFJMG9DLGlCQUFpQixDQUFDMXpCLEdBQUQsRUFBTWtJLE1BQU4sQ0FBckIsRUFBb0M7QUFDekM7QUFDQTtBQUNBLFVBQUltc0IsS0FBSyxHQUFHUCxRQUFRLENBQUMsQ0FBRCxFQUFJcjhCLElBQUksQ0FBQ3pNLE1BQUwsR0FBYyxDQUFsQixDQUFwQjtBQUNBczlCLFlBQU0sQ0FBQ2pkLFFBQUQsRUFBV0EsUUFBUSxDQUFDNVQsSUFBcEIsRUFBMEJ3OEIsU0FBMUIsQ0FBTjs7QUFDQSxVQUFJQyxNQUFKLEVBQVk7QUFBRWwwQixXQUFHLENBQUNvMEIsTUFBSixDQUFXeGdDLElBQUksQ0FBQzRELElBQWhCLEVBQXNCMDhCLE1BQXRCO0FBQWdDOztBQUM5QyxVQUFJRyxLQUFLLENBQUNycEMsTUFBVixFQUFrQjtBQUFFZ1YsV0FBRyxDQUFDbTBCLE1BQUosQ0FBV3ZnQyxJQUFJLENBQUM0RCxJQUFoQixFQUFzQjY4QixLQUF0QjtBQUErQjtBQUNwRCxLQVBNLE1BT0EsSUFBSU4sU0FBUyxJQUFJMW9CLFFBQWpCLEVBQTJCO0FBQ2hDLFVBQUk1VCxJQUFJLENBQUN6TSxNQUFMLElBQWUsQ0FBbkIsRUFBc0I7QUFDcEJzOUIsY0FBTSxDQUFDeUwsU0FBRCxFQUFZQSxTQUFTLENBQUN0OEIsSUFBVixDQUFlM00sS0FBZixDQUFxQixDQUFyQixFQUF3QjhJLElBQUksQ0FBQ2hCLEVBQTdCLElBQW1Db2hDLFFBQW5DLEdBQThDRCxTQUFTLENBQUN0OEIsSUFBVixDQUFlM00sS0FBZixDQUFxQitJLEVBQUUsQ0FBQ2pCLEVBQXhCLENBQTFELEVBQXVGcWhDLFNBQXZGLENBQU47QUFDRCxPQUZELE1BRU87QUFDTCxZQUFJSyxPQUFPLEdBQUdSLFFBQVEsQ0FBQyxDQUFELEVBQUlyOEIsSUFBSSxDQUFDek0sTUFBTCxHQUFjLENBQWxCLENBQXRCO0FBQ0FzcEMsZUFBTyxDQUFDNWlDLElBQVIsQ0FBYSxJQUFJdWEsSUFBSixDQUFTK25CLFFBQVEsR0FBR0QsU0FBUyxDQUFDdDhCLElBQVYsQ0FBZTNNLEtBQWYsQ0FBcUIrSSxFQUFFLENBQUNqQixFQUF4QixDQUFwQixFQUFpRHFoQyxTQUFqRCxFQUE0RC9uQixjQUE1RCxDQUFiO0FBQ0FvYyxjQUFNLENBQUN5TCxTQUFELEVBQVlBLFNBQVMsQ0FBQ3Q4QixJQUFWLENBQWUzTSxLQUFmLENBQXFCLENBQXJCLEVBQXdCOEksSUFBSSxDQUFDaEIsRUFBN0IsSUFBbUM2RSxJQUFJLENBQUMsQ0FBRCxDQUFuRCxFQUF3RG84QixRQUFRLENBQUMsQ0FBRCxDQUFoRSxDQUFOO0FBQ0E3ekIsV0FBRyxDQUFDbTBCLE1BQUosQ0FBV3ZnQyxJQUFJLENBQUM0RCxJQUFMLEdBQVksQ0FBdkIsRUFBMEI4OEIsT0FBMUI7QUFDRDtBQUNGLEtBVE0sTUFTQSxJQUFJNzhCLElBQUksQ0FBQ3pNLE1BQUwsSUFBZSxDQUFuQixFQUFzQjtBQUMzQnM5QixZQUFNLENBQUN5TCxTQUFELEVBQVlBLFNBQVMsQ0FBQ3Q4QixJQUFWLENBQWUzTSxLQUFmLENBQXFCLENBQXJCLEVBQXdCOEksSUFBSSxDQUFDaEIsRUFBN0IsSUFBbUM2RSxJQUFJLENBQUMsQ0FBRCxDQUF2QyxHQUE2QzRULFFBQVEsQ0FBQzVULElBQVQsQ0FBYzNNLEtBQWQsQ0FBb0IrSSxFQUFFLENBQUNqQixFQUF2QixDQUF6RCxFQUFxRmloQyxRQUFRLENBQUMsQ0FBRCxDQUE3RixDQUFOO0FBQ0E3ekIsU0FBRyxDQUFDbzBCLE1BQUosQ0FBV3hnQyxJQUFJLENBQUM0RCxJQUFMLEdBQVksQ0FBdkIsRUFBMEIwOEIsTUFBMUI7QUFDRCxLQUhNLE1BR0E7QUFDTDVMLFlBQU0sQ0FBQ3lMLFNBQUQsRUFBWUEsU0FBUyxDQUFDdDhCLElBQVYsQ0FBZTNNLEtBQWYsQ0FBcUIsQ0FBckIsRUFBd0I4SSxJQUFJLENBQUNoQixFQUE3QixJQUFtQzZFLElBQUksQ0FBQyxDQUFELENBQW5ELEVBQXdEbzhCLFFBQVEsQ0FBQyxDQUFELENBQWhFLENBQU47QUFDQXZMLFlBQU0sQ0FBQ2pkLFFBQUQsRUFBVzJvQixRQUFRLEdBQUczb0IsUUFBUSxDQUFDNVQsSUFBVCxDQUFjM00sS0FBZCxDQUFvQitJLEVBQUUsQ0FBQ2pCLEVBQXZCLENBQXRCLEVBQWtEcWhDLFNBQWxELENBQU47QUFDQSxVQUFJTSxPQUFPLEdBQUdULFFBQVEsQ0FBQyxDQUFELEVBQUlyOEIsSUFBSSxDQUFDek0sTUFBTCxHQUFjLENBQWxCLENBQXRCOztBQUNBLFVBQUlrcEMsTUFBTSxHQUFHLENBQWIsRUFBZ0I7QUFBRWwwQixXQUFHLENBQUNvMEIsTUFBSixDQUFXeGdDLElBQUksQ0FBQzRELElBQUwsR0FBWSxDQUF2QixFQUEwQjA4QixNQUFNLEdBQUcsQ0FBbkM7QUFBd0M7O0FBQzFEbDBCLFNBQUcsQ0FBQ20wQixNQUFKLENBQVd2Z0MsSUFBSSxDQUFDNEQsSUFBTCxHQUFZLENBQXZCLEVBQTBCKzhCLE9BQTFCO0FBQ0Q7O0FBRUR0akIsZUFBVyxDQUFDalIsR0FBRCxFQUFNLFFBQU4sRUFBZ0JBLEdBQWhCLEVBQXFCa0ksTUFBckIsQ0FBWDtBQUNELEdBMW9Ka0IsQ0E0b0puQjs7O0FBQ0EsV0FBU3NzQixVQUFULENBQW9CeDBCLEdBQXBCLEVBQXlCelIsQ0FBekIsRUFBNEJrbUMsY0FBNUIsRUFBNEM7QUFDMUMsYUFBU0MsU0FBVCxDQUFtQjEwQixHQUFuQixFQUF3QjIwQixJQUF4QixFQUE4QkMsVUFBOUIsRUFBMEM7QUFDeEMsVUFBSTUwQixHQUFHLENBQUM2MEIsTUFBUixFQUFnQjtBQUFFLGFBQUssSUFBSTVvQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHK1QsR0FBRyxDQUFDNjBCLE1BQUosQ0FBVzdwQyxNQUEvQixFQUF1QyxFQUFFaUIsQ0FBekMsRUFBNEM7QUFDNUQsY0FBSTZvQyxHQUFHLEdBQUc5MEIsR0FBRyxDQUFDNjBCLE1BQUosQ0FBVzVvQyxDQUFYLENBQVY7O0FBQ0EsY0FBSTZvQyxHQUFHLENBQUM5MEIsR0FBSixJQUFXMjBCLElBQWYsRUFBcUI7QUFBRTtBQUFVOztBQUNqQyxjQUFJSSxNQUFNLEdBQUdILFVBQVUsSUFBSUUsR0FBRyxDQUFDRixVQUEvQjs7QUFDQSxjQUFJSCxjQUFjLElBQUksQ0FBQ00sTUFBdkIsRUFBK0I7QUFBRTtBQUFVOztBQUMzQ3htQyxXQUFDLENBQUN1bUMsR0FBRyxDQUFDOTBCLEdBQUwsRUFBVSswQixNQUFWLENBQUQ7QUFDQUwsbUJBQVMsQ0FBQ0ksR0FBRyxDQUFDOTBCLEdBQUwsRUFBVUEsR0FBVixFQUFlKzBCLE1BQWYsQ0FBVDtBQUNEO0FBQUU7QUFDSjs7QUFDREwsYUFBUyxDQUFDMTBCLEdBQUQsRUFBTSxJQUFOLEVBQVksSUFBWixDQUFUO0FBQ0QsR0F6cEprQixDQTJwSm5COzs7QUFDQSxXQUFTZzFCLFNBQVQsQ0FBbUJ4OEIsRUFBbkIsRUFBdUJ3SCxHQUF2QixFQUE0QjtBQUMxQixRQUFJQSxHQUFHLENBQUN4SCxFQUFSLEVBQVk7QUFBRSxZQUFNLElBQUkySCxLQUFKLENBQVUsa0NBQVYsQ0FBTjtBQUFxRDs7QUFDbkUzSCxNQUFFLENBQUN3SCxHQUFILEdBQVNBLEdBQVQ7QUFDQUEsT0FBRyxDQUFDeEgsRUFBSixHQUFTQSxFQUFUO0FBQ0F1bEIsdUJBQW1CLENBQUN2bEIsRUFBRCxDQUFuQjtBQUNBKzZCLFlBQVEsQ0FBQy82QixFQUFELENBQVI7QUFDQXk4QixxQkFBaUIsQ0FBQ3o4QixFQUFELENBQWpCOztBQUNBLFFBQUksQ0FBQ0EsRUFBRSxDQUFDdUUsT0FBSCxDQUFXMlosWUFBaEIsRUFBOEI7QUFBRTlLLGlCQUFXLENBQUNwVCxFQUFELENBQVg7QUFBa0I7O0FBQ2xEQSxNQUFFLENBQUN1RSxPQUFILENBQVdQLElBQVgsR0FBa0J3RCxHQUFHLENBQUN3ekIsVUFBdEI7QUFDQTlVLGFBQVMsQ0FBQ2xtQixFQUFELENBQVQ7QUFDRDs7QUFFRCxXQUFTeThCLGlCQUFULENBQTJCejhCLEVBQTNCLEVBQStCO0FBQy9CLEtBQUNBLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT3pLLFNBQVAsSUFBb0IsS0FBcEIsR0FBNEI3SCxRQUE1QixHQUF1Q2pELE9BQXhDLEVBQWlEK04sRUFBRSxDQUFDb00sT0FBSCxDQUFXc2YsT0FBNUQsRUFBcUUsZ0JBQXJFO0FBQ0M7O0FBRUQsV0FBU2dSLGdCQUFULENBQTBCMThCLEVBQTFCLEVBQThCO0FBQzVCOHpCLFdBQU8sQ0FBQzl6QixFQUFELEVBQUssWUFBWTtBQUN0Qnk4Qix1QkFBaUIsQ0FBQ3o4QixFQUFELENBQWpCO0FBQ0FrbUIsZUFBUyxDQUFDbG1CLEVBQUQsQ0FBVDtBQUNELEtBSE0sQ0FBUDtBQUlEOztBQUVELFdBQVMyOEIsT0FBVCxDQUFpQkMsUUFBakIsRUFBMkI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsU0FBS0MsSUFBTCxHQUFZLEVBQVo7QUFBZ0IsU0FBS0MsTUFBTCxHQUFjLEVBQWQ7QUFDaEIsU0FBS0MsU0FBTCxHQUFpQjdsQixRQUFqQixDQUx5QixDQU16QjtBQUNBOztBQUNBLFNBQUs4bEIsV0FBTCxHQUFtQixLQUFLQyxXQUFMLEdBQW1CLENBQXRDO0FBQ0EsU0FBS0MsTUFBTCxHQUFjLEtBQUtDLFNBQUwsR0FBaUIsSUFBL0I7QUFDQSxTQUFLQyxVQUFMLEdBQWtCLEtBQUtDLGFBQUwsR0FBcUIsSUFBdkMsQ0FWeUIsQ0FXekI7O0FBQ0EsU0FBS0MsVUFBTCxHQUFrQixLQUFLQyxhQUFMLEdBQXFCWCxRQUFRLElBQUksQ0FBbkQ7QUFDRCxHQWhzSmtCLENBa3NKbkI7QUFDQTs7O0FBQ0EsV0FBU1ksdUJBQVQsQ0FBaUNoMkIsR0FBakMsRUFBc0NrSSxNQUF0QyxFQUE4QztBQUM1QyxRQUFJK3RCLFVBQVUsR0FBRztBQUFDcmlDLFVBQUksRUFBRWlPLE9BQU8sQ0FBQ3FHLE1BQU0sQ0FBQ3RVLElBQVIsQ0FBZDtBQUE2QkMsUUFBRSxFQUFFay9CLFNBQVMsQ0FBQzdxQixNQUFELENBQTFDO0FBQW9EelEsVUFBSSxFQUFFZ0osVUFBVSxDQUFDVCxHQUFELEVBQU1rSSxNQUFNLENBQUN0VSxJQUFiLEVBQW1Cc1UsTUFBTSxDQUFDclUsRUFBMUI7QUFBcEUsS0FBakI7QUFDQXFpQyxvQkFBZ0IsQ0FBQ2wyQixHQUFELEVBQU1pMkIsVUFBTixFQUFrQi90QixNQUFNLENBQUN0VSxJQUFQLENBQVk0RCxJQUE5QixFQUFvQzBRLE1BQU0sQ0FBQ3JVLEVBQVAsQ0FBVTJELElBQVYsR0FBaUIsQ0FBckQsQ0FBaEI7QUFDQWc5QixjQUFVLENBQUN4MEIsR0FBRCxFQUFNLFVBQVVBLEdBQVYsRUFBZTtBQUFFLGFBQU9rMkIsZ0JBQWdCLENBQUNsMkIsR0FBRCxFQUFNaTJCLFVBQU4sRUFBa0IvdEIsTUFBTSxDQUFDdFUsSUFBUCxDQUFZNEQsSUFBOUIsRUFBb0MwUSxNQUFNLENBQUNyVSxFQUFQLENBQVUyRCxJQUFWLEdBQWlCLENBQXJELENBQXZCO0FBQWlGLEtBQXhHLEVBQTBHLElBQTFHLENBQVY7QUFDQSxXQUFPeStCLFVBQVA7QUFDRCxHQXpzSmtCLENBMnNKbkI7QUFDQTs7O0FBQ0EsV0FBU0Usb0JBQVQsQ0FBOEIzbEMsS0FBOUIsRUFBcUM7QUFDbkMsV0FBT0EsS0FBSyxDQUFDeEYsTUFBYixFQUFxQjtBQUNuQixVQUFJbVgsSUFBSSxHQUFHeFEsR0FBRyxDQUFDbkIsS0FBRCxDQUFkOztBQUNBLFVBQUkyUixJQUFJLENBQUMrZCxNQUFULEVBQWlCO0FBQUUxdkIsYUFBSyxDQUFDNGxDLEdBQU47QUFBYyxPQUFqQyxNQUNLO0FBQUU7QUFBTztBQUNmO0FBQ0YsR0FudEprQixDQXF0Sm5CO0FBQ0E7OztBQUNBLFdBQVNDLGVBQVQsQ0FBeUJDLElBQXpCLEVBQStCbEosS0FBL0IsRUFBc0M7QUFDcEMsUUFBSUEsS0FBSixFQUFXO0FBQ1QrSSwwQkFBb0IsQ0FBQ0csSUFBSSxDQUFDakIsSUFBTixDQUFwQjtBQUNBLGFBQU8xakMsR0FBRyxDQUFDMmtDLElBQUksQ0FBQ2pCLElBQU4sQ0FBVjtBQUNELEtBSEQsTUFHTyxJQUFJaUIsSUFBSSxDQUFDakIsSUFBTCxDQUFVcnFDLE1BQVYsSUFBb0IsQ0FBQzJHLEdBQUcsQ0FBQzJrQyxJQUFJLENBQUNqQixJQUFOLENBQUgsQ0FBZW5WLE1BQXhDLEVBQWdEO0FBQ3JELGFBQU92dUIsR0FBRyxDQUFDMmtDLElBQUksQ0FBQ2pCLElBQU4sQ0FBVjtBQUNELEtBRk0sTUFFQSxJQUFJaUIsSUFBSSxDQUFDakIsSUFBTCxDQUFVcnFDLE1BQVYsR0FBbUIsQ0FBbkIsSUFBd0IsQ0FBQ3NyQyxJQUFJLENBQUNqQixJQUFMLENBQVVpQixJQUFJLENBQUNqQixJQUFMLENBQVVycUMsTUFBVixHQUFtQixDQUE3QixFQUFnQ2sxQixNQUE3RCxFQUFxRTtBQUMxRW9XLFVBQUksQ0FBQ2pCLElBQUwsQ0FBVWUsR0FBVjtBQUNBLGFBQU96a0MsR0FBRyxDQUFDMmtDLElBQUksQ0FBQ2pCLElBQU4sQ0FBVjtBQUNEO0FBQ0YsR0FqdUprQixDQW11Sm5CO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU2tCLGtCQUFULENBQTRCdjJCLEdBQTVCLEVBQWlDa0ksTUFBakMsRUFBeUNzdUIsUUFBekMsRUFBbURDLElBQW5ELEVBQXlEO0FBQ3ZELFFBQUlILElBQUksR0FBR3QyQixHQUFHLENBQUMwMkIsT0FBZjtBQUNBSixRQUFJLENBQUNoQixNQUFMLENBQVl0cUMsTUFBWixHQUFxQixDQUFyQjtBQUNBLFFBQUkrRSxJQUFJLEdBQUcsQ0FBQyxJQUFJSSxJQUFKLEVBQVo7QUFBQSxRQUFzQndFLEdBQXRCO0FBQ0EsUUFBSXdOLElBQUo7O0FBRUEsUUFBSSxDQUFDbTBCLElBQUksQ0FBQ1osTUFBTCxJQUFlZSxJQUFmLElBQ0FILElBQUksQ0FBQ1YsVUFBTCxJQUFtQjF0QixNQUFNLENBQUNuWCxNQUExQixJQUFvQ21YLE1BQU0sQ0FBQ25YLE1BQTNDLEtBQ0VtWCxNQUFNLENBQUNuWCxNQUFQLENBQWMwQyxNQUFkLENBQXFCLENBQXJCLEtBQTJCLEdBQTNCLElBQWtDNmlDLElBQUksQ0FBQ2QsV0FBTCxHQUFtQnpsQyxJQUFJLElBQUlpUSxHQUFHLENBQUN4SCxFQUFKLEdBQVN3SCxHQUFHLENBQUN4SCxFQUFKLENBQU91RSxPQUFQLENBQWU0NUIsaUJBQXhCLEdBQTRDLEdBQWhELENBQTFELElBQ0F6dUIsTUFBTSxDQUFDblgsTUFBUCxDQUFjMEMsTUFBZCxDQUFxQixDQUFyQixLQUEyQixHQUY1QixDQURELE1BSUNrQixHQUFHLEdBQUcwaEMsZUFBZSxDQUFDQyxJQUFELEVBQU9BLElBQUksQ0FBQ1osTUFBTCxJQUFlZSxJQUF0QixDQUp0QixDQUFKLEVBSXdEO0FBQ3REO0FBQ0F0MEIsVUFBSSxHQUFHeFEsR0FBRyxDQUFDZ0QsR0FBRyxDQUFDNGMsT0FBTCxDQUFWOztBQUNBLFVBQUk1UCxHQUFHLENBQUN1RyxNQUFNLENBQUN0VSxJQUFSLEVBQWNzVSxNQUFNLENBQUNyVSxFQUFyQixDQUFILElBQStCLENBQS9CLElBQW9DOE4sR0FBRyxDQUFDdUcsTUFBTSxDQUFDdFUsSUFBUixFQUFjdU8sSUFBSSxDQUFDdE8sRUFBbkIsQ0FBSCxJQUE2QixDQUFyRSxFQUF3RTtBQUN0RTtBQUNBO0FBQ0FzTyxZQUFJLENBQUN0TyxFQUFMLEdBQVVrL0IsU0FBUyxDQUFDN3FCLE1BQUQsQ0FBbkI7QUFDRCxPQUpELE1BSU87QUFDTDtBQUNBdlQsV0FBRyxDQUFDNGMsT0FBSixDQUFZN2YsSUFBWixDQUFpQnNrQyx1QkFBdUIsQ0FBQ2gyQixHQUFELEVBQU1rSSxNQUFOLENBQXhDO0FBQ0Q7QUFDRixLQWZELE1BZU87QUFDTDtBQUNBLFVBQUl0UixNQUFNLEdBQUdqRixHQUFHLENBQUMya0MsSUFBSSxDQUFDakIsSUFBTixDQUFoQjs7QUFDQSxVQUFJLENBQUN6K0IsTUFBRCxJQUFXLENBQUNBLE1BQU0sQ0FBQ3NwQixNQUF2QixFQUNFO0FBQUUwVyw4QkFBc0IsQ0FBQzUyQixHQUFHLENBQUNpZ0IsR0FBTCxFQUFVcVcsSUFBSSxDQUFDakIsSUFBZixDQUF0QjtBQUE2Qzs7QUFDakQxZ0MsU0FBRyxHQUFHO0FBQUM0YyxlQUFPLEVBQUUsQ0FBQ3lrQix1QkFBdUIsQ0FBQ2gyQixHQUFELEVBQU1rSSxNQUFOLENBQXhCLENBQVY7QUFDQzR0QixrQkFBVSxFQUFFUSxJQUFJLENBQUNSO0FBRGxCLE9BQU47QUFFQVEsVUFBSSxDQUFDakIsSUFBTCxDQUFVM2pDLElBQVYsQ0FBZWlELEdBQWY7O0FBQ0EsYUFBTzJoQyxJQUFJLENBQUNqQixJQUFMLENBQVVycUMsTUFBVixHQUFtQnNyQyxJQUFJLENBQUNmLFNBQS9CLEVBQTBDO0FBQ3hDZSxZQUFJLENBQUNqQixJQUFMLENBQVV0UixLQUFWOztBQUNBLFlBQUksQ0FBQ3VTLElBQUksQ0FBQ2pCLElBQUwsQ0FBVSxDQUFWLEVBQWFuVixNQUFsQixFQUEwQjtBQUFFb1csY0FBSSxDQUFDakIsSUFBTCxDQUFVdFIsS0FBVjtBQUFvQjtBQUNqRDtBQUNGOztBQUNEdVMsUUFBSSxDQUFDakIsSUFBTCxDQUFVM2pDLElBQVYsQ0FBZThrQyxRQUFmO0FBQ0FGLFFBQUksQ0FBQ1IsVUFBTCxHQUFrQixFQUFFUSxJQUFJLENBQUNQLGFBQXpCO0FBQ0FPLFFBQUksQ0FBQ2QsV0FBTCxHQUFtQmMsSUFBSSxDQUFDYixXQUFMLEdBQW1CMWxDLElBQXRDO0FBQ0F1bUMsUUFBSSxDQUFDWixNQUFMLEdBQWNZLElBQUksQ0FBQ1gsU0FBTCxHQUFpQmMsSUFBL0I7QUFDQUgsUUFBSSxDQUFDVixVQUFMLEdBQWtCVSxJQUFJLENBQUNULGFBQUwsR0FBcUIzdEIsTUFBTSxDQUFDblgsTUFBOUM7O0FBRUEsUUFBSSxDQUFDb1IsSUFBTCxFQUFXO0FBQUU5SixZQUFNLENBQUMySCxHQUFELEVBQU0sY0FBTixDQUFOO0FBQThCO0FBQzVDOztBQUVELFdBQVM2MkIseUJBQVQsQ0FBbUM3MkIsR0FBbkMsRUFBd0NqUCxNQUF4QyxFQUFnRDZFLElBQWhELEVBQXNEcXFCLEdBQXRELEVBQTJEO0FBQ3pELFFBQUlydEIsRUFBRSxHQUFHN0IsTUFBTSxDQUFDMEMsTUFBUCxDQUFjLENBQWQsQ0FBVDtBQUNBLFdBQU9iLEVBQUUsSUFBSSxHQUFOLElBQ0xBLEVBQUUsSUFBSSxHQUFOLElBQ0FnRCxJQUFJLENBQUNzcUIsTUFBTCxDQUFZbDFCLE1BQVosSUFBc0JpMUIsR0FBRyxDQUFDQyxNQUFKLENBQVdsMUIsTUFEakMsSUFFQTRLLElBQUksQ0FBQzI4QixpQkFBTCxNQUE0QnRTLEdBQUcsQ0FBQ3NTLGlCQUFKLEVBRjVCLElBR0EsSUFBSXBpQyxJQUFKLEtBQVc2UCxHQUFHLENBQUMwMkIsT0FBSixDQUFZakIsV0FBdkIsS0FBdUN6MUIsR0FBRyxDQUFDeEgsRUFBSixHQUFTd0gsR0FBRyxDQUFDeEgsRUFBSixDQUFPdUUsT0FBUCxDQUFlNDVCLGlCQUF4QixHQUE0QyxHQUFuRixDQUpGO0FBS0QsR0F4eEprQixDQTB4Sm5CO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFTRyxxQkFBVCxDQUErQjkyQixHQUEvQixFQUFvQ2lnQixHQUFwQyxFQUF5Q3dXLElBQXpDLEVBQStDMTVCLE9BQS9DLEVBQXdEO0FBQ3RELFFBQUl1NUIsSUFBSSxHQUFHdDJCLEdBQUcsQ0FBQzAyQixPQUFmO0FBQUEsUUFBd0IzbEMsTUFBTSxHQUFHZ00sT0FBTyxJQUFJQSxPQUFPLENBQUNoTSxNQUFwRCxDQURzRCxDQUd0RDtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxRQUFJMGxDLElBQUksSUFBSUgsSUFBSSxDQUFDWCxTQUFiLElBQ0M1a0MsTUFBTSxJQUFJdWxDLElBQUksQ0FBQ1QsYUFBTCxJQUFzQjlrQyxNQUFoQyxLQUNDdWxDLElBQUksQ0FBQ2QsV0FBTCxJQUFvQmMsSUFBSSxDQUFDYixXQUF6QixJQUF3Q2EsSUFBSSxDQUFDVixVQUFMLElBQW1CN2tDLE1BQTNELElBQ0E4bEMseUJBQXlCLENBQUM3MkIsR0FBRCxFQUFNalAsTUFBTixFQUFjWSxHQUFHLENBQUMya0MsSUFBSSxDQUFDakIsSUFBTixDQUFqQixFQUE4QnBWLEdBQTlCLENBRjFCLENBREwsRUFJRTtBQUFFcVcsVUFBSSxDQUFDakIsSUFBTCxDQUFVaUIsSUFBSSxDQUFDakIsSUFBTCxDQUFVcnFDLE1BQVYsR0FBbUIsQ0FBN0IsSUFBa0NpMUIsR0FBbEM7QUFBd0MsS0FKNUMsTUFNRTtBQUFFMlcsNEJBQXNCLENBQUMzVyxHQUFELEVBQU1xVyxJQUFJLENBQUNqQixJQUFYLENBQXRCO0FBQXlDOztBQUU3Q2lCLFFBQUksQ0FBQ2IsV0FBTCxHQUFtQixDQUFDLElBQUl0bEMsSUFBSixFQUFwQjtBQUNBbW1DLFFBQUksQ0FBQ1QsYUFBTCxHQUFxQjlrQyxNQUFyQjtBQUNBdWxDLFFBQUksQ0FBQ1gsU0FBTCxHQUFpQmMsSUFBakI7O0FBQ0EsUUFBSTE1QixPQUFPLElBQUlBLE9BQU8sQ0FBQ2c2QixTQUFSLEtBQXNCLEtBQXJDLEVBQ0U7QUFBRVosMEJBQW9CLENBQUNHLElBQUksQ0FBQ2hCLE1BQU4sQ0FBcEI7QUFBb0M7QUFDekM7O0FBRUQsV0FBU3NCLHNCQUFULENBQWdDM1csR0FBaEMsRUFBcUMrVyxJQUFyQyxFQUEyQztBQUN6QyxRQUFJaGdCLEdBQUcsR0FBR3JsQixHQUFHLENBQUNxbEMsSUFBRCxDQUFiOztBQUNBLFFBQUksRUFBRWhnQixHQUFHLElBQUlBLEdBQUcsQ0FBQ2tKLE1BQVgsSUFBcUJsSixHQUFHLENBQUNrYixNQUFKLENBQVdqUyxHQUFYLENBQXZCLENBQUosRUFDRTtBQUFFK1csVUFBSSxDQUFDdGxDLElBQUwsQ0FBVXV1QixHQUFWO0FBQWlCO0FBQ3RCLEdBeHpKa0IsQ0EwekpuQjs7O0FBQ0EsV0FBU2lXLGdCQUFULENBQTBCbDJCLEdBQTFCLEVBQStCa0ksTUFBL0IsRUFBdUN0VSxJQUF2QyxFQUE2Q0MsRUFBN0MsRUFBaUQ7QUFDL0MsUUFBSW9qQyxRQUFRLEdBQUcvdUIsTUFBTSxDQUFDLFdBQVdsSSxHQUFHLENBQUNsUSxFQUFoQixDQUFyQjtBQUFBLFFBQTBDSixDQUFDLEdBQUcsQ0FBOUM7QUFDQXNRLE9BQUcsQ0FBQ1UsSUFBSixDQUFTcFAsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTMEwsR0FBRyxDQUFDQyxLQUFiLEVBQW9Cck0sSUFBcEIsQ0FBVCxFQUFvQ3RDLElBQUksQ0FBQ0MsR0FBTCxDQUFTeU8sR0FBRyxDQUFDQyxLQUFKLEdBQVlELEdBQUcsQ0FBQ0UsSUFBekIsRUFBK0JyTSxFQUEvQixDQUFwQyxFQUF3RSxVQUFVMkQsSUFBVixFQUFnQjtBQUN0RixVQUFJQSxJQUFJLENBQUMyUCxXQUFULEVBQ0U7QUFBRSxTQUFDOHZCLFFBQVEsS0FBS0EsUUFBUSxHQUFHL3VCLE1BQU0sQ0FBQyxXQUFXbEksR0FBRyxDQUFDbFEsRUFBaEIsQ0FBTixHQUE0QixFQUE1QyxDQUFULEVBQTBESixDQUExRCxJQUErRDhILElBQUksQ0FBQzJQLFdBQXBFO0FBQWtGOztBQUN0RixRQUFFelgsQ0FBRjtBQUNELEtBSkQ7QUFLRCxHQWwwSmtCLENBbzBKbkI7QUFDQTs7O0FBQ0EsV0FBU3duQyxrQkFBVCxDQUE0Qm53QixLQUE1QixFQUFtQztBQUNqQyxRQUFJLENBQUNBLEtBQUwsRUFBWTtBQUFFLGFBQU8sSUFBUDtBQUFhOztBQUMzQixRQUFJalYsR0FBSjs7QUFDQSxTQUFLLElBQUk3RixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHOGEsS0FBSyxDQUFDL2IsTUFBMUIsRUFBa0MsRUFBRWlCLENBQXBDLEVBQXVDO0FBQ3JDLFVBQUk4YSxLQUFLLENBQUM5YSxDQUFELENBQUwsQ0FBUzRhLE1BQVQsQ0FBZ0Jzd0IsaUJBQXBCLEVBQXVDO0FBQUUsWUFBSSxDQUFDcmxDLEdBQUwsRUFBVTtBQUFFQSxhQUFHLEdBQUdpVixLQUFLLENBQUNqYyxLQUFOLENBQVksQ0FBWixFQUFlbUIsQ0FBZixDQUFOO0FBQTBCO0FBQUUsT0FBakYsTUFDSyxJQUFJNkYsR0FBSixFQUFTO0FBQUVBLFdBQUcsQ0FBQ0osSUFBSixDQUFTcVYsS0FBSyxDQUFDOWEsQ0FBRCxDQUFkO0FBQXFCO0FBQ3RDOztBQUNELFdBQU8sQ0FBQzZGLEdBQUQsR0FBT2lWLEtBQVAsR0FBZWpWLEdBQUcsQ0FBQzlHLE1BQUosR0FBYThHLEdBQWIsR0FBbUIsSUFBekM7QUFDRCxHQTkwSmtCLENBZzFKbkI7OztBQUNBLFdBQVNzbEMsV0FBVCxDQUFxQnAzQixHQUFyQixFQUEwQmtJLE1BQTFCLEVBQWtDO0FBQ2hDLFFBQUk5VCxLQUFLLEdBQUc4VCxNQUFNLENBQUMsV0FBV2xJLEdBQUcsQ0FBQ2xRLEVBQWhCLENBQWxCOztBQUNBLFFBQUksQ0FBQ3NFLEtBQUwsRUFBWTtBQUFFLGFBQU8sSUFBUDtBQUFhOztBQUMzQixRQUFJcVQsRUFBRSxHQUFHLEVBQVQ7O0FBQ0EsU0FBSyxJQUFJeGIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2ljLE1BQU0sQ0FBQ3pRLElBQVAsQ0FBWXpNLE1BQWhDLEVBQXdDLEVBQUVpQixDQUExQyxFQUNFO0FBQUV3YixRQUFFLENBQUMvVixJQUFILENBQVF3bEMsa0JBQWtCLENBQUM5aUMsS0FBSyxDQUFDbkksQ0FBRCxDQUFOLENBQTFCO0FBQXdDOztBQUM1QyxXQUFPd2IsRUFBUDtBQUNELEdBeDFKa0IsQ0EwMUpuQjtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBUzR2QixhQUFULENBQXVCcjNCLEdBQXZCLEVBQTRCa0ksTUFBNUIsRUFBb0M7QUFDbEMsUUFBSVosR0FBRyxHQUFHOHZCLFdBQVcsQ0FBQ3AzQixHQUFELEVBQU1rSSxNQUFOLENBQXJCO0FBQ0EsUUFBSW92QixTQUFTLEdBQUdydkIsc0JBQXNCLENBQUNqSSxHQUFELEVBQU1rSSxNQUFOLENBQXRDOztBQUNBLFFBQUksQ0FBQ1osR0FBTCxFQUFVO0FBQUUsYUFBT2d3QixTQUFQO0FBQWtCOztBQUM5QixRQUFJLENBQUNBLFNBQUwsRUFBZ0I7QUFBRSxhQUFPaHdCLEdBQVA7QUFBWTs7QUFFOUIsU0FBSyxJQUFJcmIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3FiLEdBQUcsQ0FBQ3RjLE1BQXhCLEVBQWdDLEVBQUVpQixDQUFsQyxFQUFxQztBQUNuQyxVQUFJc3JDLE1BQU0sR0FBR2p3QixHQUFHLENBQUNyYixDQUFELENBQWhCO0FBQUEsVUFBcUJ1ckMsVUFBVSxHQUFHRixTQUFTLENBQUNyckMsQ0FBRCxDQUEzQzs7QUFDQSxVQUFJc3JDLE1BQU0sSUFBSUMsVUFBZCxFQUEwQjtBQUN4Qnp3QixhQUFLLEVBQUUsS0FBSyxJQUFJelEsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2toQyxVQUFVLENBQUN4c0MsTUFBL0IsRUFBdUMsRUFBRXNMLENBQXpDLEVBQTRDO0FBQ2pELGNBQUkwUSxJQUFJLEdBQUd3d0IsVUFBVSxDQUFDbGhDLENBQUQsQ0FBckI7O0FBQ0EsZUFBSyxJQUFJOGMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR21rQixNQUFNLENBQUN2c0MsTUFBM0IsRUFBbUMsRUFBRW9vQixDQUFyQyxFQUNFO0FBQUUsZ0JBQUlta0IsTUFBTSxDQUFDbmtCLENBQUQsQ0FBTixDQUFVdk0sTUFBVixJQUFvQkcsSUFBSSxDQUFDSCxNQUE3QixFQUFxQztBQUFFLHVCQUFTRSxLQUFUO0FBQWdCO0FBQUU7O0FBQzdEd3dCLGdCQUFNLENBQUM3bEMsSUFBUCxDQUFZc1YsSUFBWjtBQUNEO0FBQ0YsT0FQRCxNQU9PLElBQUl3d0IsVUFBSixFQUFnQjtBQUNyQmx3QixXQUFHLENBQUNyYixDQUFELENBQUgsR0FBU3VyQyxVQUFUO0FBQ0Q7QUFDRjs7QUFDRCxXQUFPbHdCLEdBQVA7QUFDRCxHQWwzSmtCLENBbzNKbkI7QUFDQTs7O0FBQ0EsV0FBU213QixnQkFBVCxDQUEwQmhLLE1BQTFCLEVBQWtDaUssUUFBbEMsRUFBNENDLGNBQTVDLEVBQTREO0FBQzFELFFBQUkzMEIsSUFBSSxHQUFHLEVBQVg7O0FBQ0EsU0FBSyxJQUFJL1csQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3doQyxNQUFNLENBQUN6aUMsTUFBM0IsRUFBbUMsRUFBRWlCLENBQXJDLEVBQXdDO0FBQ3RDLFVBQUkyckMsS0FBSyxHQUFHbkssTUFBTSxDQUFDeGhDLENBQUQsQ0FBbEI7O0FBQ0EsVUFBSTJyQyxLQUFLLENBQUMxWCxNQUFWLEVBQWtCO0FBQ2hCbGQsWUFBSSxDQUFDdFIsSUFBTCxDQUFVaW1DLGNBQWMsR0FBRzFGLFNBQVMsQ0FBQ3ZqQyxTQUFWLENBQW9CMmpDLFFBQXBCLENBQTZCMWpDLElBQTdCLENBQWtDaXBDLEtBQWxDLENBQUgsR0FBOENBLEtBQXRFO0FBQ0E7QUFDRDs7QUFDRCxVQUFJcm1CLE9BQU8sR0FBR3FtQixLQUFLLENBQUNybUIsT0FBcEI7QUFBQSxVQUE2QnNtQixVQUFVLEdBQUcsRUFBMUM7QUFDQTcwQixVQUFJLENBQUN0UixJQUFMLENBQVU7QUFBQzZmLGVBQU8sRUFBRXNtQjtBQUFWLE9BQVY7O0FBQ0EsV0FBSyxJQUFJdmhDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdpYixPQUFPLENBQUN2bUIsTUFBNUIsRUFBb0MsRUFBRXNMLENBQXRDLEVBQXlDO0FBQ3ZDLFlBQUk0UixNQUFNLEdBQUdxSixPQUFPLENBQUNqYixDQUFELENBQXBCO0FBQUEsWUFBeUJTLENBQUMsR0FBSSxLQUFLLENBQW5DO0FBQ0E4Z0Msa0JBQVUsQ0FBQ25tQyxJQUFYLENBQWdCO0FBQUNrQyxjQUFJLEVBQUVzVSxNQUFNLENBQUN0VSxJQUFkO0FBQW9CQyxZQUFFLEVBQUVxVSxNQUFNLENBQUNyVSxFQUEvQjtBQUFtQzRELGNBQUksRUFBRXlRLE1BQU0sQ0FBQ3pRO0FBQWhELFNBQWhCOztBQUNBLFlBQUlpZ0MsUUFBSixFQUFjO0FBQUUsZUFBSyxJQUFJeG9DLElBQVQsSUFBaUJnWixNQUFqQixFQUF5QjtBQUFFLGdCQUFJblIsQ0FBQyxHQUFHN0gsSUFBSSxDQUFDaEYsS0FBTCxDQUFXLGVBQVgsQ0FBUixFQUFxQztBQUM5RSxrQkFBSTBGLE9BQU8sQ0FBQzhuQyxRQUFELEVBQVd2dEMsTUFBTSxDQUFDNE0sQ0FBQyxDQUFDLENBQUQsQ0FBRixDQUFqQixDQUFQLEdBQWtDLENBQUMsQ0FBdkMsRUFBMEM7QUFDeENwRixtQkFBRyxDQUFDa21DLFVBQUQsQ0FBSCxDQUFnQjNvQyxJQUFoQixJQUF3QmdaLE1BQU0sQ0FBQ2haLElBQUQsQ0FBOUI7QUFDQSx1QkFBT2daLE1BQU0sQ0FBQ2haLElBQUQsQ0FBYjtBQUNEO0FBQ0Y7QUFBRTtBQUFFO0FBQ047QUFDRjs7QUFDRCxXQUFPOFQsSUFBUDtBQUNELEdBNTRKa0IsQ0E4NEpuQjtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBUzgwQixXQUFULENBQXFCMXJDLEtBQXJCLEVBQTRCbTBCLElBQTVCLEVBQWtDN0UsS0FBbEMsRUFBeUNzUyxNQUF6QyxFQUFpRDtBQUMvQyxRQUFJQSxNQUFKLEVBQVk7QUFDVixVQUFJeFEsTUFBTSxHQUFHcHhCLEtBQUssQ0FBQ294QixNQUFuQjs7QUFDQSxVQUFJOUIsS0FBSixFQUFXO0FBQ1QsWUFBSXFjLFNBQVMsR0FBR3AyQixHQUFHLENBQUM0ZSxJQUFELEVBQU8vQyxNQUFQLENBQUgsR0FBb0IsQ0FBcEM7O0FBQ0EsWUFBSXVhLFNBQVMsSUFBS3AyQixHQUFHLENBQUMrWixLQUFELEVBQVE4QixNQUFSLENBQUgsR0FBcUIsQ0FBdkMsRUFBMkM7QUFDekNBLGdCQUFNLEdBQUcrQyxJQUFUO0FBQ0FBLGNBQUksR0FBRzdFLEtBQVA7QUFDRCxTQUhELE1BR08sSUFBSXFjLFNBQVMsSUFBS3AyQixHQUFHLENBQUM0ZSxJQUFELEVBQU83RSxLQUFQLENBQUgsR0FBbUIsQ0FBckMsRUFBeUM7QUFDOUM2RSxjQUFJLEdBQUc3RSxLQUFQO0FBQ0Q7QUFDRjs7QUFDRCxhQUFPLElBQUk0VyxLQUFKLENBQVU5VSxNQUFWLEVBQWtCK0MsSUFBbEIsQ0FBUDtBQUNELEtBWkQsTUFZTztBQUNMLGFBQU8sSUFBSStSLEtBQUosQ0FBVTVXLEtBQUssSUFBSTZFLElBQW5CLEVBQXlCQSxJQUF6QixDQUFQO0FBQ0Q7QUFDRixHQXQ2SmtCLENBdzZKbkI7OztBQUNBLFdBQVN5WCxlQUFULENBQXlCaDRCLEdBQXpCLEVBQThCdWdCLElBQTlCLEVBQW9DN0UsS0FBcEMsRUFBMkMzZSxPQUEzQyxFQUFvRGl4QixNQUFwRCxFQUE0RDtBQUMxRCxRQUFJQSxNQUFNLElBQUksSUFBZCxFQUFvQjtBQUFFQSxZQUFNLEdBQUdodUIsR0FBRyxDQUFDeEgsRUFBSixLQUFXd0gsR0FBRyxDQUFDeEgsRUFBSixDQUFPb00sT0FBUCxDQUFlbWYsS0FBZixJQUF3Qi9qQixHQUFHLENBQUNndUIsTUFBdkMsQ0FBVDtBQUEwRDs7QUFDaEZpSyxnQkFBWSxDQUFDajRCLEdBQUQsRUFBTSxJQUFJaXlCLFNBQUosQ0FBYyxDQUFDNkYsV0FBVyxDQUFDOTNCLEdBQUcsQ0FBQ2lnQixHQUFKLENBQVFKLE9BQVIsRUFBRCxFQUFvQlUsSUFBcEIsRUFBMEI3RSxLQUExQixFQUFpQ3NTLE1BQWpDLENBQVosQ0FBZCxFQUFxRSxDQUFyRSxDQUFOLEVBQStFanhCLE9BQS9FLENBQVo7QUFDRCxHQTU2SmtCLENBODZKbkI7QUFDQTs7O0FBQ0EsV0FBU203QixnQkFBVCxDQUEwQmw0QixHQUExQixFQUErQm00QixLQUEvQixFQUFzQ3A3QixPQUF0QyxFQUErQztBQUM3QyxRQUFJakwsR0FBRyxHQUFHLEVBQVY7QUFDQSxRQUFJazhCLE1BQU0sR0FBR2h1QixHQUFHLENBQUN4SCxFQUFKLEtBQVd3SCxHQUFHLENBQUN4SCxFQUFKLENBQU9vTSxPQUFQLENBQWVtZixLQUFmLElBQXdCL2pCLEdBQUcsQ0FBQ2d1QixNQUF2QyxDQUFiOztBQUNBLFNBQUssSUFBSS9oQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHK1QsR0FBRyxDQUFDaWdCLEdBQUosQ0FBUUMsTUFBUixDQUFlbDFCLE1BQW5DLEVBQTJDaUIsQ0FBQyxFQUE1QyxFQUNFO0FBQUU2RixTQUFHLENBQUM3RixDQUFELENBQUgsR0FBUzZyQyxXQUFXLENBQUM5M0IsR0FBRyxDQUFDaWdCLEdBQUosQ0FBUUMsTUFBUixDQUFlajBCLENBQWYsQ0FBRCxFQUFvQmtzQyxLQUFLLENBQUNsc0MsQ0FBRCxDQUF6QixFQUE4QixJQUE5QixFQUFvQytoQyxNQUFwQyxDQUFwQjtBQUFrRTs7QUFDdEUsUUFBSW9LLE1BQU0sR0FBRzVGLGtCQUFrQixDQUFDeHlCLEdBQUcsQ0FBQ3hILEVBQUwsRUFBUzFHLEdBQVQsRUFBY2tPLEdBQUcsQ0FBQ2lnQixHQUFKLENBQVFFLFNBQXRCLENBQS9CO0FBQ0E4WCxnQkFBWSxDQUFDajRCLEdBQUQsRUFBTW80QixNQUFOLEVBQWNyN0IsT0FBZCxDQUFaO0FBQ0QsR0F2N0prQixDQXk3Sm5COzs7QUFDQSxXQUFTczdCLG1CQUFULENBQTZCcjRCLEdBQTdCLEVBQWtDL1QsQ0FBbEMsRUFBcUNHLEtBQXJDLEVBQTRDMlEsT0FBNUMsRUFBcUQ7QUFDbkQsUUFBSW1qQixNQUFNLEdBQUdsZ0IsR0FBRyxDQUFDaWdCLEdBQUosQ0FBUUMsTUFBUixDQUFlcDFCLEtBQWYsQ0FBcUIsQ0FBckIsQ0FBYjtBQUNBbzFCLFVBQU0sQ0FBQ2owQixDQUFELENBQU4sR0FBWUcsS0FBWjtBQUNBNnJDLGdCQUFZLENBQUNqNEIsR0FBRCxFQUFNd3lCLGtCQUFrQixDQUFDeHlCLEdBQUcsQ0FBQ3hILEVBQUwsRUFBUzBuQixNQUFULEVBQWlCbGdCLEdBQUcsQ0FBQ2lnQixHQUFKLENBQVFFLFNBQXpCLENBQXhCLEVBQTZEcGpCLE9BQTdELENBQVo7QUFDRCxHQTk3SmtCLENBZzhKbkI7OztBQUNBLFdBQVN1N0Isa0JBQVQsQ0FBNEJ0NEIsR0FBNUIsRUFBaUN3ZCxNQUFqQyxFQUF5QytDLElBQXpDLEVBQStDeGpCLE9BQS9DLEVBQXdEO0FBQ3REazdCLGdCQUFZLENBQUNqNEIsR0FBRCxFQUFNOHlCLGVBQWUsQ0FBQ3RWLE1BQUQsRUFBUytDLElBQVQsQ0FBckIsRUFBcUN4akIsT0FBckMsQ0FBWjtBQUNELEdBbjhKa0IsQ0FxOEpuQjtBQUNBOzs7QUFDQSxXQUFTdzdCLHFCQUFULENBQStCdjRCLEdBQS9CLEVBQW9DaWdCLEdBQXBDLEVBQXlDbGpCLE9BQXpDLEVBQWtEO0FBQ2hELFFBQUloTyxHQUFHLEdBQUc7QUFDUm14QixZQUFNLEVBQUVELEdBQUcsQ0FBQ0MsTUFESjtBQUVSb0ksWUFBTSxFQUFFLGdCQUFTcEksTUFBVCxFQUFpQjtBQUN2QixhQUFLQSxNQUFMLEdBQWMsRUFBZDs7QUFDQSxhQUFLLElBQUlqMEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2kwQixNQUFNLENBQUNsMUIsTUFBM0IsRUFBbUNpQixDQUFDLEVBQXBDLEVBQ0U7QUFBRSxlQUFLaTBCLE1BQUwsQ0FBWWowQixDQUFaLElBQWlCLElBQUlxbUMsS0FBSixDQUFVcHdCLFFBQU8sQ0FBQ2xDLEdBQUQsRUFBTWtnQixNQUFNLENBQUNqMEIsQ0FBRCxDQUFOLENBQVV1eEIsTUFBaEIsQ0FBakIsRUFDUXRiLFFBQU8sQ0FBQ2xDLEdBQUQsRUFBTWtnQixNQUFNLENBQUNqMEIsQ0FBRCxDQUFOLENBQVVzMEIsSUFBaEIsQ0FEZixDQUFqQjtBQUN5RDtBQUM5RCxPQVBPO0FBUVJ4dkIsWUFBTSxFQUFFZ00sT0FBTyxJQUFJQSxPQUFPLENBQUNoTTtBQVJuQixLQUFWO0FBVUFzSCxVQUFNLENBQUMySCxHQUFELEVBQU0sdUJBQU4sRUFBK0JBLEdBQS9CLEVBQW9DalIsR0FBcEMsQ0FBTjs7QUFDQSxRQUFJaVIsR0FBRyxDQUFDeEgsRUFBUixFQUFZO0FBQUVILFlBQU0sQ0FBQzJILEdBQUcsQ0FBQ3hILEVBQUwsRUFBUyx1QkFBVCxFQUFrQ3dILEdBQUcsQ0FBQ3hILEVBQXRDLEVBQTBDekosR0FBMUMsQ0FBTjtBQUF1RDs7QUFDckUsUUFBSUEsR0FBRyxDQUFDbXhCLE1BQUosSUFBY0QsR0FBRyxDQUFDQyxNQUF0QixFQUE4QjtBQUFFLGFBQU9zUyxrQkFBa0IsQ0FBQ3h5QixHQUFHLENBQUN4SCxFQUFMLEVBQVN6SixHQUFHLENBQUNteEIsTUFBYixFQUFxQm54QixHQUFHLENBQUNteEIsTUFBSixDQUFXbDFCLE1BQVgsR0FBb0IsQ0FBekMsQ0FBekI7QUFBc0UsS0FBdEcsTUFDSztBQUFFLGFBQU9pMUIsR0FBUDtBQUFZO0FBQ3BCOztBQUVELFdBQVN1WSwwQkFBVCxDQUFvQ3g0QixHQUFwQyxFQUF5Q2lnQixHQUF6QyxFQUE4Q2xqQixPQUE5QyxFQUF1RDtBQUNyRCxRQUFJczRCLElBQUksR0FBR3IxQixHQUFHLENBQUMwMkIsT0FBSixDQUFZckIsSUFBdkI7QUFBQSxRQUE2Qmx6QixJQUFJLEdBQUd4USxHQUFHLENBQUMwakMsSUFBRCxDQUF2Qzs7QUFDQSxRQUFJbHpCLElBQUksSUFBSUEsSUFBSSxDQUFDK2QsTUFBakIsRUFBeUI7QUFDdkJtVixVQUFJLENBQUNBLElBQUksQ0FBQ3JxQyxNQUFMLEdBQWMsQ0FBZixDQUFKLEdBQXdCaTFCLEdBQXhCO0FBQ0F3WSx3QkFBa0IsQ0FBQ3o0QixHQUFELEVBQU1pZ0IsR0FBTixFQUFXbGpCLE9BQVgsQ0FBbEI7QUFDRCxLQUhELE1BR087QUFDTGs3QixrQkFBWSxDQUFDajRCLEdBQUQsRUFBTWlnQixHQUFOLEVBQVdsakIsT0FBWCxDQUFaO0FBQ0Q7QUFDRixHQWgrSmtCLENBaytKbkI7OztBQUNBLFdBQVNrN0IsWUFBVCxDQUFzQmo0QixHQUF0QixFQUEyQmlnQixHQUEzQixFQUFnQ2xqQixPQUFoQyxFQUF5QztBQUN2QzA3QixzQkFBa0IsQ0FBQ3o0QixHQUFELEVBQU1pZ0IsR0FBTixFQUFXbGpCLE9BQVgsQ0FBbEI7QUFDQSs1Qix5QkFBcUIsQ0FBQzkyQixHQUFELEVBQU1BLEdBQUcsQ0FBQ2lnQixHQUFWLEVBQWVqZ0IsR0FBRyxDQUFDeEgsRUFBSixHQUFTd0gsR0FBRyxDQUFDeEgsRUFBSixDQUFPUSxLQUFQLENBQWFsSixFQUF0QixHQUEyQjRvQyxHQUExQyxFQUErQzM3QixPQUEvQyxDQUFyQjtBQUNEOztBQUVELFdBQVMwN0Isa0JBQVQsQ0FBNEJ6NEIsR0FBNUIsRUFBaUNpZ0IsR0FBakMsRUFBc0NsakIsT0FBdEMsRUFBK0M7QUFDN0MsUUFBSTdELFVBQVUsQ0FBQzhHLEdBQUQsRUFBTSx1QkFBTixDQUFWLElBQTRDQSxHQUFHLENBQUN4SCxFQUFKLElBQVVVLFVBQVUsQ0FBQzhHLEdBQUcsQ0FBQ3hILEVBQUwsRUFBUyx1QkFBVCxDQUFwRSxFQUNFO0FBQUV5bkIsU0FBRyxHQUFHc1kscUJBQXFCLENBQUN2NEIsR0FBRCxFQUFNaWdCLEdBQU4sRUFBV2xqQixPQUFYLENBQTNCO0FBQWlEOztBQUVyRCxRQUFJc2EsSUFBSSxHQUFHdGEsT0FBTyxJQUFJQSxPQUFPLENBQUNzYSxJQUFuQixLQUNSMVYsR0FBRyxDQUFDc2UsR0FBRyxDQUFDSixPQUFKLEdBQWNVLElBQWYsRUFBcUJ2Z0IsR0FBRyxDQUFDaWdCLEdBQUosQ0FBUUosT0FBUixHQUFrQlUsSUFBdkMsQ0FBSCxHQUFrRCxDQUFsRCxHQUFzRCxDQUFDLENBQXZELEdBQTJELENBRG5ELENBQVg7QUFFQW9ZLHFCQUFpQixDQUFDMzRCLEdBQUQsRUFBTTQ0QixxQkFBcUIsQ0FBQzU0QixHQUFELEVBQU1pZ0IsR0FBTixFQUFXNUksSUFBWCxFQUFpQixJQUFqQixDQUEzQixDQUFqQjs7QUFFQSxRQUFJLEVBQUV0YSxPQUFPLElBQUlBLE9BQU8sQ0FBQ2xNLE1BQVIsS0FBbUIsS0FBaEMsS0FBMENtUCxHQUFHLENBQUN4SCxFQUE5QyxJQUFvRHdILEdBQUcsQ0FBQ3hILEVBQUosQ0FBT3dVLFNBQVAsQ0FBaUIsVUFBakIsS0FBZ0MsVUFBeEYsRUFDRTtBQUFFdVoseUJBQW1CLENBQUN2bUIsR0FBRyxDQUFDeEgsRUFBTCxDQUFuQjtBQUE4QjtBQUNuQzs7QUFFRCxXQUFTbWdDLGlCQUFULENBQTJCMzRCLEdBQTNCLEVBQWdDaWdCLEdBQWhDLEVBQXFDO0FBQ25DLFFBQUlBLEdBQUcsQ0FBQ2lTLE1BQUosQ0FBV2x5QixHQUFHLENBQUNpZ0IsR0FBZixDQUFKLEVBQXlCO0FBQUU7QUFBUTs7QUFFbkNqZ0IsT0FBRyxDQUFDaWdCLEdBQUosR0FBVUEsR0FBVjs7QUFFQSxRQUFJamdCLEdBQUcsQ0FBQ3hILEVBQVIsRUFBWTtBQUNWd0gsU0FBRyxDQUFDeEgsRUFBSixDQUFPUSxLQUFQLENBQWF3eEIsV0FBYixHQUEyQixDQUEzQjtBQUNBeHFCLFNBQUcsQ0FBQ3hILEVBQUosQ0FBT1EsS0FBUCxDQUFhMnhCLGdCQUFiLEdBQWdDLElBQWhDO0FBQ0E3eEIsMEJBQW9CLENBQUNrSCxHQUFHLENBQUN4SCxFQUFMLENBQXBCO0FBQ0Q7O0FBQ0R5WSxlQUFXLENBQUNqUixHQUFELEVBQU0sZ0JBQU4sRUFBd0JBLEdBQXhCLENBQVg7QUFDRCxHQS8vSmtCLENBaWdLbkI7QUFDQTs7O0FBQ0EsV0FBUzY0QixnQkFBVCxDQUEwQjc0QixHQUExQixFQUErQjtBQUM3QjI0QixxQkFBaUIsQ0FBQzM0QixHQUFELEVBQU00NEIscUJBQXFCLENBQUM1NEIsR0FBRCxFQUFNQSxHQUFHLENBQUNpZ0IsR0FBVixFQUFlLElBQWYsRUFBcUIsS0FBckIsQ0FBM0IsQ0FBakI7QUFDRCxHQXJnS2tCLENBdWdLbkI7QUFDQTs7O0FBQ0EsV0FBUzJZLHFCQUFULENBQStCNTRCLEdBQS9CLEVBQW9DaWdCLEdBQXBDLEVBQXlDNUksSUFBekMsRUFBK0N5aEIsUUFBL0MsRUFBeUQ7QUFDdkQsUUFBSWhuQyxHQUFKOztBQUNBLFNBQUssSUFBSTdGLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdnMEIsR0FBRyxDQUFDQyxNQUFKLENBQVdsMUIsTUFBL0IsRUFBdUNpQixDQUFDLEVBQXhDLEVBQTRDO0FBQzFDLFVBQUlHLEtBQUssR0FBRzZ6QixHQUFHLENBQUNDLE1BQUosQ0FBV2owQixDQUFYLENBQVo7QUFDQSxVQUFJcWIsR0FBRyxHQUFHMlksR0FBRyxDQUFDQyxNQUFKLENBQVdsMUIsTUFBWCxJQUFxQmdWLEdBQUcsQ0FBQ2lnQixHQUFKLENBQVFDLE1BQVIsQ0FBZWwxQixNQUFwQyxJQUE4Q2dWLEdBQUcsQ0FBQ2lnQixHQUFKLENBQVFDLE1BQVIsQ0FBZWowQixDQUFmLENBQXhEO0FBQ0EsVUFBSThzQyxTQUFTLEdBQUdDLFVBQVUsQ0FBQ2g1QixHQUFELEVBQU01VCxLQUFLLENBQUNveEIsTUFBWixFQUFvQmxXLEdBQUcsSUFBSUEsR0FBRyxDQUFDa1csTUFBL0IsRUFBdUNuRyxJQUF2QyxFQUE2Q3loQixRQUE3QyxDQUExQjtBQUNBLFVBQUlHLE9BQU8sR0FBR0QsVUFBVSxDQUFDaDVCLEdBQUQsRUFBTTVULEtBQUssQ0FBQ20wQixJQUFaLEVBQWtCalosR0FBRyxJQUFJQSxHQUFHLENBQUNpWixJQUE3QixFQUFtQ2xKLElBQW5DLEVBQXlDeWhCLFFBQXpDLENBQXhCOztBQUNBLFVBQUlobkMsR0FBRyxJQUFJaW5DLFNBQVMsSUFBSTNzQyxLQUFLLENBQUNveEIsTUFBMUIsSUFBb0N5YixPQUFPLElBQUk3c0MsS0FBSyxDQUFDbTBCLElBQXpELEVBQStEO0FBQzdELFlBQUksQ0FBQ3p1QixHQUFMLEVBQVU7QUFBRUEsYUFBRyxHQUFHbXVCLEdBQUcsQ0FBQ0MsTUFBSixDQUFXcDFCLEtBQVgsQ0FBaUIsQ0FBakIsRUFBb0JtQixDQUFwQixDQUFOO0FBQStCOztBQUMzQzZGLFdBQUcsQ0FBQzdGLENBQUQsQ0FBSCxHQUFTLElBQUlxbUMsS0FBSixDQUFVeUcsU0FBVixFQUFxQkUsT0FBckIsQ0FBVDtBQUNEO0FBQ0Y7O0FBQ0QsV0FBT25uQyxHQUFHLEdBQUcwZ0Msa0JBQWtCLENBQUN4eUIsR0FBRyxDQUFDeEgsRUFBTCxFQUFTMUcsR0FBVCxFQUFjbXVCLEdBQUcsQ0FBQ0UsU0FBbEIsQ0FBckIsR0FBb0RGLEdBQTlEO0FBQ0Q7O0FBRUQsV0FBU2laLGVBQVQsQ0FBeUJsNUIsR0FBekIsRUFBOEI3TyxHQUE5QixFQUFtQ2dvQyxNQUFuQyxFQUEyQzNsQyxHQUEzQyxFQUFnRHNsQyxRQUFoRCxFQUEwRDtBQUN4RCxRQUFJdGhDLElBQUksR0FBR3VJLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNN08sR0FBRyxDQUFDcUcsSUFBVixDQUFsQjs7QUFDQSxRQUFJQSxJQUFJLENBQUMyUCxXQUFULEVBQXNCO0FBQUUsV0FBSyxJQUFJbGIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VMLElBQUksQ0FBQzJQLFdBQUwsQ0FBaUJuYyxNQUFyQyxFQUE2QyxFQUFFaUIsQ0FBL0MsRUFBa0Q7QUFDeEUsWUFBSXNlLEVBQUUsR0FBRy9TLElBQUksQ0FBQzJQLFdBQUwsQ0FBaUJsYixDQUFqQixDQUFUO0FBQUEsWUFBOEI4SyxDQUFDLEdBQUd3VCxFQUFFLENBQUMxRCxNQUFyQyxDQUR3RSxDQUd4RTtBQUNBO0FBQ0E7O0FBQ0EsWUFBSXV5QixpQkFBaUIsR0FBSSxnQkFBZ0JyaUMsQ0FBakIsR0FBc0IsQ0FBQ0EsQ0FBQyxDQUFDc2lDLFVBQXpCLEdBQXNDdGlDLENBQUMsQ0FBQzRRLGFBQWhFO0FBQ0EsWUFBSTJ4QixrQkFBa0IsR0FBSSxpQkFBaUJ2aUMsQ0FBbEIsR0FBdUIsQ0FBQ0EsQ0FBQyxDQUFDd2lDLFdBQTFCLEdBQXdDeGlDLENBQUMsQ0FBQytRLGNBQW5FOztBQUVBLFlBQUksQ0FBQ3lDLEVBQUUsQ0FBQzNXLElBQUgsSUFBVyxJQUFYLEtBQW9Cd2xDLGlCQUFpQixHQUFHN3VCLEVBQUUsQ0FBQzNXLElBQUgsSUFBV3pDLEdBQUcsQ0FBQ3lCLEVBQWxCLEdBQXVCMlgsRUFBRSxDQUFDM1csSUFBSCxHQUFVekMsR0FBRyxDQUFDeUIsRUFBMUUsQ0FBRCxNQUNDMlgsRUFBRSxDQUFDMVcsRUFBSCxJQUFTLElBQVQsS0FBa0J5bEMsa0JBQWtCLEdBQUcvdUIsRUFBRSxDQUFDMVcsRUFBSCxJQUFTMUMsR0FBRyxDQUFDeUIsRUFBaEIsR0FBcUIyWCxFQUFFLENBQUMxVyxFQUFILEdBQVExQyxHQUFHLENBQUN5QixFQUFyRSxDQURELENBQUosRUFDZ0Y7QUFDOUUsY0FBSWttQyxRQUFKLEVBQWM7QUFDWnpnQyxrQkFBTSxDQUFDdEIsQ0FBRCxFQUFJLG1CQUFKLENBQU47O0FBQ0EsZ0JBQUlBLENBQUMsQ0FBQ29nQyxpQkFBTixFQUF5QjtBQUN2QixrQkFBSSxDQUFDMy9CLElBQUksQ0FBQzJQLFdBQVYsRUFBdUI7QUFBRTtBQUFPLGVBQWhDLE1BQ0s7QUFBQyxrQkFBRWxiLENBQUY7QUFBSztBQUFTO0FBQ3JCO0FBQ0Y7O0FBQ0QsY0FBSSxDQUFDOEssQ0FBQyxDQUFDeWlDLE1BQVAsRUFBZTtBQUFFO0FBQVU7O0FBRTNCLGNBQUlMLE1BQUosRUFBWTtBQUNWLGdCQUFJTSxJQUFJLEdBQUcxaUMsQ0FBQyxDQUFDc1MsSUFBRixDQUFPN1YsR0FBRyxHQUFHLENBQU4sR0FBVSxDQUFWLEdBQWMsQ0FBQyxDQUF0QixDQUFYO0FBQUEsZ0JBQXFDc04sSUFBSSxHQUFJLEtBQUssQ0FBbEQ7O0FBQ0EsZ0JBQUl0TixHQUFHLEdBQUcsQ0FBTixHQUFVOGxDLGtCQUFWLEdBQStCRixpQkFBbkMsRUFDRTtBQUFFSyxrQkFBSSxHQUFHQyxPQUFPLENBQUMxNUIsR0FBRCxFQUFNeTVCLElBQU4sRUFBWSxDQUFDam1DLEdBQWIsRUFBa0JpbUMsSUFBSSxJQUFJQSxJQUFJLENBQUNqaUMsSUFBTCxJQUFhckcsR0FBRyxDQUFDcUcsSUFBekIsR0FBZ0NBLElBQWhDLEdBQXVDLElBQXpELENBQWQ7QUFBK0U7O0FBQ25GLGdCQUFJaWlDLElBQUksSUFBSUEsSUFBSSxDQUFDamlDLElBQUwsSUFBYXJHLEdBQUcsQ0FBQ3FHLElBQXpCLEtBQWtDc0osSUFBSSxHQUFHYSxHQUFHLENBQUM4M0IsSUFBRCxFQUFPTixNQUFQLENBQTVDLE1BQWdFM2xDLEdBQUcsR0FBRyxDQUFOLEdBQVVzTixJQUFJLEdBQUcsQ0FBakIsR0FBcUJBLElBQUksR0FBRyxDQUE1RixDQUFKLEVBQ0U7QUFBRSxxQkFBT280QixlQUFlLENBQUNsNUIsR0FBRCxFQUFNeTVCLElBQU4sRUFBWXRvQyxHQUFaLEVBQWlCcUMsR0FBakIsRUFBc0JzbEMsUUFBdEIsQ0FBdEI7QUFBdUQ7QUFDNUQ7O0FBRUQsY0FBSWEsR0FBRyxHQUFHNWlDLENBQUMsQ0FBQ3NTLElBQUYsQ0FBTzdWLEdBQUcsR0FBRyxDQUFOLEdBQVUsQ0FBQyxDQUFYLEdBQWUsQ0FBdEIsQ0FBVjs7QUFDQSxjQUFJQSxHQUFHLEdBQUcsQ0FBTixHQUFVNGxDLGlCQUFWLEdBQThCRSxrQkFBbEMsRUFDRTtBQUFFSyxlQUFHLEdBQUdELE9BQU8sQ0FBQzE1QixHQUFELEVBQU0yNUIsR0FBTixFQUFXbm1DLEdBQVgsRUFBZ0JtbUMsR0FBRyxDQUFDbmlDLElBQUosSUFBWXJHLEdBQUcsQ0FBQ3FHLElBQWhCLEdBQXVCQSxJQUF2QixHQUE4QixJQUE5QyxDQUFiO0FBQW1FOztBQUN2RSxpQkFBT21pQyxHQUFHLEdBQUdULGVBQWUsQ0FBQ2w1QixHQUFELEVBQU0yNUIsR0FBTixFQUFXeG9DLEdBQVgsRUFBZ0JxQyxHQUFoQixFQUFxQnNsQyxRQUFyQixDQUFsQixHQUFtRCxJQUE3RDtBQUNEO0FBQ0Y7QUFBRTs7QUFDSCxXQUFPM25DLEdBQVA7QUFDRCxHQTdqS2tCLENBK2pLbkI7OztBQUNBLFdBQVM2bkMsVUFBVCxDQUFvQmg1QixHQUFwQixFQUF5QjdPLEdBQXpCLEVBQThCZ29DLE1BQTlCLEVBQXNDOWhCLElBQXRDLEVBQTRDeWhCLFFBQTVDLEVBQXNEO0FBQ3BELFFBQUl0bEMsR0FBRyxHQUFHNmpCLElBQUksSUFBSSxDQUFsQjtBQUNBLFFBQUlqakIsS0FBSyxHQUFHOGtDLGVBQWUsQ0FBQ2w1QixHQUFELEVBQU03TyxHQUFOLEVBQVdnb0MsTUFBWCxFQUFtQjNsQyxHQUFuQixFQUF3QnNsQyxRQUF4QixDQUFmLElBQ1AsQ0FBQ0EsUUFBRCxJQUFhSSxlQUFlLENBQUNsNUIsR0FBRCxFQUFNN08sR0FBTixFQUFXZ29DLE1BQVgsRUFBbUIzbEMsR0FBbkIsRUFBd0IsSUFBeEIsQ0FEckIsSUFFUjBsQyxlQUFlLENBQUNsNUIsR0FBRCxFQUFNN08sR0FBTixFQUFXZ29DLE1BQVgsRUFBbUIsQ0FBQzNsQyxHQUFwQixFQUF5QnNsQyxRQUF6QixDQUZQLElBR1AsQ0FBQ0EsUUFBRCxJQUFhSSxlQUFlLENBQUNsNUIsR0FBRCxFQUFNN08sR0FBTixFQUFXZ29DLE1BQVgsRUFBbUIsQ0FBQzNsQyxHQUFwQixFQUF5QixJQUF6QixDQUhqQzs7QUFJQSxRQUFJLENBQUNZLEtBQUwsRUFBWTtBQUNWNEwsU0FBRyxDQUFDNDVCLFFBQUosR0FBZSxJQUFmO0FBQ0EsYUFBT2w0QixHQUFHLENBQUMxQixHQUFHLENBQUNDLEtBQUwsRUFBWSxDQUFaLENBQVY7QUFDRDs7QUFDRCxXQUFPN0wsS0FBUDtBQUNEOztBQUVELFdBQVNzbEMsT0FBVCxDQUFpQjE1QixHQUFqQixFQUFzQjdPLEdBQXRCLEVBQTJCcUMsR0FBM0IsRUFBZ0NnRSxJQUFoQyxFQUFzQztBQUNwQyxRQUFJaEUsR0FBRyxHQUFHLENBQU4sSUFBV3JDLEdBQUcsQ0FBQ3lCLEVBQUosSUFBVSxDQUF6QixFQUE0QjtBQUMxQixVQUFJekIsR0FBRyxDQUFDcUcsSUFBSixHQUFXd0ksR0FBRyxDQUFDQyxLQUFuQixFQUEwQjtBQUFFLGVBQU9pQyxRQUFPLENBQUNsQyxHQUFELEVBQU0wQixHQUFHLENBQUN2USxHQUFHLENBQUNxRyxJQUFKLEdBQVcsQ0FBWixDQUFULENBQWQ7QUFBd0MsT0FBcEUsTUFDSztBQUFFLGVBQU8sSUFBUDtBQUFhO0FBQ3JCLEtBSEQsTUFHTyxJQUFJaEUsR0FBRyxHQUFHLENBQU4sSUFBV3JDLEdBQUcsQ0FBQ3lCLEVBQUosSUFBVSxDQUFDNEUsSUFBSSxJQUFJdUksT0FBTyxDQUFDQyxHQUFELEVBQU03TyxHQUFHLENBQUNxRyxJQUFWLENBQWhCLEVBQWlDQyxJQUFqQyxDQUFzQ3pNLE1BQS9ELEVBQXVFO0FBQzVFLFVBQUltRyxHQUFHLENBQUNxRyxJQUFKLEdBQVd3SSxHQUFHLENBQUNDLEtBQUosR0FBWUQsR0FBRyxDQUFDRSxJQUFoQixHQUF1QixDQUF0QyxFQUF5QztBQUFFLGVBQU93QixHQUFHLENBQUN2USxHQUFHLENBQUNxRyxJQUFKLEdBQVcsQ0FBWixFQUFlLENBQWYsQ0FBVjtBQUE2QixPQUF4RSxNQUNLO0FBQUUsZUFBTyxJQUFQO0FBQWE7QUFDckIsS0FITSxNQUdBO0FBQ0wsYUFBTyxJQUFJa0ssR0FBSixDQUFRdlEsR0FBRyxDQUFDcUcsSUFBWixFQUFrQnJHLEdBQUcsQ0FBQ3lCLEVBQUosR0FBU1ksR0FBM0IsQ0FBUDtBQUNEO0FBQ0Y7O0FBRUQsV0FBU3FtQyxTQUFULENBQW1CcmhDLEVBQW5CLEVBQXVCO0FBQ3JCQSxNQUFFLENBQUN5L0IsWUFBSCxDQUFnQnYyQixHQUFHLENBQUNsSixFQUFFLENBQUN1N0IsU0FBSCxFQUFELEVBQWlCLENBQWpCLENBQW5CLEVBQXdDcnlCLEdBQUcsQ0FBQ2xKLEVBQUUsQ0FBQzZTLFFBQUgsRUFBRCxDQUEzQyxFQUE0RHphLGNBQTVEO0FBQ0QsR0EzbEtrQixDQTZsS25CO0FBRUE7OztBQUNBLFdBQVNrcEMsWUFBVCxDQUFzQjk1QixHQUF0QixFQUEyQmtJLE1BQTNCLEVBQW1Db2dCLE1BQW5DLEVBQTJDO0FBQ3pDLFFBQUl2NUIsR0FBRyxHQUFHO0FBQ1JnckMsY0FBUSxFQUFFLEtBREY7QUFFUm5tQyxVQUFJLEVBQUVzVSxNQUFNLENBQUN0VSxJQUZMO0FBR1JDLFFBQUUsRUFBRXFVLE1BQU0sQ0FBQ3JVLEVBSEg7QUFJUjRELFVBQUksRUFBRXlRLE1BQU0sQ0FBQ3pRLElBSkw7QUFLUjFHLFlBQU0sRUFBRW1YLE1BQU0sQ0FBQ25YLE1BTFA7QUFNUmlwQyxZQUFNLEVBQUUsa0JBQVk7QUFBRSxlQUFPanJDLEdBQUcsQ0FBQ2dyQyxRQUFKLEdBQWUsSUFBdEI7QUFBNkI7QUFOM0MsS0FBVjs7QUFRQSxRQUFJelIsTUFBSixFQUFZO0FBQUV2NUIsU0FBRyxDQUFDdTVCLE1BQUosR0FBYSxVQUFVMTBCLElBQVYsRUFBZ0JDLEVBQWhCLEVBQW9CNEQsSUFBcEIsRUFBMEIxRyxNQUExQixFQUFrQztBQUMzRCxZQUFJNkMsSUFBSixFQUFVO0FBQUU3RSxhQUFHLENBQUM2RSxJQUFKLEdBQVdzTyxRQUFPLENBQUNsQyxHQUFELEVBQU1wTSxJQUFOLENBQWxCO0FBQWdDOztBQUM1QyxZQUFJQyxFQUFKLEVBQVE7QUFBRTlFLGFBQUcsQ0FBQzhFLEVBQUosR0FBU3FPLFFBQU8sQ0FBQ2xDLEdBQUQsRUFBTW5NLEVBQU4sQ0FBaEI7QUFBNEI7O0FBQ3RDLFlBQUk0RCxJQUFKLEVBQVU7QUFBRTFJLGFBQUcsQ0FBQzBJLElBQUosR0FBV0EsSUFBWDtBQUFrQjs7QUFDOUIsWUFBSTFHLE1BQU0sS0FBSzJOLFNBQWYsRUFBMEI7QUFBRTNQLGFBQUcsQ0FBQ2dDLE1BQUosR0FBYUEsTUFBYjtBQUFzQjtBQUNuRCxPQUxhO0FBS1Y7O0FBQ0pzSCxVQUFNLENBQUMySCxHQUFELEVBQU0sY0FBTixFQUFzQkEsR0FBdEIsRUFBMkJqUixHQUEzQixDQUFOOztBQUNBLFFBQUlpUixHQUFHLENBQUN4SCxFQUFSLEVBQVk7QUFBRUgsWUFBTSxDQUFDMkgsR0FBRyxDQUFDeEgsRUFBTCxFQUFTLGNBQVQsRUFBeUJ3SCxHQUFHLENBQUN4SCxFQUE3QixFQUFpQ3pKLEdBQWpDLENBQU47QUFBOEM7O0FBRTVELFFBQUlBLEdBQUcsQ0FBQ2dyQyxRQUFSLEVBQWtCO0FBQ2hCLFVBQUkvNUIsR0FBRyxDQUFDeEgsRUFBUixFQUFZO0FBQUV3SCxXQUFHLENBQUN4SCxFQUFKLENBQU9RLEtBQVAsQ0FBYXd4QixXQUFiLEdBQTJCLENBQTNCO0FBQStCOztBQUM3QyxhQUFPLElBQVA7QUFDRDs7QUFDRCxXQUFPO0FBQUM1MkIsVUFBSSxFQUFFN0UsR0FBRyxDQUFDNkUsSUFBWDtBQUFpQkMsUUFBRSxFQUFFOUUsR0FBRyxDQUFDOEUsRUFBekI7QUFBNkI0RCxVQUFJLEVBQUUxSSxHQUFHLENBQUMwSSxJQUF2QztBQUE2QzFHLFlBQU0sRUFBRWhDLEdBQUcsQ0FBQ2dDO0FBQXpELEtBQVA7QUFDRCxHQXZuS2tCLENBeW5LbkI7QUFDQTs7O0FBQ0EsV0FBU2twQyxVQUFULENBQW9CajZCLEdBQXBCLEVBQXlCa0ksTUFBekIsRUFBaUNneUIsY0FBakMsRUFBaUQ7QUFDL0MsUUFBSWw2QixHQUFHLENBQUN4SCxFQUFSLEVBQVk7QUFDVixVQUFJLENBQUN3SCxHQUFHLENBQUN4SCxFQUFKLENBQU9RLEtBQVosRUFBbUI7QUFBRSxlQUFPdXpCLFNBQVMsQ0FBQ3ZzQixHQUFHLENBQUN4SCxFQUFMLEVBQVN5aEMsVUFBVCxDQUFULENBQThCajZCLEdBQTlCLEVBQW1Da0ksTUFBbkMsRUFBMkNneUIsY0FBM0MsQ0FBUDtBQUFtRTs7QUFDeEYsVUFBSWw2QixHQUFHLENBQUN4SCxFQUFKLENBQU9rRixLQUFQLENBQWF5OEIsYUFBakIsRUFBZ0M7QUFBRTtBQUFRO0FBQzNDOztBQUVELFFBQUlqaEMsVUFBVSxDQUFDOEcsR0FBRCxFQUFNLGNBQU4sQ0FBVixJQUFtQ0EsR0FBRyxDQUFDeEgsRUFBSixJQUFVVSxVQUFVLENBQUM4RyxHQUFHLENBQUN4SCxFQUFMLEVBQVMsY0FBVCxDQUEzRCxFQUFxRjtBQUNuRjBQLFlBQU0sR0FBRzR4QixZQUFZLENBQUM5NUIsR0FBRCxFQUFNa0ksTUFBTixFQUFjLElBQWQsQ0FBckI7O0FBQ0EsVUFBSSxDQUFDQSxNQUFMLEVBQWE7QUFBRTtBQUFRO0FBQ3hCLEtBVDhDLENBVy9DO0FBQ0E7OztBQUNBLFFBQUluYSxLQUFLLEdBQUd5WSxnQkFBZ0IsSUFBSSxDQUFDMHpCLGNBQXJCLElBQXVDbnhCLG9CQUFvQixDQUFDL0ksR0FBRCxFQUFNa0ksTUFBTSxDQUFDdFUsSUFBYixFQUFtQnNVLE1BQU0sQ0FBQ3JVLEVBQTFCLENBQXZFOztBQUNBLFFBQUk5RixLQUFKLEVBQVc7QUFDVCxXQUFLLElBQUk5QixDQUFDLEdBQUc4QixLQUFLLENBQUMvQyxNQUFOLEdBQWUsQ0FBNUIsRUFBK0JpQixDQUFDLElBQUksQ0FBcEMsRUFBdUMsRUFBRUEsQ0FBekMsRUFDRTtBQUFFbXVDLHVCQUFlLENBQUNwNkIsR0FBRCxFQUFNO0FBQUNwTSxjQUFJLEVBQUU3RixLQUFLLENBQUM5QixDQUFELENBQUwsQ0FBUzJILElBQWhCO0FBQXNCQyxZQUFFLEVBQUU5RixLQUFLLENBQUM5QixDQUFELENBQUwsQ0FBUzRILEVBQW5DO0FBQXVDNEQsY0FBSSxFQUFFeEwsQ0FBQyxHQUFHLENBQUMsRUFBRCxDQUFILEdBQVVpYyxNQUFNLENBQUN6USxJQUEvRDtBQUFxRTFHLGdCQUFNLEVBQUVtWCxNQUFNLENBQUNuWDtBQUFwRixTQUFOLENBQWY7QUFBb0g7QUFDekgsS0FIRCxNQUdPO0FBQ0xxcEMscUJBQWUsQ0FBQ3A2QixHQUFELEVBQU1rSSxNQUFOLENBQWY7QUFDRDtBQUNGOztBQUVELFdBQVNreUIsZUFBVCxDQUF5QnA2QixHQUF6QixFQUE4QmtJLE1BQTlCLEVBQXNDO0FBQ3BDLFFBQUlBLE1BQU0sQ0FBQ3pRLElBQVAsQ0FBWXpNLE1BQVosSUFBc0IsQ0FBdEIsSUFBMkJrZCxNQUFNLENBQUN6USxJQUFQLENBQVksQ0FBWixLQUFrQixFQUE3QyxJQUFtRGtLLEdBQUcsQ0FBQ3VHLE1BQU0sQ0FBQ3RVLElBQVIsRUFBY3NVLE1BQU0sQ0FBQ3JVLEVBQXJCLENBQUgsSUFBK0IsQ0FBdEYsRUFBeUY7QUFBRTtBQUFROztBQUNuRyxRQUFJMmlDLFFBQVEsR0FBR3ZELHFCQUFxQixDQUFDanpCLEdBQUQsRUFBTWtJLE1BQU4sQ0FBcEM7QUFDQXF1QixzQkFBa0IsQ0FBQ3YyQixHQUFELEVBQU1rSSxNQUFOLEVBQWNzdUIsUUFBZCxFQUF3QngyQixHQUFHLENBQUN4SCxFQUFKLEdBQVN3SCxHQUFHLENBQUN4SCxFQUFKLENBQU9RLEtBQVAsQ0FBYWxKLEVBQXRCLEdBQTJCNG9DLEdBQW5ELENBQWxCO0FBRUEyQix1QkFBbUIsQ0FBQ3I2QixHQUFELEVBQU1rSSxNQUFOLEVBQWNzdUIsUUFBZCxFQUF3QnZ1QixzQkFBc0IsQ0FBQ2pJLEdBQUQsRUFBTWtJLE1BQU4sQ0FBOUMsQ0FBbkI7QUFDQSxRQUFJb3lCLE9BQU8sR0FBRyxFQUFkO0FBRUE5RixjQUFVLENBQUN4MEIsR0FBRCxFQUFNLFVBQVVBLEdBQVYsRUFBZTQwQixVQUFmLEVBQTJCO0FBQ3pDLFVBQUksQ0FBQ0EsVUFBRCxJQUFlaGxDLE9BQU8sQ0FBQzBxQyxPQUFELEVBQVV0NkIsR0FBRyxDQUFDMDJCLE9BQWQsQ0FBUCxJQUFpQyxDQUFDLENBQXJELEVBQXdEO0FBQ3RENkQsa0JBQVUsQ0FBQ3Y2QixHQUFHLENBQUMwMkIsT0FBTCxFQUFjeHVCLE1BQWQsQ0FBVjtBQUNBb3lCLGVBQU8sQ0FBQzVvQyxJQUFSLENBQWFzTyxHQUFHLENBQUMwMkIsT0FBakI7QUFDRDs7QUFDRDJELHlCQUFtQixDQUFDcjZCLEdBQUQsRUFBTWtJLE1BQU4sRUFBYyxJQUFkLEVBQW9CRCxzQkFBc0IsQ0FBQ2pJLEdBQUQsRUFBTWtJLE1BQU4sQ0FBMUMsQ0FBbkI7QUFDRCxLQU5TLENBQVY7QUFPRCxHQWhxS2tCLENBa3FLbkI7OztBQUNBLFdBQVNzeUIscUJBQVQsQ0FBK0J4NkIsR0FBL0IsRUFBb0NuSyxJQUFwQyxFQUEwQzRrQyxrQkFBMUMsRUFBOEQ7QUFDNUQsUUFBSUMsUUFBUSxHQUFHMTZCLEdBQUcsQ0FBQ3hILEVBQUosSUFBVXdILEdBQUcsQ0FBQ3hILEVBQUosQ0FBT2tGLEtBQVAsQ0FBYXk4QixhQUF0Qzs7QUFDQSxRQUFJTyxRQUFRLElBQUksQ0FBQ0Qsa0JBQWpCLEVBQXFDO0FBQUU7QUFBUTs7QUFFL0MsUUFBSW5FLElBQUksR0FBR3QyQixHQUFHLENBQUMwMkIsT0FBZjtBQUFBLFFBQXdCa0IsS0FBeEI7QUFBQSxRQUErQnBCLFFBQVEsR0FBR3gyQixHQUFHLENBQUNpZ0IsR0FBOUM7QUFDQSxRQUFJaHRCLE1BQU0sR0FBRzRDLElBQUksSUFBSSxNQUFSLEdBQWlCeWdDLElBQUksQ0FBQ2pCLElBQXRCLEdBQTZCaUIsSUFBSSxDQUFDaEIsTUFBL0M7QUFBQSxRQUF1RDBCLElBQUksR0FBR25oQyxJQUFJLElBQUksTUFBUixHQUFpQnlnQyxJQUFJLENBQUNoQixNQUF0QixHQUErQmdCLElBQUksQ0FBQ2pCLElBQWxHLENBTDRELENBTzVEO0FBQ0E7O0FBQ0EsUUFBSXBwQyxDQUFDLEdBQUcsQ0FBUjs7QUFDQSxXQUFPQSxDQUFDLEdBQUdnSCxNQUFNLENBQUNqSSxNQUFsQixFQUEwQmlCLENBQUMsRUFBM0IsRUFBK0I7QUFDN0IyckMsV0FBSyxHQUFHM2tDLE1BQU0sQ0FBQ2hILENBQUQsQ0FBZDs7QUFDQSxVQUFJd3VDLGtCQUFrQixHQUFHN0MsS0FBSyxDQUFDMVgsTUFBTixJQUFnQixDQUFDMFgsS0FBSyxDQUFDMUYsTUFBTixDQUFhbHlCLEdBQUcsQ0FBQ2lnQixHQUFqQixDQUFwQixHQUE0QyxDQUFDMlgsS0FBSyxDQUFDMVgsTUFBekUsRUFDRTtBQUFFO0FBQU87QUFDWjs7QUFDRCxRQUFJajBCLENBQUMsSUFBSWdILE1BQU0sQ0FBQ2pJLE1BQWhCLEVBQXdCO0FBQUU7QUFBUTs7QUFDbENzckMsUUFBSSxDQUFDVixVQUFMLEdBQWtCVSxJQUFJLENBQUNULGFBQUwsR0FBcUIsSUFBdkM7O0FBRUEsYUFBUztBQUNQK0IsV0FBSyxHQUFHM2tDLE1BQU0sQ0FBQ21qQyxHQUFQLEVBQVI7O0FBQ0EsVUFBSXdCLEtBQUssQ0FBQzFYLE1BQVYsRUFBa0I7QUFDaEIwVyw4QkFBc0IsQ0FBQ2dCLEtBQUQsRUFBUVosSUFBUixDQUF0Qjs7QUFDQSxZQUFJeUQsa0JBQWtCLElBQUksQ0FBQzdDLEtBQUssQ0FBQzFGLE1BQU4sQ0FBYWx5QixHQUFHLENBQUNpZ0IsR0FBakIsQ0FBM0IsRUFBa0Q7QUFDaERnWSxzQkFBWSxDQUFDajRCLEdBQUQsRUFBTTQzQixLQUFOLEVBQWE7QUFBQ2IscUJBQVMsRUFBRTtBQUFaLFdBQWIsQ0FBWjtBQUNBO0FBQ0Q7O0FBQ0RQLGdCQUFRLEdBQUdvQixLQUFYO0FBQ0QsT0FQRCxNQU9PLElBQUk4QyxRQUFKLEVBQWM7QUFDbkJ6bkMsY0FBTSxDQUFDdkIsSUFBUCxDQUFZa21DLEtBQVo7QUFDQTtBQUNELE9BSE0sTUFHQTtBQUFFO0FBQU87QUFDakIsS0EvQjJELENBaUM1RDtBQUNBOzs7QUFDQSxRQUFJK0MsV0FBVyxHQUFHLEVBQWxCO0FBQ0EvRCwwQkFBc0IsQ0FBQ0osUUFBRCxFQUFXUSxJQUFYLENBQXRCO0FBQ0FBLFFBQUksQ0FBQ3RsQyxJQUFMLENBQVU7QUFBQzZmLGFBQU8sRUFBRW9wQixXQUFWO0FBQXVCN0UsZ0JBQVUsRUFBRVEsSUFBSSxDQUFDUjtBQUF4QyxLQUFWO0FBQ0FRLFFBQUksQ0FBQ1IsVUFBTCxHQUFrQjhCLEtBQUssQ0FBQzlCLFVBQU4sSUFBb0IsRUFBRVEsSUFBSSxDQUFDUCxhQUE3QztBQUVBLFFBQUk2RSxNQUFNLEdBQUcxaEMsVUFBVSxDQUFDOEcsR0FBRCxFQUFNLGNBQU4sQ0FBVixJQUFtQ0EsR0FBRyxDQUFDeEgsRUFBSixJQUFVVSxVQUFVLENBQUM4RyxHQUFHLENBQUN4SCxFQUFMLEVBQVMsY0FBVCxDQUFwRTs7QUFFQSxRQUFJZ0wsSUFBSSxHQUFHLFNBQVBBLElBQU8sQ0FBV3ZYLENBQVgsRUFBZTtBQUN4QixVQUFJaWMsTUFBTSxHQUFHMHZCLEtBQUssQ0FBQ3JtQixPQUFOLENBQWN0bEIsQ0FBZCxDQUFiO0FBQ0FpYyxZQUFNLENBQUNuWCxNQUFQLEdBQWdCOEUsSUFBaEI7O0FBQ0EsVUFBSStrQyxNQUFNLElBQUksQ0FBQ2QsWUFBWSxDQUFDOTVCLEdBQUQsRUFBTWtJLE1BQU4sRUFBYyxLQUFkLENBQTNCLEVBQWlEO0FBQy9DalYsY0FBTSxDQUFDakksTUFBUCxHQUFnQixDQUFoQjtBQUNBLGVBQU8sRUFBUDtBQUNEOztBQUVEMnZDLGlCQUFXLENBQUNqcEMsSUFBWixDQUFpQnNrQyx1QkFBdUIsQ0FBQ2gyQixHQUFELEVBQU1rSSxNQUFOLENBQXhDO0FBRUEsVUFBSXJkLEtBQUssR0FBR29CLENBQUMsR0FBR2duQyxxQkFBcUIsQ0FBQ2p6QixHQUFELEVBQU1rSSxNQUFOLENBQXhCLEdBQXdDdlcsR0FBRyxDQUFDc0IsTUFBRCxDQUF4RDtBQUNBb25DLHlCQUFtQixDQUFDcjZCLEdBQUQsRUFBTWtJLE1BQU4sRUFBY3JkLEtBQWQsRUFBcUJ3c0MsYUFBYSxDQUFDcjNCLEdBQUQsRUFBTWtJLE1BQU4sQ0FBbEMsQ0FBbkI7O0FBQ0EsVUFBSSxDQUFDamMsQ0FBRCxJQUFNK1QsR0FBRyxDQUFDeEgsRUFBZCxFQUFrQjtBQUFFd0gsV0FBRyxDQUFDeEgsRUFBSixDQUFPdXNCLGNBQVAsQ0FBc0I7QUFBQ254QixjQUFJLEVBQUVzVSxNQUFNLENBQUN0VSxJQUFkO0FBQW9CQyxZQUFFLEVBQUVrL0IsU0FBUyxDQUFDN3FCLE1BQUQ7QUFBakMsU0FBdEI7QUFBb0U7O0FBQ3hGLFVBQUlveUIsT0FBTyxHQUFHLEVBQWQsQ0Fid0IsQ0FleEI7O0FBQ0E5RixnQkFBVSxDQUFDeDBCLEdBQUQsRUFBTSxVQUFVQSxHQUFWLEVBQWU0MEIsVUFBZixFQUEyQjtBQUN6QyxZQUFJLENBQUNBLFVBQUQsSUFBZWhsQyxPQUFPLENBQUMwcUMsT0FBRCxFQUFVdDZCLEdBQUcsQ0FBQzAyQixPQUFkLENBQVAsSUFBaUMsQ0FBQyxDQUFyRCxFQUF3RDtBQUN0RDZELG9CQUFVLENBQUN2NkIsR0FBRyxDQUFDMDJCLE9BQUwsRUFBY3h1QixNQUFkLENBQVY7QUFDQW95QixpQkFBTyxDQUFDNW9DLElBQVIsQ0FBYXNPLEdBQUcsQ0FBQzAyQixPQUFqQjtBQUNEOztBQUNEMkQsMkJBQW1CLENBQUNyNkIsR0FBRCxFQUFNa0ksTUFBTixFQUFjLElBQWQsRUFBb0JtdkIsYUFBYSxDQUFDcjNCLEdBQUQsRUFBTWtJLE1BQU4sQ0FBakMsQ0FBbkI7QUFDRCxPQU5TLENBQVY7QUFPRCxLQXZCRDs7QUF5QkEsU0FBSyxJQUFJdlMsR0FBRyxHQUFHaWlDLEtBQUssQ0FBQ3JtQixPQUFOLENBQWN2bUIsTUFBZCxHQUF1QixDQUF0QyxFQUF5QzJLLEdBQUcsSUFBSSxDQUFoRCxFQUFtRCxFQUFFQSxHQUFyRCxFQUEwRDtBQUN4RCxVQUFJa2xDLFFBQVEsR0FBR3IzQixJQUFJLENBQUU3TixHQUFGLENBQW5CO0FBRUEsVUFBS2tsQyxRQUFMLEVBQWdCLE9BQU9BLFFBQVEsQ0FBQ0MsQ0FBaEI7QUFDakI7QUFDRixHQTN1S2tCLENBNnVLbkI7QUFDQTs7O0FBQ0EsV0FBU0MsUUFBVCxDQUFrQi82QixHQUFsQixFQUF1Qmc3QixRQUF2QixFQUFpQztBQUMvQixRQUFJQSxRQUFRLElBQUksQ0FBaEIsRUFBbUI7QUFBRTtBQUFROztBQUM3Qmg3QixPQUFHLENBQUNDLEtBQUosSUFBYSs2QixRQUFiO0FBQ0FoN0IsT0FBRyxDQUFDaWdCLEdBQUosR0FBVSxJQUFJZ1MsU0FBSixDQUFjcGdDLEdBQUcsQ0FBQ21PLEdBQUcsQ0FBQ2lnQixHQUFKLENBQVFDLE1BQVQsRUFBaUIsVUFBVTl6QixLQUFWLEVBQWlCO0FBQUUsYUFBTyxJQUFJa21DLEtBQUosQ0FDcEU1d0IsR0FBRyxDQUFDdFYsS0FBSyxDQUFDb3hCLE1BQU4sQ0FBYWhtQixJQUFiLEdBQW9Cd2pDLFFBQXJCLEVBQStCNXVDLEtBQUssQ0FBQ294QixNQUFOLENBQWE1cUIsRUFBNUMsQ0FEaUUsRUFFcEU4TyxHQUFHLENBQUN0VixLQUFLLENBQUNtMEIsSUFBTixDQUFXL29CLElBQVgsR0FBa0J3akMsUUFBbkIsRUFBNkI1dUMsS0FBSyxDQUFDbTBCLElBQU4sQ0FBVzN0QixFQUF4QyxDQUZpRSxDQUFQO0FBRzNELEtBSHVCLENBQWpCLEVBR0hvTixHQUFHLENBQUNpZ0IsR0FBSixDQUFRRSxTQUhMLENBQVY7O0FBSUEsUUFBSW5nQixHQUFHLENBQUN4SCxFQUFSLEVBQVk7QUFDVmttQixlQUFTLENBQUMxZSxHQUFHLENBQUN4SCxFQUFMLEVBQVN3SCxHQUFHLENBQUNDLEtBQWIsRUFBb0JELEdBQUcsQ0FBQ0MsS0FBSixHQUFZKzZCLFFBQWhDLEVBQTBDQSxRQUExQyxDQUFUOztBQUNBLFdBQUssSUFBSW52QixDQUFDLEdBQUc3TCxHQUFHLENBQUN4SCxFQUFKLENBQU9vTSxPQUFmLEVBQXdCMUosQ0FBQyxHQUFHMlEsQ0FBQyxDQUFDOUcsUUFBbkMsRUFBNkM3SixDQUFDLEdBQUcyUSxDQUFDLENBQUM3RyxNQUFuRCxFQUEyRDlKLENBQUMsRUFBNUQsRUFDRTtBQUFFa2tCLHFCQUFhLENBQUNwZixHQUFHLENBQUN4SCxFQUFMLEVBQVMwQyxDQUFULEVBQVksUUFBWixDQUFiO0FBQXFDO0FBQzFDO0FBQ0YsR0EzdktrQixDQTZ2S25CO0FBQ0E7OztBQUNBLFdBQVNtL0IsbUJBQVQsQ0FBNkJyNkIsR0FBN0IsRUFBa0NrSSxNQUFsQyxFQUEwQ3N1QixRQUExQyxFQUFvRHp2QixLQUFwRCxFQUEyRDtBQUN6RCxRQUFJL0csR0FBRyxDQUFDeEgsRUFBSixJQUFVLENBQUN3SCxHQUFHLENBQUN4SCxFQUFKLENBQU9RLEtBQXRCLEVBQ0U7QUFBRSxhQUFPdXpCLFNBQVMsQ0FBQ3ZzQixHQUFHLENBQUN4SCxFQUFMLEVBQVM2aEMsbUJBQVQsQ0FBVCxDQUF1Q3I2QixHQUF2QyxFQUE0Q2tJLE1BQTVDLEVBQW9Ec3VCLFFBQXBELEVBQThEenZCLEtBQTlELENBQVA7QUFBNkU7O0FBRWpGLFFBQUltQixNQUFNLENBQUNyVSxFQUFQLENBQVUyRCxJQUFWLEdBQWlCd0ksR0FBRyxDQUFDQyxLQUF6QixFQUFnQztBQUM5Qjg2QixjQUFRLENBQUMvNkIsR0FBRCxFQUFNa0ksTUFBTSxDQUFDelEsSUFBUCxDQUFZek0sTUFBWixHQUFxQixDQUFyQixJQUEwQmtkLE1BQU0sQ0FBQ3JVLEVBQVAsQ0FBVTJELElBQVYsR0FBaUIwUSxNQUFNLENBQUN0VSxJQUFQLENBQVk0RCxJQUF2RCxDQUFOLENBQVI7QUFDQTtBQUNEOztBQUNELFFBQUkwUSxNQUFNLENBQUN0VSxJQUFQLENBQVk0RCxJQUFaLEdBQW1Cd0ksR0FBRyxDQUFDcUwsUUFBSixFQUF2QixFQUF1QztBQUFFO0FBQVEsS0FSUSxDQVV6RDs7O0FBQ0EsUUFBSW5ELE1BQU0sQ0FBQ3RVLElBQVAsQ0FBWTRELElBQVosR0FBbUJ3SSxHQUFHLENBQUNDLEtBQTNCLEVBQWtDO0FBQ2hDLFVBQUk4akIsS0FBSyxHQUFHN2IsTUFBTSxDQUFDelEsSUFBUCxDQUFZek0sTUFBWixHQUFxQixDQUFyQixJQUEwQmdWLEdBQUcsQ0FBQ0MsS0FBSixHQUFZaUksTUFBTSxDQUFDdFUsSUFBUCxDQUFZNEQsSUFBbEQsQ0FBWjtBQUNBdWpDLGNBQVEsQ0FBQy82QixHQUFELEVBQU0rakIsS0FBTixDQUFSO0FBQ0E3YixZQUFNLEdBQUc7QUFBQ3RVLFlBQUksRUFBRThOLEdBQUcsQ0FBQzFCLEdBQUcsQ0FBQ0MsS0FBTCxFQUFZLENBQVosQ0FBVjtBQUEwQnBNLFVBQUUsRUFBRTZOLEdBQUcsQ0FBQ3dHLE1BQU0sQ0FBQ3JVLEVBQVAsQ0FBVTJELElBQVYsR0FBaUJ1c0IsS0FBbEIsRUFBeUI3YixNQUFNLENBQUNyVSxFQUFQLENBQVVqQixFQUFuQyxDQUFqQztBQUNDNkUsWUFBSSxFQUFFLENBQUM5RixHQUFHLENBQUN1VyxNQUFNLENBQUN6USxJQUFSLENBQUosQ0FEUDtBQUMyQjFHLGNBQU0sRUFBRW1YLE1BQU0sQ0FBQ25YO0FBRDFDLE9BQVQ7QUFFRDs7QUFDRCxRQUFJb1IsSUFBSSxHQUFHbkMsR0FBRyxDQUFDcUwsUUFBSixFQUFYOztBQUNBLFFBQUluRCxNQUFNLENBQUNyVSxFQUFQLENBQVUyRCxJQUFWLEdBQWlCMkssSUFBckIsRUFBMkI7QUFDekIrRixZQUFNLEdBQUc7QUFBQ3RVLFlBQUksRUFBRXNVLE1BQU0sQ0FBQ3RVLElBQWQ7QUFBb0JDLFVBQUUsRUFBRTZOLEdBQUcsQ0FBQ1MsSUFBRCxFQUFPcEMsT0FBTyxDQUFDQyxHQUFELEVBQU1tQyxJQUFOLENBQVAsQ0FBbUIxSyxJQUFuQixDQUF3QnpNLE1BQS9CLENBQTNCO0FBQ0N5TSxZQUFJLEVBQUUsQ0FBQ3lRLE1BQU0sQ0FBQ3pRLElBQVAsQ0FBWSxDQUFaLENBQUQsQ0FEUDtBQUN5QjFHLGNBQU0sRUFBRW1YLE1BQU0sQ0FBQ25YO0FBRHhDLE9BQVQ7QUFFRDs7QUFFRG1YLFVBQU0sQ0FBQyt5QixPQUFQLEdBQWlCeDZCLFVBQVUsQ0FBQ1QsR0FBRCxFQUFNa0ksTUFBTSxDQUFDdFUsSUFBYixFQUFtQnNVLE1BQU0sQ0FBQ3JVLEVBQTFCLENBQTNCOztBQUVBLFFBQUksQ0FBQzJpQyxRQUFMLEVBQWU7QUFBRUEsY0FBUSxHQUFHdkQscUJBQXFCLENBQUNqekIsR0FBRCxFQUFNa0ksTUFBTixDQUFoQztBQUFnRDs7QUFDakUsUUFBSWxJLEdBQUcsQ0FBQ3hILEVBQVIsRUFBWTtBQUFFMGlDLGlDQUEyQixDQUFDbDdCLEdBQUcsQ0FBQ3hILEVBQUwsRUFBUzBQLE1BQVQsRUFBaUJuQixLQUFqQixDQUEzQjtBQUFxRCxLQUFuRSxNQUNLO0FBQUU2c0IsZUFBUyxDQUFDNXpCLEdBQUQsRUFBTWtJLE1BQU4sRUFBY25CLEtBQWQsQ0FBVDtBQUFnQzs7QUFDdkMweEIsc0JBQWtCLENBQUN6NEIsR0FBRCxFQUFNdzJCLFFBQU4sRUFBZ0I1bEMsY0FBaEIsQ0FBbEI7O0FBRUEsUUFBSW9QLEdBQUcsQ0FBQzQ1QixRQUFKLElBQWdCWixVQUFVLENBQUNoNUIsR0FBRCxFQUFNMEIsR0FBRyxDQUFDMUIsR0FBRyxDQUFDK3pCLFNBQUosRUFBRCxFQUFrQixDQUFsQixDQUFULENBQTlCLEVBQ0U7QUFBRS96QixTQUFHLENBQUM0NUIsUUFBSixHQUFlLEtBQWY7QUFBdUI7QUFDNUIsR0EveEtrQixDQWl5S25CO0FBQ0E7OztBQUNBLFdBQVNzQiwyQkFBVCxDQUFxQzFpQyxFQUFyQyxFQUF5QzBQLE1BQXpDLEVBQWlEbkIsS0FBakQsRUFBd0Q7QUFDdEQsUUFBSS9HLEdBQUcsR0FBR3hILEVBQUUsQ0FBQ3dILEdBQWI7QUFBQSxRQUFrQjRFLE9BQU8sR0FBR3BNLEVBQUUsQ0FBQ29NLE9BQS9CO0FBQUEsUUFBd0NoUixJQUFJLEdBQUdzVSxNQUFNLENBQUN0VSxJQUF0RDtBQUFBLFFBQTREQyxFQUFFLEdBQUdxVSxNQUFNLENBQUNyVSxFQUF4RTtBQUVBLFFBQUlzbkMsa0JBQWtCLEdBQUcsS0FBekI7QUFBQSxRQUFnQ0MsZUFBZSxHQUFHeG5DLElBQUksQ0FBQzRELElBQXZEOztBQUNBLFFBQUksQ0FBQ2dCLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVzJaLFlBQWhCLEVBQThCO0FBQzVCMGtCLHFCQUFlLEdBQUdyNkIsTUFBTSxDQUFDOEosVUFBVSxDQUFDOUssT0FBTyxDQUFDQyxHQUFELEVBQU1wTSxJQUFJLENBQUM0RCxJQUFYLENBQVIsQ0FBWCxDQUF4QjtBQUNBd0ksU0FBRyxDQUFDVSxJQUFKLENBQVMwNkIsZUFBVCxFQUEwQnZuQyxFQUFFLENBQUMyRCxJQUFILEdBQVUsQ0FBcEMsRUFBdUMsVUFBVUEsSUFBVixFQUFnQjtBQUNyRCxZQUFJQSxJQUFJLElBQUlvTixPQUFPLENBQUNrSCxPQUFwQixFQUE2QjtBQUMzQnF2Qiw0QkFBa0IsR0FBRyxJQUFyQjtBQUNBLGlCQUFPLElBQVA7QUFDRDtBQUNGLE9BTEQ7QUFNRDs7QUFFRCxRQUFJbjdCLEdBQUcsQ0FBQ2lnQixHQUFKLENBQVE5eUIsUUFBUixDQUFpQithLE1BQU0sQ0FBQ3RVLElBQXhCLEVBQThCc1UsTUFBTSxDQUFDclUsRUFBckMsSUFBMkMsQ0FBQyxDQUFoRCxFQUNFO0FBQUVpRiwwQkFBb0IsQ0FBQ04sRUFBRCxDQUFwQjtBQUEyQjs7QUFFL0JvN0IsYUFBUyxDQUFDNXpCLEdBQUQsRUFBTWtJLE1BQU4sRUFBY25CLEtBQWQsRUFBcUJtRixjQUFjLENBQUMxVCxFQUFELENBQW5DLENBQVQ7O0FBRUEsUUFBSSxDQUFDQSxFQUFFLENBQUN1RSxPQUFILENBQVcyWixZQUFoQixFQUE4QjtBQUM1QjFXLFNBQUcsQ0FBQ1UsSUFBSixDQUFTMDZCLGVBQVQsRUFBMEJ4bkMsSUFBSSxDQUFDNEQsSUFBTCxHQUFZMFEsTUFBTSxDQUFDelEsSUFBUCxDQUFZek0sTUFBbEQsRUFBMEQsVUFBVXdNLElBQVYsRUFBZ0I7QUFDeEUsWUFBSS9CLEdBQUcsR0FBR2tXLFVBQVUsQ0FBQ25VLElBQUQsQ0FBcEI7O0FBQ0EsWUFBSS9CLEdBQUcsR0FBR21QLE9BQU8sQ0FBQ21ILGFBQWxCLEVBQWlDO0FBQy9CbkgsaUJBQU8sQ0FBQ2tILE9BQVIsR0FBa0J0VSxJQUFsQjtBQUNBb04saUJBQU8sQ0FBQ21ILGFBQVIsR0FBd0J0VyxHQUF4QjtBQUNBbVAsaUJBQU8sQ0FBQ29ILGNBQVIsR0FBeUIsSUFBekI7QUFDQW12Qiw0QkFBa0IsR0FBRyxLQUFyQjtBQUNEO0FBQ0YsT0FSRDs7QUFTQSxVQUFJQSxrQkFBSixFQUF3QjtBQUFFM2lDLFVBQUUsQ0FBQ1EsS0FBSCxDQUFTNHhCLGFBQVQsR0FBeUIsSUFBekI7QUFBZ0M7QUFDM0Q7O0FBRURya0IsbUJBQWUsQ0FBQ3ZHLEdBQUQsRUFBTXBNLElBQUksQ0FBQzRELElBQVgsQ0FBZjtBQUNBeXZCLGVBQVcsQ0FBQ3p1QixFQUFELEVBQUssR0FBTCxDQUFYO0FBRUEsUUFBSW1tQixPQUFPLEdBQUd6VyxNQUFNLENBQUN6USxJQUFQLENBQVl6TSxNQUFaLElBQXNCNkksRUFBRSxDQUFDMkQsSUFBSCxHQUFVNUQsSUFBSSxDQUFDNEQsSUFBckMsSUFBNkMsQ0FBM0QsQ0FuQ3NELENBb0N0RDs7QUFDQSxRQUFJMFEsTUFBTSxDQUFDQyxJQUFYLEVBQ0U7QUFBRXVXLGVBQVMsQ0FBQ2xtQixFQUFELENBQVQ7QUFBZ0IsS0FEcEIsTUFFSyxJQUFJNUUsSUFBSSxDQUFDNEQsSUFBTCxJQUFhM0QsRUFBRSxDQUFDMkQsSUFBaEIsSUFBd0IwUSxNQUFNLENBQUN6USxJQUFQLENBQVl6TSxNQUFaLElBQXNCLENBQTlDLElBQW1ELENBQUMwb0MsaUJBQWlCLENBQUNsN0IsRUFBRSxDQUFDd0gsR0FBSixFQUFTa0ksTUFBVCxDQUF6RSxFQUNIO0FBQUVrWCxtQkFBYSxDQUFDNW1CLEVBQUQsRUFBSzVFLElBQUksQ0FBQzRELElBQVYsRUFBZ0IsTUFBaEIsQ0FBYjtBQUF1QyxLQUR0QyxNQUdIO0FBQUVrbkIsZUFBUyxDQUFDbG1CLEVBQUQsRUFBSzVFLElBQUksQ0FBQzRELElBQVYsRUFBZ0IzRCxFQUFFLENBQUMyRCxJQUFILEdBQVUsQ0FBMUIsRUFBNkJtbkIsT0FBN0IsQ0FBVDtBQUFpRDs7QUFFckQsUUFBSTBjLGNBQWMsR0FBR25pQyxVQUFVLENBQUNWLEVBQUQsRUFBSyxTQUFMLENBQS9CO0FBQUEsUUFBZ0Q4aUMsYUFBYSxHQUFHcGlDLFVBQVUsQ0FBQ1YsRUFBRCxFQUFLLFFBQUwsQ0FBMUU7O0FBQ0EsUUFBSThpQyxhQUFhLElBQUlELGNBQXJCLEVBQXFDO0FBQ25DLFVBQUl0c0MsR0FBRyxHQUFHO0FBQ1I2RSxZQUFJLEVBQUVBLElBREU7QUFDSUMsVUFBRSxFQUFFQSxFQURSO0FBRVI0RCxZQUFJLEVBQUV5USxNQUFNLENBQUN6USxJQUZMO0FBR1J3akMsZUFBTyxFQUFFL3lCLE1BQU0sQ0FBQyt5QixPQUhSO0FBSVJscUMsY0FBTSxFQUFFbVgsTUFBTSxDQUFDblg7QUFKUCxPQUFWOztBQU1BLFVBQUl1cUMsYUFBSixFQUFtQjtBQUFFcnFCLG1CQUFXLENBQUN6WSxFQUFELEVBQUssUUFBTCxFQUFlQSxFQUFmLEVBQW1CekosR0FBbkIsQ0FBWDtBQUFxQzs7QUFDMUQsVUFBSXNzQyxjQUFKLEVBQW9CO0FBQUUsU0FBQzdpQyxFQUFFLENBQUNRLEtBQUgsQ0FBUzB4QixVQUFULEtBQXdCbHlCLEVBQUUsQ0FBQ1EsS0FBSCxDQUFTMHhCLFVBQVQsR0FBc0IsRUFBOUMsQ0FBRCxFQUFvRGg1QixJQUFwRCxDQUF5RDNDLEdBQXpEO0FBQWdFO0FBQ3ZGOztBQUNEeUosTUFBRSxDQUFDb00sT0FBSCxDQUFXZ2YsaUJBQVgsR0FBK0IsSUFBL0I7QUFDRDs7QUFFRCxXQUFTMlgsYUFBVCxDQUFzQnY3QixHQUF0QixFQUEyQmhMLElBQTNCLEVBQWlDcEIsSUFBakMsRUFBdUNDLEVBQXZDLEVBQTJDOUMsTUFBM0MsRUFBbUQ7QUFDakQsUUFBSXlxQyxNQUFKOztBQUVBLFFBQUksQ0FBQzNuQyxFQUFMLEVBQVM7QUFBRUEsUUFBRSxHQUFHRCxJQUFMO0FBQVk7O0FBQ3ZCLFFBQUkrTixHQUFHLENBQUM5TixFQUFELEVBQUtELElBQUwsQ0FBSCxHQUFnQixDQUFwQixFQUF1QjtBQUFHNG5DLFlBQU0sR0FBRyxDQUFDM25DLEVBQUQsRUFBS0QsSUFBTCxDQUFULEVBQXFCQSxJQUFJLEdBQUc0bkMsTUFBTSxDQUFDLENBQUQsQ0FBbEMsRUFBdUMzbkMsRUFBRSxHQUFHMm5DLE1BQU0sQ0FBQyxDQUFELENBQW5EO0FBQTBEOztBQUNuRixRQUFJLE9BQU94bUMsSUFBUCxJQUFlLFFBQW5CLEVBQTZCO0FBQUVBLFVBQUksR0FBR2dMLEdBQUcsQ0FBQ3k3QixVQUFKLENBQWV6bUMsSUFBZixDQUFQO0FBQThCOztBQUM3RGlsQyxjQUFVLENBQUNqNkIsR0FBRCxFQUFNO0FBQUNwTSxVQUFJLEVBQUVBLElBQVA7QUFBYUMsUUFBRSxFQUFFQSxFQUFqQjtBQUFxQjRELFVBQUksRUFBRXpDLElBQTNCO0FBQWlDakUsWUFBTSxFQUFFQTtBQUF6QyxLQUFOLENBQVY7QUFDRCxHQXAyS2tCLENBczJLbkI7OztBQUVBLFdBQVMycUMsbUJBQVQsQ0FBNkJ2cUMsR0FBN0IsRUFBa0N5QyxJQUFsQyxFQUF3Q0MsRUFBeEMsRUFBNENpTixJQUE1QyxFQUFrRDtBQUNoRCxRQUFJak4sRUFBRSxHQUFHMUMsR0FBRyxDQUFDcUcsSUFBYixFQUFtQjtBQUNqQnJHLFNBQUcsQ0FBQ3FHLElBQUosSUFBWXNKLElBQVo7QUFDRCxLQUZELE1BRU8sSUFBSWxOLElBQUksR0FBR3pDLEdBQUcsQ0FBQ3FHLElBQWYsRUFBcUI7QUFDMUJyRyxTQUFHLENBQUNxRyxJQUFKLEdBQVc1RCxJQUFYO0FBQ0F6QyxTQUFHLENBQUN5QixFQUFKLEdBQVMsQ0FBVDtBQUNEO0FBQ0YsR0EvMktrQixDQWkzS25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxXQUFTK29DLGVBQVQsQ0FBeUJuckMsS0FBekIsRUFBZ0NvRCxJQUFoQyxFQUFzQ0MsRUFBdEMsRUFBMENpTixJQUExQyxFQUFnRDtBQUM5QyxTQUFLLElBQUk3VSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdUUsS0FBSyxDQUFDeEYsTUFBMUIsRUFBa0MsRUFBRWlCLENBQXBDLEVBQXVDO0FBQ3JDLFVBQUkydkMsR0FBRyxHQUFHcHJDLEtBQUssQ0FBQ3ZFLENBQUQsQ0FBZjtBQUFBLFVBQW9CNFMsRUFBRSxHQUFHLElBQXpCOztBQUNBLFVBQUkrOEIsR0FBRyxDQUFDMWIsTUFBUixFQUFnQjtBQUNkLFlBQUksQ0FBQzBiLEdBQUcsQ0FBQ0MsTUFBVCxFQUFpQjtBQUFFRCxhQUFHLEdBQUdwckMsS0FBSyxDQUFDdkUsQ0FBRCxDQUFMLEdBQVcydkMsR0FBRyxDQUFDdkosUUFBSixFQUFqQjtBQUFpQ3VKLGFBQUcsQ0FBQ0MsTUFBSixHQUFhLElBQWI7QUFBb0I7O0FBQ3hFLGFBQUssSUFBSXZsQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHc2xDLEdBQUcsQ0FBQzFiLE1BQUosQ0FBV2wxQixNQUEvQixFQUF1Q3NMLENBQUMsRUFBeEMsRUFBNEM7QUFDMUNvbEMsNkJBQW1CLENBQUNFLEdBQUcsQ0FBQzFiLE1BQUosQ0FBVzVwQixDQUFYLEVBQWNrbkIsTUFBZixFQUF1QjVwQixJQUF2QixFQUE2QkMsRUFBN0IsRUFBaUNpTixJQUFqQyxDQUFuQjtBQUNBNDZCLDZCQUFtQixDQUFDRSxHQUFHLENBQUMxYixNQUFKLENBQVc1cEIsQ0FBWCxFQUFjaXFCLElBQWYsRUFBcUIzc0IsSUFBckIsRUFBMkJDLEVBQTNCLEVBQStCaU4sSUFBL0IsQ0FBbkI7QUFDRDs7QUFDRDtBQUNEOztBQUNELFdBQUssSUFBSWhLLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUc4a0MsR0FBRyxDQUFDcnFCLE9BQUosQ0FBWXZtQixNQUFwQyxFQUE0QyxFQUFFOEwsR0FBOUMsRUFBbUQ7QUFDakQsWUFBSW5DLEdBQUcsR0FBR2luQyxHQUFHLENBQUNycUIsT0FBSixDQUFZemEsR0FBWixDQUFWOztBQUNBLFlBQUlqRCxFQUFFLEdBQUdjLEdBQUcsQ0FBQ2YsSUFBSixDQUFTNEQsSUFBbEIsRUFBd0I7QUFDdEI3QyxhQUFHLENBQUNmLElBQUosR0FBVzhOLEdBQUcsQ0FBQy9NLEdBQUcsQ0FBQ2YsSUFBSixDQUFTNEQsSUFBVCxHQUFnQnNKLElBQWpCLEVBQXVCbk0sR0FBRyxDQUFDZixJQUFKLENBQVNoQixFQUFoQyxDQUFkO0FBQ0ErQixhQUFHLENBQUNkLEVBQUosR0FBUzZOLEdBQUcsQ0FBQy9NLEdBQUcsQ0FBQ2QsRUFBSixDQUFPMkQsSUFBUCxHQUFjc0osSUFBZixFQUFxQm5NLEdBQUcsQ0FBQ2QsRUFBSixDQUFPakIsRUFBNUIsQ0FBWjtBQUNELFNBSEQsTUFHTyxJQUFJZ0IsSUFBSSxJQUFJZSxHQUFHLENBQUNkLEVBQUosQ0FBTzJELElBQW5CLEVBQXlCO0FBQzlCcUgsWUFBRSxHQUFHLEtBQUw7QUFDQTtBQUNEO0FBQ0Y7O0FBQ0QsVUFBSSxDQUFDQSxFQUFMLEVBQVM7QUFDUHJPLGFBQUssQ0FBQzBCLE1BQU4sQ0FBYSxDQUFiLEVBQWdCakcsQ0FBQyxHQUFHLENBQXBCO0FBQ0FBLFNBQUMsR0FBRyxDQUFKO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFdBQVNzdUMsVUFBVCxDQUFvQmpFLElBQXBCLEVBQTBCcHVCLE1BQTFCLEVBQWtDO0FBQ2hDLFFBQUl0VSxJQUFJLEdBQUdzVSxNQUFNLENBQUN0VSxJQUFQLENBQVk0RCxJQUF2QjtBQUFBLFFBQTZCM0QsRUFBRSxHQUFHcVUsTUFBTSxDQUFDclUsRUFBUCxDQUFVMkQsSUFBNUM7QUFBQSxRQUFrRHNKLElBQUksR0FBR29ILE1BQU0sQ0FBQ3pRLElBQVAsQ0FBWXpNLE1BQVosSUFBc0I2SSxFQUFFLEdBQUdELElBQTNCLElBQW1DLENBQTVGO0FBQ0ErbkMsbUJBQWUsQ0FBQ3JGLElBQUksQ0FBQ2pCLElBQU4sRUFBWXpoQyxJQUFaLEVBQWtCQyxFQUFsQixFQUFzQmlOLElBQXRCLENBQWY7QUFDQTY2QixtQkFBZSxDQUFDckYsSUFBSSxDQUFDaEIsTUFBTixFQUFjMWhDLElBQWQsRUFBb0JDLEVBQXBCLEVBQXdCaU4sSUFBeEIsQ0FBZjtBQUNELEdBeDVLa0IsQ0EwNUtuQjtBQUNBO0FBQ0E7OztBQUNBLFdBQVNnN0IsVUFBVCxDQUFvQjk3QixHQUFwQixFQUF5Qis3QixNQUF6QixFQUFpQ0MsVUFBakMsRUFBNkMxckIsRUFBN0MsRUFBaUQ7QUFDL0MsUUFBSXRQLEVBQUUsR0FBRys2QixNQUFUO0FBQUEsUUFBaUJ2a0MsSUFBSSxHQUFHdWtDLE1BQXhCOztBQUNBLFFBQUksT0FBT0EsTUFBUCxJQUFpQixRQUFyQixFQUErQjtBQUFFdmtDLFVBQUksR0FBR3VJLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNaUMsUUFBUSxDQUFDakMsR0FBRCxFQUFNKzdCLE1BQU4sQ0FBZCxDQUFkO0FBQTZDLEtBQTlFLE1BQ0s7QUFBRS82QixRQUFFLEdBQUdELE1BQU0sQ0FBQ2c3QixNQUFELENBQVg7QUFBc0I7O0FBQzdCLFFBQUkvNkIsRUFBRSxJQUFJLElBQVYsRUFBZ0I7QUFBRSxhQUFPLElBQVA7QUFBYTs7QUFDL0IsUUFBSXNQLEVBQUUsQ0FBQzlZLElBQUQsRUFBT3dKLEVBQVAsQ0FBRixJQUFnQmhCLEdBQUcsQ0FBQ3hILEVBQXhCLEVBQTRCO0FBQUU0bUIsbUJBQWEsQ0FBQ3BmLEdBQUcsQ0FBQ3hILEVBQUwsRUFBU3dJLEVBQVQsRUFBYWc3QixVQUFiLENBQWI7QUFBd0M7O0FBQ3RFLFdBQU94a0MsSUFBUDtBQUNELEdBcDZLa0IsQ0FzNktuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBLFdBQVN5a0MsU0FBVCxDQUFtQjU3QixLQUFuQixFQUEwQjtBQUN4QixTQUFLQSxLQUFMLEdBQWFBLEtBQWI7QUFDQSxTQUFLN1UsTUFBTCxHQUFjLElBQWQ7QUFDQSxRQUFJcVYsTUFBTSxHQUFHLENBQWI7O0FBQ0EsU0FBSyxJQUFJNVUsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR29VLEtBQUssQ0FBQ3JWLE1BQTFCLEVBQWtDLEVBQUVpQixDQUFwQyxFQUF1QztBQUNyQ29VLFdBQUssQ0FBQ3BVLENBQUQsQ0FBTCxDQUFTVCxNQUFULEdBQWtCLElBQWxCO0FBQ0FxVixZQUFNLElBQUlSLEtBQUssQ0FBQ3BVLENBQUQsQ0FBTCxDQUFTNFUsTUFBbkI7QUFDRDs7QUFDRCxTQUFLQSxNQUFMLEdBQWNBLE1BQWQ7QUFDRDs7QUFFRG83QixXQUFTLENBQUN2dEMsU0FBVixHQUFzQjtBQUNwQjhSLGFBQVMsRUFBRSxxQkFBVztBQUFFLGFBQU8sS0FBS0gsS0FBTCxDQUFXclYsTUFBbEI7QUFBMEIsS0FEOUI7QUFHcEI7QUFDQWt4QyxlQUFXLEVBQUUscUJBQVNqbEMsRUFBVCxFQUFhdkgsQ0FBYixFQUFnQjtBQUMzQixXQUFLLElBQUl6RCxDQUFDLEdBQUdnTCxFQUFSLEVBQVkvTCxDQUFDLEdBQUcrTCxFQUFFLEdBQUd2SCxDQUExQixFQUE2QnpELENBQUMsR0FBR2YsQ0FBakMsRUFBb0MsRUFBRWUsQ0FBdEMsRUFBeUM7QUFDdkMsWUFBSXVMLElBQUksR0FBRyxLQUFLNkksS0FBTCxDQUFXcFUsQ0FBWCxDQUFYO0FBQ0EsYUFBSzRVLE1BQUwsSUFBZXJKLElBQUksQ0FBQ3FKLE1BQXBCO0FBQ0F3TCxtQkFBVyxDQUFDN1UsSUFBRCxDQUFYO0FBQ0F5WixtQkFBVyxDQUFDelosSUFBRCxFQUFPLFFBQVAsQ0FBWDtBQUNEOztBQUNELFdBQUs2SSxLQUFMLENBQVduTyxNQUFYLENBQWtCK0UsRUFBbEIsRUFBc0J2SCxDQUF0QjtBQUNELEtBWm1CO0FBY3BCO0FBQ0ExQyxZQUFRLEVBQUUsa0JBQVNxVCxLQUFULEVBQWdCO0FBQ3hCQSxXQUFLLENBQUMzTyxJQUFOLENBQVc3QyxLQUFYLENBQWlCd1IsS0FBakIsRUFBd0IsS0FBS0EsS0FBN0I7QUFDRCxLQWpCbUI7QUFtQnBCO0FBQ0E7QUFDQTg3QixlQUFXLEVBQUUscUJBQVNsbEMsRUFBVCxFQUFhb0osS0FBYixFQUFvQlEsTUFBcEIsRUFBNEI7QUFDdkMsV0FBS0EsTUFBTCxJQUFlQSxNQUFmO0FBQ0EsV0FBS1IsS0FBTCxHQUFhLEtBQUtBLEtBQUwsQ0FBV3ZWLEtBQVgsQ0FBaUIsQ0FBakIsRUFBb0JtTSxFQUFwQixFQUF3QmUsTUFBeEIsQ0FBK0JxSSxLQUEvQixFQUFzQ3JJLE1BQXRDLENBQTZDLEtBQUtxSSxLQUFMLENBQVd2VixLQUFYLENBQWlCbU0sRUFBakIsQ0FBN0MsQ0FBYjs7QUFDQSxXQUFLLElBQUloTCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHb1UsS0FBSyxDQUFDclYsTUFBMUIsRUFBa0MsRUFBRWlCLENBQXBDLEVBQXVDO0FBQUVvVSxhQUFLLENBQUNwVSxDQUFELENBQUwsQ0FBU1QsTUFBVCxHQUFrQixJQUFsQjtBQUF5QjtBQUNuRSxLQXpCbUI7QUEyQnBCO0FBQ0E0d0MsU0FBSyxFQUFFLGVBQVNubEMsRUFBVCxFQUFhdkgsQ0FBYixFQUFnQjRnQixFQUFoQixFQUFvQjtBQUN6QixXQUFLLElBQUlwbEIsQ0FBQyxHQUFHK0wsRUFBRSxHQUFHdkgsQ0FBbEIsRUFBcUJ1SCxFQUFFLEdBQUcvTCxDQUExQixFQUE2QixFQUFFK0wsRUFBL0IsRUFDRTtBQUFFLFlBQUlxWixFQUFFLENBQUMsS0FBS2pRLEtBQUwsQ0FBV3BKLEVBQVgsQ0FBRCxDQUFOLEVBQXdCO0FBQUUsaUJBQU8sSUFBUDtBQUFhO0FBQUU7QUFDOUM7QUEvQm1CLEdBQXRCOztBQWtDQSxXQUFTb2xDLFdBQVQsQ0FBcUIvN0IsUUFBckIsRUFBK0I7QUFDN0IsU0FBS0EsUUFBTCxHQUFnQkEsUUFBaEI7QUFDQSxRQUFJSixJQUFJLEdBQUcsQ0FBWDtBQUFBLFFBQWNXLE1BQU0sR0FBRyxDQUF2Qjs7QUFDQSxTQUFLLElBQUk1VSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcVUsUUFBUSxDQUFDdFYsTUFBN0IsRUFBcUMsRUFBRWlCLENBQXZDLEVBQTBDO0FBQ3hDLFVBQUkyRyxFQUFFLEdBQUcwTixRQUFRLENBQUNyVSxDQUFELENBQWpCO0FBQ0FpVSxVQUFJLElBQUl0TixFQUFFLENBQUM0TixTQUFILEVBQVI7QUFBd0JLLFlBQU0sSUFBSWpPLEVBQUUsQ0FBQ2lPLE1BQWI7QUFDeEJqTyxRQUFFLENBQUNwSCxNQUFILEdBQVksSUFBWjtBQUNEOztBQUNELFNBQUswVSxJQUFMLEdBQVlBLElBQVo7QUFDQSxTQUFLVyxNQUFMLEdBQWNBLE1BQWQ7QUFDQSxTQUFLclYsTUFBTCxHQUFjLElBQWQ7QUFDRDs7QUFFRDZ3QyxhQUFXLENBQUMzdEMsU0FBWixHQUF3QjtBQUN0QjhSLGFBQVMsRUFBRSxxQkFBVztBQUFFLGFBQU8sS0FBS04sSUFBWjtBQUFrQixLQURwQjtBQUd0Qmc4QixlQUFXLEVBQUUscUJBQVNqbEMsRUFBVCxFQUFhdkgsQ0FBYixFQUFnQjtBQUMzQixXQUFLd1EsSUFBTCxJQUFheFEsQ0FBYjs7QUFDQSxXQUFLLElBQUl6RCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtxVSxRQUFMLENBQWN0VixNQUFsQyxFQUEwQyxFQUFFaUIsQ0FBNUMsRUFBK0M7QUFDN0MsWUFBSW1CLEtBQUssR0FBRyxLQUFLa1QsUUFBTCxDQUFjclUsQ0FBZCxDQUFaO0FBQUEsWUFBOEJzVSxFQUFFLEdBQUduVCxLQUFLLENBQUNvVCxTQUFOLEVBQW5DOztBQUNBLFlBQUl2SixFQUFFLEdBQUdzSixFQUFULEVBQWE7QUFDWCxjQUFJZ3ZCLEVBQUUsR0FBR2orQixJQUFJLENBQUNDLEdBQUwsQ0FBUzdCLENBQVQsRUFBWTZRLEVBQUUsR0FBR3RKLEVBQWpCLENBQVQ7QUFBQSxjQUErQnFsQyxTQUFTLEdBQUdsdkMsS0FBSyxDQUFDeVQsTUFBakQ7QUFDQXpULGVBQUssQ0FBQzh1QyxXQUFOLENBQWtCamxDLEVBQWxCLEVBQXNCczRCLEVBQXRCO0FBQ0EsZUFBSzF1QixNQUFMLElBQWV5N0IsU0FBUyxHQUFHbHZDLEtBQUssQ0FBQ3lULE1BQWpDOztBQUNBLGNBQUlOLEVBQUUsSUFBSWd2QixFQUFWLEVBQWM7QUFBRSxpQkFBS2p2QixRQUFMLENBQWNwTyxNQUFkLENBQXFCakcsQ0FBQyxFQUF0QixFQUEwQixDQUExQjtBQUE4Qm1CLGlCQUFLLENBQUM1QixNQUFOLEdBQWUsSUFBZjtBQUFzQjs7QUFDcEUsY0FBSSxDQUFDa0UsQ0FBQyxJQUFJNi9CLEVBQU4sS0FBYSxDQUFqQixFQUFvQjtBQUFFO0FBQU87O0FBQzdCdDRCLFlBQUUsR0FBRyxDQUFMO0FBQ0QsU0FQRCxNQU9PO0FBQUVBLFlBQUUsSUFBSXNKLEVBQU47QUFBVztBQUNyQixPQVowQixDQWEzQjtBQUNBOzs7QUFDQSxVQUFJLEtBQUtMLElBQUwsR0FBWXhRLENBQVosR0FBZ0IsRUFBaEIsS0FDQyxLQUFLNFEsUUFBTCxDQUFjdFYsTUFBZCxHQUF1QixDQUF2QixJQUE0QixFQUFFLEtBQUtzVixRQUFMLENBQWMsQ0FBZCxhQUE0QjI3QixTQUE5QixDQUQ3QixDQUFKLEVBQzRFO0FBQzFFLFlBQUk1N0IsS0FBSyxHQUFHLEVBQVo7QUFDQSxhQUFLclQsUUFBTCxDQUFjcVQsS0FBZDtBQUNBLGFBQUtDLFFBQUwsR0FBZ0IsQ0FBQyxJQUFJMjdCLFNBQUosQ0FBYzU3QixLQUFkLENBQUQsQ0FBaEI7QUFDQSxhQUFLQyxRQUFMLENBQWMsQ0FBZCxFQUFpQjlVLE1BQWpCLEdBQTBCLElBQTFCO0FBQ0Q7QUFDRixLQXpCcUI7QUEyQnRCd0IsWUFBUSxFQUFFLGtCQUFTcVQsS0FBVCxFQUFnQjtBQUN4QixXQUFLLElBQUlwVSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtxVSxRQUFMLENBQWN0VixNQUFsQyxFQUEwQyxFQUFFaUIsQ0FBNUMsRUFBK0M7QUFBRSxhQUFLcVUsUUFBTCxDQUFjclUsQ0FBZCxFQUFpQmUsUUFBakIsQ0FBMEJxVCxLQUExQjtBQUFtQztBQUNyRixLQTdCcUI7QUErQnRCODdCLGVBQVcsRUFBRSxxQkFBU2xsQyxFQUFULEVBQWFvSixLQUFiLEVBQW9CUSxNQUFwQixFQUE0QjtBQUN2QyxXQUFLWCxJQUFMLElBQWFHLEtBQUssQ0FBQ3JWLE1BQW5CO0FBQ0EsV0FBSzZWLE1BQUwsSUFBZUEsTUFBZjs7QUFDQSxXQUFLLElBQUk1VSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtxVSxRQUFMLENBQWN0VixNQUFsQyxFQUEwQyxFQUFFaUIsQ0FBNUMsRUFBK0M7QUFDN0MsWUFBSW1CLEtBQUssR0FBRyxLQUFLa1QsUUFBTCxDQUFjclUsQ0FBZCxDQUFaO0FBQUEsWUFBOEJzVSxFQUFFLEdBQUduVCxLQUFLLENBQUNvVCxTQUFOLEVBQW5DOztBQUNBLFlBQUl2SixFQUFFLElBQUlzSixFQUFWLEVBQWM7QUFDWm5ULGVBQUssQ0FBQyt1QyxXQUFOLENBQWtCbGxDLEVBQWxCLEVBQXNCb0osS0FBdEIsRUFBNkJRLE1BQTdCOztBQUNBLGNBQUl6VCxLQUFLLENBQUNpVCxLQUFOLElBQWVqVCxLQUFLLENBQUNpVCxLQUFOLENBQVlyVixNQUFaLEdBQXFCLEVBQXhDLEVBQTRDO0FBQzFDO0FBQ0E7QUFDQSxnQkFBSXV4QyxTQUFTLEdBQUdudkMsS0FBSyxDQUFDaVQsS0FBTixDQUFZclYsTUFBWixHQUFxQixFQUFyQixHQUEwQixFQUExQzs7QUFDQSxpQkFBSyxJQUFJbUcsR0FBRyxHQUFHb3JDLFNBQWYsRUFBMEJwckMsR0FBRyxHQUFHL0QsS0FBSyxDQUFDaVQsS0FBTixDQUFZclYsTUFBNUMsR0FBcUQ7QUFDbkQsa0JBQUl3eEMsSUFBSSxHQUFHLElBQUlQLFNBQUosQ0FBYzd1QyxLQUFLLENBQUNpVCxLQUFOLENBQVl2VixLQUFaLENBQWtCcUcsR0FBbEIsRUFBdUJBLEdBQUcsSUFBSSxFQUE5QixDQUFkLENBQVg7QUFDQS9ELG1CQUFLLENBQUN5VCxNQUFOLElBQWdCMjdCLElBQUksQ0FBQzM3QixNQUFyQjtBQUNBLG1CQUFLUCxRQUFMLENBQWNwTyxNQUFkLENBQXFCLEVBQUVqRyxDQUF2QixFQUEwQixDQUExQixFQUE2QnV3QyxJQUE3QjtBQUNBQSxrQkFBSSxDQUFDaHhDLE1BQUwsR0FBYyxJQUFkO0FBQ0Q7O0FBQ0Q0QixpQkFBSyxDQUFDaVQsS0FBTixHQUFjalQsS0FBSyxDQUFDaVQsS0FBTixDQUFZdlYsS0FBWixDQUFrQixDQUFsQixFQUFxQnl4QyxTQUFyQixDQUFkO0FBQ0EsaUJBQUtFLFVBQUw7QUFDRDs7QUFDRDtBQUNEOztBQUNEeGxDLFVBQUUsSUFBSXNKLEVBQU47QUFDRDtBQUNGLEtBdkRxQjtBQXlEdEI7QUFDQWs4QixjQUFVLEVBQUUsc0JBQVc7QUFDckIsVUFBSSxLQUFLbjhCLFFBQUwsQ0FBY3RWLE1BQWQsSUFBd0IsRUFBNUIsRUFBZ0M7QUFBRTtBQUFROztBQUMxQyxVQUFJMHhDLEVBQUUsR0FBRyxJQUFUOztBQUNBLFNBQUc7QUFDRCxZQUFJQyxPQUFPLEdBQUdELEVBQUUsQ0FBQ3A4QixRQUFILENBQVlwTyxNQUFaLENBQW1Cd3FDLEVBQUUsQ0FBQ3A4QixRQUFILENBQVl0VixNQUFaLEdBQXFCLENBQXhDLEVBQTJDLENBQTNDLENBQWQ7QUFDQSxZQUFJNHhDLE9BQU8sR0FBRyxJQUFJUCxXQUFKLENBQWdCTSxPQUFoQixDQUFkOztBQUNBLFlBQUksQ0FBQ0QsRUFBRSxDQUFDbHhDLE1BQVIsRUFBZ0I7QUFBRTtBQUNoQixjQUFJd1gsSUFBSSxHQUFHLElBQUlxNUIsV0FBSixDQUFnQkssRUFBRSxDQUFDcDhCLFFBQW5CLENBQVg7QUFDQTBDLGNBQUksQ0FBQ3hYLE1BQUwsR0FBY2t4QyxFQUFkO0FBQ0FBLFlBQUUsQ0FBQ3A4QixRQUFILEdBQWMsQ0FBQzBDLElBQUQsRUFBTzQ1QixPQUFQLENBQWQ7QUFDQUYsWUFBRSxHQUFHMTVCLElBQUw7QUFDRixTQUxBLE1BS007QUFDSjA1QixZQUFFLENBQUN4OEIsSUFBSCxJQUFXMDhCLE9BQU8sQ0FBQzE4QixJQUFuQjtBQUNBdzhCLFlBQUUsQ0FBQzc3QixNQUFILElBQWErN0IsT0FBTyxDQUFDLzdCLE1BQXJCO0FBQ0EsY0FBSWc4QixPQUFPLEdBQUdqdEMsT0FBTyxDQUFDOHNDLEVBQUUsQ0FBQ2x4QyxNQUFILENBQVU4VSxRQUFYLEVBQXFCbzhCLEVBQXJCLENBQXJCO0FBQ0FBLFlBQUUsQ0FBQ2x4QyxNQUFILENBQVU4VSxRQUFWLENBQW1CcE8sTUFBbkIsQ0FBMEIycUMsT0FBTyxHQUFHLENBQXBDLEVBQXVDLENBQXZDLEVBQTBDRCxPQUExQztBQUNEOztBQUNEQSxlQUFPLENBQUNweEMsTUFBUixHQUFpQmt4QyxFQUFFLENBQUNseEMsTUFBcEI7QUFDRCxPQWZELFFBZVNreEMsRUFBRSxDQUFDcDhCLFFBQUgsQ0FBWXRWLE1BQVosR0FBcUIsRUFmOUI7O0FBZ0JBMHhDLFFBQUUsQ0FBQ2x4QyxNQUFILENBQVVpeEMsVUFBVjtBQUNELEtBOUVxQjtBQWdGdEJMLFNBQUssRUFBRSxlQUFTbmxDLEVBQVQsRUFBYXZILENBQWIsRUFBZ0I0Z0IsRUFBaEIsRUFBb0I7QUFDekIsV0FBSyxJQUFJcmtCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBS3FVLFFBQUwsQ0FBY3RWLE1BQWxDLEVBQTBDLEVBQUVpQixDQUE1QyxFQUErQztBQUM3QyxZQUFJbUIsS0FBSyxHQUFHLEtBQUtrVCxRQUFMLENBQWNyVSxDQUFkLENBQVo7QUFBQSxZQUE4QnNVLEVBQUUsR0FBR25ULEtBQUssQ0FBQ29ULFNBQU4sRUFBbkM7O0FBQ0EsWUFBSXZKLEVBQUUsR0FBR3NKLEVBQVQsRUFBYTtBQUNYLGNBQUl1OEIsSUFBSSxHQUFHeHJDLElBQUksQ0FBQ0MsR0FBTCxDQUFTN0IsQ0FBVCxFQUFZNlEsRUFBRSxHQUFHdEosRUFBakIsQ0FBWDs7QUFDQSxjQUFJN0osS0FBSyxDQUFDZ3ZDLEtBQU4sQ0FBWW5sQyxFQUFaLEVBQWdCNmxDLElBQWhCLEVBQXNCeHNCLEVBQXRCLENBQUosRUFBK0I7QUFBRSxtQkFBTyxJQUFQO0FBQWE7O0FBQzlDLGNBQUksQ0FBQzVnQixDQUFDLElBQUlvdEMsSUFBTixLQUFlLENBQW5CLEVBQXNCO0FBQUU7QUFBTzs7QUFDL0I3bEMsWUFBRSxHQUFHLENBQUw7QUFDRCxTQUxELE1BS087QUFBRUEsWUFBRSxJQUFJc0osRUFBTjtBQUFXO0FBQ3JCO0FBQ0Y7QUExRnFCLEdBQXhCLENBNytLbUIsQ0Ewa0xuQjs7QUFFQSxNQUFJdzhCLFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQVMvOEIsR0FBVCxFQUFjdFYsSUFBZCxFQUFvQnFTLE9BQXBCLEVBQTZCO0FBQzVDLFFBQUlBLE9BQUosRUFBYTtBQUFFLFdBQUssSUFBSWlnQyxHQUFULElBQWdCamdDLE9BQWhCLEVBQXlCO0FBQUUsWUFBSUEsT0FBTyxDQUFDNU4sY0FBUixDQUF1QjZ0QyxHQUF2QixDQUFKLEVBQ3hDO0FBQUUsZUFBS0EsR0FBTCxJQUFZamdDLE9BQU8sQ0FBQ2lnQyxHQUFELENBQW5CO0FBQTJCO0FBQUU7QUFBRTs7QUFDbkMsU0FBS2g5QixHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLdFYsSUFBTCxHQUFZQSxJQUFaO0FBQ0QsR0FMRDs7QUFPQXF5QyxZQUFVLENBQUNydUMsU0FBWCxDQUFxQjI2QixLQUFyQixHQUE2QixZQUFZO0FBQ3ZDLFFBQUk3d0IsRUFBRSxHQUFHLEtBQUt3SCxHQUFMLENBQVN4SCxFQUFsQjtBQUFBLFFBQXNCdWIsRUFBRSxHQUFHLEtBQUt2YyxJQUFMLENBQVVzYyxPQUFyQztBQUFBLFFBQThDdGMsSUFBSSxHQUFHLEtBQUtBLElBQTFEO0FBQUEsUUFBZ0V3SixFQUFFLEdBQUdELE1BQU0sQ0FBQ3ZKLElBQUQsQ0FBM0U7O0FBQ0EsUUFBSXdKLEVBQUUsSUFBSSxJQUFOLElBQWMsQ0FBQytTLEVBQW5CLEVBQXVCO0FBQUU7QUFBUTs7QUFDakMsU0FBSyxJQUFJOW5CLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc4bkIsRUFBRSxDQUFDL29CLE1BQXZCLEVBQStCLEVBQUVpQixDQUFqQyxFQUFvQztBQUFFLFVBQUk4bkIsRUFBRSxDQUFDOW5CLENBQUQsQ0FBRixJQUFTLElBQWIsRUFBbUI7QUFBRThuQixVQUFFLENBQUM3aEIsTUFBSCxDQUFVakcsQ0FBQyxFQUFYLEVBQWUsQ0FBZjtBQUFvQjtBQUFFOztBQUNqRixRQUFJLENBQUM4bkIsRUFBRSxDQUFDL29CLE1BQVIsRUFBZ0I7QUFBRXdNLFVBQUksQ0FBQ3NjLE9BQUwsR0FBZSxJQUFmO0FBQXNCOztBQUN4QyxRQUFJalQsTUFBTSxHQUFHNlQsWUFBWSxDQUFDLElBQUQsQ0FBekI7QUFDQTlULG9CQUFnQixDQUFDcEosSUFBRCxFQUFPbEcsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTLENBQVQsRUFBWWtELElBQUksQ0FBQ3FKLE1BQUwsR0FBY0EsTUFBMUIsQ0FBUCxDQUFoQjs7QUFDQSxRQUFJckksRUFBSixFQUFRO0FBQ044ekIsYUFBTyxDQUFDOXpCLEVBQUQsRUFBSyxZQUFZO0FBQ3RCeWtDLG9DQUE0QixDQUFDemtDLEVBQUQsRUFBS2hCLElBQUwsRUFBVyxDQUFDcUosTUFBWixDQUE1QjtBQUNBdWUscUJBQWEsQ0FBQzVtQixFQUFELEVBQUt3SSxFQUFMLEVBQVMsUUFBVCxDQUFiO0FBQ0QsT0FITSxDQUFQO0FBSUFpUSxpQkFBVyxDQUFDelksRUFBRCxFQUFLLG1CQUFMLEVBQTBCQSxFQUExQixFQUE4QixJQUE5QixFQUFvQ3dJLEVBQXBDLENBQVg7QUFDRDtBQUNGLEdBZEQ7O0FBZ0JBKzdCLFlBQVUsQ0FBQ3J1QyxTQUFYLENBQXFCeTJCLE9BQXJCLEdBQStCLFlBQVk7QUFDdkMsUUFBSStYLE1BQU0sR0FBRyxJQUFiO0FBRUYsUUFBSUMsSUFBSSxHQUFHLEtBQUt0OEIsTUFBaEI7QUFBQSxRQUF3QnJJLEVBQUUsR0FBRyxLQUFLd0gsR0FBTCxDQUFTeEgsRUFBdEM7QUFBQSxRQUEwQ2hCLElBQUksR0FBRyxLQUFLQSxJQUF0RDtBQUNBLFNBQUtxSixNQUFMLEdBQWMsSUFBZDtBQUNBLFFBQUlDLElBQUksR0FBRzRULFlBQVksQ0FBQyxJQUFELENBQVosR0FBcUJ5b0IsSUFBaEM7O0FBQ0EsUUFBSSxDQUFDcjhCLElBQUwsRUFBVztBQUFFO0FBQVE7O0FBQ3JCLFFBQUksQ0FBQ3dLLFlBQVksQ0FBQyxLQUFLdEwsR0FBTixFQUFXeEksSUFBWCxDQUFqQixFQUFtQztBQUFFb0osc0JBQWdCLENBQUNwSixJQUFELEVBQU9BLElBQUksQ0FBQ3FKLE1BQUwsR0FBY0MsSUFBckIsQ0FBaEI7QUFBNkM7O0FBQ2xGLFFBQUl0SSxFQUFKLEVBQVE7QUFDTjh6QixhQUFPLENBQUM5ekIsRUFBRCxFQUFLLFlBQVk7QUFDdEJBLFVBQUUsQ0FBQ1EsS0FBSCxDQUFTMmUsV0FBVCxHQUF1QixJQUF2QjtBQUNBc2xCLG9DQUE0QixDQUFDemtDLEVBQUQsRUFBS2hCLElBQUwsRUFBV3NKLElBQVgsQ0FBNUI7QUFDQW1RLG1CQUFXLENBQUN6WSxFQUFELEVBQUssbUJBQUwsRUFBMEJBLEVBQTFCLEVBQThCMGtDLE1BQTlCLEVBQXNDbjhCLE1BQU0sQ0FBQ3ZKLElBQUQsQ0FBNUMsQ0FBWDtBQUNELE9BSk0sQ0FBUDtBQUtEO0FBQ0YsR0FmRDs7QUFnQkEyQixZQUFVLENBQUM0akMsVUFBRCxDQUFWOztBQUVBLFdBQVNFLDRCQUFULENBQXNDemtDLEVBQXRDLEVBQTBDaEIsSUFBMUMsRUFBZ0RzSixJQUFoRCxFQUFzRDtBQUNwRCxRQUFJMkssYUFBWSxDQUFDalUsSUFBRCxDQUFaLElBQXVCZ0IsRUFBRSxDQUFDUSxLQUFILElBQVlSLEVBQUUsQ0FBQ1EsS0FBSCxDQUFTdWhCLFNBQXRCLElBQW9DL2hCLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT3VhLFNBQWpFLENBQUosRUFDRTtBQUFFOEwsb0JBQWMsQ0FBQzd0QixFQUFELEVBQUtzSSxJQUFMLENBQWQ7QUFBMkI7QUFDaEM7O0FBRUQsV0FBU3M4QixhQUFULENBQXVCcDlCLEdBQXZCLEVBQTRCKzdCLE1BQTVCLEVBQW9DcnhDLElBQXBDLEVBQTBDcVMsT0FBMUMsRUFBbUQ7QUFDakQsUUFBSWtTLE1BQU0sR0FBRyxJQUFJOHRCLFVBQUosQ0FBZS84QixHQUFmLEVBQW9CdFYsSUFBcEIsRUFBMEJxUyxPQUExQixDQUFiO0FBQ0EsUUFBSXZFLEVBQUUsR0FBR3dILEdBQUcsQ0FBQ3hILEVBQWI7O0FBQ0EsUUFBSUEsRUFBRSxJQUFJeVcsTUFBTSxDQUFDa0YsU0FBakIsRUFBNEI7QUFBRTNiLFFBQUUsQ0FBQ29NLE9BQUgsQ0FBVytxQixZQUFYLEdBQTBCLElBQTFCO0FBQWlDOztBQUMvRG1NLGNBQVUsQ0FBQzk3QixHQUFELEVBQU0rN0IsTUFBTixFQUFjLFFBQWQsRUFBd0IsVUFBVXZrQyxJQUFWLEVBQWdCO0FBQ2hELFVBQUlzYyxPQUFPLEdBQUd0YyxJQUFJLENBQUNzYyxPQUFMLEtBQWlCdGMsSUFBSSxDQUFDc2MsT0FBTCxHQUFlLEVBQWhDLENBQWQ7O0FBQ0EsVUFBSTdFLE1BQU0sQ0FBQ291QixRQUFQLElBQW1CLElBQXZCLEVBQTZCO0FBQUV2cEIsZUFBTyxDQUFDcGlCLElBQVIsQ0FBYXVkLE1BQWI7QUFBdUIsT0FBdEQsTUFDSztBQUFFNkUsZUFBTyxDQUFDNWhCLE1BQVIsQ0FBZVosSUFBSSxDQUFDQyxHQUFMLENBQVN1aUIsT0FBTyxDQUFDOW9CLE1BQWpCLEVBQXlCc0csSUFBSSxDQUFDZ0QsR0FBTCxDQUFTLENBQVQsRUFBWTJhLE1BQU0sQ0FBQ291QixRQUFuQixDQUF6QixDQUFmLEVBQXVFLENBQXZFLEVBQTBFcHVCLE1BQTFFO0FBQW9GOztBQUMzRkEsWUFBTSxDQUFDelgsSUFBUCxHQUFjQSxJQUFkOztBQUNBLFVBQUlnQixFQUFFLElBQUksQ0FBQzhTLFlBQVksQ0FBQ3RMLEdBQUQsRUFBTXhJLElBQU4sQ0FBdkIsRUFBb0M7QUFDbEMsWUFBSThsQyxZQUFZLEdBQUc3eEIsYUFBWSxDQUFDalUsSUFBRCxDQUFaLEdBQXFCd0ksR0FBRyxDQUFDdWEsU0FBNUM7QUFDQTNaLHdCQUFnQixDQUFDcEosSUFBRCxFQUFPQSxJQUFJLENBQUNxSixNQUFMLEdBQWM2VCxZQUFZLENBQUN6RixNQUFELENBQWpDLENBQWhCOztBQUNBLFlBQUlxdUIsWUFBSixFQUFrQjtBQUFFalgsd0JBQWMsQ0FBQzd0QixFQUFELEVBQUt5VyxNQUFNLENBQUNwTyxNQUFaLENBQWQ7QUFBb0M7O0FBQ3hEckksVUFBRSxDQUFDUSxLQUFILENBQVMyZSxXQUFULEdBQXVCLElBQXZCO0FBQ0Q7O0FBQ0QsYUFBTyxJQUFQO0FBQ0QsS0FaUyxDQUFWOztBQWFBLFFBQUluZixFQUFKLEVBQVE7QUFBRXlZLGlCQUFXLENBQUN6WSxFQUFELEVBQUssaUJBQUwsRUFBd0JBLEVBQXhCLEVBQTRCeVcsTUFBNUIsRUFBb0MsT0FBTzhzQixNQUFQLElBQWlCLFFBQWpCLEdBQTRCQSxNQUE1QixHQUFxQ2g3QixNQUFNLENBQUNnN0IsTUFBRCxDQUEvRSxDQUFYO0FBQXNHOztBQUNoSCxXQUFPOXNCLE1BQVA7QUFDRCxHQTdvTGtCLENBK29MbkI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUNBLE1BQUlzdUIsWUFBWSxHQUFHLENBQW5COztBQUVBLE1BQUlDLFVBQVUsR0FBRyxTQUFiQSxVQUFhLENBQVN4OUIsR0FBVCxFQUFjbkssSUFBZCxFQUFvQjtBQUNuQyxTQUFLd0ssS0FBTCxHQUFhLEVBQWI7QUFDQSxTQUFLeEssSUFBTCxHQUFZQSxJQUFaO0FBQ0EsU0FBS21LLEdBQUwsR0FBV0EsR0FBWDtBQUNBLFNBQUtsUSxFQUFMLEdBQVUsRUFBRXl0QyxZQUFaO0FBQ0QsR0FMRCxDQWhxTG1CLENBdXFMbkI7OztBQUNBQyxZQUFVLENBQUM5dUMsU0FBWCxDQUFxQjI2QixLQUFyQixHQUE2QixZQUFZO0FBQ3ZDLFFBQUksS0FBSzhOLGlCQUFULEVBQTRCO0FBQUU7QUFBUTs7QUFDdEMsUUFBSTMrQixFQUFFLEdBQUcsS0FBS3dILEdBQUwsQ0FBU3hILEVBQWxCO0FBQUEsUUFBc0JpbEMsTUFBTSxHQUFHamxDLEVBQUUsSUFBSSxDQUFDQSxFQUFFLENBQUNRLEtBQXpDOztBQUNBLFFBQUl5a0MsTUFBSixFQUFZO0FBQUVsVCxxQkFBYyxDQUFDL3hCLEVBQUQsQ0FBZDtBQUFxQjs7QUFDbkMsUUFBSVUsVUFBVSxDQUFDLElBQUQsRUFBTyxPQUFQLENBQWQsRUFBK0I7QUFDN0IsVUFBSTlFLEtBQUssR0FBRyxLQUFLaVYsSUFBTCxFQUFaOztBQUNBLFVBQUlqVixLQUFKLEVBQVc7QUFBRTZjLG1CQUFXLENBQUMsSUFBRCxFQUFPLE9BQVAsRUFBZ0I3YyxLQUFLLENBQUNSLElBQXRCLEVBQTRCUSxLQUFLLENBQUNQLEVBQWxDLENBQVg7QUFBbUQ7QUFDakU7O0FBQ0QsUUFBSXRDLEdBQUcsR0FBRyxJQUFWO0FBQUEsUUFBZ0IrQyxHQUFHLEdBQUcsSUFBdEI7O0FBQ0EsU0FBSyxJQUFJckksQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLb1UsS0FBTCxDQUFXclYsTUFBL0IsRUFBdUMsRUFBRWlCLENBQXpDLEVBQTRDO0FBQzFDLFVBQUl1TCxJQUFJLEdBQUcsS0FBSzZJLEtBQUwsQ0FBV3BVLENBQVgsQ0FBWDtBQUNBLFVBQUkrYSxJQUFJLEdBQUdGLGdCQUFnQixDQUFDdFAsSUFBSSxDQUFDMlAsV0FBTixFQUFtQixJQUFuQixDQUEzQjs7QUFDQSxVQUFJM08sRUFBRSxJQUFJLENBQUMsS0FBS2dTLFNBQWhCLEVBQTJCO0FBQUU0VSxxQkFBYSxDQUFDNW1CLEVBQUQsRUFBS3VJLE1BQU0sQ0FBQ3ZKLElBQUQsQ0FBWCxFQUFtQixNQUFuQixDQUFiO0FBQTBDLE9BQXZFLE1BQ0ssSUFBSWdCLEVBQUosRUFBUTtBQUNYLFlBQUl3TyxJQUFJLENBQUNuVCxFQUFMLElBQVcsSUFBZixFQUFxQjtBQUFFUyxhQUFHLEdBQUd5TSxNQUFNLENBQUN2SixJQUFELENBQVo7QUFBcUI7O0FBQzVDLFlBQUl3UCxJQUFJLENBQUNwVCxJQUFMLElBQWEsSUFBakIsRUFBdUI7QUFBRXJDLGFBQUcsR0FBR3dQLE1BQU0sQ0FBQ3ZKLElBQUQsQ0FBWjtBQUFxQjtBQUMvQzs7QUFDREEsVUFBSSxDQUFDMlAsV0FBTCxHQUFtQkYsZ0JBQWdCLENBQUN6UCxJQUFJLENBQUMyUCxXQUFOLEVBQW1CSCxJQUFuQixDQUFuQzs7QUFDQSxVQUFJQSxJQUFJLENBQUNwVCxJQUFMLElBQWEsSUFBYixJQUFxQixLQUFLNFcsU0FBMUIsSUFBdUMsQ0FBQ2MsWUFBWSxDQUFDLEtBQUt0TCxHQUFOLEVBQVd4SSxJQUFYLENBQXBELElBQXdFZ0IsRUFBNUUsRUFDRTtBQUFFb0ksd0JBQWdCLENBQUNwSixJQUFELEVBQU8rbEIsVUFBVSxDQUFDL2tCLEVBQUUsQ0FBQ29NLE9BQUosQ0FBakIsQ0FBaEI7QUFBaUQ7QUFDdEQ7O0FBQ0QsUUFBSXBNLEVBQUUsSUFBSSxLQUFLZ1MsU0FBWCxJQUF3QixDQUFDaFMsRUFBRSxDQUFDdUUsT0FBSCxDQUFXMlosWUFBeEMsRUFBc0Q7QUFBRSxXQUFLLElBQUkvZ0IsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBRyxLQUFLMEssS0FBTCxDQUFXclYsTUFBbkMsRUFBMkMsRUFBRTJLLEdBQTdDLEVBQWtEO0FBQ3hHLFlBQUkrbkMsTUFBTSxHQUFHN3lCLFVBQVUsQ0FBQyxLQUFLeEssS0FBTCxDQUFXMUssR0FBWCxDQUFELENBQXZCO0FBQUEsWUFBMENGLEdBQUcsR0FBR2tXLFVBQVUsQ0FBQyt4QixNQUFELENBQTFEOztBQUNBLFlBQUlqb0MsR0FBRyxHQUFHK0MsRUFBRSxDQUFDb00sT0FBSCxDQUFXbUgsYUFBckIsRUFBb0M7QUFDbEN2VCxZQUFFLENBQUNvTSxPQUFILENBQVdrSCxPQUFYLEdBQXFCNHhCLE1BQXJCO0FBQ0FsbEMsWUFBRSxDQUFDb00sT0FBSCxDQUFXbUgsYUFBWCxHQUEyQnRXLEdBQTNCO0FBQ0ErQyxZQUFFLENBQUNvTSxPQUFILENBQVdvSCxjQUFYLEdBQTRCLElBQTVCO0FBQ0Q7QUFDRjtBQUFFOztBQUVILFFBQUl6YSxHQUFHLElBQUksSUFBUCxJQUFlaUgsRUFBZixJQUFxQixLQUFLZ1MsU0FBOUIsRUFBeUM7QUFBRWtVLGVBQVMsQ0FBQ2xtQixFQUFELEVBQUtqSCxHQUFMLEVBQVUrQyxHQUFHLEdBQUcsQ0FBaEIsQ0FBVDtBQUE4Qjs7QUFDekUsU0FBSytMLEtBQUwsQ0FBV3JWLE1BQVgsR0FBb0IsQ0FBcEI7QUFDQSxTQUFLbXNDLGlCQUFMLEdBQXlCLElBQXpCOztBQUNBLFFBQUksS0FBS3FDLE1BQUwsSUFBZSxLQUFLeDVCLEdBQUwsQ0FBUzQ1QixRQUE1QixFQUFzQztBQUNwQyxXQUFLNTVCLEdBQUwsQ0FBUzQ1QixRQUFULEdBQW9CLEtBQXBCOztBQUNBLFVBQUlwaEMsRUFBSixFQUFRO0FBQUVxZ0Msd0JBQWdCLENBQUNyZ0MsRUFBRSxDQUFDd0gsR0FBSixDQUFoQjtBQUEyQjtBQUN0Qzs7QUFDRCxRQUFJeEgsRUFBSixFQUFRO0FBQUV5WSxpQkFBVyxDQUFDelksRUFBRCxFQUFLLGVBQUwsRUFBc0JBLEVBQXRCLEVBQTBCLElBQTFCLEVBQWdDakgsR0FBaEMsRUFBcUMrQyxHQUFyQyxDQUFYO0FBQXVEOztBQUNqRSxRQUFJbXBDLE1BQUosRUFBWTtBQUFFNVMsbUJBQVksQ0FBQ3J5QixFQUFELENBQVo7QUFBbUI7O0FBQ2pDLFFBQUksS0FBS2hOLE1BQVQsRUFBaUI7QUFBRSxXQUFLQSxNQUFMLENBQVk2OUIsS0FBWjtBQUFzQjtBQUMxQyxHQXhDRCxDQXhxTG1CLENBa3RMbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0FtVSxZQUFVLENBQUM5dUMsU0FBWCxDQUFxQjJhLElBQXJCLEdBQTRCLFVBQVVvWSxJQUFWLEVBQWdCL1YsT0FBaEIsRUFBeUI7QUFDbkQsUUFBSStWLElBQUksSUFBSSxJQUFSLElBQWdCLEtBQUs1ckIsSUFBTCxJQUFhLFVBQWpDLEVBQTZDO0FBQUU0ckIsVUFBSSxHQUFHLENBQVA7QUFBVzs7QUFDMUQsUUFBSTd0QixJQUFKLEVBQVVDLEVBQVY7O0FBQ0EsU0FBSyxJQUFJNUgsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLb1UsS0FBTCxDQUFXclYsTUFBL0IsRUFBdUMsRUFBRWlCLENBQXpDLEVBQTRDO0FBQzFDLFVBQUl1TCxJQUFJLEdBQUcsS0FBSzZJLEtBQUwsQ0FBV3BVLENBQVgsQ0FBWDtBQUNBLFVBQUkrYSxJQUFJLEdBQUdGLGdCQUFnQixDQUFDdFAsSUFBSSxDQUFDMlAsV0FBTixFQUFtQixJQUFuQixDQUEzQjs7QUFDQSxVQUFJSCxJQUFJLENBQUNwVCxJQUFMLElBQWEsSUFBakIsRUFBdUI7QUFDckJBLFlBQUksR0FBRzhOLEdBQUcsQ0FBQ2dLLE9BQU8sR0FBR2xVLElBQUgsR0FBVXVKLE1BQU0sQ0FBQ3ZKLElBQUQsQ0FBeEIsRUFBZ0N3UCxJQUFJLENBQUNwVCxJQUFyQyxDQUFWOztBQUNBLFlBQUk2dEIsSUFBSSxJQUFJLENBQUMsQ0FBYixFQUFnQjtBQUFFLGlCQUFPN3RCLElBQVA7QUFBYTtBQUNoQzs7QUFDRCxVQUFJb1QsSUFBSSxDQUFDblQsRUFBTCxJQUFXLElBQWYsRUFBcUI7QUFDbkJBLFVBQUUsR0FBRzZOLEdBQUcsQ0FBQ2dLLE9BQU8sR0FBR2xVLElBQUgsR0FBVXVKLE1BQU0sQ0FBQ3ZKLElBQUQsQ0FBeEIsRUFBZ0N3UCxJQUFJLENBQUNuVCxFQUFyQyxDQUFSOztBQUNBLFlBQUk0dEIsSUFBSSxJQUFJLENBQVosRUFBZTtBQUFFLGlCQUFPNXRCLEVBQVA7QUFBVztBQUM3QjtBQUNGOztBQUNELFdBQU9ELElBQUksSUFBSTtBQUFDQSxVQUFJLEVBQUVBLElBQVA7QUFBYUMsUUFBRSxFQUFFQTtBQUFqQixLQUFmO0FBQ0QsR0FoQkQsQ0F2dExtQixDQXl1TG5CO0FBQ0E7OztBQUNBMnBDLFlBQVUsQ0FBQzl1QyxTQUFYLENBQXFCeTJCLE9BQXJCLEdBQStCLFlBQVk7QUFDdkMsUUFBSStYLE1BQU0sR0FBRyxJQUFiO0FBRUYsUUFBSS9yQyxHQUFHLEdBQUcsS0FBS2tZLElBQUwsQ0FBVSxDQUFDLENBQVgsRUFBYyxJQUFkLENBQVY7QUFBQSxRQUErQjRGLE1BQU0sR0FBRyxJQUF4QztBQUFBLFFBQThDelcsRUFBRSxHQUFHLEtBQUt3SCxHQUFMLENBQVN4SCxFQUE1RDs7QUFDQSxRQUFJLENBQUNySCxHQUFELElBQVEsQ0FBQ3FILEVBQWIsRUFBaUI7QUFBRTtBQUFROztBQUMzQjh6QixXQUFPLENBQUM5ekIsRUFBRCxFQUFLLFlBQVk7QUFDdEIsVUFBSWhCLElBQUksR0FBR3JHLEdBQUcsQ0FBQ3FHLElBQWY7QUFBQSxVQUFxQjBULEtBQUssR0FBR25LLE1BQU0sQ0FBQzVQLEdBQUcsQ0FBQ3FHLElBQUwsQ0FBbkM7QUFDQSxVQUFJMlksSUFBSSxHQUFHcUgsZUFBZSxDQUFDaGYsRUFBRCxFQUFLMFMsS0FBTCxDQUExQjs7QUFDQSxVQUFJaUYsSUFBSixFQUFVO0FBQ1JzSixvQ0FBNEIsQ0FBQ3RKLElBQUQsQ0FBNUI7QUFDQTNYLFVBQUUsQ0FBQ1EsS0FBSCxDQUFTMnhCLGdCQUFULEdBQTRCbnlCLEVBQUUsQ0FBQ1EsS0FBSCxDQUFTMmUsV0FBVCxHQUF1QixJQUFuRDtBQUNEOztBQUNEbmYsUUFBRSxDQUFDUSxLQUFILENBQVM0eEIsYUFBVCxHQUF5QixJQUF6Qjs7QUFDQSxVQUFJLENBQUN0ZixZQUFZLENBQUMyRCxNQUFNLENBQUNqUCxHQUFSLEVBQWF4SSxJQUFiLENBQWIsSUFBbUN5WCxNQUFNLENBQUNwTyxNQUFQLElBQWlCLElBQXhELEVBQThEO0FBQzVELFlBQUl5N0IsU0FBUyxHQUFHcnRCLE1BQU0sQ0FBQ3BPLE1BQXZCO0FBQ0FvTyxjQUFNLENBQUNwTyxNQUFQLEdBQWdCLElBQWhCO0FBQ0EsWUFBSTg4QixPQUFPLEdBQUdqcEIsWUFBWSxDQUFDekYsTUFBRCxDQUFaLEdBQXVCcXRCLFNBQXJDOztBQUNBLFlBQUlxQixPQUFKLEVBQ0U7QUFBRS84QiwwQkFBZ0IsQ0FBQ3BKLElBQUQsRUFBT0EsSUFBSSxDQUFDcUosTUFBTCxHQUFjODhCLE9BQXJCLENBQWhCO0FBQWdEO0FBQ3JEOztBQUNEMXNCLGlCQUFXLENBQUN6WSxFQUFELEVBQUssZUFBTCxFQUFzQkEsRUFBdEIsRUFBMEIwa0MsTUFBMUIsQ0FBWDtBQUNELEtBaEJNLENBQVA7QUFpQkQsR0F0QkQ7O0FBd0JBTSxZQUFVLENBQUM5dUMsU0FBWCxDQUFxQjBZLFVBQXJCLEdBQWtDLFVBQVU1UCxJQUFWLEVBQWdCO0FBQ2hELFFBQUksQ0FBQyxLQUFLNkksS0FBTCxDQUFXclYsTUFBWixJQUFzQixLQUFLZ1YsR0FBTCxDQUFTeEgsRUFBbkMsRUFBdUM7QUFDckMsVUFBSThYLEVBQUUsR0FBRyxLQUFLdFEsR0FBTCxDQUFTeEgsRUFBVCxDQUFZUSxLQUFyQjs7QUFDQSxVQUFJLENBQUNzWCxFQUFFLENBQUM0YixrQkFBSixJQUEwQnQ4QixPQUFPLENBQUMwZ0IsRUFBRSxDQUFDNGIsa0JBQUosRUFBd0IsSUFBeEIsQ0FBUCxJQUF3QyxDQUFDLENBQXZFLEVBQ0U7QUFBRSxTQUFDNWIsRUFBRSxDQUFDOGIsb0JBQUgsS0FBNEI5YixFQUFFLENBQUM4YixvQkFBSCxHQUEwQixFQUF0RCxDQUFELEVBQTREMTZCLElBQTVELENBQWlFLElBQWpFO0FBQXlFO0FBQzlFOztBQUNELFNBQUsyTyxLQUFMLENBQVczTyxJQUFYLENBQWdCOEYsSUFBaEI7QUFDRCxHQVBEOztBQVNBZ21DLFlBQVUsQ0FBQzl1QyxTQUFYLENBQXFCaWIsVUFBckIsR0FBa0MsVUFBVW5TLElBQVYsRUFBZ0I7QUFDaEQsU0FBSzZJLEtBQUwsQ0FBV25PLE1BQVgsQ0FBa0J0QyxPQUFPLENBQUMsS0FBS3lRLEtBQU4sRUFBYTdJLElBQWIsQ0FBekIsRUFBNkMsQ0FBN0M7O0FBQ0EsUUFBSSxDQUFDLEtBQUs2SSxLQUFMLENBQVdyVixNQUFaLElBQXNCLEtBQUtnVixHQUFMLENBQVN4SCxFQUFuQyxFQUF1QztBQUNyQyxVQUFJOFgsRUFBRSxHQUFHLEtBQUt0USxHQUFMLENBQVN4SCxFQUFULENBQVlRLEtBQXJCO0FBQ0MsT0FBQ3NYLEVBQUUsQ0FBQzRiLGtCQUFILEtBQTBCNWIsRUFBRSxDQUFDNGIsa0JBQUgsR0FBd0IsRUFBbEQsQ0FBRCxFQUF3RHg2QixJQUF4RCxDQUE2RCxJQUE3RDtBQUNGO0FBQ0YsR0FORDs7QUFPQXlILFlBQVUsQ0FBQ3FrQyxVQUFELENBQVYsQ0FueExtQixDQXF4TG5COztBQUNBLFdBQVNJLFNBQVQsQ0FBa0I1OUIsR0FBbEIsRUFBdUJwTSxJQUF2QixFQUE2QkMsRUFBN0IsRUFBaUNrSixPQUFqQyxFQUEwQ2xILElBQTFDLEVBQWdEO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLFFBQUlrSCxPQUFPLElBQUlBLE9BQU8sQ0FBQ2c0QixNQUF2QixFQUErQjtBQUFFLGFBQU84SSxjQUFjLENBQUM3OUIsR0FBRCxFQUFNcE0sSUFBTixFQUFZQyxFQUFaLEVBQWdCa0osT0FBaEIsRUFBeUJsSCxJQUF6QixDQUFyQjtBQUFxRCxLQUp4QyxDQUs5Qzs7O0FBQ0EsUUFBSW1LLEdBQUcsQ0FBQ3hILEVBQUosSUFBVSxDQUFDd0gsR0FBRyxDQUFDeEgsRUFBSixDQUFPUSxLQUF0QixFQUE2QjtBQUFFLGFBQU91ekIsU0FBUyxDQUFDdnNCLEdBQUcsQ0FBQ3hILEVBQUwsRUFBU29sQyxTQUFULENBQVQsQ0FBNEI1OUIsR0FBNUIsRUFBaUNwTSxJQUFqQyxFQUF1Q0MsRUFBdkMsRUFBMkNrSixPQUEzQyxFQUFvRGxILElBQXBELENBQVA7QUFBa0U7O0FBRWpHLFFBQUlnUixNQUFNLEdBQUcsSUFBSTIyQixVQUFKLENBQWV4OUIsR0FBZixFQUFvQm5LLElBQXBCLENBQWI7QUFBQSxRQUF3Q2lMLElBQUksR0FBR2EsR0FBRyxDQUFDL04sSUFBRCxFQUFPQyxFQUFQLENBQWxEOztBQUNBLFFBQUlrSixPQUFKLEVBQWE7QUFBRWpPLGFBQU8sQ0FBQ2lPLE9BQUQsRUFBVThKLE1BQVYsRUFBa0IsS0FBbEIsQ0FBUDtBQUFrQyxLQVRILENBVTlDOzs7QUFDQSxRQUFJL0YsSUFBSSxHQUFHLENBQVAsSUFBWUEsSUFBSSxJQUFJLENBQVIsSUFBYStGLE1BQU0sQ0FBQ2lDLGNBQVAsS0FBMEIsS0FBdkQsRUFDRTtBQUFFLGFBQU9qQyxNQUFQO0FBQWU7O0FBQ25CLFFBQUlBLE1BQU0sQ0FBQ2kzQixZQUFYLEVBQXlCO0FBQ3ZCO0FBQ0FqM0IsWUFBTSxDQUFDMkQsU0FBUCxHQUFtQixJQUFuQjtBQUNBM0QsWUFBTSxDQUFDMEUsVUFBUCxHQUFvQnJmLElBQUksQ0FBQyxNQUFELEVBQVMsQ0FBQzJhLE1BQU0sQ0FBQ2kzQixZQUFSLENBQVQsRUFBZ0MsbUJBQWhDLENBQXhCOztBQUNBLFVBQUksQ0FBQy9nQyxPQUFPLENBQUNpWCxpQkFBYixFQUFnQztBQUFFbk4sY0FBTSxDQUFDMEUsVUFBUCxDQUFrQnBmLFlBQWxCLENBQStCLGtCQUEvQixFQUFtRCxNQUFuRDtBQUE2RDs7QUFDL0YsVUFBSTRRLE9BQU8sQ0FBQzZLLFVBQVosRUFBd0I7QUFBRWYsY0FBTSxDQUFDMEUsVUFBUCxDQUFrQjNELFVBQWxCLEdBQStCLElBQS9CO0FBQXNDO0FBQ2pFOztBQUNELFFBQUlmLE1BQU0sQ0FBQzJELFNBQVgsRUFBc0I7QUFDcEIsVUFBSUkseUJBQXlCLENBQUM1SyxHQUFELEVBQU1wTSxJQUFJLENBQUM0RCxJQUFYLEVBQWlCNUQsSUFBakIsRUFBdUJDLEVBQXZCLEVBQTJCZ1QsTUFBM0IsQ0FBekIsSUFDQWpULElBQUksQ0FBQzRELElBQUwsSUFBYTNELEVBQUUsQ0FBQzJELElBQWhCLElBQXdCb1QseUJBQXlCLENBQUM1SyxHQUFELEVBQU1uTSxFQUFFLENBQUMyRCxJQUFULEVBQWU1RCxJQUFmLEVBQXFCQyxFQUFyQixFQUF5QmdULE1BQXpCLENBRHJELEVBRUU7QUFBRSxjQUFNLElBQUkxRyxLQUFKLENBQVUsa0VBQVYsQ0FBTjtBQUFxRjs7QUFDekZ3Ryx1QkFBaUI7QUFDbEI7O0FBRUQsUUFBSUUsTUFBTSxDQUFDazNCLFlBQVgsRUFDRTtBQUFFeEgsd0JBQWtCLENBQUN2MkIsR0FBRCxFQUFNO0FBQUNwTSxZQUFJLEVBQUVBLElBQVA7QUFBYUMsVUFBRSxFQUFFQSxFQUFqQjtBQUFxQjlDLGNBQU0sRUFBRTtBQUE3QixPQUFOLEVBQWdEaVAsR0FBRyxDQUFDaWdCLEdBQXBELEVBQXlEeVksR0FBekQsQ0FBbEI7QUFBa0Y7O0FBRXRGLFFBQUlzRixPQUFPLEdBQUdwcUMsSUFBSSxDQUFDNEQsSUFBbkI7QUFBQSxRQUF5QmdCLEVBQUUsR0FBR3dILEdBQUcsQ0FBQ3hILEVBQWxDO0FBQUEsUUFBc0NveUIsYUFBdEM7QUFDQTVxQixPQUFHLENBQUNVLElBQUosQ0FBU3M5QixPQUFULEVBQWtCbnFDLEVBQUUsQ0FBQzJELElBQUgsR0FBVSxDQUE1QixFQUErQixVQUFVQSxJQUFWLEVBQWdCO0FBQzdDLFVBQUlnQixFQUFFLElBQUlxTyxNQUFNLENBQUMyRCxTQUFiLElBQTBCLENBQUNoUyxFQUFFLENBQUN1RSxPQUFILENBQVcyWixZQUF0QyxJQUFzRDdMLFVBQVUsQ0FBQ3JULElBQUQsQ0FBVixJQUFvQmdCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV2tILE9BQXpGLEVBQ0U7QUFBRThlLHFCQUFhLEdBQUcsSUFBaEI7QUFBdUI7O0FBQzNCLFVBQUkvakIsTUFBTSxDQUFDMkQsU0FBUCxJQUFvQnd6QixPQUFPLElBQUlwcUMsSUFBSSxDQUFDNEQsSUFBeEMsRUFBOEM7QUFBRW9KLHdCQUFnQixDQUFDcEosSUFBRCxFQUFPLENBQVAsQ0FBaEI7QUFBNEI7O0FBQzVFMFAsbUJBQWEsQ0FBQzFQLElBQUQsRUFBTyxJQUFJb1AsVUFBSixDQUFlQyxNQUFmLEVBQ2VtM0IsT0FBTyxJQUFJcHFDLElBQUksQ0FBQzRELElBQWhCLEdBQXVCNUQsSUFBSSxDQUFDaEIsRUFBNUIsR0FBaUMsSUFEaEQsRUFFZW9yQyxPQUFPLElBQUlucUMsRUFBRSxDQUFDMkQsSUFBZCxHQUFxQjNELEVBQUUsQ0FBQ2pCLEVBQXhCLEdBQTZCLElBRjVDLENBQVAsQ0FBYjtBQUdBLFFBQUVvckMsT0FBRjtBQUNELEtBUkQsRUEvQjhDLENBd0M5Qzs7QUFDQSxRQUFJbjNCLE1BQU0sQ0FBQzJELFNBQVgsRUFBc0I7QUFBRXhLLFNBQUcsQ0FBQ1UsSUFBSixDQUFTOU0sSUFBSSxDQUFDNEQsSUFBZCxFQUFvQjNELEVBQUUsQ0FBQzJELElBQUgsR0FBVSxDQUE5QixFQUFpQyxVQUFVQSxJQUFWLEVBQWdCO0FBQ3ZFLFlBQUk4VCxZQUFZLENBQUN0TCxHQUFELEVBQU14SSxJQUFOLENBQWhCLEVBQTZCO0FBQUVvSiwwQkFBZ0IsQ0FBQ3BKLElBQUQsRUFBTyxDQUFQLENBQWhCO0FBQTRCO0FBQzVELE9BRnVCO0FBRW5COztBQUVMLFFBQUlxUCxNQUFNLENBQUNvM0IsWUFBWCxFQUF5QjtBQUFFdG1DLFFBQUUsQ0FBQ2tQLE1BQUQsRUFBUyxtQkFBVCxFQUE4QixZQUFZO0FBQUUsZUFBT0EsTUFBTSxDQUFDd2lCLEtBQVAsRUFBUDtBQUF3QixPQUFwRSxDQUFGO0FBQTBFOztBQUVyRyxRQUFJeGlCLE1BQU0sQ0FBQ3FDLFFBQVgsRUFBcUI7QUFDbkJ4QyxzQkFBZ0I7O0FBQ2hCLFVBQUkxRyxHQUFHLENBQUMwMkIsT0FBSixDQUFZckIsSUFBWixDQUFpQnJxQyxNQUFqQixJQUEyQmdWLEdBQUcsQ0FBQzAyQixPQUFKLENBQVlwQixNQUFaLENBQW1CdHFDLE1BQWxELEVBQ0U7QUFBRWdWLFdBQUcsQ0FBQ2srQixZQUFKO0FBQXFCO0FBQzFCOztBQUNELFFBQUlyM0IsTUFBTSxDQUFDMkQsU0FBWCxFQUFzQjtBQUNwQjNELFlBQU0sQ0FBQy9XLEVBQVAsR0FBWSxFQUFFeXRDLFlBQWQ7QUFDQTEyQixZQUFNLENBQUMyeUIsTUFBUCxHQUFnQixJQUFoQjtBQUNEOztBQUNELFFBQUloaEMsRUFBSixFQUFRO0FBQ047QUFDQSxVQUFJb3lCLGFBQUosRUFBbUI7QUFBRXB5QixVQUFFLENBQUNRLEtBQUgsQ0FBUzR4QixhQUFULEdBQXlCLElBQXpCO0FBQWdDOztBQUNyRCxVQUFJL2pCLE1BQU0sQ0FBQzJELFNBQVgsRUFDRTtBQUFFa1UsaUJBQVMsQ0FBQ2xtQixFQUFELEVBQUs1RSxJQUFJLENBQUM0RCxJQUFWLEVBQWdCM0QsRUFBRSxDQUFDMkQsSUFBSCxHQUFVLENBQTFCLENBQVQ7QUFBd0MsT0FENUMsTUFFSyxJQUFJcVAsTUFBTSxDQUFDamMsU0FBUCxJQUFvQmljLE1BQU0sQ0FBQ2lILFVBQTNCLElBQXlDakgsTUFBTSxDQUFDa0gsUUFBaEQsSUFBNERsSCxNQUFNLENBQUNtSCxHQUFuRSxJQUNBbkgsTUFBTSxDQUFDb0gsVUFEUCxJQUNxQnBILE1BQU0sQ0FBQ2dILEtBRGhDLEVBRUg7QUFBRSxhQUFLLElBQUk1aEIsQ0FBQyxHQUFHMkgsSUFBSSxDQUFDNEQsSUFBbEIsRUFBd0J2TCxDQUFDLElBQUk0SCxFQUFFLENBQUMyRCxJQUFoQyxFQUFzQ3ZMLENBQUMsRUFBdkMsRUFBMkM7QUFBRW16Qix1QkFBYSxDQUFDNW1CLEVBQUQsRUFBS3ZNLENBQUwsRUFBUSxNQUFSLENBQWI7QUFBK0I7QUFBRTs7QUFDbEYsVUFBSTRhLE1BQU0sQ0FBQzJ5QixNQUFYLEVBQW1CO0FBQUVYLHdCQUFnQixDQUFDcmdDLEVBQUUsQ0FBQ3dILEdBQUosQ0FBaEI7QUFBMkI7O0FBQ2hEaVIsaUJBQVcsQ0FBQ3pZLEVBQUQsRUFBSyxhQUFMLEVBQW9CQSxFQUFwQixFQUF3QnFPLE1BQXhCLENBQVg7QUFDRDs7QUFDRCxXQUFPQSxNQUFQO0FBQ0QsR0ExMUxrQixDQTQxTG5CO0FBRUE7QUFDQTtBQUNBOzs7QUFDQSxNQUFJczNCLGdCQUFnQixHQUFHLFNBQW5CQSxnQkFBbUIsQ0FBU24xQixPQUFULEVBQWtCNlcsT0FBbEIsRUFBMkI7QUFDaEQsU0FBSzdXLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUs2VyxPQUFMLEdBQWVBLE9BQWY7O0FBQ0EsU0FBSyxJQUFJNXpCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcrYyxPQUFPLENBQUNoZSxNQUE1QixFQUFvQyxFQUFFaUIsQ0FBdEMsRUFDRTtBQUFFK2MsYUFBTyxDQUFDL2MsQ0FBRCxDQUFQLENBQVdULE1BQVgsR0FBb0IsSUFBcEI7QUFBMkI7QUFDaEMsR0FMRDs7QUFPQTJ5QyxrQkFBZ0IsQ0FBQ3p2QyxTQUFqQixDQUEyQjI2QixLQUEzQixHQUFtQyxZQUFZO0FBQzdDLFFBQUksS0FBSzhOLGlCQUFULEVBQTRCO0FBQUU7QUFBUTs7QUFDdEMsU0FBS0EsaUJBQUwsR0FBeUIsSUFBekI7O0FBQ0EsU0FBSyxJQUFJbHJDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsS0FBSytjLE9BQUwsQ0FBYWhlLE1BQWpDLEVBQXlDLEVBQUVpQixDQUEzQyxFQUNFO0FBQUUsV0FBSytjLE9BQUwsQ0FBYS9jLENBQWIsRUFBZ0JvOUIsS0FBaEI7QUFBMEI7O0FBQzlCcFksZUFBVyxDQUFDLElBQUQsRUFBTyxPQUFQLENBQVg7QUFDRCxHQU5EOztBQVFBa3RCLGtCQUFnQixDQUFDenZDLFNBQWpCLENBQTJCMmEsSUFBM0IsR0FBa0MsVUFBVW9ZLElBQVYsRUFBZ0IvVixPQUFoQixFQUF5QjtBQUN6RCxXQUFPLEtBQUttVSxPQUFMLENBQWF4VyxJQUFiLENBQWtCb1ksSUFBbEIsRUFBd0IvVixPQUF4QixDQUFQO0FBQ0QsR0FGRDs7QUFHQXZTLFlBQVUsQ0FBQ2dsQyxnQkFBRCxDQUFWOztBQUVBLFdBQVNOLGNBQVQsQ0FBd0I3OUIsR0FBeEIsRUFBNkJwTSxJQUE3QixFQUFtQ0MsRUFBbkMsRUFBdUNrSixPQUF2QyxFQUFnRGxILElBQWhELEVBQXNEO0FBQ3BEa0gsV0FBTyxHQUFHak8sT0FBTyxDQUFDaU8sT0FBRCxDQUFqQjtBQUNBQSxXQUFPLENBQUNnNEIsTUFBUixHQUFpQixLQUFqQjtBQUNBLFFBQUkvckIsT0FBTyxHQUFHLENBQUM0MEIsU0FBUSxDQUFDNTlCLEdBQUQsRUFBTXBNLElBQU4sRUFBWUMsRUFBWixFQUFnQmtKLE9BQWhCLEVBQXlCbEgsSUFBekIsQ0FBVCxDQUFkO0FBQUEsUUFBd0RncUIsT0FBTyxHQUFHN1csT0FBTyxDQUFDLENBQUQsQ0FBekU7QUFDQSxRQUFJaUcsTUFBTSxHQUFHbFMsT0FBTyxDQUFDd08sVUFBckI7QUFDQWlwQixjQUFVLENBQUN4MEIsR0FBRCxFQUFNLFVBQVVBLEdBQVYsRUFBZTtBQUM3QixVQUFJaVAsTUFBSixFQUFZO0FBQUVsUyxlQUFPLENBQUN3TyxVQUFSLEdBQXFCMEQsTUFBTSxDQUFDbXZCLFNBQVAsQ0FBaUIsSUFBakIsQ0FBckI7QUFBOEM7O0FBQzVEcDFCLGFBQU8sQ0FBQ3RYLElBQVIsQ0FBYWtzQyxTQUFRLENBQUM1OUIsR0FBRCxFQUFNa0MsUUFBTyxDQUFDbEMsR0FBRCxFQUFNcE0sSUFBTixDQUFiLEVBQTBCc08sUUFBTyxDQUFDbEMsR0FBRCxFQUFNbk0sRUFBTixDQUFqQyxFQUE0Q2tKLE9BQTVDLEVBQXFEbEgsSUFBckQsQ0FBckI7O0FBQ0EsV0FBSyxJQUFJNUosQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRytULEdBQUcsQ0FBQzYwQixNQUFKLENBQVc3cEMsTUFBL0IsRUFBdUMsRUFBRWlCLENBQXpDLEVBQ0U7QUFBRSxZQUFJK1QsR0FBRyxDQUFDNjBCLE1BQUosQ0FBVzVvQyxDQUFYLEVBQWNveUMsUUFBbEIsRUFBNEI7QUFBRTtBQUFRO0FBQUU7O0FBQzVDeGUsYUFBTyxHQUFHbHVCLEdBQUcsQ0FBQ3FYLE9BQUQsQ0FBYjtBQUNELEtBTlMsQ0FBVjtBQU9BLFdBQU8sSUFBSW0xQixnQkFBSixDQUFxQm4xQixPQUFyQixFQUE4QjZXLE9BQTlCLENBQVA7QUFDRDs7QUFFRCxXQUFTeWUsaUJBQVQsQ0FBMkJ0K0IsR0FBM0IsRUFBZ0M7QUFDOUIsV0FBT0EsR0FBRyxDQUFDdStCLFNBQUosQ0FBYzc4QixHQUFHLENBQUMxQixHQUFHLENBQUNDLEtBQUwsRUFBWSxDQUFaLENBQWpCLEVBQWlDRCxHQUFHLENBQUNrQyxPQUFKLENBQVlSLEdBQUcsQ0FBQzFCLEdBQUcsQ0FBQ3FMLFFBQUosRUFBRCxDQUFmLENBQWpDLEVBQW1FLFVBQVV0VSxDQUFWLEVBQWE7QUFBRSxhQUFPQSxDQUFDLENBQUN2TCxNQUFUO0FBQWtCLEtBQXBHLENBQVA7QUFDRDs7QUFFRCxXQUFTZ3pDLGlCQUFULENBQTJCeCtCLEdBQTNCLEVBQWdDZ0osT0FBaEMsRUFBeUM7QUFDdkMsU0FBSyxJQUFJL2MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRytjLE9BQU8sQ0FBQ2hlLE1BQTVCLEVBQW9DaUIsQ0FBQyxFQUFyQyxFQUF5QztBQUN2QyxVQUFJNGEsTUFBTSxHQUFHbUMsT0FBTyxDQUFDL2MsQ0FBRCxDQUFwQjtBQUFBLFVBQXlCa0YsR0FBRyxHQUFHMFYsTUFBTSxDQUFDd0MsSUFBUCxFQUEvQjtBQUNBLFVBQUlvMUIsS0FBSyxHQUFHeitCLEdBQUcsQ0FBQ2tDLE9BQUosQ0FBWS9RLEdBQUcsQ0FBQ3lDLElBQWhCLENBQVo7QUFBQSxVQUFtQzhxQyxHQUFHLEdBQUcxK0IsR0FBRyxDQUFDa0MsT0FBSixDQUFZL1EsR0FBRyxDQUFDMEMsRUFBaEIsQ0FBekM7O0FBQ0EsVUFBSThOLEdBQUcsQ0FBQzg4QixLQUFELEVBQVFDLEdBQVIsQ0FBUCxFQUFxQjtBQUNuQixZQUFJQyxPQUFPLEdBQUdmLFNBQVEsQ0FBQzU5QixHQUFELEVBQU15K0IsS0FBTixFQUFhQyxHQUFiLEVBQWtCNzNCLE1BQU0sQ0FBQ2daLE9BQXpCLEVBQWtDaFosTUFBTSxDQUFDZ1osT0FBUCxDQUFlaHFCLElBQWpELENBQXRCOztBQUNBZ1IsY0FBTSxDQUFDbUMsT0FBUCxDQUFldFgsSUFBZixDQUFvQml0QyxPQUFwQjtBQUNBQSxlQUFPLENBQUNuekMsTUFBUixHQUFpQnFiLE1BQWpCO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFdBQVMrM0IsbUJBQVQsQ0FBNkI1MUIsT0FBN0IsRUFBc0M7QUFDcEMsUUFBSXhGLElBQUksR0FBRyxTQUFQQSxJQUFPLENBQVd2WCxDQUFYLEVBQWU7QUFDeEIsVUFBSTRhLE1BQU0sR0FBR21DLE9BQU8sQ0FBQy9jLENBQUQsQ0FBcEI7QUFBQSxVQUF5QjRvQyxNQUFNLEdBQUcsQ0FBQ2h1QixNQUFNLENBQUNnWixPQUFQLENBQWU3ZixHQUFoQixDQUFsQztBQUNBdzBCLGdCQUFVLENBQUMzdEIsTUFBTSxDQUFDZ1osT0FBUCxDQUFlN2YsR0FBaEIsRUFBcUIsVUFBVTZMLENBQVYsRUFBYTtBQUFFLGVBQU9ncEIsTUFBTSxDQUFDbmpDLElBQVAsQ0FBWW1hLENBQVosQ0FBUDtBQUF3QixPQUE1RCxDQUFWOztBQUNBLFdBQUssSUFBSXZWLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1USxNQUFNLENBQUNtQyxPQUFQLENBQWVoZSxNQUFuQyxFQUEyQ3NMLENBQUMsRUFBNUMsRUFBZ0Q7QUFDOUMsWUFBSXVvQyxTQUFTLEdBQUdoNEIsTUFBTSxDQUFDbUMsT0FBUCxDQUFlMVMsQ0FBZixDQUFoQjs7QUFDQSxZQUFJMUcsT0FBTyxDQUFDaWxDLE1BQUQsRUFBU2dLLFNBQVMsQ0FBQzcrQixHQUFuQixDQUFQLElBQWtDLENBQUMsQ0FBdkMsRUFBMEM7QUFDeEM2K0IsbUJBQVMsQ0FBQ3J6QyxNQUFWLEdBQW1CLElBQW5CO0FBQ0FxYixnQkFBTSxDQUFDbUMsT0FBUCxDQUFlOVcsTUFBZixDQUFzQm9FLENBQUMsRUFBdkIsRUFBMkIsQ0FBM0I7QUFDRDtBQUNGO0FBQ0YsS0FWRDs7QUFZQSxTQUFLLElBQUlySyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHK2MsT0FBTyxDQUFDaGUsTUFBNUIsRUFBb0NpQixDQUFDLEVBQXJDO0FBQXlDdVgsVUFBSSxDQUFFdlgsQ0FBRixDQUFKO0FBQXpDO0FBQ0Q7O0FBRUQsTUFBSTZ5QyxTQUFTLEdBQUcsQ0FBaEI7O0FBQ0EsTUFBSUMsR0FBRyxHQUFHLFNBQU5BLEdBQU0sQ0FBU3RuQyxJQUFULEVBQWUrRSxJQUFmLEVBQXFCdTNCLFNBQXJCLEVBQWdDaUwsT0FBaEMsRUFBeUN6cEMsU0FBekMsRUFBb0Q7QUFDNUQsUUFBSSxFQUFFLGdCQUFnQndwQyxHQUFsQixDQUFKLEVBQTRCO0FBQUUsYUFBTyxJQUFJQSxHQUFKLENBQVF0bkMsSUFBUixFQUFjK0UsSUFBZCxFQUFvQnUzQixTQUFwQixFQUErQmlMLE9BQS9CLEVBQXdDenBDLFNBQXhDLENBQVA7QUFBMkQ7O0FBQ3pGLFFBQUl3K0IsU0FBUyxJQUFJLElBQWpCLEVBQXVCO0FBQUVBLGVBQVMsR0FBRyxDQUFaO0FBQWdCOztBQUV6Q3NJLGVBQVcsQ0FBQzF0QyxJQUFaLENBQWlCLElBQWpCLEVBQXVCLENBQUMsSUFBSXN0QyxTQUFKLENBQWMsQ0FBQyxJQUFJaHdCLElBQUosQ0FBUyxFQUFULEVBQWEsSUFBYixDQUFELENBQWQsQ0FBRCxDQUF2QjtBQUNBLFNBQUtoTSxLQUFMLEdBQWE4ekIsU0FBYjtBQUNBLFNBQUt4WixTQUFMLEdBQWlCLEtBQUtKLFVBQUwsR0FBa0IsQ0FBbkM7QUFDQSxTQUFLeWYsUUFBTCxHQUFnQixLQUFoQjtBQUNBLFNBQUtxRixlQUFMLEdBQXVCLENBQXZCO0FBQ0EsU0FBS3Y2QixZQUFMLEdBQW9CLEtBQUtELGlCQUFMLEdBQXlCc3ZCLFNBQTdDO0FBQ0EsUUFBSXpuQyxLQUFLLEdBQUdvVixHQUFHLENBQUNxeUIsU0FBRCxFQUFZLENBQVosQ0FBZjtBQUNBLFNBQUs5VCxHQUFMLEdBQVc2UyxlQUFlLENBQUN4bUMsS0FBRCxDQUExQjtBQUNBLFNBQUtvcUMsT0FBTCxHQUFlLElBQUl2QixPQUFKLENBQVksSUFBWixDQUFmO0FBQ0EsU0FBS3JsQyxFQUFMLEdBQVUsRUFBRWd2QyxTQUFaO0FBQ0EsU0FBS3RMLFVBQUwsR0FBa0JoM0IsSUFBbEI7QUFDQSxTQUFLd2lDLE9BQUwsR0FBZUEsT0FBZjtBQUNBLFNBQUt6cEMsU0FBTCxHQUFrQkEsU0FBUyxJQUFJLEtBQWQsR0FBdUIsS0FBdkIsR0FBK0IsS0FBaEQ7QUFDQSxTQUFLeTRCLE1BQUwsR0FBYyxLQUFkOztBQUVBLFFBQUksT0FBT3YyQixJQUFQLElBQWUsUUFBbkIsRUFBNkI7QUFBRUEsVUFBSSxHQUFHLEtBQUtna0MsVUFBTCxDQUFnQmhrQyxJQUFoQixDQUFQO0FBQStCOztBQUM5RG04QixhQUFTLENBQUMsSUFBRCxFQUFPO0FBQUNoZ0MsVUFBSSxFQUFFdEgsS0FBUDtBQUFjdUgsUUFBRSxFQUFFdkgsS0FBbEI7QUFBeUJtTCxVQUFJLEVBQUVBO0FBQS9CLEtBQVAsQ0FBVDtBQUNBd2dDLGdCQUFZLENBQUMsSUFBRCxFQUFPbkYsZUFBZSxDQUFDeG1DLEtBQUQsQ0FBdEIsRUFBK0JzRSxjQUEvQixDQUFaO0FBQ0QsR0F0QkQ7O0FBd0JBbXVDLEtBQUcsQ0FBQ3J3QyxTQUFKLEdBQWdCMEQsU0FBUyxDQUFDaXFDLFdBQVcsQ0FBQzN0QyxTQUFiLEVBQXdCO0FBQy9Dd3dDLGVBQVcsRUFBRUgsR0FEa0M7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQXIrQixRQUFJLEVBQUUsY0FBUzlNLElBQVQsRUFBZUMsRUFBZixFQUFtQnljLEVBQW5CLEVBQXVCO0FBQzNCLFVBQUlBLEVBQUosRUFBUTtBQUFFLGFBQUs4ckIsS0FBTCxDQUFXeG9DLElBQUksR0FBRyxLQUFLcU0sS0FBdkIsRUFBOEJwTSxFQUFFLEdBQUdELElBQW5DLEVBQXlDMGMsRUFBekM7QUFBK0MsT0FBekQsTUFDSztBQUFFLGFBQUs4ckIsS0FBTCxDQUFXLEtBQUtuOEIsS0FBaEIsRUFBdUIsS0FBS0EsS0FBTCxHQUFhLEtBQUtDLElBQXpDLEVBQStDdE0sSUFBL0M7QUFBdUQ7QUFDL0QsS0FUOEM7QUFXL0M7QUFDQXVnQyxVQUFNLEVBQUUsZ0JBQVNsOUIsRUFBVCxFQUFhb0osS0FBYixFQUFvQjtBQUMxQixVQUFJUSxNQUFNLEdBQUcsQ0FBYjs7QUFDQSxXQUFLLElBQUk1VSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHb1UsS0FBSyxDQUFDclYsTUFBMUIsRUFBa0MsRUFBRWlCLENBQXBDLEVBQXVDO0FBQUU0VSxjQUFNLElBQUlSLEtBQUssQ0FBQ3BVLENBQUQsQ0FBTCxDQUFTNFUsTUFBbkI7QUFBNEI7O0FBQ3JFLFdBQUtzN0IsV0FBTCxDQUFpQmxsQyxFQUFFLEdBQUcsS0FBS2dKLEtBQTNCLEVBQWtDSSxLQUFsQyxFQUF5Q1EsTUFBekM7QUFDRCxLQWhCOEM7QUFpQi9DdXpCLFVBQU0sRUFBRSxnQkFBU245QixFQUFULEVBQWF2SCxDQUFiLEVBQWdCO0FBQUUsV0FBS3dzQyxXQUFMLENBQWlCamxDLEVBQUUsR0FBRyxLQUFLZ0osS0FBM0IsRUFBa0N2USxDQUFsQztBQUF1QyxLQWpCbEI7QUFtQi9DO0FBQ0E7QUFFQXl2QyxZQUFRLEVBQUUsa0JBQVNILE9BQVQsRUFBa0I7QUFDMUIsVUFBSTMrQixLQUFLLEdBQUdNLFFBQVEsQ0FBQyxJQUFELEVBQU8sS0FBS1YsS0FBWixFQUFtQixLQUFLQSxLQUFMLEdBQWEsS0FBS0MsSUFBckMsQ0FBcEI7O0FBQ0EsVUFBSTgrQixPQUFPLEtBQUssS0FBaEIsRUFBdUI7QUFBRSxlQUFPMytCLEtBQVA7QUFBYzs7QUFDdkMsYUFBT0EsS0FBSyxDQUFDKytCLElBQU4sQ0FBV0osT0FBTyxJQUFJLEtBQUtLLGFBQUwsRUFBdEIsQ0FBUDtBQUNELEtBMUI4QztBQTJCL0NDLFlBQVEsRUFBRTdTLFdBQVcsQ0FBQyxVQUFTejNCLElBQVQsRUFBZTtBQUNuQyxVQUFJZ2lCLEdBQUcsR0FBR3RWLEdBQUcsQ0FBQyxLQUFLekIsS0FBTixFQUFhLENBQWIsQ0FBYjtBQUFBLFVBQThCa0MsSUFBSSxHQUFHLEtBQUtsQyxLQUFMLEdBQWEsS0FBS0MsSUFBbEIsR0FBeUIsQ0FBOUQ7QUFDQSs1QixnQkFBVSxDQUFDLElBQUQsRUFBTztBQUFDcm1DLFlBQUksRUFBRW9qQixHQUFQO0FBQVluakIsVUFBRSxFQUFFNk4sR0FBRyxDQUFDUyxJQUFELEVBQU9wQyxPQUFPLENBQUMsSUFBRCxFQUFPb0MsSUFBUCxDQUFQLENBQW9CMUssSUFBcEIsQ0FBeUJ6TSxNQUFoQyxDQUFuQjtBQUNDeU0sWUFBSSxFQUFFLEtBQUtna0MsVUFBTCxDQUFnQnptQyxJQUFoQixDQURQO0FBQzhCakUsY0FBTSxFQUFFLFVBRHRDO0FBQ2tEb1gsWUFBSSxFQUFFO0FBRHhELE9BQVAsRUFDc0UsSUFEdEUsQ0FBVjs7QUFFQSxVQUFJLEtBQUszUCxFQUFULEVBQWE7QUFBRW11QixzQkFBYyxDQUFDLEtBQUtudUIsRUFBTixFQUFVLENBQVYsRUFBYSxDQUFiLENBQWQ7QUFBZ0M7O0FBQy9DeS9CLGtCQUFZLENBQUMsSUFBRCxFQUFPbkYsZUFBZSxDQUFDOWIsR0FBRCxDQUF0QixFQUE2QnBtQixjQUE3QixDQUFaO0FBQ0QsS0FOb0IsQ0EzQjBCO0FBa0MvQzJxQyxnQkFBWSxFQUFFLHNCQUFTdm1DLElBQVQsRUFBZXBCLElBQWYsRUFBcUJDLEVBQXJCLEVBQXlCOUMsTUFBekIsRUFBaUM7QUFDN0M2QyxVQUFJLEdBQUdzTyxRQUFPLENBQUMsSUFBRCxFQUFPdE8sSUFBUCxDQUFkO0FBQ0FDLFFBQUUsR0FBR0EsRUFBRSxHQUFHcU8sUUFBTyxDQUFDLElBQUQsRUFBT3JPLEVBQVAsQ0FBVixHQUF1QkQsSUFBOUI7O0FBQ0EybkMsbUJBQVksQ0FBQyxJQUFELEVBQU92bUMsSUFBUCxFQUFhcEIsSUFBYixFQUFtQkMsRUFBbkIsRUFBdUI5QyxNQUF2QixDQUFaO0FBQ0QsS0F0QzhDO0FBdUMvQ3d1QyxZQUFRLEVBQUUsa0JBQVMzckMsSUFBVCxFQUFlQyxFQUFmLEVBQW1CbXJDLE9BQW5CLEVBQTRCO0FBQ3BDLFVBQUkzK0IsS0FBSyxHQUFHSSxVQUFVLENBQUMsSUFBRCxFQUFPeUIsUUFBTyxDQUFDLElBQUQsRUFBT3RPLElBQVAsQ0FBZCxFQUE0QnNPLFFBQU8sQ0FBQyxJQUFELEVBQU9yTyxFQUFQLENBQW5DLENBQXRCOztBQUNBLFVBQUltckMsT0FBTyxLQUFLLEtBQWhCLEVBQXVCO0FBQUUsZUFBTzMrQixLQUFQO0FBQWM7O0FBQ3ZDLGFBQU9BLEtBQUssQ0FBQysrQixJQUFOLENBQVdKLE9BQU8sSUFBSSxLQUFLSyxhQUFMLEVBQXRCLENBQVA7QUFDRCxLQTNDOEM7QUE2Qy9DdC9CLFdBQU8sRUFBRSxpQkFBU3ZJLElBQVQsRUFBZTtBQUFDLFVBQUkwRCxDQUFDLEdBQUcsS0FBS3NrQyxhQUFMLENBQW1CaG9DLElBQW5CLENBQVI7QUFBa0MsYUFBTzBELENBQUMsSUFBSUEsQ0FBQyxDQUFDekQsSUFBZDtBQUFtQixLQTdDL0I7QUErQy9DK25DLGlCQUFhLEVBQUUsdUJBQVNob0MsSUFBVCxFQUFlO0FBQUMsVUFBSTZKLE1BQU0sQ0FBQyxJQUFELEVBQU83SixJQUFQLENBQVYsRUFBd0I7QUFBRSxlQUFPdUksT0FBTyxDQUFDLElBQUQsRUFBT3ZJLElBQVAsQ0FBZDtBQUE0QjtBQUFDLEtBL0N2QztBQWdEL0Npb0MsaUJBQWEsRUFBRSx1QkFBU2pvQyxJQUFULEVBQWU7QUFBQyxhQUFPdUosTUFBTSxDQUFDdkosSUFBRCxDQUFiO0FBQW9CLEtBaERKO0FBa0QvQ2tvQyw0QkFBd0IsRUFBRSxrQ0FBU2xvQyxJQUFULEVBQWU7QUFDdkMsVUFBSSxPQUFPQSxJQUFQLElBQWUsUUFBbkIsRUFBNkI7QUFBRUEsWUFBSSxHQUFHdUksT0FBTyxDQUFDLElBQUQsRUFBT3ZJLElBQVAsQ0FBZDtBQUE2Qjs7QUFDNUQsYUFBT3FULFVBQVUsQ0FBQ3JULElBQUQsQ0FBakI7QUFDRCxLQXJEOEM7QUF1RC9DbW9DLGFBQVMsRUFBRSxxQkFBVztBQUFDLGFBQU8sS0FBS3ovQixJQUFaO0FBQWlCLEtBdkRPO0FBd0QvQzZ6QixhQUFTLEVBQUUscUJBQVc7QUFBQyxhQUFPLEtBQUs5ekIsS0FBWjtBQUFrQixLQXhETTtBQXlEL0NvTCxZQUFRLEVBQUUsb0JBQVc7QUFBQyxhQUFPLEtBQUtwTCxLQUFMLEdBQWEsS0FBS0MsSUFBbEIsR0FBeUIsQ0FBaEM7QUFBa0MsS0F6RFQ7QUEyRC9DZ0MsV0FBTyxFQUFFLGlCQUFTL1EsR0FBVCxFQUFjO0FBQUMsYUFBTytRLFFBQU8sQ0FBQyxJQUFELEVBQU8vUSxHQUFQLENBQWQ7QUFBMEIsS0EzREg7QUE2RC9DcTFCLGFBQVMsRUFBRSxtQkFBU2w2QixLQUFULEVBQWdCO0FBQ3pCLFVBQUlGLEtBQUssR0FBRyxLQUFLNnpCLEdBQUwsQ0FBU0osT0FBVCxFQUFaO0FBQUEsVUFBZ0MxdUIsR0FBaEM7O0FBQ0EsVUFBSTdFLEtBQUssSUFBSSxJQUFULElBQWlCQSxLQUFLLElBQUksTUFBOUIsRUFBc0M7QUFBRTZFLFdBQUcsR0FBRy9FLEtBQUssQ0FBQ20wQixJQUFaO0FBQW1CLE9BQTNELE1BQ0ssSUFBSWowQixLQUFLLElBQUksUUFBYixFQUF1QjtBQUFFNkUsV0FBRyxHQUFHL0UsS0FBSyxDQUFDb3hCLE1BQVo7QUFBcUIsT0FBOUMsTUFDQSxJQUFJbHhCLEtBQUssSUFBSSxLQUFULElBQWtCQSxLQUFLLElBQUksSUFBM0IsSUFBbUNBLEtBQUssS0FBSyxLQUFqRCxFQUF3RDtBQUFFNkUsV0FBRyxHQUFHL0UsS0FBSyxDQUFDeUgsRUFBTixFQUFOO0FBQW1CLE9BQTdFLE1BQ0E7QUFBRTFDLFdBQUcsR0FBRy9FLEtBQUssQ0FBQ3dILElBQU4sRUFBTjtBQUFxQjs7QUFDNUIsYUFBT3pDLEdBQVA7QUFDRCxLQXBFOEM7QUFxRS9DeXVDLGtCQUFjLEVBQUUsMEJBQVc7QUFBRSxhQUFPLEtBQUszZixHQUFMLENBQVNDLE1BQWhCO0FBQXdCLEtBckVOO0FBc0UvQ3FTLHFCQUFpQixFQUFFLDZCQUFXO0FBQUMsYUFBTyxLQUFLdFMsR0FBTCxDQUFTc1MsaUJBQVQsRUFBUDtBQUFvQyxLQXRFcEI7QUF3RS9Dc04sYUFBUyxFQUFFcFQsV0FBVyxDQUFDLFVBQVNqMUIsSUFBVCxFQUFlNUUsRUFBZixFQUFtQm1LLE9BQW5CLEVBQTRCO0FBQ2pEdTdCLHdCQUFrQixDQUFDLElBQUQsRUFBT3AyQixRQUFPLENBQUMsSUFBRCxFQUFPLE9BQU8xSyxJQUFQLElBQWUsUUFBZixHQUEwQmtLLEdBQUcsQ0FBQ2xLLElBQUQsRUFBTzVFLEVBQUUsSUFBSSxDQUFiLENBQTdCLEdBQStDNEUsSUFBdEQsQ0FBZCxFQUEyRSxJQUEzRSxFQUFpRnVGLE9BQWpGLENBQWxCO0FBQ0QsS0FGcUIsQ0F4RXlCO0FBMkUvQ2s3QixnQkFBWSxFQUFFeEwsV0FBVyxDQUFDLFVBQVNqUCxNQUFULEVBQWlCK0MsSUFBakIsRUFBdUJ4akIsT0FBdkIsRUFBZ0M7QUFDeER1N0Isd0JBQWtCLENBQUMsSUFBRCxFQUFPcDJCLFFBQU8sQ0FBQyxJQUFELEVBQU9zYixNQUFQLENBQWQsRUFBOEJ0YixRQUFPLENBQUMsSUFBRCxFQUFPcWUsSUFBSSxJQUFJL0MsTUFBZixDQUFyQyxFQUE2RHpnQixPQUE3RCxDQUFsQjtBQUNELEtBRndCLENBM0VzQjtBQThFL0NpN0IsbUJBQWUsRUFBRXZMLFdBQVcsQ0FBQyxVQUFTbE0sSUFBVCxFQUFlN0UsS0FBZixFQUFzQjNlLE9BQXRCLEVBQStCO0FBQzFEaTdCLHFCQUFlLENBQUMsSUFBRCxFQUFPOTFCLFFBQU8sQ0FBQyxJQUFELEVBQU9xZSxJQUFQLENBQWQsRUFBNEI3RSxLQUFLLElBQUl4WixRQUFPLENBQUMsSUFBRCxFQUFPd1osS0FBUCxDQUE1QyxFQUEyRDNlLE9BQTNELENBQWY7QUFDRCxLQUYyQixDQTlFbUI7QUFpRi9DbTdCLG9CQUFnQixFQUFFekwsV0FBVyxDQUFDLFVBQVMwTCxLQUFULEVBQWdCcDdCLE9BQWhCLEVBQXlCO0FBQ3JEbTdCLHNCQUFnQixDQUFDLElBQUQsRUFBTzUxQixZQUFZLENBQUMsSUFBRCxFQUFPNjFCLEtBQVAsQ0FBbkIsRUFBa0NwN0IsT0FBbEMsQ0FBaEI7QUFDRCxLQUY0QixDQWpGa0I7QUFvRi9DK2lDLHNCQUFrQixFQUFFclQsV0FBVyxDQUFDLFVBQVNsK0IsQ0FBVCxFQUFZd08sT0FBWixFQUFxQjtBQUNuRCxVQUFJbzdCLEtBQUssR0FBR3RtQyxHQUFHLENBQUMsS0FBS291QixHQUFMLENBQVNDLE1BQVYsRUFBa0IzeEIsQ0FBbEIsQ0FBZjtBQUNBMnBDLHNCQUFnQixDQUFDLElBQUQsRUFBTzUxQixZQUFZLENBQUMsSUFBRCxFQUFPNjFCLEtBQVAsQ0FBbkIsRUFBa0NwN0IsT0FBbEMsQ0FBaEI7QUFDRCxLQUg4QixDQXBGZ0I7QUF3Ri9DZ2pDLGlCQUFhLEVBQUV0VCxXQUFXLENBQUMsVUFBU3ZNLE1BQVQsRUFBaUJMLE9BQWpCLEVBQTBCOWlCLE9BQTFCLEVBQW1DO0FBQzVELFVBQUksQ0FBQ21qQixNQUFNLENBQUNsMUIsTUFBWixFQUFvQjtBQUFFO0FBQVE7O0FBQzlCLFVBQUk4RyxHQUFHLEdBQUcsRUFBVjs7QUFDQSxXQUFLLElBQUk3RixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaTBCLE1BQU0sQ0FBQ2wxQixNQUEzQixFQUFtQ2lCLENBQUMsRUFBcEMsRUFDRTtBQUFFNkYsV0FBRyxDQUFDN0YsQ0FBRCxDQUFILEdBQVMsSUFBSXFtQyxLQUFKLENBQVVwd0IsUUFBTyxDQUFDLElBQUQsRUFBT2dlLE1BQU0sQ0FBQ2owQixDQUFELENBQU4sQ0FBVXV4QixNQUFqQixDQUFqQixFQUNRdGIsUUFBTyxDQUFDLElBQUQsRUFBT2dlLE1BQU0sQ0FBQ2owQixDQUFELENBQU4sQ0FBVXMwQixJQUFqQixDQURmLENBQVQ7QUFDa0Q7O0FBQ3RELFVBQUlWLE9BQU8sSUFBSSxJQUFmLEVBQXFCO0FBQUVBLGVBQU8sR0FBR3Z1QixJQUFJLENBQUNDLEdBQUwsQ0FBUzJ1QixNQUFNLENBQUNsMUIsTUFBUCxHQUFnQixDQUF6QixFQUE0QixLQUFLaTFCLEdBQUwsQ0FBU0UsU0FBckMsQ0FBVjtBQUE0RDs7QUFDbkY4WCxrQkFBWSxDQUFDLElBQUQsRUFBT3pGLGtCQUFrQixDQUFDLEtBQUtoNkIsRUFBTixFQUFVMUcsR0FBVixFQUFlK3RCLE9BQWYsQ0FBekIsRUFBa0Q5aUIsT0FBbEQsQ0FBWjtBQUNELEtBUnlCLENBeEZxQjtBQWlHL0NpakMsZ0JBQVksRUFBRXZULFdBQVcsQ0FBQyxVQUFTalAsTUFBVCxFQUFpQitDLElBQWpCLEVBQXVCeGpCLE9BQXZCLEVBQWdDO0FBQ3hELFVBQUltakIsTUFBTSxHQUFHLEtBQUtELEdBQUwsQ0FBU0MsTUFBVCxDQUFnQnAxQixLQUFoQixDQUFzQixDQUF0QixDQUFiO0FBQ0FvMUIsWUFBTSxDQUFDeHVCLElBQVAsQ0FBWSxJQUFJNGdDLEtBQUosQ0FBVXB3QixRQUFPLENBQUMsSUFBRCxFQUFPc2IsTUFBUCxDQUFqQixFQUFpQ3RiLFFBQU8sQ0FBQyxJQUFELEVBQU9xZSxJQUFJLElBQUkvQyxNQUFmLENBQXhDLENBQVo7QUFDQXlhLGtCQUFZLENBQUMsSUFBRCxFQUFPekYsa0JBQWtCLENBQUMsS0FBS2g2QixFQUFOLEVBQVUwbkIsTUFBVixFQUFrQkEsTUFBTSxDQUFDbDFCLE1BQVAsR0FBZ0IsQ0FBbEMsQ0FBekIsRUFBK0QrUixPQUEvRCxDQUFaO0FBQ0QsS0FKd0IsQ0FqR3NCO0FBdUcvQ3hCLGdCQUFZLEVBQUUsc0JBQVN5akMsT0FBVCxFQUFrQjtBQUM5QixVQUFJOWUsTUFBTSxHQUFHLEtBQUtELEdBQUwsQ0FBU0MsTUFBdEI7QUFBQSxVQUE4QjdmLEtBQTlCOztBQUNBLFdBQUssSUFBSXBVLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdpMEIsTUFBTSxDQUFDbDFCLE1BQTNCLEVBQW1DaUIsQ0FBQyxFQUFwQyxFQUF3QztBQUN0QyxZQUFJZzBCLEdBQUcsR0FBR3hmLFVBQVUsQ0FBQyxJQUFELEVBQU95ZixNQUFNLENBQUNqMEIsQ0FBRCxDQUFOLENBQVUySCxJQUFWLEVBQVAsRUFBeUJzc0IsTUFBTSxDQUFDajBCLENBQUQsQ0FBTixDQUFVNEgsRUFBVixFQUF6QixDQUFwQjtBQUNBd00sYUFBSyxHQUFHQSxLQUFLLEdBQUdBLEtBQUssQ0FBQ3JJLE1BQU4sQ0FBYWlvQixHQUFiLENBQUgsR0FBdUJBLEdBQXBDO0FBQ0Q7O0FBQ0QsVUFBSStlLE9BQU8sS0FBSyxLQUFoQixFQUF1QjtBQUFFLGVBQU8zK0IsS0FBUDtBQUFjLE9BQXZDLE1BQ0s7QUFBRSxlQUFPQSxLQUFLLENBQUMrK0IsSUFBTixDQUFXSixPQUFPLElBQUksS0FBS0ssYUFBTCxFQUF0QixDQUFQO0FBQW9EO0FBQzVELEtBL0c4QztBQWdIL0NZLGlCQUFhLEVBQUUsdUJBQVNqQixPQUFULEVBQWtCO0FBQy9CLFVBQUk3MUIsS0FBSyxHQUFHLEVBQVo7QUFBQSxVQUFnQitXLE1BQU0sR0FBRyxLQUFLRCxHQUFMLENBQVNDLE1BQWxDOztBQUNBLFdBQUssSUFBSWowQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaTBCLE1BQU0sQ0FBQ2wxQixNQUEzQixFQUFtQ2lCLENBQUMsRUFBcEMsRUFBd0M7QUFDdEMsWUFBSWcwQixHQUFHLEdBQUd4ZixVQUFVLENBQUMsSUFBRCxFQUFPeWYsTUFBTSxDQUFDajBCLENBQUQsQ0FBTixDQUFVMkgsSUFBVixFQUFQLEVBQXlCc3NCLE1BQU0sQ0FBQ2owQixDQUFELENBQU4sQ0FBVTRILEVBQVYsRUFBekIsQ0FBcEI7O0FBQ0EsWUFBSW1yQyxPQUFPLEtBQUssS0FBaEIsRUFBdUI7QUFBRS9lLGFBQUcsR0FBR0EsR0FBRyxDQUFDbWYsSUFBSixDQUFTSixPQUFPLElBQUksS0FBS0ssYUFBTCxFQUFwQixDQUFOO0FBQWtEOztBQUMzRWwyQixhQUFLLENBQUNsZCxDQUFELENBQUwsR0FBV2cwQixHQUFYO0FBQ0Q7O0FBQ0QsYUFBTzlXLEtBQVA7QUFDRCxLQXhIOEM7QUF5SC9DKzJCLG9CQUFnQixFQUFFLDBCQUFTbHJDLElBQVQsRUFBZWhJLFFBQWYsRUFBeUIrRCxNQUF6QixFQUFpQztBQUNqRCxVQUFJb3ZDLEdBQUcsR0FBRyxFQUFWOztBQUNBLFdBQUssSUFBSWwwQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEtBQUtnMEIsR0FBTCxDQUFTQyxNQUFULENBQWdCbDFCLE1BQXBDLEVBQTRDaUIsQ0FBQyxFQUE3QyxFQUNFO0FBQUVrMEMsV0FBRyxDQUFDbDBDLENBQUQsQ0FBSCxHQUFTK0ksSUFBVDtBQUFnQjs7QUFDcEIsV0FBS29yQyxpQkFBTCxDQUF1QkQsR0FBdkIsRUFBNEJuekMsUUFBNUIsRUFBc0MrRCxNQUFNLElBQUksUUFBaEQ7QUFDRCxLQTlIOEM7QUErSC9DcXZDLHFCQUFpQixFQUFFM1QsV0FBVyxDQUFDLFVBQVN6M0IsSUFBVCxFQUFlaEksUUFBZixFQUF5QitELE1BQXpCLEVBQWlDO0FBQzlELFVBQUl3Z0IsT0FBTyxHQUFHLEVBQWQ7QUFBQSxVQUFrQjBPLEdBQUcsR0FBRyxLQUFLQSxHQUE3Qjs7QUFDQSxXQUFLLElBQUloMEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2cwQixHQUFHLENBQUNDLE1BQUosQ0FBV2wxQixNQUEvQixFQUF1Q2lCLENBQUMsRUFBeEMsRUFBNEM7QUFDMUMsWUFBSUcsS0FBSyxHQUFHNnpCLEdBQUcsQ0FBQ0MsTUFBSixDQUFXajBCLENBQVgsQ0FBWjtBQUNBc2xCLGVBQU8sQ0FBQ3RsQixDQUFELENBQVAsR0FBYTtBQUFDMkgsY0FBSSxFQUFFeEgsS0FBSyxDQUFDd0gsSUFBTixFQUFQO0FBQXFCQyxZQUFFLEVBQUV6SCxLQUFLLENBQUN5SCxFQUFOLEVBQXpCO0FBQXFDNEQsY0FBSSxFQUFFLEtBQUtna0MsVUFBTCxDQUFnQnptQyxJQUFJLENBQUMvSSxDQUFELENBQXBCLENBQTNDO0FBQXFFOEUsZ0JBQU0sRUFBRUE7QUFBN0UsU0FBYjtBQUNEOztBQUNELFVBQUlxbkMsTUFBTSxHQUFHcHJDLFFBQVEsSUFBSUEsUUFBUSxJQUFJLEtBQXhCLElBQWlDbW1DLGtCQUFrQixDQUFDLElBQUQsRUFBTzVoQixPQUFQLEVBQWdCdmtCLFFBQWhCLENBQWhFOztBQUNBLFdBQUssSUFBSTJJLEdBQUcsR0FBRzRiLE9BQU8sQ0FBQ3ZtQixNQUFSLEdBQWlCLENBQWhDLEVBQW1DMkssR0FBRyxJQUFJLENBQTFDLEVBQTZDQSxHQUFHLEVBQWhELEVBQ0U7QUFBRXNrQyxrQkFBVSxDQUFDLElBQUQsRUFBTzFvQixPQUFPLENBQUM1YixHQUFELENBQWQsQ0FBVjtBQUFpQzs7QUFDckMsVUFBSXlpQyxNQUFKLEVBQVk7QUFBRUksa0NBQTBCLENBQUMsSUFBRCxFQUFPSixNQUFQLENBQTFCO0FBQTJDLE9BQXpELE1BQ0ssSUFBSSxLQUFLNS9CLEVBQVQsRUFBYTtBQUFFK3RCLDJCQUFtQixDQUFDLEtBQUsvdEIsRUFBTixDQUFuQjtBQUErQjtBQUNwRCxLQVg2QixDQS9IaUI7QUEySS9DNm5DLFFBQUksRUFBRTVULFdBQVcsQ0FBQyxZQUFXO0FBQUMrTiwyQkFBcUIsQ0FBQyxJQUFELEVBQU8sTUFBUCxDQUFyQjtBQUFxQyxLQUFsRCxDQTNJOEI7QUE0SS9DOEYsUUFBSSxFQUFFN1QsV0FBVyxDQUFDLFlBQVc7QUFBQytOLDJCQUFxQixDQUFDLElBQUQsRUFBTyxNQUFQLENBQXJCO0FBQXFDLEtBQWxELENBNUk4QjtBQTZJL0MrRixpQkFBYSxFQUFFOVQsV0FBVyxDQUFDLFlBQVc7QUFBQytOLDJCQUFxQixDQUFDLElBQUQsRUFBTyxNQUFQLEVBQWUsSUFBZixDQUFyQjtBQUEyQyxLQUF4RCxDQTdJcUI7QUE4SS9DZ0csaUJBQWEsRUFBRS9ULFdBQVcsQ0FBQyxZQUFXO0FBQUMrTiwyQkFBcUIsQ0FBQyxJQUFELEVBQU8sTUFBUCxFQUFlLElBQWYsQ0FBckI7QUFBMkMsS0FBeEQsQ0E5SXFCO0FBZ0ovQ2lHLGdCQUFZLEVBQUUsc0JBQVM3aUMsR0FBVCxFQUFjO0FBQUMsV0FBS293QixNQUFMLEdBQWNwd0IsR0FBZDtBQUFtQixLQWhKRDtBQWlKL0M4aUMsZ0JBQVksRUFBRSx3QkFBVztBQUFDLGFBQU8sS0FBSzFTLE1BQVo7QUFBbUIsS0FqSkU7QUFtSi9DMlMsZUFBVyxFQUFFLHVCQUFXO0FBQ3RCLFVBQUlySyxJQUFJLEdBQUcsS0FBS0ksT0FBaEI7QUFBQSxVQUF5QnJCLElBQUksR0FBRyxDQUFoQztBQUFBLFVBQW1DQyxNQUFNLEdBQUcsQ0FBNUM7O0FBQ0EsV0FBSyxJQUFJcnBDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxcUMsSUFBSSxDQUFDakIsSUFBTCxDQUFVcnFDLE1BQTlCLEVBQXNDaUIsQ0FBQyxFQUF2QyxFQUEyQztBQUFFLFlBQUksQ0FBQ3FxQyxJQUFJLENBQUNqQixJQUFMLENBQVVwcEMsQ0FBVixFQUFhaTBCLE1BQWxCLEVBQTBCO0FBQUUsWUFBRW1WLElBQUY7QUFBUztBQUFFOztBQUNwRixXQUFLLElBQUkxL0IsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBRzJnQyxJQUFJLENBQUNoQixNQUFMLENBQVl0cUMsTUFBcEMsRUFBNEMySyxHQUFHLEVBQS9DLEVBQW1EO0FBQUUsWUFBSSxDQUFDMmdDLElBQUksQ0FBQ2hCLE1BQUwsQ0FBWTMvQixHQUFaLEVBQWlCdXFCLE1BQXRCLEVBQThCO0FBQUUsWUFBRW9WLE1BQUY7QUFBVztBQUFFOztBQUNsRyxhQUFPO0FBQUMrSyxZQUFJLEVBQUVoTCxJQUFQO0FBQWFpTCxZQUFJLEVBQUVoTDtBQUFuQixPQUFQO0FBQ0QsS0F4SjhDO0FBeUovQzRJLGdCQUFZLEVBQUUsd0JBQVc7QUFDdkIsVUFBSWhCLE1BQU0sR0FBRyxJQUFiO0FBRUEsV0FBS3hHLE9BQUwsR0FBZSxJQUFJdkIsT0FBSixDQUFZLEtBQUt1QixPQUFMLENBQWFYLGFBQXpCLENBQWY7QUFDQXZCLGdCQUFVLENBQUMsSUFBRCxFQUFPLFVBQVV4MEIsR0FBVixFQUFlO0FBQUUsZUFBT0EsR0FBRyxDQUFDMDJCLE9BQUosR0FBY3dHLE1BQU0sQ0FBQ3hHLE9BQTVCO0FBQXNDLE9BQTlELEVBQWdFLElBQWhFLENBQVY7QUFDRCxLQTlKOEM7QUFnSy9Da0ssYUFBUyxFQUFFLHFCQUFXO0FBQ3BCLFdBQUszQixlQUFMLEdBQXVCLEtBQUs0QixnQkFBTCxDQUFzQixJQUF0QixDQUF2QjtBQUNELEtBbEs4QztBQW1LL0NBLG9CQUFnQixFQUFFLDBCQUFTQyxVQUFULEVBQXFCO0FBQ3JDLFVBQUlBLFVBQUosRUFDRTtBQUFFLGFBQUtwSyxPQUFMLENBQWFoQixNQUFiLEdBQXNCLEtBQUtnQixPQUFMLENBQWFmLFNBQWIsR0FBeUIsS0FBS2UsT0FBTCxDQUFhZCxVQUFiLEdBQTBCLElBQXpFO0FBQWdGOztBQUNwRixhQUFPLEtBQUtjLE9BQUwsQ0FBYVosVUFBcEI7QUFDRCxLQXZLOEM7QUF3Sy9DaUwsV0FBTyxFQUFFLGlCQUFVQyxHQUFWLEVBQWU7QUFDdEIsYUFBTyxLQUFLdEssT0FBTCxDQUFhWixVQUFiLEtBQTRCa0wsR0FBRyxJQUFJLEtBQUsvQixlQUF4QyxDQUFQO0FBQ0QsS0ExSzhDO0FBNEsvQ2dDLGNBQVUsRUFBRSxzQkFBVztBQUNyQixhQUFPO0FBQUM1TCxZQUFJLEVBQUVvQyxnQkFBZ0IsQ0FBQyxLQUFLZixPQUFMLENBQWFyQixJQUFkLENBQXZCO0FBQ0NDLGNBQU0sRUFBRW1DLGdCQUFnQixDQUFDLEtBQUtmLE9BQUwsQ0FBYXBCLE1BQWQ7QUFEekIsT0FBUDtBQUVELEtBL0s4QztBQWdML0M0TCxjQUFVLEVBQUUsb0JBQVNDLFFBQVQsRUFBbUI7QUFDN0IsVUFBSTdLLElBQUksR0FBRyxLQUFLSSxPQUFMLEdBQWUsSUFBSXZCLE9BQUosQ0FBWSxLQUFLdUIsT0FBTCxDQUFhWCxhQUF6QixDQUExQjtBQUNBTyxVQUFJLENBQUNqQixJQUFMLEdBQVlvQyxnQkFBZ0IsQ0FBQzBKLFFBQVEsQ0FBQzlMLElBQVQsQ0FBY3ZxQyxLQUFkLENBQW9CLENBQXBCLENBQUQsRUFBeUIsSUFBekIsRUFBK0IsSUFBL0IsQ0FBNUI7QUFDQXdyQyxVQUFJLENBQUNoQixNQUFMLEdBQWNtQyxnQkFBZ0IsQ0FBQzBKLFFBQVEsQ0FBQzdMLE1BQVQsQ0FBZ0J4cUMsS0FBaEIsQ0FBc0IsQ0FBdEIsQ0FBRCxFQUEyQixJQUEzQixFQUFpQyxJQUFqQyxDQUE5QjtBQUNELEtBcEw4QztBQXNML0NzMkMsbUJBQWUsRUFBRTNVLFdBQVcsQ0FBQyxVQUFTajFCLElBQVQsRUFBZTZwQyxRQUFmLEVBQXlCanpDLEtBQXpCLEVBQWdDO0FBQzNELGFBQU8wdEMsVUFBVSxDQUFDLElBQUQsRUFBT3RrQyxJQUFQLEVBQWEsUUFBYixFQUF1QixVQUFVQSxJQUFWLEVBQWdCO0FBQ3RELFlBQUl3UixPQUFPLEdBQUd4UixJQUFJLENBQUNxYixhQUFMLEtBQXVCcmIsSUFBSSxDQUFDcWIsYUFBTCxHQUFxQixFQUE1QyxDQUFkO0FBQ0E3SixlQUFPLENBQUNxNEIsUUFBRCxDQUFQLEdBQW9CanpDLEtBQXBCOztBQUNBLFlBQUksQ0FBQ0EsS0FBRCxJQUFVOEUsT0FBTyxDQUFDOFYsT0FBRCxDQUFyQixFQUFnQztBQUFFeFIsY0FBSSxDQUFDcWIsYUFBTCxHQUFxQixJQUFyQjtBQUE0Qjs7QUFDOUQsZUFBTyxJQUFQO0FBQ0QsT0FMZ0IsQ0FBakI7QUFNRCxLQVAyQixDQXRMbUI7QUErTC9DeXVCLGVBQVcsRUFBRTdVLFdBQVcsQ0FBQyxVQUFTNFUsUUFBVCxFQUFtQjtBQUMxQyxVQUFJbkUsTUFBTSxHQUFHLElBQWI7QUFFQSxXQUFLeDhCLElBQUwsQ0FBVSxVQUFVbEosSUFBVixFQUFnQjtBQUN4QixZQUFJQSxJQUFJLENBQUNxYixhQUFMLElBQXNCcmIsSUFBSSxDQUFDcWIsYUFBTCxDQUFtQnd1QixRQUFuQixDQUExQixFQUF3RDtBQUN0RHZGLG9CQUFVLENBQUNvQixNQUFELEVBQVMxbEMsSUFBVCxFQUFlLFFBQWYsRUFBeUIsWUFBWTtBQUM3Q0EsZ0JBQUksQ0FBQ3FiLGFBQUwsQ0FBbUJ3dUIsUUFBbkIsSUFBK0IsSUFBL0I7O0FBQ0EsZ0JBQUludUMsT0FBTyxDQUFDc0UsSUFBSSxDQUFDcWIsYUFBTixDQUFYLEVBQWlDO0FBQUVyYixrQkFBSSxDQUFDcWIsYUFBTCxHQUFxQixJQUFyQjtBQUE0Qjs7QUFDL0QsbUJBQU8sSUFBUDtBQUNELFdBSlMsQ0FBVjtBQUtEO0FBQ0YsT0FSRDtBQVNELEtBWnVCLENBL0x1QjtBQTZNL0MwdUIsWUFBUSxFQUFFLGtCQUFTL3BDLElBQVQsRUFBZTtBQUN2QixVQUFJOUgsQ0FBSjs7QUFDQSxVQUFJLE9BQU84SCxJQUFQLElBQWUsUUFBbkIsRUFBNkI7QUFDM0IsWUFBSSxDQUFDNkosTUFBTSxDQUFDLElBQUQsRUFBTzdKLElBQVAsQ0FBWCxFQUF5QjtBQUFFLGlCQUFPLElBQVA7QUFBYTs7QUFDeEM5SCxTQUFDLEdBQUc4SCxJQUFKO0FBQ0FBLFlBQUksR0FBR3VJLE9BQU8sQ0FBQyxJQUFELEVBQU92SSxJQUFQLENBQWQ7O0FBQ0EsWUFBSSxDQUFDQSxJQUFMLEVBQVc7QUFBRSxpQkFBTyxJQUFQO0FBQWE7QUFDM0IsT0FMRCxNQUtPO0FBQ0w5SCxTQUFDLEdBQUdxUixNQUFNLENBQUN2SixJQUFELENBQVY7O0FBQ0EsWUFBSTlILENBQUMsSUFBSSxJQUFULEVBQWU7QUFBRSxpQkFBTyxJQUFQO0FBQWE7QUFDL0I7O0FBQ0QsYUFBTztBQUFDOEgsWUFBSSxFQUFFOUgsQ0FBUDtBQUFVcXNDLGNBQU0sRUFBRXZrQyxJQUFsQjtBQUF3QkMsWUFBSSxFQUFFRCxJQUFJLENBQUNDLElBQW5DO0FBQXlDb2IscUJBQWEsRUFBRXJiLElBQUksQ0FBQ3FiLGFBQTdEO0FBQ0M1TyxpQkFBUyxFQUFFek0sSUFBSSxDQUFDeU0sU0FEakI7QUFDNEJELGVBQU8sRUFBRXhNLElBQUksQ0FBQ3dNLE9BRDFDO0FBQ21Ec08saUJBQVMsRUFBRTlhLElBQUksQ0FBQzhhLFNBRG5FO0FBRUN3QixlQUFPLEVBQUV0YyxJQUFJLENBQUNzYztBQUZmLE9BQVA7QUFHRCxLQTNOOEM7QUE2Ti9DMHRCLGdCQUFZLEVBQUUvVSxXQUFXLENBQUMsVUFBU3NQLE1BQVQsRUFBaUIwRixLQUFqQixFQUF3QmwzQyxHQUF4QixFQUE2QjtBQUNyRCxhQUFPdXhDLFVBQVUsQ0FBQyxJQUFELEVBQU9DLE1BQVAsRUFBZTBGLEtBQUssSUFBSSxRQUFULEdBQW9CLFFBQXBCLEdBQStCLE9BQTlDLEVBQXVELFVBQVVqcUMsSUFBVixFQUFnQjtBQUN0RixZQUFJdEksSUFBSSxHQUFHdXlDLEtBQUssSUFBSSxNQUFULEdBQWtCLFdBQWxCLEdBQ0FBLEtBQUssSUFBSSxZQUFULEdBQXdCLFNBQXhCLEdBQ0FBLEtBQUssSUFBSSxRQUFULEdBQW9CLGFBQXBCLEdBQW9DLFdBRi9DOztBQUdBLFlBQUksQ0FBQ2pxQyxJQUFJLENBQUN0SSxJQUFELENBQVQsRUFBaUI7QUFBRXNJLGNBQUksQ0FBQ3RJLElBQUQsQ0FBSixHQUFhM0UsR0FBYjtBQUFtQixTQUF0QyxNQUNLLElBQUlELFNBQVMsQ0FBQ0MsR0FBRCxDQUFULENBQWU5QixJQUFmLENBQW9CK08sSUFBSSxDQUFDdEksSUFBRCxDQUF4QixDQUFKLEVBQXFDO0FBQUUsaUJBQU8sS0FBUDtBQUFjLFNBQXJELE1BQ0E7QUFBRXNJLGNBQUksQ0FBQ3RJLElBQUQsQ0FBSixJQUFjLE1BQU0zRSxHQUFwQjtBQUEwQjs7QUFDakMsZUFBTyxJQUFQO0FBQ0QsT0FSZ0IsQ0FBakI7QUFTRCxLQVZ3QixDQTdOc0I7QUF3Ty9DbTNDLG1CQUFlLEVBQUVqVixXQUFXLENBQUMsVUFBU3NQLE1BQVQsRUFBaUIwRixLQUFqQixFQUF3QmwzQyxHQUF4QixFQUE2QjtBQUN4RCxhQUFPdXhDLFVBQVUsQ0FBQyxJQUFELEVBQU9DLE1BQVAsRUFBZTBGLEtBQUssSUFBSSxRQUFULEdBQW9CLFFBQXBCLEdBQStCLE9BQTlDLEVBQXVELFVBQVVqcUMsSUFBVixFQUFnQjtBQUN0RixZQUFJdEksSUFBSSxHQUFHdXlDLEtBQUssSUFBSSxNQUFULEdBQWtCLFdBQWxCLEdBQ0FBLEtBQUssSUFBSSxZQUFULEdBQXdCLFNBQXhCLEdBQ0FBLEtBQUssSUFBSSxRQUFULEdBQW9CLGFBQXBCLEdBQW9DLFdBRi9DO0FBR0EsWUFBSTlzQyxHQUFHLEdBQUc2QyxJQUFJLENBQUN0SSxJQUFELENBQWQ7O0FBQ0EsWUFBSSxDQUFDeUYsR0FBTCxFQUFVO0FBQUUsaUJBQU8sS0FBUDtBQUFjLFNBQTFCLE1BQ0ssSUFBSXBLLEdBQUcsSUFBSSxJQUFYLEVBQWlCO0FBQUVpTixjQUFJLENBQUN0SSxJQUFELENBQUosR0FBYSxJQUFiO0FBQW9CLFNBQXZDLE1BQ0E7QUFDSCxjQUFJa0YsS0FBSyxHQUFHTyxHQUFHLENBQUN6SyxLQUFKLENBQVVJLFNBQVMsQ0FBQ0MsR0FBRCxDQUFuQixDQUFaOztBQUNBLGNBQUksQ0FBQzZKLEtBQUwsRUFBWTtBQUFFLG1CQUFPLEtBQVA7QUFBYzs7QUFDNUIsY0FBSTdILEdBQUcsR0FBRzZILEtBQUssQ0FBQ3JKLEtBQU4sR0FBY3FKLEtBQUssQ0FBQyxDQUFELENBQUwsQ0FBU3BKLE1BQWpDO0FBQ0F3TSxjQUFJLENBQUN0SSxJQUFELENBQUosR0FBYXlGLEdBQUcsQ0FBQzdKLEtBQUosQ0FBVSxDQUFWLEVBQWFzSixLQUFLLENBQUNySixLQUFuQixLQUE2QixDQUFDcUosS0FBSyxDQUFDckosS0FBUCxJQUFnQndCLEdBQUcsSUFBSW9JLEdBQUcsQ0FBQzNKLE1BQTNCLEdBQW9DLEVBQXBDLEdBQXlDLEdBQXRFLElBQTZFMkosR0FBRyxDQUFDN0osS0FBSixDQUFVeUIsR0FBVixDQUE3RSxJQUErRixJQUE1RztBQUNEOztBQUNELGVBQU8sSUFBUDtBQUNELE9BZGdCLENBQWpCO0FBZUQsS0FoQjJCLENBeE9tQjtBQTBQL0M2d0MsaUJBQWEsRUFBRTNRLFdBQVcsQ0FBQyxVQUFTc1AsTUFBVCxFQUFpQnJ4QyxJQUFqQixFQUF1QnFTLE9BQXZCLEVBQWdDO0FBQ3pELGFBQU9xZ0MsYUFBYSxDQUFDLElBQUQsRUFBT3JCLE1BQVAsRUFBZXJ4QyxJQUFmLEVBQXFCcVMsT0FBckIsQ0FBcEI7QUFDRCxLQUZ5QixDQTFQcUI7QUE2UC9DNGtDLG9CQUFnQixFQUFFLDBCQUFTMXlCLE1BQVQsRUFBaUI7QUFBRUEsWUFBTSxDQUFDb2EsS0FBUDtBQUFpQixLQTdQUDtBQStQL0N1VSxZQUFRLEVBQUUsa0JBQVNocUMsSUFBVCxFQUFlQyxFQUFmLEVBQW1Ca0osT0FBbkIsRUFBNEI7QUFDcEMsYUFBTzZnQyxTQUFRLENBQUMsSUFBRCxFQUFPMTdCLFFBQU8sQ0FBQyxJQUFELEVBQU90TyxJQUFQLENBQWQsRUFBNEJzTyxRQUFPLENBQUMsSUFBRCxFQUFPck8sRUFBUCxDQUFuQyxFQUErQ2tKLE9BQS9DLEVBQXdEQSxPQUFPLElBQUlBLE9BQU8sQ0FBQ2xILElBQW5CLElBQTJCLE9BQW5GLENBQWY7QUFDRCxLQWpROEM7QUFrUS9DK3JDLGVBQVcsRUFBRSxxQkFBU3p3QyxHQUFULEVBQWM0TCxPQUFkLEVBQXVCO0FBQ2xDLFVBQUk4a0MsUUFBUSxHQUFHO0FBQUMvRCxvQkFBWSxFQUFFL2dDLE9BQU8sS0FBS0EsT0FBTyxDQUFDMVAsUUFBUixJQUFvQixJQUFwQixHQUEyQjBQLE9BQU8sQ0FBQ2tTLE1BQW5DLEdBQTRDbFMsT0FBakQsQ0FBdEI7QUFDQzZLLGtCQUFVLEVBQUU3SyxPQUFPLElBQUlBLE9BQU8sQ0FBQzZLLFVBRGhDO0FBRUNrQixzQkFBYyxFQUFFLEtBRmpCO0FBRXdCaXNCLGNBQU0sRUFBRWg0QixPQUFPLElBQUlBLE9BQU8sQ0FBQ2c0QixNQUZuRDtBQUdDL2dCLHlCQUFpQixFQUFFalgsT0FBTyxJQUFJQSxPQUFPLENBQUNpWDtBQUh2QyxPQUFmO0FBSUE3aUIsU0FBRyxHQUFHK1EsUUFBTyxDQUFDLElBQUQsRUFBTy9RLEdBQVAsQ0FBYjtBQUNBLGFBQU95c0MsU0FBUSxDQUFDLElBQUQsRUFBT3pzQyxHQUFQLEVBQVlBLEdBQVosRUFBaUIwd0MsUUFBakIsRUFBMkIsVUFBM0IsQ0FBZjtBQUNELEtBelE4QztBQTBRL0NDLGVBQVcsRUFBRSxxQkFBUzN3QyxHQUFULEVBQWM7QUFDekJBLFNBQUcsR0FBRytRLFFBQU8sQ0FBQyxJQUFELEVBQU8vUSxHQUFQLENBQWI7QUFDQSxVQUFJNlgsT0FBTyxHQUFHLEVBQWQ7QUFBQSxVQUFrQmpDLEtBQUssR0FBR2hILE9BQU8sQ0FBQyxJQUFELEVBQU81TyxHQUFHLENBQUNxRyxJQUFYLENBQVAsQ0FBd0IyUCxXQUFsRDs7QUFDQSxVQUFJSixLQUFKLEVBQVc7QUFBRSxhQUFLLElBQUk5YSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHOGEsS0FBSyxDQUFDL2IsTUFBMUIsRUFBa0MsRUFBRWlCLENBQXBDLEVBQXVDO0FBQ2xELGNBQUkrYSxJQUFJLEdBQUdELEtBQUssQ0FBQzlhLENBQUQsQ0FBaEI7O0FBQ0EsY0FBSSxDQUFDK2EsSUFBSSxDQUFDcFQsSUFBTCxJQUFhLElBQWIsSUFBcUJvVCxJQUFJLENBQUNwVCxJQUFMLElBQWF6QyxHQUFHLENBQUN5QixFQUF2QyxNQUNDb1UsSUFBSSxDQUFDblQsRUFBTCxJQUFXLElBQVgsSUFBbUJtVCxJQUFJLENBQUNuVCxFQUFMLElBQVcxQyxHQUFHLENBQUN5QixFQURuQyxDQUFKLEVBRUU7QUFBRW9XLG1CQUFPLENBQUN0WCxJQUFSLENBQWFzVixJQUFJLENBQUNILE1BQUwsQ0FBWXJiLE1BQVosSUFBc0J3YixJQUFJLENBQUNILE1BQXhDO0FBQWtEO0FBQ3ZEO0FBQUU7O0FBQ0gsYUFBT21DLE9BQVA7QUFDRCxLQXBSOEM7QUFxUi9DdTFCLGFBQVMsRUFBRSxtQkFBUzNxQyxJQUFULEVBQWVDLEVBQWYsRUFBbUIrbUMsTUFBbkIsRUFBMkI7QUFDcENobkMsVUFBSSxHQUFHc08sUUFBTyxDQUFDLElBQUQsRUFBT3RPLElBQVAsQ0FBZDtBQUE0QkMsUUFBRSxHQUFHcU8sUUFBTyxDQUFDLElBQUQsRUFBT3JPLEVBQVAsQ0FBWjtBQUM1QixVQUFJTyxLQUFLLEdBQUcsRUFBWjtBQUFBLFVBQWdCMk0sTUFBTSxHQUFHbk4sSUFBSSxDQUFDNEQsSUFBOUI7QUFDQSxXQUFLa0osSUFBTCxDQUFVOU0sSUFBSSxDQUFDNEQsSUFBZixFQUFxQjNELEVBQUUsQ0FBQzJELElBQUgsR0FBVSxDQUEvQixFQUFrQyxVQUFVQSxJQUFWLEVBQWdCO0FBQ2hELFlBQUl1UCxLQUFLLEdBQUd2UCxJQUFJLENBQUMyUCxXQUFqQjs7QUFDQSxZQUFJSixLQUFKLEVBQVc7QUFBRSxlQUFLLElBQUk5YSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHOGEsS0FBSyxDQUFDL2IsTUFBMUIsRUFBa0NpQixDQUFDLEVBQW5DLEVBQXVDO0FBQ2xELGdCQUFJK2EsSUFBSSxHQUFHRCxLQUFLLENBQUM5YSxDQUFELENBQWhCOztBQUNBLGdCQUFJLEVBQUUrYSxJQUFJLENBQUNuVCxFQUFMLElBQVcsSUFBWCxJQUFtQmtOLE1BQU0sSUFBSW5OLElBQUksQ0FBQzRELElBQWxDLElBQTBDNUQsSUFBSSxDQUFDaEIsRUFBTCxJQUFXb1UsSUFBSSxDQUFDblQsRUFBMUQsSUFDQW1ULElBQUksQ0FBQ3BULElBQUwsSUFBYSxJQUFiLElBQXFCbU4sTUFBTSxJQUFJbk4sSUFBSSxDQUFDNEQsSUFEcEMsSUFFQXdQLElBQUksQ0FBQ3BULElBQUwsSUFBYSxJQUFiLElBQXFCbU4sTUFBTSxJQUFJbE4sRUFBRSxDQUFDMkQsSUFBbEMsSUFBMEN3UCxJQUFJLENBQUNwVCxJQUFMLElBQWFDLEVBQUUsQ0FBQ2pCLEVBRjVELE1BR0MsQ0FBQ2dvQyxNQUFELElBQVdBLE1BQU0sQ0FBQzV6QixJQUFJLENBQUNILE1BQU4sQ0FIbEIsQ0FBSixFQUlFO0FBQUV6UyxtQkFBSyxDQUFDMUMsSUFBTixDQUFXc1YsSUFBSSxDQUFDSCxNQUFMLENBQVlyYixNQUFaLElBQXNCd2IsSUFBSSxDQUFDSCxNQUF0QztBQUFnRDtBQUNyRDtBQUFFOztBQUNILFVBQUU5RixNQUFGO0FBQ0QsT0FYRDtBQVlBLGFBQU8zTSxLQUFQO0FBQ0QsS0FyUzhDO0FBc1MvQzJ0QyxlQUFXLEVBQUUsdUJBQVc7QUFDdEIsVUFBSS80QixPQUFPLEdBQUcsRUFBZDtBQUNBLFdBQUt0SSxJQUFMLENBQVUsVUFBVWxKLElBQVYsRUFBZ0I7QUFDeEIsWUFBSThTLEdBQUcsR0FBRzlTLElBQUksQ0FBQzJQLFdBQWY7O0FBQ0EsWUFBSW1ELEdBQUosRUFBUztBQUFFLGVBQUssSUFBSXJlLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdxZSxHQUFHLENBQUN0ZixNQUF4QixFQUFnQyxFQUFFaUIsQ0FBbEMsRUFDVDtBQUFFLGdCQUFJcWUsR0FBRyxDQUFDcmUsQ0FBRCxDQUFILENBQU8ySCxJQUFQLElBQWUsSUFBbkIsRUFBeUI7QUFBRW9WLHFCQUFPLENBQUN0WCxJQUFSLENBQWE0WSxHQUFHLENBQUNyZSxDQUFELENBQUgsQ0FBTzRhLE1BQXBCO0FBQThCO0FBQUU7QUFBRTtBQUNsRSxPQUpEO0FBS0EsYUFBT21DLE9BQVA7QUFDRCxLQTlTOEM7QUFnVC9DZzVCLGdCQUFZLEVBQUUsc0JBQVM5cEMsR0FBVCxFQUFjO0FBQzFCLFVBQUl0RixFQUFKO0FBQUEsVUFBUW1PLE1BQU0sR0FBRyxLQUFLZCxLQUF0QjtBQUFBLFVBQTZCZ2lDLE9BQU8sR0FBRyxLQUFLNUMsYUFBTCxHQUFxQnIwQyxNQUE1RDtBQUNBLFdBQUswVixJQUFMLENBQVUsVUFBVWxKLElBQVYsRUFBZ0I7QUFDeEIsWUFBSStJLEVBQUUsR0FBRy9JLElBQUksQ0FBQ0MsSUFBTCxDQUFVek0sTUFBVixHQUFtQmkzQyxPQUE1Qjs7QUFDQSxZQUFJMWhDLEVBQUUsR0FBR3JJLEdBQVQsRUFBYztBQUFFdEYsWUFBRSxHQUFHc0YsR0FBTDtBQUFVLGlCQUFPLElBQVA7QUFBYTs7QUFDdkNBLFdBQUcsSUFBSXFJLEVBQVA7QUFDQSxVQUFFUSxNQUFGO0FBQ0QsT0FMRDtBQU1BLGFBQU9tQixRQUFPLENBQUMsSUFBRCxFQUFPUixHQUFHLENBQUNYLE1BQUQsRUFBU25PLEVBQVQsQ0FBVixDQUFkO0FBQ0QsS0F6VDhDO0FBMFQvQ3N2QyxnQkFBWSxFQUFFLHNCQUFVbG5CLE1BQVYsRUFBa0I7QUFDOUJBLFlBQU0sR0FBRzlZLFFBQU8sQ0FBQyxJQUFELEVBQU84WSxNQUFQLENBQWhCO0FBQ0EsVUFBSWp3QixLQUFLLEdBQUdpd0IsTUFBTSxDQUFDcG9CLEVBQW5COztBQUNBLFVBQUlvb0IsTUFBTSxDQUFDeGpCLElBQVAsR0FBYyxLQUFLeUksS0FBbkIsSUFBNEIrYSxNQUFNLENBQUNwb0IsRUFBUCxHQUFZLENBQTVDLEVBQStDO0FBQUUsZUFBTyxDQUFQO0FBQVU7O0FBQzNELFVBQUlxdkMsT0FBTyxHQUFHLEtBQUs1QyxhQUFMLEdBQXFCcjBDLE1BQW5DO0FBQ0EsV0FBSzBWLElBQUwsQ0FBVSxLQUFLVCxLQUFmLEVBQXNCK2EsTUFBTSxDQUFDeGpCLElBQTdCLEVBQW1DLFVBQVVBLElBQVYsRUFBZ0I7QUFBRTtBQUNuRHpNLGFBQUssSUFBSXlNLElBQUksQ0FBQ0MsSUFBTCxDQUFVek0sTUFBVixHQUFtQmkzQyxPQUE1QjtBQUNELE9BRkQ7QUFHQSxhQUFPbDNDLEtBQVA7QUFDRCxLQW5VOEM7QUFxVS9DaVksUUFBSSxFQUFFLGNBQVNtL0IsV0FBVCxFQUFzQjtBQUMxQixVQUFJbmlDLEdBQUcsR0FBRyxJQUFJKytCLEdBQUosQ0FBUXArQixRQUFRLENBQUMsSUFBRCxFQUFPLEtBQUtWLEtBQVosRUFBbUIsS0FBS0EsS0FBTCxHQUFhLEtBQUtDLElBQXJDLENBQWhCLEVBQ1EsS0FBS3N6QixVQURiLEVBQ3lCLEtBQUt2ekIsS0FEOUIsRUFDcUMsS0FBSysrQixPQUQxQyxFQUNtRCxLQUFLenBDLFNBRHhELENBQVY7QUFFQXlLLFNBQUcsQ0FBQ3VhLFNBQUosR0FBZ0IsS0FBS0EsU0FBckI7QUFBZ0N2YSxTQUFHLENBQUNtYSxVQUFKLEdBQWlCLEtBQUtBLFVBQXRCO0FBQ2hDbmEsU0FBRyxDQUFDaWdCLEdBQUosR0FBVSxLQUFLQSxHQUFmO0FBQ0FqZ0IsU0FBRyxDQUFDZ3VCLE1BQUosR0FBYSxLQUFiOztBQUNBLFVBQUltVSxXQUFKLEVBQWlCO0FBQ2ZuaUMsV0FBRyxDQUFDMDJCLE9BQUosQ0FBWW5CLFNBQVosR0FBd0IsS0FBS21CLE9BQUwsQ0FBYW5CLFNBQXJDO0FBQ0F2MUIsV0FBRyxDQUFDa2hDLFVBQUosQ0FBZSxLQUFLRCxVQUFMLEVBQWY7QUFDRDs7QUFDRCxhQUFPamhDLEdBQVA7QUFDRCxLQWhWOEM7QUFrVi9Db2lDLGFBQVMsRUFBRSxtQkFBU3JsQyxPQUFULEVBQWtCO0FBQzNCLFVBQUksQ0FBQ0EsT0FBTCxFQUFjO0FBQUVBLGVBQU8sR0FBRyxFQUFWO0FBQWU7O0FBQy9CLFVBQUluSixJQUFJLEdBQUcsS0FBS3FNLEtBQWhCO0FBQUEsVUFBdUJwTSxFQUFFLEdBQUcsS0FBS29NLEtBQUwsR0FBYSxLQUFLQyxJQUE5Qzs7QUFDQSxVQUFJbkQsT0FBTyxDQUFDbkosSUFBUixJQUFnQixJQUFoQixJQUF3Qm1KLE9BQU8sQ0FBQ25KLElBQVIsR0FBZUEsSUFBM0MsRUFBaUQ7QUFBRUEsWUFBSSxHQUFHbUosT0FBTyxDQUFDbkosSUFBZjtBQUFzQjs7QUFDekUsVUFBSW1KLE9BQU8sQ0FBQ2xKLEVBQVIsSUFBYyxJQUFkLElBQXNCa0osT0FBTyxDQUFDbEosRUFBUixHQUFhQSxFQUF2QyxFQUEyQztBQUFFQSxVQUFFLEdBQUdrSixPQUFPLENBQUNsSixFQUFiO0FBQWtCOztBQUMvRCxVQUFJbVAsSUFBSSxHQUFHLElBQUkrN0IsR0FBSixDQUFRcCtCLFFBQVEsQ0FBQyxJQUFELEVBQU8vTSxJQUFQLEVBQWFDLEVBQWIsQ0FBaEIsRUFBa0NrSixPQUFPLENBQUNQLElBQVIsSUFBZ0IsS0FBS2czQixVQUF2RCxFQUFtRTUvQixJQUFuRSxFQUF5RSxLQUFLb3JDLE9BQTlFLEVBQXVGLEtBQUt6cEMsU0FBNUYsQ0FBWDs7QUFDQSxVQUFJd0gsT0FBTyxDQUFDNjNCLFVBQVosRUFBd0I7QUFBRTV4QixZQUFJLENBQUMwekIsT0FBTCxHQUFlLEtBQUtBLE9BQXBCO0FBQ3ZCOztBQUFBLE9BQUMsS0FBSzdCLE1BQUwsS0FBZ0IsS0FBS0EsTUFBTCxHQUFjLEVBQTlCLENBQUQsRUFBb0NuakMsSUFBcEMsQ0FBeUM7QUFBQ3NPLFdBQUcsRUFBRWdELElBQU47QUFBWTR4QixrQkFBVSxFQUFFNzNCLE9BQU8sQ0FBQzYzQjtBQUFoQyxPQUF6QztBQUNINXhCLFVBQUksQ0FBQzZ4QixNQUFMLEdBQWMsQ0FBQztBQUFDNzBCLFdBQUcsRUFBRSxJQUFOO0FBQVlxK0IsZ0JBQVEsRUFBRSxJQUF0QjtBQUE0QnpKLGtCQUFVLEVBQUU3M0IsT0FBTyxDQUFDNjNCO0FBQWhELE9BQUQsQ0FBZDtBQUNBNEosdUJBQWlCLENBQUN4N0IsSUFBRCxFQUFPczdCLGlCQUFpQixDQUFDLElBQUQsQ0FBeEIsQ0FBakI7QUFDQSxhQUFPdDdCLElBQVA7QUFDRCxLQTdWOEM7QUE4Vi9DcS9CLGFBQVMsRUFBRSxtQkFBUzNtQixLQUFULEVBQWdCO0FBQ3pCLFVBQUlBLEtBQUssWUFBWTRtQixVQUFyQixFQUFpQztBQUFFNW1CLGFBQUssR0FBR0EsS0FBSyxDQUFDMWIsR0FBZDtBQUFvQjs7QUFDdkQsVUFBSSxLQUFLNjBCLE1BQVQsRUFBaUI7QUFBRSxhQUFLLElBQUk1b0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLNG9DLE1BQUwsQ0FBWTdwQyxNQUFoQyxFQUF3QyxFQUFFaUIsQ0FBMUMsRUFBNkM7QUFDOUQsY0FBSXMyQyxJQUFJLEdBQUcsS0FBSzFOLE1BQUwsQ0FBWTVvQyxDQUFaLENBQVg7O0FBQ0EsY0FBSXMyQyxJQUFJLENBQUN2aUMsR0FBTCxJQUFZMGIsS0FBaEIsRUFBdUI7QUFBRTtBQUFVOztBQUNuQyxlQUFLbVosTUFBTCxDQUFZM2lDLE1BQVosQ0FBbUJqRyxDQUFuQixFQUFzQixDQUF0QjtBQUNBeXZCLGVBQUssQ0FBQzJtQixTQUFOLENBQWdCLElBQWhCO0FBQ0F6RCw2QkFBbUIsQ0FBQ04saUJBQWlCLENBQUMsSUFBRCxDQUFsQixDQUFuQjtBQUNBO0FBQ0Q7QUFBRSxPQVRzQixDQVV6Qjs7O0FBQ0EsVUFBSTVpQixLQUFLLENBQUNnYixPQUFOLElBQWlCLEtBQUtBLE9BQTFCLEVBQW1DO0FBQ2pDLFlBQUk4TCxRQUFRLEdBQUcsQ0FBQzltQixLQUFLLENBQUM1ckIsRUFBUCxDQUFmO0FBQ0Ewa0Msa0JBQVUsQ0FBQzlZLEtBQUQsRUFBUSxVQUFVMWIsR0FBVixFQUFlO0FBQUUsaUJBQU93aUMsUUFBUSxDQUFDOXdDLElBQVQsQ0FBY3NPLEdBQUcsQ0FBQ2xRLEVBQWxCLENBQVA7QUFBK0IsU0FBeEQsRUFBMEQsSUFBMUQsQ0FBVjtBQUNBNHJCLGFBQUssQ0FBQ2diLE9BQU4sR0FBZ0IsSUFBSXZCLE9BQUosQ0FBWSxJQUFaLENBQWhCO0FBQ0F6WixhQUFLLENBQUNnYixPQUFOLENBQWNyQixJQUFkLEdBQXFCb0MsZ0JBQWdCLENBQUMsS0FBS2YsT0FBTCxDQUFhckIsSUFBZCxFQUFvQm1OLFFBQXBCLENBQXJDO0FBQ0E5bUIsYUFBSyxDQUFDZ2IsT0FBTixDQUFjcEIsTUFBZCxHQUF1Qm1DLGdCQUFnQixDQUFDLEtBQUtmLE9BQUwsQ0FBYXBCLE1BQWQsRUFBc0JrTixRQUF0QixDQUF2QztBQUNEO0FBQ0YsS0FoWDhDO0FBaVgvQ0Msa0JBQWMsRUFBRSx3QkFBU2wwQyxDQUFULEVBQVk7QUFBQ2ltQyxnQkFBVSxDQUFDLElBQUQsRUFBT2ptQyxDQUFQLENBQVY7QUFBcUIsS0FqWEg7QUFtWC9DdU8sV0FBTyxFQUFFLG1CQUFXO0FBQUMsYUFBTyxLQUFLTixJQUFaO0FBQWlCLEtBblhTO0FBb1gvQ2ttQyxhQUFTLEVBQUUscUJBQVc7QUFBQyxhQUFPLEtBQUtscUMsRUFBWjtBQUFlLEtBcFhTO0FBc1gvQ2lqQyxjQUFVLEVBQUUsb0JBQVNsb0MsR0FBVCxFQUFjO0FBQ3hCLFVBQUksS0FBS3lyQyxPQUFULEVBQWtCO0FBQUUsZUFBT3pyQyxHQUFHLENBQUN4RixLQUFKLENBQVUsS0FBS2l4QyxPQUFmLENBQVA7QUFBZ0M7O0FBQ3BELGFBQU9oa0MsY0FBYyxDQUFDekgsR0FBRCxDQUFyQjtBQUNELEtBelg4QztBQTBYL0M4ckMsaUJBQWEsRUFBRSx5QkFBVztBQUFFLGFBQU8sS0FBS0wsT0FBTCxJQUFnQixJQUF2QjtBQUE2QixLQTFYVjtBQTRYL0MyRCxnQkFBWSxFQUFFbFcsV0FBVyxDQUFDLFVBQVVqNUIsR0FBVixFQUFlO0FBQ3ZDLFVBQUlBLEdBQUcsSUFBSSxLQUFYLEVBQWtCO0FBQUVBLFdBQUcsR0FBRyxLQUFOO0FBQWM7O0FBQ2xDLFVBQUlBLEdBQUcsSUFBSSxLQUFLK0IsU0FBaEIsRUFBMkI7QUFBRTtBQUFROztBQUNyQyxXQUFLQSxTQUFMLEdBQWlCL0IsR0FBakI7QUFDQSxXQUFLa04sSUFBTCxDQUFVLFVBQVVsSixJQUFWLEVBQWdCO0FBQUUsZUFBT0EsSUFBSSxDQUFDckQsS0FBTCxHQUFhLElBQXBCO0FBQTJCLE9BQXZEOztBQUNBLFVBQUksS0FBS3FFLEVBQVQsRUFBYTtBQUFFMDhCLHdCQUFnQixDQUFDLEtBQUsxOEIsRUFBTixDQUFoQjtBQUE0QjtBQUM1QyxLQU53QjtBQTVYc0IsR0FBeEIsQ0FBekIsQ0E3N0xtQixDQWswTW5COztBQUNBdW1DLEtBQUcsQ0FBQ3J3QyxTQUFKLENBQWNrMEMsUUFBZCxHQUF5QjdELEdBQUcsQ0FBQ3J3QyxTQUFKLENBQWNnUyxJQUF2QyxDQW4wTW1CLENBcTBNbkI7QUFDQTs7QUFDQSxNQUFJbWlDLFFBQVEsR0FBRyxDQUFmOztBQUVBLFdBQVNDLE1BQVQsQ0FBZ0I1M0MsQ0FBaEIsRUFBbUI7QUFDakIsUUFBSXNOLEVBQUUsR0FBRyxJQUFUO0FBQ0F1cUMsbUJBQWUsQ0FBQ3ZxQyxFQUFELENBQWY7O0FBQ0EsUUFBSUQsY0FBYyxDQUFDQyxFQUFELEVBQUt0TixDQUFMLENBQWQsSUFBeUI2cEIsYUFBYSxDQUFDdmMsRUFBRSxDQUFDb00sT0FBSixFQUFhMVosQ0FBYixDQUExQyxFQUNFO0FBQUU7QUFBUTs7QUFDWm1PLG9CQUFnQixDQUFDbk8sQ0FBRCxDQUFoQjs7QUFDQSxRQUFJcEMsRUFBSixFQUFRO0FBQUUrNUMsY0FBUSxHQUFHLENBQUMsSUFBSTF5QyxJQUFKLEVBQVo7QUFBdUI7O0FBQ2pDLFFBQUlnQixHQUFHLEdBQUc4c0IsWUFBWSxDQUFDemxCLEVBQUQsRUFBS3ROLENBQUwsRUFBUSxJQUFSLENBQXRCO0FBQUEsUUFBcUM4M0MsS0FBSyxHQUFHOTNDLENBQUMsQ0FBQyszQyxZQUFGLENBQWVELEtBQTVEOztBQUNBLFFBQUksQ0FBQzd4QyxHQUFELElBQVFxSCxFQUFFLENBQUMwcUMsVUFBSCxFQUFaLEVBQTZCO0FBQUU7QUFBUSxLQVJ0QixDQVNqQjtBQUNBOzs7QUFDQSxRQUFJRixLQUFLLElBQUlBLEtBQUssQ0FBQ2g0QyxNQUFmLElBQXlCc1EsTUFBTSxDQUFDNm5DLFVBQWhDLElBQThDN25DLE1BQU0sQ0FBQzhuQyxJQUF6RCxFQUErRDtBQUM3RCxVQUFJMXpDLENBQUMsR0FBR3N6QyxLQUFLLENBQUNoNEMsTUFBZDtBQUFBLFVBQXNCeU0sSUFBSSxHQUFHaEosS0FBSyxDQUFDaUIsQ0FBRCxDQUFsQztBQUFBLFVBQXVDMnpDLElBQUksR0FBRyxDQUE5Qzs7QUFDQSxVQUFJQyxtQ0FBbUMsR0FBRyxTQUF0Q0EsbUNBQXNDLEdBQVk7QUFDcEQsWUFBSSxFQUFFRCxJQUFGLElBQVUzekMsQ0FBZCxFQUFpQjtBQUNmNjhCLG1CQUFTLENBQUMvekIsRUFBRCxFQUFLLFlBQVk7QUFDeEJySCxlQUFHLEdBQUcrUSxRQUFPLENBQUMxSixFQUFFLENBQUN3SCxHQUFKLEVBQVM3TyxHQUFULENBQWI7QUFDQSxnQkFBSStXLE1BQU0sR0FBRztBQUFDdFUsa0JBQUksRUFBRXpDLEdBQVA7QUFBWTBDLGdCQUFFLEVBQUUxQyxHQUFoQjtBQUNDc0csa0JBQUksRUFBRWUsRUFBRSxDQUFDd0gsR0FBSCxDQUFPeTdCLFVBQVAsQ0FDRmhrQyxJQUFJLENBQUNtakMsTUFBTCxDQUFZLFVBQVUySSxDQUFWLEVBQWE7QUFBRSx1QkFBT0EsQ0FBQyxJQUFJLElBQVo7QUFBbUIsZUFBOUMsRUFBZ0RuRSxJQUFoRCxDQUFxRDVtQyxFQUFFLENBQUN3SCxHQUFILENBQU9xL0IsYUFBUCxFQUFyRCxDQURFLENBRFA7QUFHQ3R1QyxvQkFBTSxFQUFFO0FBSFQsYUFBYjtBQUlBa3BDLHNCQUFVLENBQUN6aEMsRUFBRSxDQUFDd0gsR0FBSixFQUFTa0ksTUFBVCxDQUFWO0FBQ0Fzd0Isc0NBQTBCLENBQUNoZ0MsRUFBRSxDQUFDd0gsR0FBSixFQUFTOHlCLGVBQWUsQ0FBQzV3QixRQUFPLENBQUMxSixFQUFFLENBQUN3SCxHQUFKLEVBQVM3TyxHQUFULENBQVIsRUFBdUIrUSxRQUFPLENBQUMxSixFQUFFLENBQUN3SCxHQUFKLEVBQVMreUIsU0FBUyxDQUFDN3FCLE1BQUQsQ0FBbEIsQ0FBOUIsQ0FBeEIsQ0FBMUI7QUFDRCxXQVJRLENBQVQ7QUFTRDtBQUNGLE9BWkQ7O0FBYUEsVUFBSXM3QixnQkFBZ0IsR0FBRyxTQUFuQkEsZ0JBQW1CLENBQVVDLElBQVYsRUFBZ0J4M0MsQ0FBaEIsRUFBbUI7QUFDeEMsWUFBSXVNLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVzJtQyxrQkFBWCxJQUNBOXpDLE9BQU8sQ0FBQzRJLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVzJtQyxrQkFBWixFQUFnQ0QsSUFBSSxDQUFDNXRDLElBQXJDLENBQVAsSUFBcUQsQ0FBQyxDQUQxRCxFQUM2RDtBQUMzRHl0Qyw2Q0FBbUM7QUFDbkM7QUFDRDs7QUFDRCxZQUFJSyxNQUFNLEdBQUcsSUFBSVIsVUFBSixFQUFiOztBQUNBUSxjQUFNLENBQUNDLE9BQVAsR0FBaUIsWUFBWTtBQUFFLGlCQUFPTixtQ0FBbUMsRUFBMUM7QUFBK0MsU0FBOUU7O0FBQ0FLLGNBQU0sQ0FBQ0UsTUFBUCxHQUFnQixZQUFZO0FBQzFCLGNBQUlqNEMsT0FBTyxHQUFHKzNDLE1BQU0sQ0FBQzFvQyxNQUFyQjs7QUFDQSxjQUFJLDBCQUEwQnhTLElBQTFCLENBQStCbUQsT0FBL0IsQ0FBSixFQUE2QztBQUMzQzAzQywrQ0FBbUM7QUFDbkM7QUFDRDs7QUFDRDdyQyxjQUFJLENBQUN4TCxDQUFELENBQUosR0FBVUwsT0FBVjtBQUNBMDNDLDZDQUFtQztBQUNwQyxTQVJEOztBQVNBSyxjQUFNLENBQUNHLFVBQVAsQ0FBa0JMLElBQWxCO0FBQ0QsT0FsQkQ7O0FBbUJBLFdBQUssSUFBSXgzQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHKzJDLEtBQUssQ0FBQ2g0QyxNQUExQixFQUFrQ2lCLENBQUMsRUFBbkMsRUFBdUM7QUFBRXUzQyx3QkFBZ0IsQ0FBQ1IsS0FBSyxDQUFDLzJDLENBQUQsQ0FBTixFQUFXQSxDQUFYLENBQWhCO0FBQWdDO0FBQzFFLEtBbkNELE1BbUNPO0FBQUU7QUFDUDtBQUNBLFVBQUl1TSxFQUFFLENBQUNrRixLQUFILENBQVNpbUIsWUFBVCxJQUF5Qm5yQixFQUFFLENBQUN3SCxHQUFILENBQU9pZ0IsR0FBUCxDQUFXOXlCLFFBQVgsQ0FBb0JnRSxHQUFwQixJQUEyQixDQUFDLENBQXpELEVBQTREO0FBQzFEcUgsVUFBRSxDQUFDa0YsS0FBSCxDQUFTaW1CLFlBQVQsQ0FBc0J6NEIsQ0FBdEIsRUFEMEQsQ0FFMUQ7O0FBQ0FrRixrQkFBVSxDQUFDLFlBQVk7QUFBRSxpQkFBT29JLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NLLEtBQVgsQ0FBaUJxVSxLQUFqQixFQUFQO0FBQWtDLFNBQWpELEVBQW1ELEVBQW5ELENBQVY7QUFDQTtBQUNEOztBQUNELFVBQUk7QUFDRixZQUFJd2dCLE1BQU0sR0FBRzc0QyxDQUFDLENBQUMrM0MsWUFBRixDQUFlZSxPQUFmLENBQXVCLE1BQXZCLENBQWI7O0FBQ0EsWUFBSUQsTUFBSixFQUFZO0FBQ1YsY0FBSUUsUUFBSjs7QUFDQSxjQUFJenJDLEVBQUUsQ0FBQ2tGLEtBQUgsQ0FBU2ltQixZQUFULElBQXlCLENBQUNuckIsRUFBRSxDQUFDa0YsS0FBSCxDQUFTaW1CLFlBQVQsQ0FBc0IzZ0IsSUFBcEQsRUFDRTtBQUFFaWhDLG9CQUFRLEdBQUd6ckMsRUFBRSxDQUFDb25DLGNBQUgsRUFBWDtBQUFpQzs7QUFDckNuSCw0QkFBa0IsQ0FBQ2pnQyxFQUFFLENBQUN3SCxHQUFKLEVBQVM4eUIsZUFBZSxDQUFDM2hDLEdBQUQsRUFBTUEsR0FBTixDQUF4QixDQUFsQjs7QUFDQSxjQUFJOHlDLFFBQUosRUFBYztBQUFFLGlCQUFLLElBQUl0dUMsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBR3N1QyxRQUFRLENBQUNqNUMsTUFBakMsRUFBeUMsRUFBRTJLLEdBQTNDLEVBQ2Q7QUFBRTRsQywyQkFBWSxDQUFDL2lDLEVBQUUsQ0FBQ3dILEdBQUosRUFBUyxFQUFULEVBQWFpa0MsUUFBUSxDQUFDdHVDLEdBQUQsQ0FBUixDQUFjNm5CLE1BQTNCLEVBQW1DeW1CLFFBQVEsQ0FBQ3R1QyxHQUFELENBQVIsQ0FBYzRxQixJQUFqRCxFQUF1RCxNQUF2RCxDQUFaO0FBQTZFO0FBQUU7O0FBQ25GL25CLFlBQUUsQ0FBQzBuQyxnQkFBSCxDQUFvQjZELE1BQXBCLEVBQTRCLFFBQTVCLEVBQXNDLE9BQXRDO0FBQ0F2ckMsWUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQnFVLEtBQWpCO0FBQ0Q7QUFDRixPQVpELENBYUEsT0FBTWhGLEdBQU4sRUFBVSxDQUFFO0FBQ2I7QUFDRjs7QUFFRCxXQUFTMmxCLFdBQVQsQ0FBcUIxckMsRUFBckIsRUFBeUJ0TixDQUF6QixFQUE0QjtBQUMxQixRQUFJcEMsRUFBRSxLQUFLLENBQUMwUCxFQUFFLENBQUNrRixLQUFILENBQVNpbUIsWUFBVixJQUEwQixDQUFDLElBQUl4ekIsSUFBSixFQUFELEdBQVkweUMsUUFBWixHQUF1QixHQUF0RCxDQUFOLEVBQWtFO0FBQUVucEMsWUFBTSxDQUFDeE8sQ0FBRCxDQUFOO0FBQVc7QUFBUTs7QUFDdkYsUUFBSXFOLGNBQWMsQ0FBQ0MsRUFBRCxFQUFLdE4sQ0FBTCxDQUFkLElBQXlCNnBCLGFBQWEsQ0FBQ3ZjLEVBQUUsQ0FBQ29NLE9BQUosRUFBYTFaLENBQWIsQ0FBMUMsRUFBMkQ7QUFBRTtBQUFROztBQUVyRUEsS0FBQyxDQUFDKzNDLFlBQUYsQ0FBZWtCLE9BQWYsQ0FBdUIsTUFBdkIsRUFBK0IzckMsRUFBRSxDQUFDK0MsWUFBSCxFQUEvQjtBQUNBclEsS0FBQyxDQUFDKzNDLFlBQUYsQ0FBZW1CLGFBQWYsR0FBK0IsVUFBL0IsQ0FMMEIsQ0FPMUI7QUFDQTs7QUFDQSxRQUFJbDVDLENBQUMsQ0FBQyszQyxZQUFGLENBQWVvQixZQUFmLElBQStCLENBQUMvNkMsTUFBcEMsRUFBNEM7QUFDMUMsVUFBSWc3QyxHQUFHLEdBQUc1NEMsR0FBRyxDQUFDLEtBQUQsRUFBUSxJQUFSLEVBQWMsSUFBZCxFQUFvQixtQ0FBcEIsQ0FBYjtBQUNBNDRDLFNBQUcsQ0FBQ0MsR0FBSixHQUFVLDRFQUFWOztBQUNBLFVBQUlsN0MsTUFBSixFQUFZO0FBQ1ZpN0MsV0FBRyxDQUFDbHdCLEtBQUosR0FBWWt3QixHQUFHLENBQUN6akMsTUFBSixHQUFhLENBQXpCO0FBQ0FySSxVQUFFLENBQUNvTSxPQUFILENBQVdpUSxPQUFYLENBQW1CcHBCLFdBQW5CLENBQStCNjRDLEdBQS9CLEVBRlUsQ0FHVjs7QUFDQUEsV0FBRyxDQUFDRSxJQUFKLEdBQVdGLEdBQUcsQ0FBQ2p2QixTQUFmO0FBQ0Q7O0FBQ0RucUIsT0FBQyxDQUFDKzNDLFlBQUYsQ0FBZW9CLFlBQWYsQ0FBNEJDLEdBQTVCLEVBQWlDLENBQWpDLEVBQW9DLENBQXBDOztBQUNBLFVBQUlqN0MsTUFBSixFQUFZO0FBQUVpN0MsV0FBRyxDQUFDdjNDLFVBQUosQ0FBZTFCLFdBQWYsQ0FBMkJpNUMsR0FBM0I7QUFBa0M7QUFDakQ7QUFDRjs7QUFFRCxXQUFTRyxVQUFULENBQW9CanNDLEVBQXBCLEVBQXdCdE4sQ0FBeEIsRUFBMkI7QUFDekIsUUFBSWlHLEdBQUcsR0FBRzhzQixZQUFZLENBQUN6bEIsRUFBRCxFQUFLdE4sQ0FBTCxDQUF0Qjs7QUFDQSxRQUFJLENBQUNpRyxHQUFMLEVBQVU7QUFBRTtBQUFROztBQUNwQixRQUFJdXpDLElBQUksR0FBRzE3QyxRQUFRLENBQUNzbEIsc0JBQVQsRUFBWDtBQUNBZ1MsdUJBQW1CLENBQUM5bkIsRUFBRCxFQUFLckgsR0FBTCxFQUFVdXpDLElBQVYsQ0FBbkI7O0FBQ0EsUUFBSSxDQUFDbHNDLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBVysvQixVQUFoQixFQUE0QjtBQUMxQm5zQyxRQUFFLENBQUNvTSxPQUFILENBQVcrL0IsVUFBWCxHQUF3Qmo1QyxHQUFHLENBQUMsS0FBRCxFQUFRLElBQVIsRUFBYywyQ0FBZCxDQUEzQjtBQUNBOE0sUUFBRSxDQUFDb00sT0FBSCxDQUFXd1EsU0FBWCxDQUFxQmxELFlBQXJCLENBQWtDMVosRUFBRSxDQUFDb00sT0FBSCxDQUFXKy9CLFVBQTdDLEVBQXlEbnNDLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV29lLFNBQXBFO0FBQ0Q7O0FBQ0R6M0Isd0JBQW9CLENBQUNpTixFQUFFLENBQUNvTSxPQUFILENBQVcrL0IsVUFBWixFQUF3QkQsSUFBeEIsQ0FBcEI7QUFDRDs7QUFFRCxXQUFTM0IsZUFBVCxDQUF5QnZxQyxFQUF6QixFQUE2QjtBQUMzQixRQUFJQSxFQUFFLENBQUNvTSxPQUFILENBQVcrL0IsVUFBZixFQUEyQjtBQUN6Qm5zQyxRQUFFLENBQUNvTSxPQUFILENBQVd3USxTQUFYLENBQXFCL3BCLFdBQXJCLENBQWlDbU4sRUFBRSxDQUFDb00sT0FBSCxDQUFXKy9CLFVBQTVDO0FBQ0Fuc0MsUUFBRSxDQUFDb00sT0FBSCxDQUFXKy9CLFVBQVgsR0FBd0IsSUFBeEI7QUFDRDtBQUNGLEdBeDdNa0IsQ0EwN01uQjtBQUNBO0FBQ0E7OztBQUVBLFdBQVNDLGlCQUFULENBQTJCcjJDLENBQTNCLEVBQThCO0FBQzVCLFFBQUksQ0FBQ3ZGLFFBQVEsQ0FBQzY3QyxzQkFBZCxFQUFzQztBQUFFO0FBQVE7O0FBQ2hELFFBQUlDLE9BQU8sR0FBRzk3QyxRQUFRLENBQUM2N0Msc0JBQVQsQ0FBZ0MsWUFBaEMsQ0FBZDtBQUFBLFFBQTZERSxPQUFPLEdBQUcsRUFBdkU7O0FBQ0EsU0FBSyxJQUFJOTRDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc2NEMsT0FBTyxDQUFDOTVDLE1BQTVCLEVBQW9DaUIsQ0FBQyxFQUFyQyxFQUF5QztBQUN2QyxVQUFJdU0sRUFBRSxHQUFHc3NDLE9BQU8sQ0FBQzc0QyxDQUFELENBQVAsQ0FBV3EyQyxVQUFwQjs7QUFDQSxVQUFJOXBDLEVBQUosRUFBUTtBQUFFdXNDLGVBQU8sQ0FBQ3J6QyxJQUFSLENBQWE4RyxFQUFiO0FBQW1CO0FBQzlCOztBQUNELFFBQUl1c0MsT0FBTyxDQUFDLzVDLE1BQVosRUFBb0I7QUFBRSs1QyxhQUFPLENBQUMsQ0FBRCxDQUFQLENBQVd4WSxTQUFYLENBQXFCLFlBQVk7QUFDckQsYUFBSyxJQUFJdGdDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc4NEMsT0FBTyxDQUFDLzVDLE1BQTVCLEVBQW9DaUIsQ0FBQyxFQUFyQyxFQUF5QztBQUFFc0MsV0FBQyxDQUFDdzJDLE9BQU8sQ0FBQzk0QyxDQUFELENBQVIsQ0FBRDtBQUFnQjtBQUM1RCxPQUZxQjtBQUVqQjtBQUNOOztBQUVELE1BQUkrNEMsaUJBQWlCLEdBQUcsS0FBeEI7O0FBQ0EsV0FBU0Msb0JBQVQsR0FBZ0M7QUFDOUIsUUFBSUQsaUJBQUosRUFBdUI7QUFBRTtBQUFROztBQUNqQ0UsMEJBQXNCO0FBQ3RCRixxQkFBaUIsR0FBRyxJQUFwQjtBQUNEOztBQUNELFdBQVNFLHNCQUFULEdBQWtDO0FBQ2hDO0FBQ0EsUUFBSUMsV0FBSjtBQUNBeHRDLE1BQUUsQ0FBQzJELE1BQUQsRUFBUyxRQUFULEVBQW1CLFlBQVk7QUFDL0IsVUFBSTZwQyxXQUFXLElBQUksSUFBbkIsRUFBeUI7QUFBRUEsbUJBQVcsR0FBRy8wQyxVQUFVLENBQUMsWUFBWTtBQUM5RCswQyxxQkFBVyxHQUFHLElBQWQ7QUFDQVAsMkJBQWlCLENBQUNRLFFBQUQsQ0FBakI7QUFDRCxTQUhrRCxFQUdoRCxHQUhnRCxDQUF4QjtBQUdqQjtBQUNYLEtBTEMsQ0FBRixDQUhnQyxDQVNoQzs7QUFDQXp0QyxNQUFFLENBQUMyRCxNQUFELEVBQVMsTUFBVCxFQUFpQixZQUFZO0FBQUUsYUFBT3NwQyxpQkFBaUIsQ0FBQ3ZoQixNQUFELENBQXhCO0FBQW1DLEtBQWxFLENBQUY7QUFDRCxHQTM5TWtCLENBNDlNbkI7OztBQUNBLFdBQVMraEIsUUFBVCxDQUFrQjVzQyxFQUFsQixFQUFzQjtBQUNwQixRQUFJcVQsQ0FBQyxHQUFHclQsRUFBRSxDQUFDb00sT0FBWCxDQURvQixDQUVwQjs7QUFDQWlILEtBQUMsQ0FBQ2dPLGVBQUYsR0FBb0JoTyxDQUFDLENBQUNpTyxnQkFBRixHQUFxQmpPLENBQUMsQ0FBQzJKLGNBQUYsR0FBbUIsSUFBNUQ7QUFDQTNKLEtBQUMsQ0FBQzZoQixpQkFBRixHQUFzQixLQUF0QjtBQUNBbDFCLE1BQUUsQ0FBQzZzQyxPQUFIO0FBQ0Q7O0FBRUQsTUFBSUMsUUFBUSxHQUFHO0FBQ2IsT0FBRyxPQURVO0FBQ0QsT0FBRyxXQURGO0FBQ2UsT0FBRyxLQURsQjtBQUN5QixRQUFJLE9BRDdCO0FBQ3NDLFFBQUksT0FEMUM7QUFDbUQsUUFBSSxNQUR2RDtBQUMrRCxRQUFJLEtBRG5FO0FBRWIsUUFBSSxPQUZTO0FBRUEsUUFBSSxVQUZKO0FBRWdCLFFBQUksS0FGcEI7QUFFMkIsUUFBSSxPQUYvQjtBQUV3QyxRQUFJLFFBRjVDO0FBRXNELFFBQUksVUFGMUQ7QUFFc0UsUUFBSSxLQUYxRTtBQUdiLFFBQUksTUFIUztBQUdELFFBQUksTUFISDtBQUdXLFFBQUksSUFIZjtBQUdxQixRQUFJLE9BSHpCO0FBR2tDLFFBQUksTUFIdEM7QUFHOEMsUUFBSSxXQUhsRDtBQUcrRCxRQUFJLFFBSG5FO0FBSWIsUUFBSSxRQUpTO0FBSUMsUUFBSSxHQUpMO0FBSVUsUUFBSSxHQUpkO0FBSW1CLFFBQUksS0FKdkI7QUFJOEIsUUFBSSxLQUpsQztBQUl5QyxRQUFJLEtBSjdDO0FBS2IsU0FBSyxHQUxRO0FBS0gsU0FBSyxHQUxGO0FBS08sU0FBSyxHQUxaO0FBS2lCLFNBQUssR0FMdEI7QUFLMkIsU0FBSyxHQUxoQztBQUtxQyxTQUFLLFlBTDFDO0FBTWIsU0FBSyxHQU5RO0FBTUgsU0FBSyxHQU5GO0FBTU8sU0FBSyxHQU5aO0FBTWlCLFNBQUssR0FOdEI7QUFNMkIsU0FBSyxHQU5oQztBQU1xQyxTQUFLLEdBTjFDO0FBTStDLFNBQUssR0FOcEQ7QUFNeUQsU0FBSyxHQU45RDtBQU1tRSxTQUFLLEdBTnhFO0FBTTZFLFNBQUssSUFObEY7QUFPYixTQUFLLEdBUFE7QUFPSCxTQUFLLEdBUEY7QUFPTyxTQUFLLEtBUFo7QUFPbUIsV0FBTyxJQVAxQjtBQU9nQyxXQUFPLE1BUHZDO0FBTytDLFdBQU8sTUFQdEQ7QUFPOEQsV0FBTyxPQVByRTtBQU84RSxXQUFPLFFBUHJGO0FBUWIsV0FBTyxNQVJNO0FBUUUsV0FBTyxLQVJUO0FBUWdCLFdBQU8sUUFSdkI7QUFRaUMsV0FBTyxVQVJ4QztBQVFvRCxXQUFPO0FBUjNELEdBQWYsQ0FyK01tQixDQWcvTW5COztBQUNBLE9BQUssSUFBSXI1QyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEVBQXBCLEVBQXdCQSxDQUFDLEVBQXpCLEVBQTZCO0FBQUVxNUMsWUFBUSxDQUFDcjVDLENBQUMsR0FBRyxFQUFMLENBQVIsR0FBbUJxNUMsUUFBUSxDQUFDcjVDLENBQUMsR0FBRyxFQUFMLENBQVIsR0FBbUJzVixNQUFNLENBQUN0VixDQUFELENBQTVDO0FBQWtELEdBai9NOUQsQ0FrL01uQjs7O0FBQ0EsT0FBSyxJQUFJMEosR0FBRyxHQUFHLEVBQWYsRUFBbUJBLEdBQUcsSUFBSSxFQUExQixFQUE4QkEsR0FBRyxFQUFqQyxFQUFxQztBQUFFMnZDLFlBQVEsQ0FBQzN2QyxHQUFELENBQVIsR0FBZ0I0TCxNQUFNLENBQUNna0MsWUFBUCxDQUFvQjV2QyxHQUFwQixDQUFoQjtBQUEyQyxHQW4vTS9ELENBby9NbkI7OztBQUNBLE9BQUssSUFBSUcsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsSUFBSSxFQUF6QixFQUE2QkEsR0FBRyxFQUFoQyxFQUFvQztBQUFFd3ZDLFlBQVEsQ0FBQ3h2QyxHQUFHLEdBQUcsR0FBUCxDQUFSLEdBQXNCd3ZDLFFBQVEsQ0FBQ3h2QyxHQUFHLEdBQUcsS0FBUCxDQUFSLEdBQXdCLE1BQU1BLEdBQXBEO0FBQTBEOztBQUVoRyxNQUFJMHZDLE1BQU0sR0FBRyxFQUFiO0FBRUFBLFFBQU0sQ0FBQ0MsS0FBUCxHQUFlO0FBQ2IsWUFBUSxZQURLO0FBQ1MsYUFBUyxhQURsQjtBQUNpQyxVQUFNLFVBRHZDO0FBQ21ELFlBQVEsWUFEM0Q7QUFFYixXQUFPLFdBRk07QUFFTyxZQUFRLGtCQUZmO0FBRW1DLGNBQVUsVUFGN0M7QUFFeUQsZ0JBQVksWUFGckU7QUFHYixjQUFVLGNBSEc7QUFHYSxpQkFBYSxlQUgxQjtBQUcyQyx1QkFBbUIsZUFIOUQ7QUFJYixXQUFPLFlBSk07QUFJUSxpQkFBYSxZQUpyQjtBQUtiLGFBQVMsa0JBTEk7QUFLZ0IsY0FBVSxpQkFMMUI7QUFNYixXQUFPO0FBTk0sR0FBZixDQXovTW1CLENBaWdObkI7QUFDQTtBQUNBOztBQUNBRCxRQUFNLENBQUNFLFNBQVAsR0FBbUI7QUFDakIsY0FBVSxXQURPO0FBQ00sY0FBVSxZQURoQjtBQUM4QixjQUFVLE1BRHhDO0FBQ2dELG9CQUFnQixNQURoRTtBQUN3RSxjQUFVLE1BRGxGO0FBRWpCLGlCQUFhLFlBRkk7QUFFVSxnQkFBWSxVQUZ0QjtBQUVrQyxlQUFXLFVBRjdDO0FBRXlELGlCQUFhLFlBRnRFO0FBR2pCLGlCQUFhLGFBSEk7QUFHVyxrQkFBYyxjQUh6QjtBQUd5QyxnQkFBWSxhQUhyRDtBQUdvRSxpQkFBYSxXQUhqRjtBQUlqQixzQkFBa0IsZ0JBSkQ7QUFJbUIsbUJBQWUsZUFKbEM7QUFJbUQsY0FBVSxNQUo3RDtBQUlxRSxjQUFVLE1BSi9FO0FBS2pCLGNBQVUsVUFMTztBQUtLLG9CQUFnQixVQUxyQjtBQUtpQyxvQkFBZ0IsU0FMakQ7QUFLNEQsb0JBQWdCLFlBTDVFO0FBTWpCLGNBQVUsWUFOTztBQU1PLGNBQVUsWUFOakI7QUFPakIsY0FBVSxlQVBPO0FBT1Usb0JBQWdCLGVBUDFCO0FBTzJDLGFBQVMsZUFQcEQ7QUFRakIsbUJBQWU7QUFSRSxHQUFuQixDQXBnTm1CLENBOGdObkI7O0FBQ0FGLFFBQU0sQ0FBQ0csTUFBUCxHQUFnQjtBQUNkLGNBQVUsYUFESTtBQUNXLGNBQVUsWUFEckI7QUFDbUMsY0FBVSxVQUQ3QztBQUN5RCxjQUFVLFlBRG5FO0FBRWQsYUFBUyxhQUZLO0FBRVUsYUFBUyxZQUZuQjtBQUVpQyxjQUFVLGFBRjNDO0FBRTBELGNBQVUsV0FGcEU7QUFHZCxjQUFVLFlBSEk7QUFHVSxvQkFBZ0IsVUFIMUI7QUFHc0MsY0FBVSxjQUhoRDtBQUdnRSxjQUFVLGVBSDFFO0FBSWQsYUFBUyxjQUpLO0FBSVcscUJBQWlCLGVBSjVCO0FBSTZDLGNBQVUsVUFKdkQ7QUFJbUUsY0FBVSxnQkFKN0U7QUFLZCxjQUFVO0FBTEksR0FBaEI7QUFPQUgsUUFBTSxDQUFDSSxVQUFQLEdBQW9CO0FBQ2xCLGFBQVMsV0FEUztBQUNJLGFBQVMsWUFEYjtBQUMyQixhQUFTLE1BRHBDO0FBQzRDLG1CQUFlLE1BRDNEO0FBQ21FLGFBQVMsTUFENUU7QUFFbEIsZ0JBQVksWUFGTTtBQUVRLGNBQVUsWUFGbEI7QUFFZ0MsZUFBVyxVQUYzQztBQUV1RCxnQkFBWSxVQUZuRTtBQUUrRSxnQkFBWSxhQUYzRjtBQUdsQixpQkFBYSxjQUhLO0FBR1csZ0JBQVksWUFIdkI7QUFHcUMsaUJBQWEsYUFIbEQ7QUFHaUUscUJBQWlCLGdCQUhsRjtBQUlsQiwwQkFBc0IsZUFKSjtBQUlxQixrQkFBYyxlQUpuQztBQUlvRCxhQUFTLE1BSjdEO0FBSXFFLGFBQVMsTUFKOUU7QUFLbEIsYUFBUyxVQUxTO0FBS0csbUJBQWUsVUFMbEI7QUFLOEIsaUJBQWEsU0FMM0M7QUFLc0QsdUJBQW1CLFlBTHpFO0FBTWxCLGFBQVMsWUFOUztBQU1LLGFBQVMsWUFOZDtBQU00QixxQkFBaUIsb0JBTjdDO0FBTW1FLGtCQUFjLHFCQU5qRjtBQU9sQixhQUFTLGVBUFM7QUFPUSxtQkFBZSxlQVB2QjtBQU93QyxlQUFXLFlBUG5EO0FBT2lFLGlCQUFhLFVBUDlFO0FBUWxCLG1CQUFlLENBQUMsT0FBRCxFQUFVLFFBQVY7QUFSRyxHQUFwQjtBQVVBSixRQUFNLENBQUMsU0FBRCxDQUFOLEdBQW9CMTdDLEdBQUcsR0FBRzA3QyxNQUFNLENBQUNJLFVBQVYsR0FBdUJKLE1BQU0sQ0FBQ0UsU0FBckQsQ0FoaU5tQixDQWtpTm5COztBQUVBLFdBQVNHLGdCQUFULENBQTBCdHBDLElBQTFCLEVBQWdDO0FBQzlCLFFBQUk0TSxLQUFLLEdBQUc1TSxJQUFJLENBQUN4TyxLQUFMLENBQVcsUUFBWCxDQUFaO0FBQ0F3TyxRQUFJLEdBQUc0TSxLQUFLLENBQUNBLEtBQUssQ0FBQ25lLE1BQU4sR0FBZSxDQUFoQixDQUFaO0FBQ0EsUUFBSTg2QyxHQUFKLEVBQVNDLElBQVQsRUFBZWhpQixLQUFmLEVBQXNCaWlCLEdBQXRCOztBQUNBLFNBQUssSUFBSS81QyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHa2QsS0FBSyxDQUFDbmUsTUFBTixHQUFlLENBQW5DLEVBQXNDaUIsQ0FBQyxFQUF2QyxFQUEyQztBQUN6QyxVQUFJZzZDLEdBQUcsR0FBRzk4QixLQUFLLENBQUNsZCxDQUFELENBQWY7O0FBQ0EsVUFBSSxrQkFBa0J4RCxJQUFsQixDQUF1Qnc5QyxHQUF2QixDQUFKLEVBQWlDO0FBQUVELFdBQUcsR0FBRyxJQUFOO0FBQWEsT0FBaEQsTUFDSyxJQUFJLFlBQVl2OUMsSUFBWixDQUFpQnc5QyxHQUFqQixDQUFKLEVBQTJCO0FBQUVILFdBQUcsR0FBRyxJQUFOO0FBQWEsT0FBMUMsTUFDQSxJQUFJLHNCQUFzQnI5QyxJQUF0QixDQUEyQnc5QyxHQUEzQixDQUFKLEVBQXFDO0FBQUVGLFlBQUksR0FBRyxJQUFQO0FBQWMsT0FBckQsTUFDQSxJQUFJLGNBQWN0OUMsSUFBZCxDQUFtQnc5QyxHQUFuQixDQUFKLEVBQTZCO0FBQUVsaUIsYUFBSyxHQUFHLElBQVI7QUFBZSxPQUE5QyxNQUNBO0FBQUUsY0FBTSxJQUFJNWpCLEtBQUosQ0FBVSxpQ0FBaUM4bEMsR0FBM0MsQ0FBTjtBQUF1RDtBQUMvRDs7QUFDRCxRQUFJSCxHQUFKLEVBQVM7QUFBRXZwQyxVQUFJLEdBQUcsU0FBU0EsSUFBaEI7QUFBdUI7O0FBQ2xDLFFBQUl3cEMsSUFBSixFQUFVO0FBQUV4cEMsVUFBSSxHQUFHLFVBQVVBLElBQWpCO0FBQXdCOztBQUNwQyxRQUFJeXBDLEdBQUosRUFBUztBQUFFenBDLFVBQUksR0FBRyxTQUFTQSxJQUFoQjtBQUF1Qjs7QUFDbEMsUUFBSXduQixLQUFKLEVBQVc7QUFBRXhuQixVQUFJLEdBQUcsV0FBV0EsSUFBbEI7QUFBeUI7O0FBQ3RDLFdBQU9BLElBQVA7QUFDRCxHQXJqTmtCLENBdWpObkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBUzJwQyxlQUFULENBQXlCQyxNQUF6QixFQUFpQztBQUMvQixRQUFJbmpDLElBQUksR0FBRyxFQUFYOztBQUNBLFNBQUssSUFBSW9qQyxPQUFULElBQW9CRCxNQUFwQixFQUE0QjtBQUFFLFVBQUlBLE1BQU0sQ0FBQ2gzQyxjQUFQLENBQXNCaTNDLE9BQXRCLENBQUosRUFBb0M7QUFDaEUsWUFBSWg0QyxLQUFLLEdBQUcrM0MsTUFBTSxDQUFDQyxPQUFELENBQWxCOztBQUNBLFlBQUksbUNBQW1DMzlDLElBQW5DLENBQXdDMjlDLE9BQXhDLENBQUosRUFBc0Q7QUFBRTtBQUFVOztBQUNsRSxZQUFJaDRDLEtBQUssSUFBSSxLQUFiLEVBQW9CO0FBQUUsaUJBQU8rM0MsTUFBTSxDQUFDQyxPQUFELENBQWI7QUFBd0I7QUFBVTs7QUFFeEQsWUFBSUMsSUFBSSxHQUFHeDBDLEdBQUcsQ0FBQ3UwQyxPQUFPLENBQUNyNEMsS0FBUixDQUFjLEdBQWQsQ0FBRCxFQUFxQjgzQyxnQkFBckIsQ0FBZDs7QUFDQSxhQUFLLElBQUk1NUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR282QyxJQUFJLENBQUNyN0MsTUFBekIsRUFBaUNpQixDQUFDLEVBQWxDLEVBQXNDO0FBQ3BDLGNBQUkyUixHQUFHLEdBQUksS0FBSyxDQUFoQjtBQUFBLGNBQW9CckIsSUFBSSxHQUFJLEtBQUssQ0FBakM7O0FBQ0EsY0FBSXRRLENBQUMsSUFBSW82QyxJQUFJLENBQUNyN0MsTUFBTCxHQUFjLENBQXZCLEVBQTBCO0FBQ3hCdVIsZ0JBQUksR0FBRzhwQyxJQUFJLENBQUNqSCxJQUFMLENBQVUsR0FBVixDQUFQO0FBQ0F4aEMsZUFBRyxHQUFHeFAsS0FBTjtBQUNELFdBSEQsTUFHTztBQUNMbU8sZ0JBQUksR0FBRzhwQyxJQUFJLENBQUN2N0MsS0FBTCxDQUFXLENBQVgsRUFBY21CLENBQUMsR0FBRyxDQUFsQixFQUFxQm16QyxJQUFyQixDQUEwQixHQUExQixDQUFQO0FBQ0F4aEMsZUFBRyxHQUFHLEtBQU47QUFDRDs7QUFDRCxjQUFJaEksSUFBSSxHQUFHb04sSUFBSSxDQUFDekcsSUFBRCxDQUFmOztBQUNBLGNBQUksQ0FBQzNHLElBQUwsRUFBVztBQUFFb04sZ0JBQUksQ0FBQ3pHLElBQUQsQ0FBSixHQUFhcUIsR0FBYjtBQUFtQixXQUFoQyxNQUNLLElBQUloSSxJQUFJLElBQUlnSSxHQUFaLEVBQWlCO0FBQUUsa0JBQU0sSUFBSXVDLEtBQUosQ0FBVSwrQkFBK0I1RCxJQUF6QyxDQUFOO0FBQXNEO0FBQy9FOztBQUNELGVBQU80cEMsTUFBTSxDQUFDQyxPQUFELENBQWI7QUFDRDtBQUFFOztBQUNILFNBQUssSUFBSWwzQyxJQUFULElBQWlCOFQsSUFBakIsRUFBdUI7QUFBRW1qQyxZQUFNLENBQUNqM0MsSUFBRCxDQUFOLEdBQWU4VCxJQUFJLENBQUM5VCxJQUFELENBQW5CO0FBQTRCOztBQUNyRCxXQUFPaTNDLE1BQVA7QUFDRDs7QUFFRCxXQUFTRyxTQUFULENBQW1CdnVCLEdBQW5CLEVBQXdCbG1CLEdBQXhCLEVBQTZCa3FDLE1BQTdCLEVBQXFDNzRCLE9BQXJDLEVBQThDO0FBQzVDclIsT0FBRyxHQUFHMDBDLFNBQVMsQ0FBQzEwQyxHQUFELENBQWY7QUFDQSxRQUFJdUMsS0FBSyxHQUFHdkMsR0FBRyxDQUFDbEQsSUFBSixHQUFXa0QsR0FBRyxDQUFDbEQsSUFBSixDQUFTb3BCLEdBQVQsRUFBYzdVLE9BQWQsQ0FBWCxHQUFvQ3JSLEdBQUcsQ0FBQ2ttQixHQUFELENBQW5EOztBQUNBLFFBQUkzakIsS0FBSyxLQUFLLEtBQWQsRUFBcUI7QUFBRSxhQUFPLFNBQVA7QUFBa0I7O0FBQ3pDLFFBQUlBLEtBQUssS0FBSyxLQUFkLEVBQXFCO0FBQUUsYUFBTyxPQUFQO0FBQWdCOztBQUN2QyxRQUFJQSxLQUFLLElBQUksSUFBVCxJQUFpQjJuQyxNQUFNLENBQUMzbkMsS0FBRCxDQUEzQixFQUFvQztBQUFFLGFBQU8sU0FBUDtBQUFrQjs7QUFFeEQsUUFBSXZDLEdBQUcsQ0FBQzIwQyxXQUFSLEVBQXFCO0FBQ25CLFVBQUloMEMsTUFBTSxDQUFDOUQsU0FBUCxDQUFpQmlDLFFBQWpCLENBQTBCaEMsSUFBMUIsQ0FBK0JrRCxHQUFHLENBQUMyMEMsV0FBbkMsS0FBbUQsZ0JBQXZELEVBQ0U7QUFBRSxlQUFPRixTQUFTLENBQUN2dUIsR0FBRCxFQUFNbG1CLEdBQUcsQ0FBQzIwQyxXQUFWLEVBQXVCekssTUFBdkIsRUFBK0I3NEIsT0FBL0IsQ0FBaEI7QUFBeUQ7O0FBQzdELFdBQUssSUFBSWpYLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc0RixHQUFHLENBQUMyMEMsV0FBSixDQUFnQng3QyxNQUFwQyxFQUE0Q2lCLENBQUMsRUFBN0MsRUFBaUQ7QUFDL0MsWUFBSWdQLE1BQU0sR0FBR3FyQyxTQUFTLENBQUN2dUIsR0FBRCxFQUFNbG1CLEdBQUcsQ0FBQzIwQyxXQUFKLENBQWdCdjZDLENBQWhCLENBQU4sRUFBMEI4dkMsTUFBMUIsRUFBa0M3NEIsT0FBbEMsQ0FBdEI7O0FBQ0EsWUFBSWpJLE1BQUosRUFBWTtBQUFFLGlCQUFPQSxNQUFQO0FBQWU7QUFDOUI7QUFDRjtBQUNGLEdBdG1Oa0IsQ0F3bU5uQjtBQUNBOzs7QUFDQSxXQUFTd3JDLGFBQVQsQ0FBdUJyNEMsS0FBdkIsRUFBOEI7QUFDNUIsUUFBSW1PLElBQUksR0FBRyxPQUFPbk8sS0FBUCxJQUFnQixRQUFoQixHQUEyQkEsS0FBM0IsR0FBbUNrM0MsUUFBUSxDQUFDbDNDLEtBQUssQ0FBQ3M0QyxPQUFQLENBQXREO0FBQ0EsV0FBT25xQyxJQUFJLElBQUksTUFBUixJQUFrQkEsSUFBSSxJQUFJLEtBQTFCLElBQW1DQSxJQUFJLElBQUksT0FBM0MsSUFBc0RBLElBQUksSUFBSSxLQUFyRTtBQUNEOztBQUVELFdBQVNvcUMsZ0JBQVQsQ0FBMEJwcUMsSUFBMUIsRUFBZ0NxN0IsS0FBaEMsRUFBdUNnUCxPQUF2QyxFQUFnRDtBQUM5QyxRQUFJdjBDLElBQUksR0FBR2tLLElBQVg7O0FBQ0EsUUFBSXE3QixLQUFLLENBQUNpUCxNQUFOLElBQWdCeDBDLElBQUksSUFBSSxLQUE1QixFQUFtQztBQUFFa0ssVUFBSSxHQUFHLFNBQVNBLElBQWhCO0FBQXVCOztBQUM1RCxRQUFJLENBQUNuUyxXQUFXLEdBQUd3dEMsS0FBSyxDQUFDa1AsT0FBVCxHQUFtQmxQLEtBQUssQ0FBQzU5QixPQUFyQyxLQUFpRDNILElBQUksSUFBSSxNQUE3RCxFQUFxRTtBQUFFa0ssVUFBSSxHQUFHLFVBQVVBLElBQWpCO0FBQXdCOztBQUMvRixRQUFJLENBQUNuUyxXQUFXLEdBQUd3dEMsS0FBSyxDQUFDNTlCLE9BQVQsR0FBbUI0OUIsS0FBSyxDQUFDa1AsT0FBckMsS0FBaUR6MEMsSUFBSSxJQUFJLEtBQTdELEVBQW9FO0FBQUVrSyxVQUFJLEdBQUcsU0FBU0EsSUFBaEI7QUFBdUI7O0FBQzdGLFFBQUksQ0FBQ3FxQyxPQUFELElBQVloUCxLQUFLLENBQUNtUCxRQUFsQixJQUE4QjEwQyxJQUFJLElBQUksT0FBMUMsRUFBbUQ7QUFBRWtLLFVBQUksR0FBRyxXQUFXQSxJQUFsQjtBQUF5Qjs7QUFDOUUsV0FBT0EsSUFBUDtBQUNELEdBdG5Oa0IsQ0F3bk5uQjs7O0FBQ0EsV0FBU3lxQyxPQUFULENBQWlCcFAsS0FBakIsRUFBd0JnUCxPQUF4QixFQUFpQztBQUMvQixRQUFJdjlDLE1BQU0sSUFBSXV1QyxLQUFLLENBQUM4TyxPQUFOLElBQWlCLEVBQTNCLElBQWlDOU8sS0FBSyxDQUFDLE1BQUQsQ0FBMUMsRUFBb0Q7QUFBRSxhQUFPLEtBQVA7QUFBYzs7QUFDcEUsUUFBSXI3QixJQUFJLEdBQUcrb0MsUUFBUSxDQUFDMU4sS0FBSyxDQUFDOE8sT0FBUCxDQUFuQjs7QUFDQSxRQUFJbnFDLElBQUksSUFBSSxJQUFSLElBQWdCcTdCLEtBQUssQ0FBQ3FQLFdBQTFCLEVBQXVDO0FBQUUsYUFBTyxLQUFQO0FBQWMsS0FIeEIsQ0FJL0I7QUFDQTs7O0FBQ0EsUUFBSXJQLEtBQUssQ0FBQzhPLE9BQU4sSUFBaUIsQ0FBakIsSUFBc0I5TyxLQUFLLENBQUM1aUMsSUFBaEMsRUFBc0M7QUFBRXVILFVBQUksR0FBR3E3QixLQUFLLENBQUM1aUMsSUFBYjtBQUFvQjs7QUFDNUQsV0FBTzJ4QyxnQkFBZ0IsQ0FBQ3BxQyxJQUFELEVBQU9xN0IsS0FBUCxFQUFjZ1AsT0FBZCxDQUF2QjtBQUNEOztBQUVELFdBQVNMLFNBQVQsQ0FBbUIzb0MsR0FBbkIsRUFBd0I7QUFDdEIsV0FBTyxPQUFPQSxHQUFQLElBQWMsUUFBZCxHQUF5QjRuQyxNQUFNLENBQUM1bkMsR0FBRCxDQUEvQixHQUF1Q0EsR0FBOUM7QUFDRCxHQXJvTmtCLENBdW9ObkI7QUFDQTs7O0FBQ0EsV0FBU3NwQyxtQkFBVCxDQUE2QjF1QyxFQUE3QixFQUFpQzJ1QyxPQUFqQyxFQUEwQztBQUN4QyxRQUFJam5CLE1BQU0sR0FBRzFuQixFQUFFLENBQUN3SCxHQUFILENBQU9pZ0IsR0FBUCxDQUFXQyxNQUF4QjtBQUFBLFFBQWdDa25CLElBQUksR0FBRyxFQUF2QyxDQUR3QyxDQUV4QztBQUNBOztBQUNBLFNBQUssSUFBSW43QyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaTBCLE1BQU0sQ0FBQ2wxQixNQUEzQixFQUFtQ2lCLENBQUMsRUFBcEMsRUFBd0M7QUFDdEMsVUFBSW83QyxNQUFNLEdBQUdGLE9BQU8sQ0FBQ2puQixNQUFNLENBQUNqMEIsQ0FBRCxDQUFQLENBQXBCOztBQUNBLGFBQU9tN0MsSUFBSSxDQUFDcDhDLE1BQUwsSUFBZTJXLEdBQUcsQ0FBQzBsQyxNQUFNLENBQUN6ekMsSUFBUixFQUFjakMsR0FBRyxDQUFDeTFDLElBQUQsQ0FBSCxDQUFVdnpDLEVBQXhCLENBQUgsSUFBa0MsQ0FBeEQsRUFBMkQ7QUFDekQsWUFBSXl6QyxRQUFRLEdBQUdGLElBQUksQ0FBQ2hSLEdBQUwsRUFBZjs7QUFDQSxZQUFJejBCLEdBQUcsQ0FBQzJsQyxRQUFRLENBQUMxekMsSUFBVixFQUFnQnl6QyxNQUFNLENBQUN6ekMsSUFBdkIsQ0FBSCxHQUFrQyxDQUF0QyxFQUF5QztBQUN2Q3l6QyxnQkFBTSxDQUFDenpDLElBQVAsR0FBYzB6QyxRQUFRLENBQUMxekMsSUFBdkI7QUFDQTtBQUNEO0FBQ0Y7O0FBQ0R3ekMsVUFBSSxDQUFDMTFDLElBQUwsQ0FBVTIxQyxNQUFWO0FBQ0QsS0FkdUMsQ0FleEM7OztBQUNBL2EsV0FBTyxDQUFDOXpCLEVBQUQsRUFBSyxZQUFZO0FBQ3RCLFdBQUssSUFBSXZNLENBQUMsR0FBR203QyxJQUFJLENBQUNwOEMsTUFBTCxHQUFjLENBQTNCLEVBQThCaUIsQ0FBQyxJQUFJLENBQW5DLEVBQXNDQSxDQUFDLEVBQXZDLEVBQ0U7QUFBRXN2QyxxQkFBWSxDQUFDL2lDLEVBQUUsQ0FBQ3dILEdBQUosRUFBUyxFQUFULEVBQWFvbkMsSUFBSSxDQUFDbjdDLENBQUQsQ0FBSixDQUFRMkgsSUFBckIsRUFBMkJ3ekMsSUFBSSxDQUFDbjdDLENBQUQsQ0FBSixDQUFRNEgsRUFBbkMsRUFBdUMsU0FBdkMsQ0FBWjtBQUFnRTs7QUFDcEUweUIseUJBQW1CLENBQUMvdEIsRUFBRCxDQUFuQjtBQUNELEtBSk0sQ0FBUDtBQUtEOztBQUVELFdBQVMrdUMsaUJBQVQsQ0FBMkIvdkMsSUFBM0IsRUFBaUM1RSxFQUFqQyxFQUFxQ1ksR0FBckMsRUFBMEM7QUFDeEMsUUFBSXhFLE1BQU0sR0FBR3NFLGtCQUFrQixDQUFDa0UsSUFBSSxDQUFDQyxJQUFOLEVBQVk3RSxFQUFFLEdBQUdZLEdBQWpCLEVBQXNCQSxHQUF0QixDQUEvQjtBQUNBLFdBQU94RSxNQUFNLEdBQUcsQ0FBVCxJQUFjQSxNQUFNLEdBQUd3SSxJQUFJLENBQUNDLElBQUwsQ0FBVXpNLE1BQWpDLEdBQTBDLElBQTFDLEdBQWlEZ0UsTUFBeEQ7QUFDRDs7QUFFRCxXQUFTdzRDLGFBQVQsQ0FBdUJod0MsSUFBdkIsRUFBNkJsTCxLQUE3QixFQUFvQ2tILEdBQXBDLEVBQXlDO0FBQ3ZDLFFBQUlaLEVBQUUsR0FBRzIwQyxpQkFBaUIsQ0FBQy92QyxJQUFELEVBQU9sTCxLQUFLLENBQUNzRyxFQUFiLEVBQWlCWSxHQUFqQixDQUExQjtBQUNBLFdBQU9aLEVBQUUsSUFBSSxJQUFOLEdBQWEsSUFBYixHQUFvQixJQUFJOE8sR0FBSixDQUFRcFYsS0FBSyxDQUFDa0wsSUFBZCxFQUFvQjVFLEVBQXBCLEVBQXdCWSxHQUFHLEdBQUcsQ0FBTixHQUFVLE9BQVYsR0FBb0IsUUFBNUMsQ0FBM0I7QUFDRDs7QUFFRCxXQUFTaTBDLFNBQVQsQ0FBbUJDLFFBQW5CLEVBQTZCbHZDLEVBQTdCLEVBQWlDa1QsT0FBakMsRUFBMEMzSyxNQUExQyxFQUFrRHZOLEdBQWxELEVBQXVEO0FBQ3JELFFBQUlrMEMsUUFBSixFQUFjO0FBQ1osVUFBSWx2QyxFQUFFLENBQUN3SCxHQUFILENBQU96SyxTQUFQLElBQW9CLEtBQXhCLEVBQStCO0FBQUUvQixXQUFHLEdBQUcsQ0FBQ0EsR0FBUDtBQUFhOztBQUM5QyxVQUFJVyxLQUFLLEdBQUdvRCxRQUFRLENBQUNtVSxPQUFELEVBQVVsVCxFQUFFLENBQUN3SCxHQUFILENBQU96SyxTQUFqQixDQUFwQjs7QUFDQSxVQUFJcEIsS0FBSixFQUFXO0FBQ1QsWUFBSUUsSUFBSSxHQUFHYixHQUFHLEdBQUcsQ0FBTixHQUFVN0IsR0FBRyxDQUFDd0MsS0FBRCxDQUFiLEdBQXVCQSxLQUFLLENBQUMsQ0FBRCxDQUF2QztBQUNBLFlBQUl3ekMsa0JBQWtCLEdBQUluMEMsR0FBRyxHQUFHLENBQVAsS0FBY2EsSUFBSSxDQUFDRSxLQUFMLElBQWMsQ0FBNUIsQ0FBekI7QUFDQSxZQUFJRyxNQUFNLEdBQUdpekMsa0JBQWtCLEdBQUcsT0FBSCxHQUFhLFFBQTVDO0FBQ0EsWUFBSS8wQyxFQUFKLENBSlMsQ0FLVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsWUFBSXlCLElBQUksQ0FBQ0UsS0FBTCxHQUFhLENBQWIsSUFBa0JpRSxFQUFFLENBQUN3SCxHQUFILENBQU96SyxTQUFQLElBQW9CLEtBQTFDLEVBQWlEO0FBQy9DLGNBQUlxeUMsSUFBSSxHQUFHcndCLHFCQUFxQixDQUFDL2UsRUFBRCxFQUFLa1QsT0FBTCxDQUFoQztBQUNBOVksWUFBRSxHQUFHWSxHQUFHLEdBQUcsQ0FBTixHQUFVa1ksT0FBTyxDQUFDalUsSUFBUixDQUFhek0sTUFBYixHQUFzQixDQUFoQyxHQUFvQyxDQUF6QztBQUNBLGNBQUlzeEIsU0FBUyxHQUFHaEYsbUJBQW1CLENBQUM5ZSxFQUFELEVBQUtvdkMsSUFBTCxFQUFXaDFDLEVBQVgsQ0FBbkIsQ0FBa0Nva0IsR0FBbEQ7QUFDQXBrQixZQUFFLEdBQUdjLFNBQVMsQ0FBQyxVQUFVZCxFQUFWLEVBQWM7QUFBRSxtQkFBTzBrQixtQkFBbUIsQ0FBQzllLEVBQUQsRUFBS292QyxJQUFMLEVBQVdoMUMsRUFBWCxDQUFuQixDQUFrQ29rQixHQUFsQyxJQUF5Q3NGLFNBQWhEO0FBQTRELFdBQTdFLEVBQWdGOW9CLEdBQUcsR0FBRyxDQUFQLEtBQWNhLElBQUksQ0FBQ0UsS0FBTCxJQUFjLENBQTVCLElBQWlDRixJQUFJLENBQUNULElBQXRDLEdBQTZDUyxJQUFJLENBQUNSLEVBQUwsR0FBVSxDQUF0SSxFQUF5SWpCLEVBQXpJLENBQWQ7O0FBQ0EsY0FBSThCLE1BQU0sSUFBSSxRQUFkLEVBQXdCO0FBQUU5QixjQUFFLEdBQUcyMEMsaUJBQWlCLENBQUM3N0IsT0FBRCxFQUFVOVksRUFBVixFQUFjLENBQWQsQ0FBdEI7QUFBeUM7QUFDcEUsU0FORCxNQU1PO0FBQUVBLFlBQUUsR0FBR1ksR0FBRyxHQUFHLENBQU4sR0FBVWEsSUFBSSxDQUFDUixFQUFmLEdBQW9CUSxJQUFJLENBQUNULElBQTlCO0FBQXFDOztBQUM5QyxlQUFPLElBQUk4TixHQUFKLENBQVFYLE1BQVIsRUFBZ0JuTyxFQUFoQixFQUFvQjhCLE1BQXBCLENBQVA7QUFDRDtBQUNGOztBQUNELFdBQU8sSUFBSWdOLEdBQUosQ0FBUVgsTUFBUixFQUFnQnZOLEdBQUcsR0FBRyxDQUFOLEdBQVVrWSxPQUFPLENBQUNqVSxJQUFSLENBQWF6TSxNQUF2QixHQUFnQyxDQUFoRCxFQUFtRHdJLEdBQUcsR0FBRyxDQUFOLEdBQVUsUUFBVixHQUFxQixPQUF4RSxDQUFQO0FBQ0Q7O0FBRUQsV0FBU3EwQyxZQUFULENBQXNCcnZDLEVBQXRCLEVBQTBCaEIsSUFBMUIsRUFBZ0NsTCxLQUFoQyxFQUF1Q2tILEdBQXZDLEVBQTRDO0FBQzFDLFFBQUlzMEMsSUFBSSxHQUFHdndDLFFBQVEsQ0FBQ0MsSUFBRCxFQUFPZ0IsRUFBRSxDQUFDd0gsR0FBSCxDQUFPekssU0FBZCxDQUFuQjs7QUFDQSxRQUFJLENBQUN1eUMsSUFBTCxFQUFXO0FBQUUsYUFBT04sYUFBYSxDQUFDaHdDLElBQUQsRUFBT2xMLEtBQVAsRUFBY2tILEdBQWQsQ0FBcEI7QUFBd0M7O0FBQ3JELFFBQUlsSCxLQUFLLENBQUNzRyxFQUFOLElBQVk0RSxJQUFJLENBQUNDLElBQUwsQ0FBVXpNLE1BQTFCLEVBQWtDO0FBQ2hDc0IsV0FBSyxDQUFDc0csRUFBTixHQUFXNEUsSUFBSSxDQUFDQyxJQUFMLENBQVV6TSxNQUFyQjtBQUNBc0IsV0FBSyxDQUFDb0ksTUFBTixHQUFlLFFBQWY7QUFDRCxLQUhELE1BR08sSUFBSXBJLEtBQUssQ0FBQ3NHLEVBQU4sSUFBWSxDQUFoQixFQUFtQjtBQUN4QnRHLFdBQUssQ0FBQ3NHLEVBQU4sR0FBVyxDQUFYO0FBQ0F0RyxXQUFLLENBQUNvSSxNQUFOLEdBQWUsT0FBZjtBQUNEOztBQUNELFFBQUk4bUIsT0FBTyxHQUFHL21CLGFBQWEsQ0FBQ3F6QyxJQUFELEVBQU94N0MsS0FBSyxDQUFDc0csRUFBYixFQUFpQnRHLEtBQUssQ0FBQ29JLE1BQXZCLENBQTNCO0FBQUEsUUFBMkRMLElBQUksR0FBR3l6QyxJQUFJLENBQUN0c0IsT0FBRCxDQUF0RTs7QUFDQSxRQUFJaGpCLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT3pLLFNBQVAsSUFBb0IsS0FBcEIsSUFBNkJsQixJQUFJLENBQUNFLEtBQUwsR0FBYSxDQUFiLElBQWtCLENBQS9DLEtBQXFEZixHQUFHLEdBQUcsQ0FBTixHQUFVYSxJQUFJLENBQUNSLEVBQUwsR0FBVXZILEtBQUssQ0FBQ3NHLEVBQTFCLEdBQStCeUIsSUFBSSxDQUFDVCxJQUFMLEdBQVl0SCxLQUFLLENBQUNzRyxFQUF0RyxDQUFKLEVBQStHO0FBQzdHO0FBQ0E7QUFDQSxhQUFPNDBDLGFBQWEsQ0FBQ2h3QyxJQUFELEVBQU9sTCxLQUFQLEVBQWNrSCxHQUFkLENBQXBCO0FBQ0Q7O0FBRUQsUUFBSXUwQyxFQUFFLEdBQUcsU0FBTEEsRUFBSyxDQUFVNTJDLEdBQVYsRUFBZXFDLEdBQWYsRUFBb0I7QUFBRSxhQUFPK3pDLGlCQUFpQixDQUFDL3ZDLElBQUQsRUFBT3JHLEdBQUcsWUFBWXVRLEdBQWYsR0FBcUJ2USxHQUFHLENBQUN5QixFQUF6QixHQUE4QnpCLEdBQXJDLEVBQTBDcUMsR0FBMUMsQ0FBeEI7QUFBeUUsS0FBeEc7O0FBQ0EsUUFBSW8wQyxJQUFKOztBQUNBLFFBQUlJLG9CQUFvQixHQUFHLFNBQXZCQSxvQkFBdUIsQ0FBVXAxQyxFQUFWLEVBQWM7QUFDdkMsVUFBSSxDQUFDNEYsRUFBRSxDQUFDdUUsT0FBSCxDQUFXMlosWUFBaEIsRUFBOEI7QUFBRSxlQUFPO0FBQUMwRixlQUFLLEVBQUUsQ0FBUjtBQUFXN3ZCLGFBQUcsRUFBRWlMLElBQUksQ0FBQ0MsSUFBTCxDQUFVek07QUFBMUIsU0FBUDtBQUEwQzs7QUFDMUU0OEMsVUFBSSxHQUFHQSxJQUFJLElBQUlyd0IscUJBQXFCLENBQUMvZSxFQUFELEVBQUtoQixJQUFMLENBQXBDO0FBQ0EsYUFBTzZrQixxQkFBcUIsQ0FBQzdqQixFQUFELEVBQUtoQixJQUFMLEVBQVdvd0MsSUFBWCxFQUFpQmgxQyxFQUFqQixDQUE1QjtBQUNELEtBSkQ7O0FBS0EsUUFBSXVwQixpQkFBaUIsR0FBRzZyQixvQkFBb0IsQ0FBQzE3QyxLQUFLLENBQUNvSSxNQUFOLElBQWdCLFFBQWhCLEdBQTJCcXpDLEVBQUUsQ0FBQ3o3QyxLQUFELEVBQVEsQ0FBQyxDQUFULENBQTdCLEdBQTJDQSxLQUFLLENBQUNzRyxFQUFsRCxDQUE1Qzs7QUFFQSxRQUFJNEYsRUFBRSxDQUFDd0gsR0FBSCxDQUFPekssU0FBUCxJQUFvQixLQUFwQixJQUE2QmxCLElBQUksQ0FBQ0UsS0FBTCxJQUFjLENBQS9DLEVBQWtEO0FBQ2hELFVBQUlvekMsa0JBQWtCLEdBQUl0ekMsSUFBSSxDQUFDRSxLQUFMLElBQWMsQ0FBZixJQUFzQmYsR0FBRyxHQUFHLENBQXJEO0FBQ0EsVUFBSVosRUFBRSxHQUFHbTFDLEVBQUUsQ0FBQ3o3QyxLQUFELEVBQVFxN0Msa0JBQWtCLEdBQUcsQ0FBSCxHQUFPLENBQUMsQ0FBbEMsQ0FBWDs7QUFDQSxVQUFJLzBDLEVBQUUsSUFBSSxJQUFOLEtBQWUsQ0FBQyswQyxrQkFBRCxHQUFzQi8wQyxFQUFFLElBQUl5QixJQUFJLENBQUNULElBQVgsSUFBbUJoQixFQUFFLElBQUl1cEIsaUJBQWlCLENBQUNDLEtBQWpFLEdBQXlFeHBCLEVBQUUsSUFBSXlCLElBQUksQ0FBQ1IsRUFBWCxJQUFpQmpCLEVBQUUsSUFBSXVwQixpQkFBaUIsQ0FBQzV2QixHQUFqSSxDQUFKLEVBQTJJO0FBQ3pJO0FBQ0EsWUFBSW1JLE1BQU0sR0FBR2l6QyxrQkFBa0IsR0FBRyxRQUFILEdBQWMsT0FBN0M7QUFDQSxlQUFPLElBQUlqbUMsR0FBSixDQUFRcFYsS0FBSyxDQUFDa0wsSUFBZCxFQUFvQjVFLEVBQXBCLEVBQXdCOEIsTUFBeEIsQ0FBUDtBQUNEO0FBQ0YsS0FsQ3lDLENBb0MxQztBQUNBOzs7QUFFQSxRQUFJdXpDLGtCQUFrQixHQUFHLFNBQXJCQSxrQkFBcUIsQ0FBVXpzQixPQUFWLEVBQW1CaG9CLEdBQW5CLEVBQXdCMm9CLGlCQUF4QixFQUEyQztBQUNsRSxVQUFJK3JCLE1BQU0sR0FBRyxTQUFUQSxNQUFTLENBQVV0MUMsRUFBVixFQUFjKzBDLGtCQUFkLEVBQWtDO0FBQUUsZUFBT0Esa0JBQWtCLEdBQ3RFLElBQUlqbUMsR0FBSixDQUFRcFYsS0FBSyxDQUFDa0wsSUFBZCxFQUFvQnV3QyxFQUFFLENBQUNuMUMsRUFBRCxFQUFLLENBQUwsQ0FBdEIsRUFBK0IsUUFBL0IsQ0FEc0UsR0FFdEUsSUFBSThPLEdBQUosQ0FBUXBWLEtBQUssQ0FBQ2tMLElBQWQsRUFBb0I1RSxFQUFwQixFQUF3QixPQUF4QixDQUY2QztBQUVWLE9BRnZDOztBQUlBLGFBQU80b0IsT0FBTyxJQUFJLENBQVgsSUFBZ0JBLE9BQU8sR0FBR3NzQixJQUFJLENBQUM5OEMsTUFBdEMsRUFBOEN3d0IsT0FBTyxJQUFJaG9CLEdBQXpELEVBQThEO0FBQzVELFlBQUlhLElBQUksR0FBR3l6QyxJQUFJLENBQUN0c0IsT0FBRCxDQUFmO0FBQ0EsWUFBSW1zQixrQkFBa0IsR0FBSW4wQyxHQUFHLEdBQUcsQ0FBUCxLQUFjYSxJQUFJLENBQUNFLEtBQUwsSUFBYyxDQUE1QixDQUF6QjtBQUNBLFlBQUkzQixFQUFFLEdBQUcrMEMsa0JBQWtCLEdBQUd4ckIsaUJBQWlCLENBQUNDLEtBQXJCLEdBQTZCMnJCLEVBQUUsQ0FBQzVyQixpQkFBaUIsQ0FBQzV2QixHQUFuQixFQUF3QixDQUFDLENBQXpCLENBQTFEOztBQUNBLFlBQUk4SCxJQUFJLENBQUNULElBQUwsSUFBYWhCLEVBQWIsSUFBbUJBLEVBQUUsR0FBR3lCLElBQUksQ0FBQ1IsRUFBakMsRUFBcUM7QUFBRSxpQkFBT3EwQyxNQUFNLENBQUN0MUMsRUFBRCxFQUFLKzBDLGtCQUFMLENBQWI7QUFBdUM7O0FBQzlFLzBDLFVBQUUsR0FBRyswQyxrQkFBa0IsR0FBR3R6QyxJQUFJLENBQUNULElBQVIsR0FBZW0wQyxFQUFFLENBQUMxekMsSUFBSSxDQUFDUixFQUFOLEVBQVUsQ0FBQyxDQUFYLENBQXhDOztBQUNBLFlBQUlzb0IsaUJBQWlCLENBQUNDLEtBQWxCLElBQTJCeHBCLEVBQTNCLElBQWlDQSxFQUFFLEdBQUd1cEIsaUJBQWlCLENBQUM1dkIsR0FBNUQsRUFBaUU7QUFBRSxpQkFBTzI3QyxNQUFNLENBQUN0MUMsRUFBRCxFQUFLKzBDLGtCQUFMLENBQWI7QUFBdUM7QUFDM0c7QUFDRixLQWJELENBdkMwQyxDQXNEMUM7OztBQUNBLFFBQUlRLEdBQUcsR0FBR0Ysa0JBQWtCLENBQUN6c0IsT0FBTyxHQUFHaG9CLEdBQVgsRUFBZ0JBLEdBQWhCLEVBQXFCMm9CLGlCQUFyQixDQUE1Qjs7QUFDQSxRQUFJZ3NCLEdBQUosRUFBUztBQUFFLGFBQU9BLEdBQVA7QUFBWSxLQXhEbUIsQ0EwRDFDOzs7QUFDQSxRQUFJQyxNQUFNLEdBQUc1MEMsR0FBRyxHQUFHLENBQU4sR0FBVTJvQixpQkFBaUIsQ0FBQzV2QixHQUE1QixHQUFrQ3c3QyxFQUFFLENBQUM1ckIsaUJBQWlCLENBQUNDLEtBQW5CLEVBQTBCLENBQUMsQ0FBM0IsQ0FBakQ7O0FBQ0EsUUFBSWdzQixNQUFNLElBQUksSUFBVixJQUFrQixFQUFFNTBDLEdBQUcsR0FBRyxDQUFOLElBQVc0MEMsTUFBTSxJQUFJNXdDLElBQUksQ0FBQ0MsSUFBTCxDQUFVek0sTUFBakMsQ0FBdEIsRUFBZ0U7QUFDOURtOUMsU0FBRyxHQUFHRixrQkFBa0IsQ0FBQ3owQyxHQUFHLEdBQUcsQ0FBTixHQUFVLENBQVYsR0FBY3MwQyxJQUFJLENBQUM5OEMsTUFBTCxHQUFjLENBQTdCLEVBQWdDd0ksR0FBaEMsRUFBcUN3MEMsb0JBQW9CLENBQUNJLE1BQUQsQ0FBekQsQ0FBeEI7O0FBQ0EsVUFBSUQsR0FBSixFQUFTO0FBQUUsZUFBT0EsR0FBUDtBQUFZO0FBQ3hCLEtBL0R5QyxDQWlFMUM7OztBQUNBLFdBQU8sSUFBUDtBQUNELEdBendOa0IsQ0Eyd05uQjtBQUNBOzs7QUFDQSxNQUFJRSxRQUFRLEdBQUc7QUFDYnhPLGFBQVMsRUFBRUEsU0FERTtBQUVieU8sbUJBQWUsRUFBRSx5QkFBVTl2QyxFQUFWLEVBQWM7QUFBRSxhQUFPQSxFQUFFLENBQUN5L0IsWUFBSCxDQUFnQnovQixFQUFFLENBQUNndUIsU0FBSCxDQUFhLFFBQWIsQ0FBaEIsRUFBd0NodUIsRUFBRSxDQUFDZ3VCLFNBQUgsQ0FBYSxNQUFiLENBQXhDLEVBQThENTFCLGNBQTlELENBQVA7QUFBdUYsS0FGM0c7QUFHYjIzQyxZQUFRLEVBQUUsa0JBQVUvdkMsRUFBVixFQUFjO0FBQUUsYUFBTzB1QyxtQkFBbUIsQ0FBQzF1QyxFQUFELEVBQUssVUFBVXBNLEtBQVYsRUFBaUI7QUFDeEUsWUFBSUEsS0FBSyxDQUFDZzBCLEtBQU4sRUFBSixFQUFtQjtBQUNqQixjQUFJM3FCLEdBQUcsR0FBR3NLLE9BQU8sQ0FBQ3ZILEVBQUUsQ0FBQ3dILEdBQUosRUFBUzVULEtBQUssQ0FBQ20wQixJQUFOLENBQVcvb0IsSUFBcEIsQ0FBUCxDQUFpQ0MsSUFBakMsQ0FBc0N6TSxNQUFoRDs7QUFDQSxjQUFJb0IsS0FBSyxDQUFDbTBCLElBQU4sQ0FBVzN0QixFQUFYLElBQWlCNkMsR0FBakIsSUFBd0JySixLQUFLLENBQUNtMEIsSUFBTixDQUFXL29CLElBQVgsR0FBa0JnQixFQUFFLENBQUM2UyxRQUFILEVBQTlDLEVBQ0U7QUFBRSxtQkFBTztBQUFDelgsa0JBQUksRUFBRXhILEtBQUssQ0FBQ20wQixJQUFiO0FBQW1CMXNCLGdCQUFFLEVBQUU2TixHQUFHLENBQUN0VixLQUFLLENBQUNtMEIsSUFBTixDQUFXL29CLElBQVgsR0FBa0IsQ0FBbkIsRUFBc0IsQ0FBdEI7QUFBMUIsYUFBUDtBQUE0RCxXQURoRSxNQUdFO0FBQUUsbUJBQU87QUFBQzVELGtCQUFJLEVBQUV4SCxLQUFLLENBQUNtMEIsSUFBYjtBQUFtQjFzQixnQkFBRSxFQUFFNk4sR0FBRyxDQUFDdFYsS0FBSyxDQUFDbTBCLElBQU4sQ0FBVy9vQixJQUFaLEVBQWtCL0IsR0FBbEI7QUFBMUIsYUFBUDtBQUEwRDtBQUMvRCxTQU5ELE1BTU87QUFDTCxpQkFBTztBQUFDN0IsZ0JBQUksRUFBRXhILEtBQUssQ0FBQ3dILElBQU4sRUFBUDtBQUFxQkMsY0FBRSxFQUFFekgsS0FBSyxDQUFDeUgsRUFBTjtBQUF6QixXQUFQO0FBQ0Q7QUFDRixPQVZtRCxDQUExQjtBQVVyQixLQWJRO0FBY2IyMEMsY0FBVSxFQUFFLG9CQUFVaHdDLEVBQVYsRUFBYztBQUFFLGFBQU8wdUMsbUJBQW1CLENBQUMxdUMsRUFBRCxFQUFLLFVBQVVwTSxLQUFWLEVBQWlCO0FBQUUsZUFBUTtBQUNwRndILGNBQUksRUFBRThOLEdBQUcsQ0FBQ3RWLEtBQUssQ0FBQ3dILElBQU4sR0FBYTRELElBQWQsRUFBb0IsQ0FBcEIsQ0FEMkU7QUFFcEYzRCxZQUFFLEVBQUVxTyxRQUFPLENBQUMxSixFQUFFLENBQUN3SCxHQUFKLEVBQVMwQixHQUFHLENBQUN0VixLQUFLLENBQUN5SCxFQUFOLEdBQVcyRCxJQUFYLEdBQWtCLENBQW5CLEVBQXNCLENBQXRCLENBQVo7QUFGeUUsU0FBUjtBQUd6RSxPQUhpRCxDQUExQjtBQUduQixLQWpCSTtBQWtCYml4QyxlQUFXLEVBQUUscUJBQVVqd0MsRUFBVixFQUFjO0FBQUUsYUFBTzB1QyxtQkFBbUIsQ0FBQzF1QyxFQUFELEVBQUssVUFBVXBNLEtBQVYsRUFBaUI7QUFBRSxlQUFRO0FBQ3JGd0gsY0FBSSxFQUFFOE4sR0FBRyxDQUFDdFYsS0FBSyxDQUFDd0gsSUFBTixHQUFhNEQsSUFBZCxFQUFvQixDQUFwQixDQUQ0RTtBQUNwRDNELFlBQUUsRUFBRXpILEtBQUssQ0FBQ3dILElBQU47QUFEZ0QsU0FBUjtBQUUxRSxPQUZrRCxDQUExQjtBQUVwQixLQXBCSTtBQXFCYjgwQyxzQkFBa0IsRUFBRSw0QkFBVWx3QyxFQUFWLEVBQWM7QUFBRSxhQUFPMHVDLG1CQUFtQixDQUFDMXVDLEVBQUQsRUFBSyxVQUFVcE0sS0FBVixFQUFpQjtBQUNsRixZQUFJNHFCLEdBQUcsR0FBR3hlLEVBQUUsQ0FBQzJpQixVQUFILENBQWMvdUIsS0FBSyxDQUFDbTBCLElBQXBCLEVBQTBCLEtBQTFCLEVBQWlDdkosR0FBakMsR0FBdUMsQ0FBakQ7QUFDQSxZQUFJMnhCLE9BQU8sR0FBR253QyxFQUFFLENBQUN1akIsVUFBSCxDQUFjO0FBQUNqaEIsY0FBSSxFQUFFLENBQVA7QUFBVWtjLGFBQUcsRUFBRUE7QUFBZixTQUFkLEVBQW1DLEtBQW5DLENBQWQ7QUFDQSxlQUFPO0FBQUNwakIsY0FBSSxFQUFFKzBDLE9BQVA7QUFBZ0I5MEMsWUFBRSxFQUFFekgsS0FBSyxDQUFDd0gsSUFBTjtBQUFwQixTQUFQO0FBQ0QsT0FKNkQsQ0FBMUI7QUFJL0IsS0F6QlE7QUEwQmJnMUMsdUJBQW1CLEVBQUUsNkJBQVVwd0MsRUFBVixFQUFjO0FBQUUsYUFBTzB1QyxtQkFBbUIsQ0FBQzF1QyxFQUFELEVBQUssVUFBVXBNLEtBQVYsRUFBaUI7QUFDbkYsWUFBSTRxQixHQUFHLEdBQUd4ZSxFQUFFLENBQUMyaUIsVUFBSCxDQUFjL3VCLEtBQUssQ0FBQ20wQixJQUFwQixFQUEwQixLQUExQixFQUFpQ3ZKLEdBQWpDLEdBQXVDLENBQWpEO0FBQ0EsWUFBSTZ4QixRQUFRLEdBQUdyd0MsRUFBRSxDQUFDdWpCLFVBQUgsQ0FBYztBQUFDamhCLGNBQUksRUFBRXRDLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NmLE9BQVgsQ0FBbUIzcEIsV0FBbkIsR0FBaUMsR0FBeEM7QUFBNkN5YyxhQUFHLEVBQUVBO0FBQWxELFNBQWQsRUFBc0UsS0FBdEUsQ0FBZjtBQUNBLGVBQU87QUFBQ3BqQixjQUFJLEVBQUV4SCxLQUFLLENBQUN3SCxJQUFOLEVBQVA7QUFBcUJDLFlBQUUsRUFBRWcxQztBQUF6QixTQUFQO0FBQ0QsT0FKOEQsQ0FBMUI7QUFJaEMsS0E5QlE7QUErQmJ4SSxRQUFJLEVBQUUsY0FBVTduQyxFQUFWLEVBQWM7QUFBRSxhQUFPQSxFQUFFLENBQUM2bkMsSUFBSCxFQUFQO0FBQW1CLEtBL0I1QjtBQWdDYkMsUUFBSSxFQUFFLGNBQVU5bkMsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDOG5DLElBQUgsRUFBUDtBQUFtQixLQWhDNUI7QUFpQ2JDLGlCQUFhLEVBQUUsdUJBQVUvbkMsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDK25DLGFBQUgsRUFBUDtBQUE0QixLQWpDOUM7QUFrQ2JDLGlCQUFhLEVBQUUsdUJBQVVob0MsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDZ29DLGFBQUgsRUFBUDtBQUE0QixLQWxDOUM7QUFtQ2JzSSxjQUFVLEVBQUUsb0JBQVV0d0MsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDdy9CLGVBQUgsQ0FBbUJ0MkIsR0FBRyxDQUFDbEosRUFBRSxDQUFDdTdCLFNBQUgsRUFBRCxFQUFpQixDQUFqQixDQUF0QixDQUFQO0FBQW9ELEtBbkNuRTtBQW9DYmdWLFlBQVEsRUFBRSxrQkFBVXZ3QyxFQUFWLEVBQWM7QUFBRSxhQUFPQSxFQUFFLENBQUN3L0IsZUFBSCxDQUFtQnQyQixHQUFHLENBQUNsSixFQUFFLENBQUM2UyxRQUFILEVBQUQsQ0FBdEIsQ0FBUDtBQUFnRCxLQXBDN0Q7QUFxQ2IyOUIsZUFBVyxFQUFFLHFCQUFVeHdDLEVBQVYsRUFBYztBQUFFLGFBQU9BLEVBQUUsQ0FBQ3NuQyxrQkFBSCxDQUFzQixVQUFVMXpDLEtBQVYsRUFBaUI7QUFBRSxlQUFPa1MsU0FBUyxDQUFDOUYsRUFBRCxFQUFLcE0sS0FBSyxDQUFDbTBCLElBQU4sQ0FBVy9vQixJQUFoQixDQUFoQjtBQUF3QyxPQUFqRixFQUNsQztBQUFDekcsY0FBTSxFQUFFLE9BQVQ7QUFBa0JzbUIsWUFBSSxFQUFFO0FBQXhCLE9BRGtDLENBQVA7QUFFekIsS0F2Q1M7QUF3Q2I0eEIsb0JBQWdCLEVBQUUsMEJBQVV6d0MsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDc25DLGtCQUFILENBQXNCLFVBQVUxekMsS0FBVixFQUFpQjtBQUFFLGVBQU84OEMsY0FBYyxDQUFDMXdDLEVBQUQsRUFBS3BNLEtBQUssQ0FBQ20wQixJQUFYLENBQXJCO0FBQXdDLE9BQWpGLEVBQ3ZDO0FBQUN4dkIsY0FBTSxFQUFFLE9BQVQ7QUFBa0JzbUIsWUFBSSxFQUFFO0FBQXhCLE9BRHVDLENBQVA7QUFFOUIsS0ExQ1M7QUEyQ2I4eEIsYUFBUyxFQUFFLG1CQUFVM3dDLEVBQVYsRUFBYztBQUFFLGFBQU9BLEVBQUUsQ0FBQ3NuQyxrQkFBSCxDQUFzQixVQUFVMXpDLEtBQVYsRUFBaUI7QUFBRSxlQUFPZzlDLE9BQU8sQ0FBQzV3QyxFQUFELEVBQUtwTSxLQUFLLENBQUNtMEIsSUFBTixDQUFXL29CLElBQWhCLENBQWQ7QUFBc0MsT0FBL0UsRUFDaEM7QUFBQ3pHLGNBQU0sRUFBRSxPQUFUO0FBQWtCc21CLFlBQUksRUFBRSxDQUFDO0FBQXpCLE9BRGdDLENBQVA7QUFFdkIsS0E3Q1M7QUE4Q2JneUIsZUFBVyxFQUFFLHFCQUFVN3dDLEVBQVYsRUFBYztBQUFFLGFBQU9BLEVBQUUsQ0FBQ3NuQyxrQkFBSCxDQUFzQixVQUFVMXpDLEtBQVYsRUFBaUI7QUFDekUsWUFBSTRxQixHQUFHLEdBQUd4ZSxFQUFFLENBQUM0aUIsWUFBSCxDQUFnQmh2QixLQUFLLENBQUNtMEIsSUFBdEIsRUFBNEIsS0FBNUIsRUFBbUN2SixHQUFuQyxHQUF5QyxDQUFuRDtBQUNBLGVBQU94ZSxFQUFFLENBQUN1akIsVUFBSCxDQUFjO0FBQUNqaEIsY0FBSSxFQUFFdEMsRUFBRSxDQUFDb00sT0FBSCxDQUFXc2YsT0FBWCxDQUFtQjNwQixXQUFuQixHQUFpQyxHQUF4QztBQUE2Q3ljLGFBQUcsRUFBRUE7QUFBbEQsU0FBZCxFQUFzRSxLQUF0RSxDQUFQO0FBQ0QsT0FIbUMsRUFHakNobUIsUUFIaUMsQ0FBUDtBQUdkLEtBakRGO0FBa0RiczRDLGNBQVUsRUFBRSxvQkFBVTl3QyxFQUFWLEVBQWM7QUFBRSxhQUFPQSxFQUFFLENBQUNzbkMsa0JBQUgsQ0FBc0IsVUFBVTF6QyxLQUFWLEVBQWlCO0FBQ3hFLFlBQUk0cUIsR0FBRyxHQUFHeGUsRUFBRSxDQUFDNGlCLFlBQUgsQ0FBZ0JodkIsS0FBSyxDQUFDbTBCLElBQXRCLEVBQTRCLEtBQTVCLEVBQW1DdkosR0FBbkMsR0FBeUMsQ0FBbkQ7QUFDQSxlQUFPeGUsRUFBRSxDQUFDdWpCLFVBQUgsQ0FBYztBQUFDamhCLGNBQUksRUFBRSxDQUFQO0FBQVVrYyxhQUFHLEVBQUVBO0FBQWYsU0FBZCxFQUFtQyxLQUFuQyxDQUFQO0FBQ0QsT0FIa0MsRUFHaENobUIsUUFIZ0MsQ0FBUDtBQUdiLEtBckRGO0FBc0RidTRDLG1CQUFlLEVBQUUseUJBQVUvd0MsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDc25DLGtCQUFILENBQXNCLFVBQVUxekMsS0FBVixFQUFpQjtBQUM3RSxZQUFJNHFCLEdBQUcsR0FBR3hlLEVBQUUsQ0FBQzRpQixZQUFILENBQWdCaHZCLEtBQUssQ0FBQ20wQixJQUF0QixFQUE0QixLQUE1QixFQUFtQ3ZKLEdBQW5DLEdBQXlDLENBQW5EO0FBQ0EsWUFBSTdsQixHQUFHLEdBQUdxSCxFQUFFLENBQUN1akIsVUFBSCxDQUFjO0FBQUNqaEIsY0FBSSxFQUFFLENBQVA7QUFBVWtjLGFBQUcsRUFBRUE7QUFBZixTQUFkLEVBQW1DLEtBQW5DLENBQVY7O0FBQ0EsWUFBSTdsQixHQUFHLENBQUN5QixFQUFKLEdBQVM0RixFQUFFLENBQUN1SCxPQUFILENBQVc1TyxHQUFHLENBQUNxRyxJQUFmLEVBQXFCL0gsTUFBckIsQ0FBNEIsSUFBNUIsQ0FBYixFQUFnRDtBQUFFLGlCQUFPeTVDLGNBQWMsQ0FBQzF3QyxFQUFELEVBQUtwTSxLQUFLLENBQUNtMEIsSUFBWCxDQUFyQjtBQUF1Qzs7QUFDekYsZUFBT3B2QixHQUFQO0FBQ0QsT0FMdUMsRUFLckNILFFBTHFDLENBQVA7QUFLbEIsS0EzREY7QUE0RGJ3NEMsWUFBUSxFQUFFLGtCQUFVaHhDLEVBQVYsRUFBYztBQUFFLGFBQU9BLEVBQUUsQ0FBQ2l4QyxLQUFILENBQVMsQ0FBQyxDQUFWLEVBQWEsTUFBYixDQUFQO0FBQThCLEtBNUQzQztBQTZEYkMsY0FBVSxFQUFFLG9CQUFVbHhDLEVBQVYsRUFBYztBQUFFLGFBQU9BLEVBQUUsQ0FBQ2l4QyxLQUFILENBQVMsQ0FBVCxFQUFZLE1BQVosQ0FBUDtBQUE2QixLQTdENUM7QUE4RGJFLFlBQVEsRUFBRSxrQkFBVW54QyxFQUFWLEVBQWM7QUFBRSxhQUFPQSxFQUFFLENBQUNpeEMsS0FBSCxDQUFTLENBQUMsQ0FBVixFQUFhLE1BQWIsQ0FBUDtBQUE4QixLQTlEM0M7QUErRGJHLGNBQVUsRUFBRSxvQkFBVXB4QyxFQUFWLEVBQWM7QUFBRSxhQUFPQSxFQUFFLENBQUNpeEMsS0FBSCxDQUFTLENBQVQsRUFBWSxNQUFaLENBQVA7QUFBNkIsS0EvRDVDO0FBZ0ViSSxjQUFVLEVBQUUsb0JBQVVyeEMsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDc3hDLEtBQUgsQ0FBUyxDQUFDLENBQVYsRUFBYSxNQUFiLENBQVA7QUFBOEIsS0FoRTdDO0FBaUViQyxlQUFXLEVBQUUscUJBQVV2eEMsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDc3hDLEtBQUgsQ0FBUyxDQUFULEVBQVksTUFBWixDQUFQO0FBQTZCLEtBakU3QztBQWtFYkUsZ0JBQVksRUFBRSxzQkFBVXh4QyxFQUFWLEVBQWM7QUFBRSxhQUFPQSxFQUFFLENBQUNzeEMsS0FBSCxDQUFTLENBQUMsQ0FBVixFQUFhLFFBQWIsQ0FBUDtBQUFnQyxLQWxFakQ7QUFtRWJHLGlCQUFhLEVBQUUsdUJBQVV6eEMsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDc3hDLEtBQUgsQ0FBUyxDQUFULEVBQVksUUFBWixDQUFQO0FBQStCLEtBbkVqRDtBQW9FYkksY0FBVSxFQUFFLG9CQUFVMXhDLEVBQVYsRUFBYztBQUFFLGFBQU9BLEVBQUUsQ0FBQ3N4QyxLQUFILENBQVMsQ0FBQyxDQUFWLEVBQWEsTUFBYixDQUFQO0FBQThCLEtBcEU3QztBQXFFYkssZ0JBQVksRUFBRSxzQkFBVTN4QyxFQUFWLEVBQWM7QUFBRSxhQUFPQSxFQUFFLENBQUNzeEMsS0FBSCxDQUFTLENBQVQsRUFBWSxPQUFaLENBQVA7QUFBOEIsS0FyRS9DO0FBc0ViTSxlQUFXLEVBQUUscUJBQVU1eEMsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDc3hDLEtBQUgsQ0FBUyxDQUFDLENBQVYsRUFBYSxPQUFiLENBQVA7QUFBK0IsS0F0RS9DO0FBdUViTyxlQUFXLEVBQUUscUJBQVU3eEMsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDc3hDLEtBQUgsQ0FBUyxDQUFULEVBQVksTUFBWixDQUFQO0FBQTZCLEtBdkU3QztBQXdFYlEsaUJBQWEsRUFBRSx1QkFBVTl4QyxFQUFWLEVBQWM7QUFBRSxhQUFPQSxFQUFFLENBQUMreEMsT0FBSCxDQUFXLENBQUMsQ0FBWixFQUFlLFdBQWYsQ0FBUDtBQUFxQyxLQXhFdkQ7QUF5RWJDLGdCQUFZLEVBQUUsc0JBQVVoeUMsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDK3hDLE9BQUgsQ0FBVyxDQUFYLEVBQWMsTUFBZCxDQUFQO0FBQStCLEtBekVoRDtBQTBFYkUsaUJBQWEsRUFBRSx1QkFBVWp5QyxFQUFWLEVBQWM7QUFBRSxhQUFPQSxFQUFFLENBQUMreEMsT0FBSCxDQUFXLENBQUMsQ0FBWixFQUFlLE1BQWYsQ0FBUDtBQUFnQyxLQTFFbEQ7QUEyRWJHLGdCQUFZLEVBQUUsc0JBQVVseUMsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDK3hDLE9BQUgsQ0FBVyxDQUFYLEVBQWMsTUFBZCxDQUFQO0FBQStCLEtBM0VoRDtBQTRFYkksa0JBQWMsRUFBRSx3QkFBVW55QyxFQUFWLEVBQWM7QUFBRSxhQUFPQSxFQUFFLENBQUMreEMsT0FBSCxDQUFXLENBQUMsQ0FBWixFQUFlLE9BQWYsQ0FBUDtBQUFpQyxLQTVFcEQ7QUE2RWJLLGlCQUFhLEVBQUUsdUJBQVVweUMsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDK3hDLE9BQUgsQ0FBVyxDQUFYLEVBQWMsT0FBZCxDQUFQO0FBQWdDLEtBN0VsRDtBQThFYk0sY0FBVSxFQUFFLG9CQUFVcnlDLEVBQVYsRUFBYztBQUFFLGFBQU9BLEVBQUUsQ0FBQ3N5QyxlQUFILENBQW1CLE9BQW5CLENBQVA7QUFBcUMsS0E5RXBEO0FBK0ViQyxjQUFVLEVBQUUsb0JBQVV2eUMsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDc3lDLGVBQUgsQ0FBbUIsS0FBbkIsQ0FBUDtBQUFtQyxLQS9FbEQ7QUFnRmJFLGNBQVUsRUFBRSxvQkFBVXh5QyxFQUFWLEVBQWM7QUFBRSxhQUFPQSxFQUFFLENBQUNzeUMsZUFBSCxDQUFtQixVQUFuQixDQUFQO0FBQXdDLEtBaEZ2RDtBQWlGYkcsYUFBUyxFQUFFLG1CQUFVenlDLEVBQVYsRUFBYztBQUFFLGFBQU9BLEVBQUUsQ0FBQzBuQyxnQkFBSCxDQUFvQixJQUFwQixDQUFQO0FBQW1DLEtBakZqRDtBQWtGYmdMLGlCQUFhLEVBQUUsdUJBQVUxeUMsRUFBVixFQUFjO0FBQzNCLFVBQUkyeUMsTUFBTSxHQUFHLEVBQWI7QUFBQSxVQUFpQmpyQixNQUFNLEdBQUcxbkIsRUFBRSxDQUFDb25DLGNBQUgsRUFBMUI7QUFBQSxVQUErQ3R3QyxPQUFPLEdBQUdrSixFQUFFLENBQUN1RSxPQUFILENBQVd6TixPQUFwRTs7QUFDQSxXQUFLLElBQUlyRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaTBCLE1BQU0sQ0FBQ2wxQixNQUEzQixFQUFtQ2lCLENBQUMsRUFBcEMsRUFBd0M7QUFDdEMsWUFBSWtGLEdBQUcsR0FBRyt1QixNQUFNLENBQUNqMEIsQ0FBRCxDQUFOLENBQVUySCxJQUFWLEVBQVY7QUFDQSxZQUFJeEMsR0FBRyxHQUFHaEMsV0FBVyxDQUFDb0osRUFBRSxDQUFDdUgsT0FBSCxDQUFXNU8sR0FBRyxDQUFDcUcsSUFBZixDQUFELEVBQXVCckcsR0FBRyxDQUFDeUIsRUFBM0IsRUFBK0J0RCxPQUEvQixDQUFyQjtBQUNBNjdDLGNBQU0sQ0FBQ3o1QyxJQUFQLENBQVlELFFBQVEsQ0FBQ25DLE9BQU8sR0FBRzhCLEdBQUcsR0FBRzlCLE9BQWpCLENBQXBCO0FBQ0Q7O0FBQ0RrSixRQUFFLENBQUM0bkMsaUJBQUgsQ0FBcUIrSyxNQUFyQjtBQUNELEtBMUZZO0FBMkZiQyxjQUFVLEVBQUUsb0JBQVU1eUMsRUFBVixFQUFjO0FBQ3hCLFVBQUlBLEVBQUUsQ0FBQys1QixpQkFBSCxFQUFKLEVBQTRCO0FBQUUvNUIsVUFBRSxDQUFDc3lDLGVBQUgsQ0FBbUIsS0FBbkI7QUFBNEIsT0FBMUQsTUFDSztBQUFFdHlDLFVBQUUsQ0FBQzZ5QyxXQUFILENBQWUsV0FBZjtBQUE4QjtBQUN0QyxLQTlGWTtBQStGYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBQyxrQkFBYyxFQUFFLHdCQUFVOXlDLEVBQVYsRUFBYztBQUFFLGFBQU84ekIsT0FBTyxDQUFDOXpCLEVBQUQsRUFBSyxZQUFZO0FBQzdELFlBQUkwbkIsTUFBTSxHQUFHMW5CLEVBQUUsQ0FBQ29uQyxjQUFILEVBQWI7QUFBQSxZQUFrQ3hILE1BQU0sR0FBRyxFQUEzQzs7QUFDQSxhQUFLLElBQUluc0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2kwQixNQUFNLENBQUNsMUIsTUFBM0IsRUFBbUNpQixDQUFDLEVBQXBDLEVBQXdDO0FBQ3RDLGNBQUksQ0FBQ2kwQixNQUFNLENBQUNqMEIsQ0FBRCxDQUFOLENBQVVtMEIsS0FBVixFQUFMLEVBQXdCO0FBQUU7QUFBVTs7QUFDcEMsY0FBSXpyQixHQUFHLEdBQUd1ckIsTUFBTSxDQUFDajBCLENBQUQsQ0FBTixDQUFVczBCLElBQXBCO0FBQUEsY0FBMEIvb0IsSUFBSSxHQUFHdUksT0FBTyxDQUFDdkgsRUFBRSxDQUFDd0gsR0FBSixFQUFTckwsR0FBRyxDQUFDNkMsSUFBYixDQUFQLENBQTBCQyxJQUEzRDs7QUFDQSxjQUFJRCxJQUFKLEVBQVU7QUFDUixnQkFBSTdDLEdBQUcsQ0FBQy9CLEVBQUosSUFBVTRFLElBQUksQ0FBQ3hNLE1BQW5CLEVBQTJCO0FBQUUySixpQkFBRyxHQUFHLElBQUkrTSxHQUFKLENBQVEvTSxHQUFHLENBQUM2QyxJQUFaLEVBQWtCN0MsR0FBRyxDQUFDL0IsRUFBSixHQUFTLENBQTNCLENBQU47QUFBc0M7O0FBQ25FLGdCQUFJK0IsR0FBRyxDQUFDL0IsRUFBSixHQUFTLENBQWIsRUFBZ0I7QUFDZCtCLGlCQUFHLEdBQUcsSUFBSStNLEdBQUosQ0FBUS9NLEdBQUcsQ0FBQzZDLElBQVosRUFBa0I3QyxHQUFHLENBQUMvQixFQUFKLEdBQVMsQ0FBM0IsQ0FBTjtBQUNBNEYsZ0JBQUUsQ0FBQytpQyxZQUFILENBQWdCL2pDLElBQUksQ0FBQy9ELE1BQUwsQ0FBWWtCLEdBQUcsQ0FBQy9CLEVBQUosR0FBUyxDQUFyQixJQUEwQjRFLElBQUksQ0FBQy9ELE1BQUwsQ0FBWWtCLEdBQUcsQ0FBQy9CLEVBQUosR0FBUyxDQUFyQixDQUExQyxFQUNnQjhPLEdBQUcsQ0FBQy9NLEdBQUcsQ0FBQzZDLElBQUwsRUFBVzdDLEdBQUcsQ0FBQy9CLEVBQUosR0FBUyxDQUFwQixDQURuQixFQUMyQytCLEdBRDNDLEVBQ2dELFlBRGhEO0FBRUQsYUFKRCxNQUlPLElBQUlBLEdBQUcsQ0FBQzZDLElBQUosR0FBV2dCLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT0MsS0FBdEIsRUFBNkI7QUFDbEMsa0JBQUlySyxJQUFJLEdBQUdtSyxPQUFPLENBQUN2SCxFQUFFLENBQUN3SCxHQUFKLEVBQVNyTCxHQUFHLENBQUM2QyxJQUFKLEdBQVcsQ0FBcEIsQ0FBUCxDQUE4QkMsSUFBekM7O0FBQ0Esa0JBQUk3QixJQUFKLEVBQVU7QUFDUmpCLG1CQUFHLEdBQUcsSUFBSStNLEdBQUosQ0FBUS9NLEdBQUcsQ0FBQzZDLElBQVosRUFBa0IsQ0FBbEIsQ0FBTjtBQUNBZ0Isa0JBQUUsQ0FBQytpQyxZQUFILENBQWdCL2pDLElBQUksQ0FBQy9ELE1BQUwsQ0FBWSxDQUFaLElBQWlCK0UsRUFBRSxDQUFDd0gsR0FBSCxDQUFPcS9CLGFBQVAsRUFBakIsR0FDQXpwQyxJQUFJLENBQUNuQyxNQUFMLENBQVltQyxJQUFJLENBQUM1SyxNQUFMLEdBQWMsQ0FBMUIsQ0FEaEIsRUFFZ0IwVyxHQUFHLENBQUMvTSxHQUFHLENBQUM2QyxJQUFKLEdBQVcsQ0FBWixFQUFlNUIsSUFBSSxDQUFDNUssTUFBTCxHQUFjLENBQTdCLENBRm5CLEVBRW9EMkosR0FGcEQsRUFFeUQsWUFGekQ7QUFHRDtBQUNGO0FBQ0Y7O0FBQ0R5akMsZ0JBQU0sQ0FBQzFtQyxJQUFQLENBQVksSUFBSTRnQyxLQUFKLENBQVUzOUIsR0FBVixFQUFlQSxHQUFmLENBQVo7QUFDRDs7QUFDRDZELFVBQUUsQ0FBQ3VuQyxhQUFILENBQWlCM0gsTUFBakI7QUFDRCxPQXhCNkMsQ0FBZDtBQXdCM0IsS0E5SFE7QUErSGJtVCxvQkFBZ0IsRUFBRSwwQkFBVS95QyxFQUFWLEVBQWM7QUFBRSxhQUFPOHpCLE9BQU8sQ0FBQzl6QixFQUFELEVBQUssWUFBWTtBQUMvRCxZQUFJZ3pDLElBQUksR0FBR2h6QyxFQUFFLENBQUNvbkMsY0FBSCxFQUFYOztBQUNBLGFBQUssSUFBSTN6QyxDQUFDLEdBQUd1L0MsSUFBSSxDQUFDeGdELE1BQUwsR0FBYyxDQUEzQixFQUE4QmlCLENBQUMsSUFBSSxDQUFuQyxFQUFzQ0EsQ0FBQyxFQUF2QyxFQUNFO0FBQUV1TSxZQUFFLENBQUMraUMsWUFBSCxDQUFnQi9pQyxFQUFFLENBQUN3SCxHQUFILENBQU9xL0IsYUFBUCxFQUFoQixFQUF3Q21NLElBQUksQ0FBQ3YvQyxDQUFELENBQUosQ0FBUXV4QixNQUFoRCxFQUF3RGd1QixJQUFJLENBQUN2L0MsQ0FBRCxDQUFKLENBQVFzMEIsSUFBaEUsRUFBc0UsUUFBdEU7QUFBa0Y7O0FBQ3RGaXJCLFlBQUksR0FBR2h6QyxFQUFFLENBQUNvbkMsY0FBSCxFQUFQOztBQUNBLGFBQUssSUFBSWpxQyxHQUFHLEdBQUcsQ0FBZixFQUFrQkEsR0FBRyxHQUFHNjFDLElBQUksQ0FBQ3hnRCxNQUE3QixFQUFxQzJLLEdBQUcsRUFBeEMsRUFDRTtBQUFFNkMsWUFBRSxDQUFDaXpDLFVBQUgsQ0FBY0QsSUFBSSxDQUFDNzFDLEdBQUQsQ0FBSixDQUFVL0IsSUFBVixHQUFpQjRELElBQS9CLEVBQXFDLElBQXJDLEVBQTJDLElBQTNDO0FBQW1EOztBQUN2RCt1QiwyQkFBbUIsQ0FBQy90QixFQUFELENBQW5CO0FBQ0QsT0FSK0MsQ0FBZDtBQVE3QixLQXZJUTtBQXdJYmt6QyxZQUFRLEVBQUUsa0JBQVVsekMsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDMG5DLGdCQUFILENBQW9CLElBQXBCLEVBQTBCLE9BQTFCLENBQVA7QUFBNEMsS0F4SXpEO0FBeUlieUwsbUJBQWUsRUFBRSx5QkFBVW56QyxFQUFWLEVBQWM7QUFBRSxhQUFPQSxFQUFFLENBQUNtekMsZUFBSCxFQUFQO0FBQThCO0FBeklsRCxHQUFmOztBQTZJQSxXQUFTcnRDLFNBQVQsQ0FBbUI5RixFQUFuQixFQUF1QjBTLEtBQXZCLEVBQThCO0FBQzVCLFFBQUkxVCxJQUFJLEdBQUd1SSxPQUFPLENBQUN2SCxFQUFFLENBQUN3SCxHQUFKLEVBQVNrTCxLQUFULENBQWxCO0FBQ0EsUUFBSXd5QixNQUFNLEdBQUc3eUIsVUFBVSxDQUFDclQsSUFBRCxDQUF2Qjs7QUFDQSxRQUFJa21DLE1BQU0sSUFBSWxtQyxJQUFkLEVBQW9CO0FBQUUwVCxXQUFLLEdBQUduSyxNQUFNLENBQUMyOEIsTUFBRCxDQUFkO0FBQXlCOztBQUMvQyxXQUFPK0osU0FBUyxDQUFDLElBQUQsRUFBT2p2QyxFQUFQLEVBQVdrbEMsTUFBWCxFQUFtQnh5QixLQUFuQixFQUEwQixDQUExQixDQUFoQjtBQUNEOztBQUNELFdBQVNrK0IsT0FBVCxDQUFpQjV3QyxFQUFqQixFQUFxQjBTLEtBQXJCLEVBQTRCO0FBQzFCLFFBQUkxVCxJQUFJLEdBQUd1SSxPQUFPLENBQUN2SCxFQUFFLENBQUN3SCxHQUFKLEVBQVNrTCxLQUFULENBQWxCO0FBQ0EsUUFBSXd5QixNQUFNLEdBQUczeUIsYUFBYSxDQUFDdlQsSUFBRCxDQUExQjs7QUFDQSxRQUFJa21DLE1BQU0sSUFBSWxtQyxJQUFkLEVBQW9CO0FBQUUwVCxXQUFLLEdBQUduSyxNQUFNLENBQUMyOEIsTUFBRCxDQUFkO0FBQXlCOztBQUMvQyxXQUFPK0osU0FBUyxDQUFDLElBQUQsRUFBT2p2QyxFQUFQLEVBQVdoQixJQUFYLEVBQWlCMFQsS0FBakIsRUFBd0IsQ0FBQyxDQUF6QixDQUFoQjtBQUNEOztBQUNELFdBQVNnK0IsY0FBVCxDQUF3QjF3QyxFQUF4QixFQUE0QnJILEdBQTVCLEVBQWlDO0FBQy9CLFFBQUk3RSxLQUFLLEdBQUdnUyxTQUFTLENBQUM5RixFQUFELEVBQUtySCxHQUFHLENBQUNxRyxJQUFULENBQXJCO0FBQ0EsUUFBSUEsSUFBSSxHQUFHdUksT0FBTyxDQUFDdkgsRUFBRSxDQUFDd0gsR0FBSixFQUFTMVQsS0FBSyxDQUFDa0wsSUFBZixDQUFsQjtBQUNBLFFBQUlyRCxLQUFLLEdBQUdvRCxRQUFRLENBQUNDLElBQUQsRUFBT2dCLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT3pLLFNBQWQsQ0FBcEI7O0FBQ0EsUUFBSSxDQUFDcEIsS0FBRCxJQUFVQSxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNJLEtBQVQsSUFBa0IsQ0FBaEMsRUFBbUM7QUFDakMsVUFBSXEzQyxVQUFVLEdBQUd0NkMsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTaEksS0FBSyxDQUFDc0csRUFBZixFQUFtQjRFLElBQUksQ0FBQ0MsSUFBTCxDQUFVaEksTUFBVixDQUFpQixJQUFqQixDQUFuQixDQUFqQjtBQUNBLFVBQUlvOEMsSUFBSSxHQUFHMTZDLEdBQUcsQ0FBQ3FHLElBQUosSUFBWWxMLEtBQUssQ0FBQ2tMLElBQWxCLElBQTBCckcsR0FBRyxDQUFDeUIsRUFBSixJQUFVZzVDLFVBQXBDLElBQWtEejZDLEdBQUcsQ0FBQ3lCLEVBQWpFO0FBQ0EsYUFBTzhPLEdBQUcsQ0FBQ3BWLEtBQUssQ0FBQ2tMLElBQVAsRUFBYXEwQyxJQUFJLEdBQUcsQ0FBSCxHQUFPRCxVQUF4QixFQUFvQ3QvQyxLQUFLLENBQUNvSSxNQUExQyxDQUFWO0FBQ0Q7O0FBQ0QsV0FBT3BJLEtBQVA7QUFDRCxHQWg3TmtCLENBazdObkI7OztBQUNBLFdBQVN3L0MsZUFBVCxDQUF5QnR6QyxFQUF6QixFQUE2QnV6QyxLQUE3QixFQUFvQ0MsU0FBcEMsRUFBK0M7QUFDN0MsUUFBSSxPQUFPRCxLQUFQLElBQWdCLFFBQXBCLEVBQThCO0FBQzVCQSxXQUFLLEdBQUcxRCxRQUFRLENBQUMwRCxLQUFELENBQWhCOztBQUNBLFVBQUksQ0FBQ0EsS0FBTCxFQUFZO0FBQUUsZUFBTyxLQUFQO0FBQWM7QUFDN0IsS0FKNEMsQ0FLN0M7QUFDQTs7O0FBQ0F2ekMsTUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQis4QixZQUFqQjtBQUNBLFFBQUlDLFNBQVMsR0FBRzF6QyxFQUFFLENBQUNvTSxPQUFILENBQVdtZixLQUEzQjtBQUFBLFFBQWtDc1IsSUFBSSxHQUFHLEtBQXpDOztBQUNBLFFBQUk7QUFDRixVQUFJNzhCLEVBQUUsQ0FBQzBxQyxVQUFILEVBQUosRUFBcUI7QUFBRTFxQyxVQUFFLENBQUNrRixLQUFILENBQVN5OEIsYUFBVCxHQUF5QixJQUF6QjtBQUFnQzs7QUFDdkQsVUFBSTZSLFNBQUosRUFBZTtBQUFFeHpDLFVBQUUsQ0FBQ29NLE9BQUgsQ0FBV21mLEtBQVgsR0FBbUIsS0FBbkI7QUFBMkI7O0FBQzVDc1IsVUFBSSxHQUFHMFcsS0FBSyxDQUFDdnpDLEVBQUQsQ0FBTCxJQUFhOUgsSUFBcEI7QUFDRCxLQUpELFNBSVU7QUFDUjhILFFBQUUsQ0FBQ29NLE9BQUgsQ0FBV21mLEtBQVgsR0FBbUJtb0IsU0FBbkI7QUFDQTF6QyxRQUFFLENBQUNrRixLQUFILENBQVN5OEIsYUFBVCxHQUF5QixLQUF6QjtBQUNEOztBQUNELFdBQU85RSxJQUFQO0FBQ0Q7O0FBRUQsV0FBUzhXLGtCQUFULENBQTRCM3pDLEVBQTVCLEVBQWdDK0QsSUFBaEMsRUFBc0N3L0IsTUFBdEMsRUFBOEM7QUFDNUMsU0FBSyxJQUFJOXZDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1TSxFQUFFLENBQUNrRixLQUFILENBQVMwdUMsT0FBVCxDQUFpQnBoRCxNQUFyQyxFQUE2Q2lCLENBQUMsRUFBOUMsRUFBa0Q7QUFDaEQsVUFBSWdQLE1BQU0sR0FBR3FyQyxTQUFTLENBQUMvcEMsSUFBRCxFQUFPL0QsRUFBRSxDQUFDa0YsS0FBSCxDQUFTMHVDLE9BQVQsQ0FBaUJuZ0QsQ0FBakIsQ0FBUCxFQUE0Qjh2QyxNQUE1QixFQUFvQ3ZqQyxFQUFwQyxDQUF0Qjs7QUFDQSxVQUFJeUMsTUFBSixFQUFZO0FBQUUsZUFBT0EsTUFBUDtBQUFlO0FBQzlCOztBQUNELFdBQVF6QyxFQUFFLENBQUN1RSxPQUFILENBQVdzdkMsU0FBWCxJQUF3Qi9GLFNBQVMsQ0FBQy9wQyxJQUFELEVBQU8vRCxFQUFFLENBQUN1RSxPQUFILENBQVdzdkMsU0FBbEIsRUFBNkJ0USxNQUE3QixFQUFxQ3ZqQyxFQUFyQyxDQUFsQyxJQUNGOHRDLFNBQVMsQ0FBQy9wQyxJQUFELEVBQU8vRCxFQUFFLENBQUN1RSxPQUFILENBQVd5b0MsTUFBbEIsRUFBMEJ6SixNQUExQixFQUFrQ3ZqQyxFQUFsQyxDQURkO0FBRUQsR0E5OE5rQixDQWc5Tm5CO0FBQ0E7OztBQUVBLE1BQUk4ekMsT0FBTyxHQUFHLElBQUl6OEMsT0FBSixFQUFkOztBQUVBLFdBQVMwOEMsV0FBVCxDQUFxQi96QyxFQUFyQixFQUF5QitELElBQXpCLEVBQStCclIsQ0FBL0IsRUFBa0M2d0MsTUFBbEMsRUFBMEM7QUFDeEMsUUFBSXlRLEdBQUcsR0FBR2gwQyxFQUFFLENBQUNrRixLQUFILENBQVMrdUMsTUFBbkI7O0FBQ0EsUUFBSUQsR0FBSixFQUFTO0FBQ1AsVUFBSS9GLGFBQWEsQ0FBQ2xxQyxJQUFELENBQWpCLEVBQXlCO0FBQUUsZUFBTyxTQUFQO0FBQWtCOztBQUM3QyxVQUFJLE1BQU05VCxJQUFOLENBQVc4VCxJQUFYLENBQUosRUFDRTtBQUFFL0QsVUFBRSxDQUFDa0YsS0FBSCxDQUFTK3VDLE1BQVQsR0FBa0IsSUFBbEI7QUFBeUIsT0FEN0IsTUFHRTtBQUFFSCxlQUFPLENBQUNqOEMsR0FBUixDQUFZLEVBQVosRUFBZ0IsWUFBWTtBQUM1QixjQUFJbUksRUFBRSxDQUFDa0YsS0FBSCxDQUFTK3VDLE1BQVQsSUFBbUJELEdBQXZCLEVBQTRCO0FBQzFCaDBDLGNBQUUsQ0FBQ2tGLEtBQUgsQ0FBUyt1QyxNQUFULEdBQWtCLElBQWxCO0FBQ0FqMEMsY0FBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQjJVLEtBQWpCO0FBQ0Q7QUFDRixTQUxDO0FBS0c7O0FBQ1AsVUFBSTZvQixnQkFBZ0IsQ0FBQ2wwQyxFQUFELEVBQUtnMEMsR0FBRyxHQUFHLEdBQU4sR0FBWWp3QyxJQUFqQixFQUF1QnJSLENBQXZCLEVBQTBCNndDLE1BQTFCLENBQXBCLEVBQXVEO0FBQUUsZUFBTyxJQUFQO0FBQWE7QUFDdkU7O0FBQ0QsV0FBTzJRLGdCQUFnQixDQUFDbDBDLEVBQUQsRUFBSytELElBQUwsRUFBV3JSLENBQVgsRUFBYzZ3QyxNQUFkLENBQXZCO0FBQ0Q7O0FBRUQsV0FBUzJRLGdCQUFULENBQTBCbDBDLEVBQTFCLEVBQThCK0QsSUFBOUIsRUFBb0NyUixDQUFwQyxFQUF1QzZ3QyxNQUF2QyxFQUErQztBQUM3QyxRQUFJOWdDLE1BQU0sR0FBR2t4QyxrQkFBa0IsQ0FBQzN6QyxFQUFELEVBQUsrRCxJQUFMLEVBQVd3L0IsTUFBWCxDQUEvQjs7QUFFQSxRQUFJOWdDLE1BQU0sSUFBSSxPQUFkLEVBQ0U7QUFBRXpDLFFBQUUsQ0FBQ2tGLEtBQUgsQ0FBUyt1QyxNQUFULEdBQWtCbHdDLElBQWxCO0FBQXlCOztBQUM3QixRQUFJdEIsTUFBTSxJQUFJLFNBQWQsRUFDRTtBQUFFZ1csaUJBQVcsQ0FBQ3pZLEVBQUQsRUFBSyxZQUFMLEVBQW1CQSxFQUFuQixFQUF1QitELElBQXZCLEVBQTZCclIsQ0FBN0IsQ0FBWDtBQUE2Qzs7QUFFakQsUUFBSStQLE1BQU0sSUFBSSxTQUFWLElBQXVCQSxNQUFNLElBQUksT0FBckMsRUFBOEM7QUFDNUM1QixzQkFBZ0IsQ0FBQ25PLENBQUQsQ0FBaEI7QUFDQTAzQixrQkFBWSxDQUFDcHFCLEVBQUQsQ0FBWjtBQUNEOztBQUVELFdBQU8sQ0FBQyxDQUFDeUMsTUFBVDtBQUNELEdBci9Oa0IsQ0F1L05uQjs7O0FBQ0EsV0FBUzB4QyxnQkFBVCxDQUEwQm4wQyxFQUExQixFQUE4QnROLENBQTlCLEVBQWlDO0FBQy9CLFFBQUlxUixJQUFJLEdBQUd5cUMsT0FBTyxDQUFDOTdDLENBQUQsRUFBSSxJQUFKLENBQWxCOztBQUNBLFFBQUksQ0FBQ3FSLElBQUwsRUFBVztBQUFFLGFBQU8sS0FBUDtBQUFjOztBQUUzQixRQUFJclIsQ0FBQyxDQUFDNjdDLFFBQUYsSUFBYyxDQUFDdnVDLEVBQUUsQ0FBQ2tGLEtBQUgsQ0FBUyt1QyxNQUE1QixFQUFvQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxhQUFPRixXQUFXLENBQUMvekMsRUFBRCxFQUFLLFdBQVcrRCxJQUFoQixFQUFzQnJSLENBQXRCLEVBQXlCLFVBQVUyQyxDQUFWLEVBQWE7QUFBRSxlQUFPaStDLGVBQWUsQ0FBQ3R6QyxFQUFELEVBQUszSyxDQUFMLEVBQVEsSUFBUixDQUF0QjtBQUFzQyxPQUE5RSxDQUFYLElBQ0EwK0MsV0FBVyxDQUFDL3pDLEVBQUQsRUFBSytELElBQUwsRUFBV3JSLENBQVgsRUFBYyxVQUFVMkMsQ0FBVixFQUFhO0FBQ3BDLFlBQUksT0FBT0EsQ0FBUCxJQUFZLFFBQVosR0FBdUIsV0FBV3BGLElBQVgsQ0FBZ0JvRixDQUFoQixDQUF2QixHQUE0Q0EsQ0FBQyxDQUFDKytDLE1BQWxELEVBQ0U7QUFBRSxpQkFBT2QsZUFBZSxDQUFDdHpDLEVBQUQsRUFBSzNLLENBQUwsQ0FBdEI7QUFBK0I7QUFDcEMsT0FIVSxDQURsQjtBQUtELEtBVEQsTUFTTztBQUNMLGFBQU8wK0MsV0FBVyxDQUFDL3pDLEVBQUQsRUFBSytELElBQUwsRUFBV3JSLENBQVgsRUFBYyxVQUFVMkMsQ0FBVixFQUFhO0FBQUUsZUFBT2krQyxlQUFlLENBQUN0ekMsRUFBRCxFQUFLM0ssQ0FBTCxDQUF0QjtBQUFnQyxPQUE3RCxDQUFsQjtBQUNEO0FBQ0YsR0F4Z09rQixDQTBnT25COzs7QUFDQSxXQUFTZy9DLGlCQUFULENBQTJCcjBDLEVBQTNCLEVBQStCdE4sQ0FBL0IsRUFBa0MwSCxFQUFsQyxFQUFzQztBQUNwQyxXQUFPMjVDLFdBQVcsQ0FBQy96QyxFQUFELEVBQUssTUFBTTVGLEVBQU4sR0FBVyxHQUFoQixFQUFxQjFILENBQXJCLEVBQXdCLFVBQVUyQyxDQUFWLEVBQWE7QUFBRSxhQUFPaStDLGVBQWUsQ0FBQ3R6QyxFQUFELEVBQUszSyxDQUFMLEVBQVEsSUFBUixDQUF0QjtBQUFzQyxLQUE3RSxDQUFsQjtBQUNEOztBQUVELE1BQUlpL0MsY0FBYyxHQUFHLElBQXJCOztBQUNBLFdBQVNDLFNBQVQsQ0FBbUI3aEQsQ0FBbkIsRUFBc0I7QUFDcEIsUUFBSXNOLEVBQUUsR0FBRyxJQUFUOztBQUNBLFFBQUl0TixDQUFDLENBQUM4RCxNQUFGLElBQVk5RCxDQUFDLENBQUM4RCxNQUFGLElBQVl3SixFQUFFLENBQUNvTSxPQUFILENBQVdzSyxLQUFYLENBQWlCODlCLFFBQWpCLEVBQTVCLEVBQXlEO0FBQUU7QUFBUTs7QUFDbkV4MEMsTUFBRSxDQUFDUSxLQUFILENBQVN1cUIsS0FBVCxHQUFpQmgyQixTQUFTLEVBQTFCOztBQUNBLFFBQUlnTCxjQUFjLENBQUNDLEVBQUQsRUFBS3ROLENBQUwsQ0FBbEIsRUFBMkI7QUFBRTtBQUFRLEtBSmpCLENBS3BCOzs7QUFDQSxRQUFJcEMsRUFBRSxJQUFJQyxVQUFVLEdBQUcsRUFBbkIsSUFBeUJtQyxDQUFDLENBQUN3N0MsT0FBRixJQUFhLEVBQTFDLEVBQThDO0FBQUV4N0MsT0FBQyxDQUFDb08sV0FBRixHQUFnQixLQUFoQjtBQUF3Qjs7QUFDeEUsUUFBSXRFLElBQUksR0FBRzlKLENBQUMsQ0FBQ3c3QyxPQUFiO0FBQ0FsdUMsTUFBRSxDQUFDb00sT0FBSCxDQUFXbWYsS0FBWCxHQUFtQi91QixJQUFJLElBQUksRUFBUixJQUFjOUosQ0FBQyxDQUFDNjdDLFFBQW5DO0FBQ0EsUUFBSWtHLE9BQU8sR0FBR04sZ0JBQWdCLENBQUNuMEMsRUFBRCxFQUFLdE4sQ0FBTCxDQUE5Qjs7QUFDQSxRQUFJN0IsTUFBSixFQUFZO0FBQ1Z5akQsb0JBQWMsR0FBR0csT0FBTyxHQUFHajRDLElBQUgsR0FBVSxJQUFsQyxDQURVLENBRVY7O0FBQ0EsVUFBSSxDQUFDaTRDLE9BQUQsSUFBWWo0QyxJQUFJLElBQUksRUFBcEIsSUFBMEIsQ0FBQzZHLFlBQTNCLEtBQTRDL1IsR0FBRyxHQUFHb0IsQ0FBQyxDQUFDNDdDLE9BQUwsR0FBZTU3QyxDQUFDLENBQUM4TyxPQUFoRSxDQUFKLEVBQ0U7QUFBRXhCLFVBQUUsQ0FBQzBuQyxnQkFBSCxDQUFvQixFQUFwQixFQUF3QixJQUF4QixFQUE4QixLQUE5QjtBQUF1QztBQUM1Qzs7QUFDRCxRQUFJMTNDLEtBQUssSUFBSSxDQUFDc0IsR0FBVixJQUFpQixDQUFDbWpELE9BQWxCLElBQTZCajRDLElBQUksSUFBSSxFQUFyQyxJQUEyQzlKLENBQUMsQ0FBQzY3QyxRQUE3QyxJQUF5RCxDQUFDNzdDLENBQUMsQ0FBQzhPLE9BQTVELElBQXVFaFIsUUFBUSxDQUFDcWlELFdBQXBGLEVBQ0U7QUFBRXJpRCxjQUFRLENBQUNxaUQsV0FBVCxDQUFxQixLQUFyQjtBQUE4QixLQWpCZCxDQW1CcEI7OztBQUNBLFFBQUlyMkMsSUFBSSxJQUFJLEVBQVIsSUFBYyxDQUFDLDJCQUEyQnZNLElBQTNCLENBQWdDK1AsRUFBRSxDQUFDb00sT0FBSCxDQUFXc2YsT0FBWCxDQUFtQnQ1QixTQUFuRCxDQUFuQixFQUNFO0FBQUVzaUQsbUJBQWEsQ0FBQzEwQyxFQUFELENBQWI7QUFBb0I7QUFDekI7O0FBRUQsV0FBUzAwQyxhQUFULENBQXVCMTBDLEVBQXZCLEVBQTJCO0FBQ3pCLFFBQUkwckIsT0FBTyxHQUFHMXJCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NmLE9BQXpCO0FBQ0F4MkIsWUFBUSxDQUFDdzJCLE9BQUQsRUFBVSxzQkFBVixDQUFSOztBQUVBLGFBQVNpcEIsRUFBVCxDQUFZamlELENBQVosRUFBZTtBQUNiLFVBQUlBLENBQUMsQ0FBQ3c3QyxPQUFGLElBQWEsRUFBYixJQUFtQixDQUFDeDdDLENBQUMsQ0FBQzI3QyxNQUExQixFQUFrQztBQUNoQ3A4QyxlQUFPLENBQUN5NUIsT0FBRCxFQUFVLHNCQUFWLENBQVA7QUFDQWhzQixXQUFHLENBQUNsUCxRQUFELEVBQVcsT0FBWCxFQUFvQm1rRCxFQUFwQixDQUFIO0FBQ0FqMUMsV0FBRyxDQUFDbFAsUUFBRCxFQUFXLFdBQVgsRUFBd0Jta0QsRUFBeEIsQ0FBSDtBQUNEO0FBQ0Y7O0FBQ0R4MUMsTUFBRSxDQUFDM08sUUFBRCxFQUFXLE9BQVgsRUFBb0Jta0QsRUFBcEIsQ0FBRjtBQUNBeDFDLE1BQUUsQ0FBQzNPLFFBQUQsRUFBVyxXQUFYLEVBQXdCbWtELEVBQXhCLENBQUY7QUFDRDs7QUFFRCxXQUFTQyxPQUFULENBQWlCbGlELENBQWpCLEVBQW9CO0FBQ2xCLFFBQUlBLENBQUMsQ0FBQ3c3QyxPQUFGLElBQWEsRUFBakIsRUFBcUI7QUFBRSxXQUFLMW1DLEdBQUwsQ0FBU2lnQixHQUFULENBQWE4RCxLQUFiLEdBQXFCLEtBQXJCO0FBQTZCOztBQUNwRHhyQixrQkFBYyxDQUFDLElBQUQsRUFBT3JOLENBQVAsQ0FBZDtBQUNEOztBQUVELFdBQVNtaUQsVUFBVCxDQUFvQm5pRCxDQUFwQixFQUF1QjtBQUNyQixRQUFJc04sRUFBRSxHQUFHLElBQVQ7O0FBQ0EsUUFBSXROLENBQUMsQ0FBQzhELE1BQUYsSUFBWTlELENBQUMsQ0FBQzhELE1BQUYsSUFBWXdKLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NLLEtBQVgsQ0FBaUI4OUIsUUFBakIsRUFBNUIsRUFBeUQ7QUFBRTtBQUFROztBQUNuRSxRQUFJajRCLGFBQWEsQ0FBQ3ZjLEVBQUUsQ0FBQ29NLE9BQUosRUFBYTFaLENBQWIsQ0FBYixJQUFnQ3FOLGNBQWMsQ0FBQ0MsRUFBRCxFQUFLdE4sQ0FBTCxDQUE5QyxJQUF5REEsQ0FBQyxDQUFDOE8sT0FBRixJQUFhLENBQUM5TyxDQUFDLENBQUMyN0MsTUFBekUsSUFBbUYvOEMsR0FBRyxJQUFJb0IsQ0FBQyxDQUFDNDdDLE9BQWhHLEVBQXlHO0FBQUU7QUFBUTs7QUFDbkgsUUFBSUosT0FBTyxHQUFHeDdDLENBQUMsQ0FBQ3c3QyxPQUFoQjtBQUFBLFFBQXlCNEcsUUFBUSxHQUFHcGlELENBQUMsQ0FBQ29pRCxRQUF0Qzs7QUFDQSxRQUFJamtELE1BQU0sSUFBSXE5QyxPQUFPLElBQUlvRyxjQUF6QixFQUF5QztBQUFDQSxvQkFBYyxHQUFHLElBQWpCO0FBQXVCenpDLHNCQUFnQixDQUFDbk8sQ0FBRCxDQUFoQjtBQUFxQjtBQUFPOztBQUM3RixRQUFLN0IsTUFBTSxLQUFLLENBQUM2QixDQUFDLENBQUM0TyxLQUFILElBQVk1TyxDQUFDLENBQUM0TyxLQUFGLEdBQVUsRUFBM0IsQ0FBUCxJQUEwQzZ5QyxnQkFBZ0IsQ0FBQ24wQyxFQUFELEVBQUt0TixDQUFMLENBQTlELEVBQXVFO0FBQUU7QUFBUTs7QUFDakYsUUFBSTBILEVBQUUsR0FBRzJPLE1BQU0sQ0FBQ2drQyxZQUFQLENBQW9CK0gsUUFBUSxJQUFJLElBQVosR0FBbUI1RyxPQUFuQixHQUE2QjRHLFFBQWpELENBQVQsQ0FQcUIsQ0FRckI7O0FBQ0EsUUFBSTE2QyxFQUFFLElBQUksTUFBVixFQUFrQjtBQUFFO0FBQVE7O0FBQzVCLFFBQUlpNkMsaUJBQWlCLENBQUNyMEMsRUFBRCxFQUFLdE4sQ0FBTCxFQUFRMEgsRUFBUixDQUFyQixFQUFrQztBQUFFO0FBQVE7O0FBQzVDNEYsTUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQm0rQixVQUFqQixDQUE0Qm5pRCxDQUE1QjtBQUNEOztBQUVELE1BQUlxaUQsaUJBQWlCLEdBQUcsR0FBeEI7O0FBRUEsTUFBSUMsU0FBUyxHQUFHLFNBQVpBLFNBQVksQ0FBU3o5QyxJQUFULEVBQWVvQixHQUFmLEVBQW9CNEksTUFBcEIsRUFBNEI7QUFDMUMsU0FBS2hLLElBQUwsR0FBWUEsSUFBWjtBQUNBLFNBQUtvQixHQUFMLEdBQVdBLEdBQVg7QUFDQSxTQUFLNEksTUFBTCxHQUFjQSxNQUFkO0FBQ0QsR0FKRDs7QUFNQXl6QyxXQUFTLENBQUM5K0MsU0FBVixDQUFvQisrQyxPQUFwQixHQUE4QixVQUFVMTlDLElBQVYsRUFBZ0JvQixHQUFoQixFQUFxQjRJLE1BQXJCLEVBQTZCO0FBQ3pELFdBQU8sS0FBS2hLLElBQUwsR0FBWXc5QyxpQkFBWixHQUFnQ3g5QyxJQUFoQyxJQUNMNFIsR0FBRyxDQUFDeFEsR0FBRCxFQUFNLEtBQUtBLEdBQVgsQ0FBSCxJQUFzQixDQURqQixJQUNzQjRJLE1BQU0sSUFBSSxLQUFLQSxNQUQ1QztBQUVELEdBSEQ7O0FBS0EsTUFBSTJ6QyxTQUFKLEVBQWVDLGVBQWY7O0FBQ0EsV0FBU0MsV0FBVCxDQUFxQno4QyxHQUFyQixFQUEwQjRJLE1BQTFCLEVBQWtDO0FBQ2hDLFFBQUk4ekMsR0FBRyxHQUFHLENBQUMsSUFBSTE5QyxJQUFKLEVBQVg7O0FBQ0EsUUFBSXc5QyxlQUFlLElBQUlBLGVBQWUsQ0FBQ0YsT0FBaEIsQ0FBd0JJLEdBQXhCLEVBQTZCMThDLEdBQTdCLEVBQWtDNEksTUFBbEMsQ0FBdkIsRUFBa0U7QUFDaEUyekMsZUFBUyxHQUFHQyxlQUFlLEdBQUcsSUFBOUI7QUFDQSxhQUFPLFFBQVA7QUFDRCxLQUhELE1BR08sSUFBSUQsU0FBUyxJQUFJQSxTQUFTLENBQUNELE9BQVYsQ0FBa0JJLEdBQWxCLEVBQXVCMThDLEdBQXZCLEVBQTRCNEksTUFBNUIsQ0FBakIsRUFBc0Q7QUFDM0Q0ekMscUJBQWUsR0FBRyxJQUFJSCxTQUFKLENBQWNLLEdBQWQsRUFBbUIxOEMsR0FBbkIsRUFBd0I0SSxNQUF4QixDQUFsQjtBQUNBMnpDLGVBQVMsR0FBRyxJQUFaO0FBQ0EsYUFBTyxRQUFQO0FBQ0QsS0FKTSxNQUlBO0FBQ0xBLGVBQVMsR0FBRyxJQUFJRixTQUFKLENBQWNLLEdBQWQsRUFBbUIxOEMsR0FBbkIsRUFBd0I0SSxNQUF4QixDQUFaO0FBQ0E0ekMscUJBQWUsR0FBRyxJQUFsQjtBQUNBLGFBQU8sUUFBUDtBQUNEO0FBQ0YsR0F0bU9rQixDQXdtT25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFdBQVNHLFdBQVQsQ0FBcUI1aUQsQ0FBckIsRUFBd0I7QUFDdEIsUUFBSXNOLEVBQUUsR0FBRyxJQUFUO0FBQUEsUUFBZW9NLE9BQU8sR0FBR3BNLEVBQUUsQ0FBQ29NLE9BQTVCOztBQUNBLFFBQUlyTSxjQUFjLENBQUNDLEVBQUQsRUFBS3ROLENBQUwsQ0FBZCxJQUF5QjBaLE9BQU8sQ0FBQytyQixXQUFSLElBQXVCL3JCLE9BQU8sQ0FBQ3NLLEtBQVIsQ0FBYzYrQixhQUFkLEVBQXBELEVBQW1GO0FBQUU7QUFBUTs7QUFDN0ZucEMsV0FBTyxDQUFDc0ssS0FBUixDQUFjKzhCLFlBQWQ7QUFDQXJuQyxXQUFPLENBQUNtZixLQUFSLEdBQWdCNzRCLENBQUMsQ0FBQzY3QyxRQUFsQjs7QUFFQSxRQUFJaHlCLGFBQWEsQ0FBQ25RLE9BQUQsRUFBVTFaLENBQVYsQ0FBakIsRUFBK0I7QUFDN0IsVUFBSSxDQUFDaEMsTUFBTCxFQUFhO0FBQ1g7QUFDQTtBQUNBMGIsZUFBTyxDQUFDc1IsUUFBUixDQUFpQnNhLFNBQWpCLEdBQTZCLEtBQTdCO0FBQ0FwZ0Msa0JBQVUsQ0FBQyxZQUFZO0FBQUUsaUJBQU93VSxPQUFPLENBQUNzUixRQUFSLENBQWlCc2EsU0FBakIsR0FBNkIsSUFBcEM7QUFBMkMsU0FBMUQsRUFBNEQsR0FBNUQsQ0FBVjtBQUNEOztBQUNEO0FBQ0Q7O0FBQ0QsUUFBSXdkLGFBQWEsQ0FBQ3gxQyxFQUFELEVBQUt0TixDQUFMLENBQWpCLEVBQTBCO0FBQUU7QUFBUTs7QUFDcEMsUUFBSWlHLEdBQUcsR0FBRzhzQixZQUFZLENBQUN6bEIsRUFBRCxFQUFLdE4sQ0FBTCxDQUF0QjtBQUFBLFFBQStCNk8sTUFBTSxHQUFHRixRQUFRLENBQUMzTyxDQUFELENBQWhEO0FBQUEsUUFBcUQraUQsTUFBTSxHQUFHOThDLEdBQUcsR0FBR3k4QyxXQUFXLENBQUN6OEMsR0FBRCxFQUFNNEksTUFBTixDQUFkLEdBQThCLFFBQS9GO0FBQ0F1QixVQUFNLENBQUNpb0IsS0FBUCxHQWpCc0IsQ0FtQnRCOztBQUNBLFFBQUl4cEIsTUFBTSxJQUFJLENBQVYsSUFBZXZCLEVBQUUsQ0FBQ2tGLEtBQUgsQ0FBU3d3QyxhQUE1QixFQUNFO0FBQUUxMUMsUUFBRSxDQUFDa0YsS0FBSCxDQUFTd3dDLGFBQVQsQ0FBdUJoakQsQ0FBdkI7QUFBNEI7O0FBRWhDLFFBQUlpRyxHQUFHLElBQUlnOUMsa0JBQWtCLENBQUMzMUMsRUFBRCxFQUFLdUIsTUFBTCxFQUFhNUksR0FBYixFQUFrQjg4QyxNQUFsQixFQUEwQi9pRCxDQUExQixDQUE3QixFQUEyRDtBQUFFO0FBQVE7O0FBRXJFLFFBQUk2TyxNQUFNLElBQUksQ0FBZCxFQUFpQjtBQUNmLFVBQUk1SSxHQUFKLEVBQVM7QUFBRWk5QyxzQkFBYyxDQUFDNTFDLEVBQUQsRUFBS3JILEdBQUwsRUFBVTg4QyxNQUFWLEVBQWtCL2lELENBQWxCLENBQWQ7QUFBcUMsT0FBaEQsTUFDSyxJQUFJeU8sUUFBUSxDQUFDek8sQ0FBRCxDQUFSLElBQWUwWixPQUFPLENBQUNzUixRQUEzQixFQUFxQztBQUFFN2Msd0JBQWdCLENBQUNuTyxDQUFELENBQWhCO0FBQXNCO0FBQ25FLEtBSEQsTUFHTyxJQUFJNk8sTUFBTSxJQUFJLENBQWQsRUFBaUI7QUFDdEIsVUFBSTVJLEdBQUosRUFBUztBQUFFNm1DLHVCQUFlLENBQUN4L0IsRUFBRSxDQUFDd0gsR0FBSixFQUFTN08sR0FBVCxDQUFmO0FBQStCOztBQUMxQ2YsZ0JBQVUsQ0FBQyxZQUFZO0FBQUUsZUFBT3dVLE9BQU8sQ0FBQ3NLLEtBQVIsQ0FBY3FVLEtBQWQsRUFBUDtBQUErQixPQUE5QyxFQUFnRCxFQUFoRCxDQUFWO0FBQ0QsS0FITSxNQUdBLElBQUl4cEIsTUFBTSxJQUFJLENBQWQsRUFBaUI7QUFDdEIsVUFBSTFQLGlCQUFKLEVBQXVCO0FBQUVtTyxVQUFFLENBQUNvTSxPQUFILENBQVdzSyxLQUFYLENBQWlCbS9CLGFBQWpCLENBQStCbmpELENBQS9CO0FBQW9DLE9BQTdELE1BQ0s7QUFBRXU0QixzQkFBYyxDQUFDanJCLEVBQUQsQ0FBZDtBQUFxQjtBQUM3QjtBQUNGOztBQUVELFdBQVMyMUMsa0JBQVQsQ0FBNEIzMUMsRUFBNUIsRUFBZ0N1QixNQUFoQyxFQUF3QzVJLEdBQXhDLEVBQTZDODhDLE1BQTdDLEVBQXFEclcsS0FBckQsRUFBNEQ7QUFDMUQsUUFBSXI3QixJQUFJLEdBQUcsT0FBWDs7QUFDQSxRQUFJMHhDLE1BQU0sSUFBSSxRQUFkLEVBQXdCO0FBQUUxeEMsVUFBSSxHQUFHLFdBQVdBLElBQWxCO0FBQXlCLEtBQW5ELE1BQ0ssSUFBSTB4QyxNQUFNLElBQUksUUFBZCxFQUF3QjtBQUFFMXhDLFVBQUksR0FBRyxXQUFXQSxJQUFsQjtBQUF5Qjs7QUFDeERBLFFBQUksR0FBRyxDQUFDeEMsTUFBTSxJQUFJLENBQVYsR0FBYyxNQUFkLEdBQXVCQSxNQUFNLElBQUksQ0FBVixHQUFjLFFBQWQsR0FBeUIsT0FBakQsSUFBNER3QyxJQUFuRTtBQUVBLFdBQU9nd0MsV0FBVyxDQUFDL3pDLEVBQUQsRUFBTW11QyxnQkFBZ0IsQ0FBQ3BxQyxJQUFELEVBQU9xN0IsS0FBUCxDQUF0QixFQUFxQ0EsS0FBckMsRUFBNEMsVUFBVW1VLEtBQVYsRUFBaUI7QUFDN0UsVUFBSSxPQUFPQSxLQUFQLElBQWdCLFFBQXBCLEVBQThCO0FBQUVBLGFBQUssR0FBRzFELFFBQVEsQ0FBQzBELEtBQUQsQ0FBaEI7QUFBMEI7O0FBQzFELFVBQUksQ0FBQ0EsS0FBTCxFQUFZO0FBQUUsZUFBTyxLQUFQO0FBQWM7O0FBQzVCLFVBQUkxVyxJQUFJLEdBQUcsS0FBWDs7QUFDQSxVQUFJO0FBQ0YsWUFBSTc4QixFQUFFLENBQUMwcUMsVUFBSCxFQUFKLEVBQXFCO0FBQUUxcUMsWUFBRSxDQUFDa0YsS0FBSCxDQUFTeThCLGFBQVQsR0FBeUIsSUFBekI7QUFBZ0M7O0FBQ3ZEOUUsWUFBSSxHQUFHMFcsS0FBSyxDQUFDdnpDLEVBQUQsRUFBS3JILEdBQUwsQ0FBTCxJQUFrQlQsSUFBekI7QUFDRCxPQUhELFNBR1U7QUFDUjhILFVBQUUsQ0FBQ2tGLEtBQUgsQ0FBU3k4QixhQUFULEdBQXlCLEtBQXpCO0FBQ0Q7O0FBQ0QsYUFBTzlFLElBQVA7QUFDRCxLQVhpQixDQUFsQjtBQVlEOztBQUVELFdBQVNpWixjQUFULENBQXdCOTFDLEVBQXhCLEVBQTRCeTFDLE1BQTVCLEVBQW9DclcsS0FBcEMsRUFBMkM7QUFDekMsUUFBSTJXLE1BQU0sR0FBRy8xQyxFQUFFLENBQUN3VSxTQUFILENBQWEsZ0JBQWIsQ0FBYjtBQUNBLFFBQUk1ZSxLQUFLLEdBQUdtZ0QsTUFBTSxHQUFHQSxNQUFNLENBQUMvMUMsRUFBRCxFQUFLeTFDLE1BQUwsRUFBYXJXLEtBQWIsQ0FBVCxHQUErQixFQUFqRDs7QUFDQSxRQUFJeHBDLEtBQUssQ0FBQ29nRCxJQUFOLElBQWMsSUFBbEIsRUFBd0I7QUFDdEIsVUFBSWg0QixJQUFJLEdBQUd6c0IsUUFBUSxHQUFHNnRDLEtBQUssQ0FBQ21QLFFBQU4sSUFBa0JuUCxLQUFLLENBQUNrUCxPQUEzQixHQUFxQ2xQLEtBQUssQ0FBQ2lQLE1BQTlEO0FBQ0F6NEMsV0FBSyxDQUFDb2dELElBQU4sR0FBYWg0QixJQUFJLEdBQUcsV0FBSCxHQUFpQnkzQixNQUFNLElBQUksUUFBVixHQUFxQixNQUFyQixHQUE4QkEsTUFBTSxJQUFJLFFBQVYsR0FBcUIsTUFBckIsR0FBOEIsTUFBOUY7QUFDRDs7QUFDRCxRQUFJNy9DLEtBQUssQ0FBQzQvQixNQUFOLElBQWdCLElBQWhCLElBQXdCeDFCLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT2d1QixNQUFuQyxFQUEyQztBQUFFNS9CLFdBQUssQ0FBQzQvQixNQUFOLEdBQWV4MUIsRUFBRSxDQUFDd0gsR0FBSCxDQUFPZ3VCLE1BQVAsSUFBaUI0SixLQUFLLENBQUNtUCxRQUF0QztBQUFpRDs7QUFDOUYsUUFBSTM0QyxLQUFLLENBQUNxZ0QsTUFBTixJQUFnQixJQUFwQixFQUEwQjtBQUFFcmdELFdBQUssQ0FBQ3FnRCxNQUFOLEdBQWUza0QsR0FBRyxHQUFHOHRDLEtBQUssQ0FBQ2tQLE9BQVQsR0FBbUJsUCxLQUFLLENBQUM1OUIsT0FBM0M7QUFBcUQ7O0FBQ2pGLFFBQUk1TCxLQUFLLENBQUNzZ0QsVUFBTixJQUFvQixJQUF4QixFQUE4QjtBQUFFdGdELFdBQUssQ0FBQ3NnRCxVQUFOLEdBQW1CLEVBQUU1a0QsR0FBRyxHQUFHOHRDLEtBQUssQ0FBQ2lQLE1BQVQsR0FBa0JqUCxLQUFLLENBQUM1OUIsT0FBN0IsQ0FBbkI7QUFBMkQ7O0FBQzNGLFdBQU81TCxLQUFQO0FBQ0Q7O0FBRUQsV0FBU2dnRCxjQUFULENBQXdCNTFDLEVBQXhCLEVBQTRCckgsR0FBNUIsRUFBaUM4OEMsTUFBakMsRUFBeUNyVyxLQUF6QyxFQUFnRDtBQUM5QyxRQUFJOXVDLEVBQUosRUFBUTtBQUFFc0gsZ0JBQVUsQ0FBQzlCLElBQUksQ0FBQ2cxQixXQUFELEVBQWM5cUIsRUFBZCxDQUFMLEVBQXdCLENBQXhCLENBQVY7QUFBdUMsS0FBakQsTUFDSztBQUFFQSxRQUFFLENBQUNRLEtBQUgsQ0FBU3VxQixLQUFULEdBQWlCaDJCLFNBQVMsRUFBMUI7QUFBK0I7O0FBRXRDLFFBQUlvaEQsUUFBUSxHQUFHTCxjQUFjLENBQUM5MUMsRUFBRCxFQUFLeTFDLE1BQUwsRUFBYXJXLEtBQWIsQ0FBN0I7QUFFQSxRQUFJM1gsR0FBRyxHQUFHem5CLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT2lnQixHQUFqQjtBQUFBLFFBQXNCMnVCLFNBQXRCOztBQUNBLFFBQUlwMkMsRUFBRSxDQUFDdUUsT0FBSCxDQUFXOHhDLFFBQVgsSUFBdUI1MEMsV0FBdkIsSUFBc0MsQ0FBQ3pCLEVBQUUsQ0FBQzBxQyxVQUFILEVBQXZDLElBQ0ErSyxNQUFNLElBQUksUUFEVixJQUNzQixDQUFDVyxTQUFTLEdBQUczdUIsR0FBRyxDQUFDOXlCLFFBQUosQ0FBYWdFLEdBQWIsQ0FBYixJQUFrQyxDQUFDLENBRHpELEtBRUN3USxHQUFHLENBQUMsQ0FBQ2l0QyxTQUFTLEdBQUczdUIsR0FBRyxDQUFDQyxNQUFKLENBQVcwdUIsU0FBWCxDQUFiLEVBQW9DaDdDLElBQXBDLEVBQUQsRUFBNkN6QyxHQUE3QyxDQUFILEdBQXVELENBQXZELElBQTREQSxHQUFHLENBQUMycUIsSUFBSixHQUFXLENBRnhFLE1BR0NuYSxHQUFHLENBQUNpdEMsU0FBUyxDQUFDLzZDLEVBQVYsRUFBRCxFQUFpQjFDLEdBQWpCLENBQUgsR0FBMkIsQ0FBM0IsSUFBZ0NBLEdBQUcsQ0FBQzJxQixJQUFKLEdBQVcsQ0FINUMsQ0FBSixFQUlFO0FBQUVnekIseUJBQW1CLENBQUN0MkMsRUFBRCxFQUFLby9CLEtBQUwsRUFBWXptQyxHQUFaLEVBQWlCdzlDLFFBQWpCLENBQW5CO0FBQWdELEtBSnBELE1BTUU7QUFBRUksc0JBQWdCLENBQUN2MkMsRUFBRCxFQUFLby9CLEtBQUwsRUFBWXptQyxHQUFaLEVBQWlCdzlDLFFBQWpCLENBQWhCO0FBQTZDO0FBQ2xELEdBanNPa0IsQ0Ftc09uQjtBQUNBOzs7QUFDQSxXQUFTRyxtQkFBVCxDQUE2QnQyQyxFQUE3QixFQUFpQ28vQixLQUFqQyxFQUF3Q3ptQyxHQUF4QyxFQUE2Q3c5QyxRQUE3QyxFQUF1RDtBQUNyRCxRQUFJL3BDLE9BQU8sR0FBR3BNLEVBQUUsQ0FBQ29NLE9BQWpCO0FBQUEsUUFBMEJvcUMsS0FBSyxHQUFHLEtBQWxDO0FBQ0EsUUFBSUMsT0FBTyxHQUFHMWlCLFNBQVMsQ0FBQy96QixFQUFELEVBQUssVUFBVXROLENBQVYsRUFBYTtBQUN2QyxVQUFJaEMsTUFBSixFQUFZO0FBQUUwYixlQUFPLENBQUNzUixRQUFSLENBQWlCc2EsU0FBakIsR0FBNkIsS0FBN0I7QUFBcUM7O0FBQ25EaDRCLFFBQUUsQ0FBQ2tGLEtBQUgsQ0FBU2ltQixZQUFULEdBQXdCLEtBQXhCOztBQUNBLFVBQUluckIsRUFBRSxDQUFDa0YsS0FBSCxDQUFTZ21CLGlCQUFiLEVBQWdDO0FBQzlCLFlBQUlsckIsRUFBRSxDQUFDNHFCLFFBQUgsRUFBSixFQUFtQjtBQUFFNXFCLFlBQUUsQ0FBQ2tGLEtBQUgsQ0FBU2dtQixpQkFBVCxHQUE2QixLQUE3QjtBQUFxQyxTQUExRCxNQUNLO0FBQUVELHdCQUFjLENBQUNqckIsRUFBRCxDQUFkO0FBQXFCO0FBQzdCOztBQUNETixTQUFHLENBQUMwTSxPQUFPLENBQUNpUSxPQUFSLENBQWdCcFosYUFBakIsRUFBZ0MsU0FBaEMsRUFBMkN3ekMsT0FBM0MsQ0FBSDtBQUNBLzJDLFNBQUcsQ0FBQzBNLE9BQU8sQ0FBQ2lRLE9BQVIsQ0FBZ0JwWixhQUFqQixFQUFnQyxXQUFoQyxFQUE2Q3l6QyxTQUE3QyxDQUFIO0FBQ0FoM0MsU0FBRyxDQUFDME0sT0FBTyxDQUFDc1IsUUFBVCxFQUFtQixXQUFuQixFQUFnQ2k1QixTQUFoQyxDQUFIO0FBQ0FqM0MsU0FBRyxDQUFDME0sT0FBTyxDQUFDc1IsUUFBVCxFQUFtQixNQUFuQixFQUEyQis0QixPQUEzQixDQUFIOztBQUNBLFVBQUksQ0FBQ0QsS0FBTCxFQUFZO0FBQ1YzMUMsd0JBQWdCLENBQUNuTyxDQUFELENBQWhCOztBQUNBLFlBQUksQ0FBQ3lqRCxRQUFRLENBQUNGLE1BQWQsRUFDRTtBQUFFelcseUJBQWUsQ0FBQ3gvQixFQUFFLENBQUN3SCxHQUFKLEVBQVM3TyxHQUFULEVBQWMsSUFBZCxFQUFvQixJQUFwQixFQUEwQnc5QyxRQUFRLENBQUMzZ0IsTUFBbkMsQ0FBZjtBQUE0RCxTQUh0RCxDQUlWOzs7QUFDQSxZQUFLOWtDLE1BQU0sSUFBSSxDQUFDSSxNQUFaLElBQXVCUixFQUFFLElBQUlDLFVBQVUsSUFBSSxDQUEvQyxFQUNFO0FBQUVxSCxvQkFBVSxDQUFDLFlBQVk7QUFBQ3dVLG1CQUFPLENBQUNpUSxPQUFSLENBQWdCcFosYUFBaEIsQ0FBOEI3TyxJQUE5QixDQUFtQzIyQixLQUFuQyxDQUF5QztBQUFDNnJCLDJCQUFhLEVBQUU7QUFBaEIsYUFBekM7QUFBaUV4cUMsbUJBQU8sQ0FBQ3NLLEtBQVIsQ0FBY3FVLEtBQWQ7QUFBdUIsV0FBdEcsRUFBd0csRUFBeEcsQ0FBVjtBQUF3SCxTQUQ1SCxNQUdFO0FBQUUzZSxpQkFBTyxDQUFDc0ssS0FBUixDQUFjcVUsS0FBZDtBQUF3QjtBQUM3QjtBQUNGLEtBckJzQixDQUF2Qjs7QUFzQkEsUUFBSTJyQixTQUFTLEdBQUcsU0FBWkEsU0FBWSxDQUFTRyxFQUFULEVBQWE7QUFDM0JMLFdBQUssR0FBR0EsS0FBSyxJQUFJMTlDLElBQUksQ0FBQzZLLEdBQUwsQ0FBU3k3QixLQUFLLENBQUN2WixPQUFOLEdBQWdCZ3hCLEVBQUUsQ0FBQ2h4QixPQUE1QixJQUF1Qy9zQixJQUFJLENBQUM2SyxHQUFMLENBQVN5N0IsS0FBSyxDQUFDdFosT0FBTixHQUFnQit3QixFQUFFLENBQUMvd0IsT0FBNUIsQ0FBdkMsSUFBK0UsRUFBaEc7QUFDRCxLQUZEOztBQUdBLFFBQUk2d0IsU0FBUyxHQUFHLFNBQVpBLFNBQVksR0FBWTtBQUFFLGFBQU9ILEtBQUssR0FBRyxJQUFmO0FBQXNCLEtBQXBELENBM0JxRCxDQTRCckQ7OztBQUNBLFFBQUk5bEQsTUFBSixFQUFZO0FBQUUwYixhQUFPLENBQUNzUixRQUFSLENBQWlCc2EsU0FBakIsR0FBNkIsSUFBN0I7QUFBb0M7O0FBQ2xEaDRCLE1BQUUsQ0FBQ2tGLEtBQUgsQ0FBU2ltQixZQUFULEdBQXdCc3JCLE9BQXhCO0FBQ0FBLFdBQU8sQ0FBQ2pzQyxJQUFSLEdBQWUsQ0FBQzJyQyxRQUFRLENBQUNELFVBQXpCO0FBQ0EvMkMsTUFBRSxDQUFDaU4sT0FBTyxDQUFDaVEsT0FBUixDQUFnQnBaLGFBQWpCLEVBQWdDLFNBQWhDLEVBQTJDd3pDLE9BQTNDLENBQUY7QUFDQXQzQyxNQUFFLENBQUNpTixPQUFPLENBQUNpUSxPQUFSLENBQWdCcFosYUFBakIsRUFBZ0MsV0FBaEMsRUFBNkN5ekMsU0FBN0MsQ0FBRjtBQUNBdjNDLE1BQUUsQ0FBQ2lOLE9BQU8sQ0FBQ3NSLFFBQVQsRUFBbUIsV0FBbkIsRUFBZ0NpNUIsU0FBaEMsQ0FBRjtBQUNBeDNDLE1BQUUsQ0FBQ2lOLE9BQU8sQ0FBQ3NSLFFBQVQsRUFBbUIsTUFBbkIsRUFBMkIrNEIsT0FBM0IsQ0FBRjtBQUVBejJDLE1BQUUsQ0FBQ2tGLEtBQUgsQ0FBU2dtQixpQkFBVCxHQUE2QixJQUE3QjtBQUNBdHpCLGNBQVUsQ0FBQyxZQUFZO0FBQUUsYUFBT3dVLE9BQU8sQ0FBQ3NLLEtBQVIsQ0FBY3FVLEtBQWQsRUFBUDtBQUErQixLQUE5QyxFQUFnRCxFQUFoRCxDQUFWLENBdENxRCxDQXVDckQ7O0FBQ0EsUUFBSTNlLE9BQU8sQ0FBQ3NSLFFBQVIsQ0FBaUIyNEIsUUFBckIsRUFBK0I7QUFBRWpxQyxhQUFPLENBQUNzUixRQUFSLENBQWlCMjRCLFFBQWpCO0FBQThCO0FBQ2hFOztBQUVELFdBQVNTLFlBQVQsQ0FBc0I5MkMsRUFBdEIsRUFBMEJySCxHQUExQixFQUErQnE5QyxJQUEvQixFQUFxQztBQUNuQyxRQUFJQSxJQUFJLElBQUksTUFBWixFQUFvQjtBQUFFLGFBQU8sSUFBSWxjLEtBQUosQ0FBVW5oQyxHQUFWLEVBQWVBLEdBQWYsQ0FBUDtBQUE0Qjs7QUFDbEQsUUFBSXE5QyxJQUFJLElBQUksTUFBWixFQUFvQjtBQUFFLGFBQU9oMkMsRUFBRSxDQUFDKzJDLFVBQUgsQ0FBY3ArQyxHQUFkLENBQVA7QUFBMkI7O0FBQ2pELFFBQUlxOUMsSUFBSSxJQUFJLE1BQVosRUFBb0I7QUFBRSxhQUFPLElBQUlsYyxLQUFKLENBQVU1d0IsR0FBRyxDQUFDdlEsR0FBRyxDQUFDcUcsSUFBTCxFQUFXLENBQVgsQ0FBYixFQUE0QjBLLFFBQU8sQ0FBQzFKLEVBQUUsQ0FBQ3dILEdBQUosRUFBUzBCLEdBQUcsQ0FBQ3ZRLEdBQUcsQ0FBQ3FHLElBQUosR0FBVyxDQUFaLEVBQWUsQ0FBZixDQUFaLENBQW5DLENBQVA7QUFBMkU7O0FBQ2pHLFFBQUl5RCxNQUFNLEdBQUd1ekMsSUFBSSxDQUFDaDJDLEVBQUQsRUFBS3JILEdBQUwsQ0FBakI7QUFDQSxXQUFPLElBQUltaEMsS0FBSixDQUFVcjNCLE1BQU0sQ0FBQ3JILElBQWpCLEVBQXVCcUgsTUFBTSxDQUFDcEgsRUFBOUIsQ0FBUDtBQUNELEdBdHZPa0IsQ0F3dk9uQjs7O0FBQ0EsV0FBU2s3QyxnQkFBVCxDQUEwQnYyQyxFQUExQixFQUE4Qm8vQixLQUE5QixFQUFxQ3RyQyxLQUFyQyxFQUE0Q3FpRCxRQUE1QyxFQUFzRDtBQUNwRCxRQUFJN2xELEVBQUosRUFBUTtBQUFFMjZCLG9CQUFjLENBQUNqckIsRUFBRCxDQUFkO0FBQXFCOztBQUMvQixRQUFJb00sT0FBTyxHQUFHcE0sRUFBRSxDQUFDb00sT0FBakI7QUFBQSxRQUEwQjVFLEdBQUcsR0FBR3hILEVBQUUsQ0FBQ3dILEdBQW5DO0FBQ0EzRyxvQkFBZ0IsQ0FBQ3UrQixLQUFELENBQWhCO0FBRUEsUUFBSTRYLFFBQUo7QUFBQSxRQUFjQyxRQUFkO0FBQUEsUUFBd0JDLFFBQVEsR0FBRzF2QyxHQUFHLENBQUNpZ0IsR0FBdkM7QUFBQSxRQUE0Q0MsTUFBTSxHQUFHd3ZCLFFBQVEsQ0FBQ3h2QixNQUE5RDs7QUFDQSxRQUFJeXVCLFFBQVEsQ0FBQ0YsTUFBVCxJQUFtQixDQUFDRSxRQUFRLENBQUMzZ0IsTUFBakMsRUFBeUM7QUFDdkN5aEIsY0FBUSxHQUFHenZDLEdBQUcsQ0FBQ2lnQixHQUFKLENBQVE5eUIsUUFBUixDQUFpQmIsS0FBakIsQ0FBWDs7QUFDQSxVQUFJbWpELFFBQVEsR0FBRyxDQUFDLENBQWhCLEVBQ0U7QUFBRUQsZ0JBQVEsR0FBR3R2QixNQUFNLENBQUN1dkIsUUFBRCxDQUFqQjtBQUE4QixPQURsQyxNQUdFO0FBQUVELGdCQUFRLEdBQUcsSUFBSWxkLEtBQUosQ0FBVWhtQyxLQUFWLEVBQWlCQSxLQUFqQixDQUFYO0FBQXFDO0FBQzFDLEtBTkQsTUFNTztBQUNMa2pELGNBQVEsR0FBR3h2QyxHQUFHLENBQUNpZ0IsR0FBSixDQUFRSixPQUFSLEVBQVg7QUFDQTR2QixjQUFRLEdBQUd6dkMsR0FBRyxDQUFDaWdCLEdBQUosQ0FBUUUsU0FBbkI7QUFDRDs7QUFFRCxRQUFJd3VCLFFBQVEsQ0FBQ0gsSUFBVCxJQUFpQixXQUFyQixFQUFrQztBQUNoQyxVQUFJLENBQUNHLFFBQVEsQ0FBQ0YsTUFBZCxFQUFzQjtBQUFFZSxnQkFBUSxHQUFHLElBQUlsZCxLQUFKLENBQVVobUMsS0FBVixFQUFpQkEsS0FBakIsQ0FBWDtBQUFxQzs7QUFDN0RBLFdBQUssR0FBRzJ4QixZQUFZLENBQUN6bEIsRUFBRCxFQUFLby9CLEtBQUwsRUFBWSxJQUFaLEVBQWtCLElBQWxCLENBQXBCO0FBQ0E2WCxjQUFRLEdBQUcsQ0FBQyxDQUFaO0FBQ0QsS0FKRCxNQUlPO0FBQ0wsVUFBSXJqRCxLQUFLLEdBQUdrakQsWUFBWSxDQUFDOTJDLEVBQUQsRUFBS2xNLEtBQUwsRUFBWXFpRCxRQUFRLENBQUNILElBQXJCLENBQXhCOztBQUNBLFVBQUlHLFFBQVEsQ0FBQzNnQixNQUFiLEVBQ0U7QUFBRXdoQixnQkFBUSxHQUFHMVgsV0FBVyxDQUFDMFgsUUFBRCxFQUFXcGpELEtBQUssQ0FBQ294QixNQUFqQixFQUF5QnB4QixLQUFLLENBQUNtMEIsSUFBL0IsRUFBcUNvdUIsUUFBUSxDQUFDM2dCLE1BQTlDLENBQXRCO0FBQThFLE9BRGxGLE1BR0U7QUFBRXdoQixnQkFBUSxHQUFHcGpELEtBQVg7QUFBbUI7QUFDeEI7O0FBRUQsUUFBSSxDQUFDdWlELFFBQVEsQ0FBQ0YsTUFBZCxFQUFzQjtBQUNwQmdCLGNBQVEsR0FBRyxDQUFYO0FBQ0F4WCxrQkFBWSxDQUFDajRCLEdBQUQsRUFBTSxJQUFJaXlCLFNBQUosQ0FBYyxDQUFDdWQsUUFBRCxDQUFkLEVBQTBCLENBQTFCLENBQU4sRUFBb0MxK0MsU0FBcEMsQ0FBWjtBQUNBNCtDLGNBQVEsR0FBRzF2QyxHQUFHLENBQUNpZ0IsR0FBZjtBQUNELEtBSkQsTUFJTyxJQUFJd3ZCLFFBQVEsSUFBSSxDQUFDLENBQWpCLEVBQW9CO0FBQ3pCQSxjQUFRLEdBQUd2dkIsTUFBTSxDQUFDbDFCLE1BQWxCO0FBQ0FpdEMsa0JBQVksQ0FBQ2o0QixHQUFELEVBQU13eUIsa0JBQWtCLENBQUNoNkIsRUFBRCxFQUFLMG5CLE1BQU0sQ0FBQ2xvQixNQUFQLENBQWMsQ0FBQ3czQyxRQUFELENBQWQsQ0FBTCxFQUFnQ0MsUUFBaEMsQ0FBeEIsRUFDQztBQUFDNStDLGNBQU0sRUFBRSxLQUFUO0FBQWdCRSxjQUFNLEVBQUU7QUFBeEIsT0FERCxDQUFaO0FBRUQsS0FKTSxNQUlBLElBQUltdkIsTUFBTSxDQUFDbDFCLE1BQVAsR0FBZ0IsQ0FBaEIsSUFBcUJrMUIsTUFBTSxDQUFDdXZCLFFBQUQsQ0FBTixDQUFpQnJ2QixLQUFqQixFQUFyQixJQUFpRHV1QixRQUFRLENBQUNILElBQVQsSUFBaUIsTUFBbEUsSUFBNEUsQ0FBQ0csUUFBUSxDQUFDM2dCLE1BQTFGLEVBQWtHO0FBQ3ZHaUssa0JBQVksQ0FBQ2o0QixHQUFELEVBQU13eUIsa0JBQWtCLENBQUNoNkIsRUFBRCxFQUFLMG5CLE1BQU0sQ0FBQ3AxQixLQUFQLENBQWEsQ0FBYixFQUFnQjJrRCxRQUFoQixFQUEwQnozQyxNQUExQixDQUFpQ2tvQixNQUFNLENBQUNwMUIsS0FBUCxDQUFhMmtELFFBQVEsR0FBRyxDQUF4QixDQUFqQyxDQUFMLEVBQW1FLENBQW5FLENBQXhCLEVBQ0M7QUFBQzUrQyxjQUFNLEVBQUUsS0FBVDtBQUFnQkUsY0FBTSxFQUFFO0FBQXhCLE9BREQsQ0FBWjtBQUVBMitDLGNBQVEsR0FBRzF2QyxHQUFHLENBQUNpZ0IsR0FBZjtBQUNELEtBSk0sTUFJQTtBQUNMb1kseUJBQW1CLENBQUNyNEIsR0FBRCxFQUFNeXZDLFFBQU4sRUFBZ0JELFFBQWhCLEVBQTBCMStDLFNBQTFCLENBQW5CO0FBQ0Q7O0FBRUQsUUFBSTYrQyxPQUFPLEdBQUdyakQsS0FBZDs7QUFDQSxhQUFTc2pELFFBQVQsQ0FBa0J6K0MsR0FBbEIsRUFBdUI7QUFDckIsVUFBSXdRLEdBQUcsQ0FBQ2d1QyxPQUFELEVBQVV4K0MsR0FBVixDQUFILElBQXFCLENBQXpCLEVBQTRCO0FBQUU7QUFBUTs7QUFDdEN3K0MsYUFBTyxHQUFHeCtDLEdBQVY7O0FBRUEsVUFBSXc5QyxRQUFRLENBQUNILElBQVQsSUFBaUIsV0FBckIsRUFBa0M7QUFDaEMsWUFBSXR1QixNQUFNLEdBQUcsRUFBYjtBQUFBLFlBQWlCNXdCLE9BQU8sR0FBR2tKLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBV3pOLE9BQXRDO0FBQ0EsWUFBSXVnRCxRQUFRLEdBQUd6Z0QsV0FBVyxDQUFDMlEsT0FBTyxDQUFDQyxHQUFELEVBQU0xVCxLQUFLLENBQUNrTCxJQUFaLENBQVAsQ0FBeUJDLElBQTFCLEVBQWdDbkwsS0FBSyxDQUFDc0csRUFBdEMsRUFBMEN0RCxPQUExQyxDQUExQjtBQUNBLFlBQUl3Z0QsTUFBTSxHQUFHMWdELFdBQVcsQ0FBQzJRLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNN08sR0FBRyxDQUFDcUcsSUFBVixDQUFQLENBQXVCQyxJQUF4QixFQUE4QnRHLEdBQUcsQ0FBQ3lCLEVBQWxDLEVBQXNDdEQsT0FBdEMsQ0FBeEI7QUFDQSxZQUFJd0wsSUFBSSxHQUFHeEosSUFBSSxDQUFDQyxHQUFMLENBQVNzK0MsUUFBVCxFQUFtQkMsTUFBbkIsQ0FBWDtBQUFBLFlBQXVDLzBDLEtBQUssR0FBR3pKLElBQUksQ0FBQ2dELEdBQUwsQ0FBU3U3QyxRQUFULEVBQW1CQyxNQUFuQixDQUEvQzs7QUFDQSxhQUFLLElBQUl0NEMsSUFBSSxHQUFHbEcsSUFBSSxDQUFDQyxHQUFMLENBQVNqRixLQUFLLENBQUNrTCxJQUFmLEVBQXFCckcsR0FBRyxDQUFDcUcsSUFBekIsQ0FBWCxFQUEyQ2pMLEdBQUcsR0FBRytFLElBQUksQ0FBQ0MsR0FBTCxDQUFTaUgsRUFBRSxDQUFDNlMsUUFBSCxFQUFULEVBQXdCL1osSUFBSSxDQUFDZ0QsR0FBTCxDQUFTaEksS0FBSyxDQUFDa0wsSUFBZixFQUFxQnJHLEdBQUcsQ0FBQ3FHLElBQXpCLENBQXhCLENBQXRELEVBQ0tBLElBQUksSUFBSWpMLEdBRGIsRUFDa0JpTCxJQUFJLEVBRHRCLEVBQzBCO0FBQ3hCLGNBQUlDLElBQUksR0FBR3NJLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNeEksSUFBTixDQUFQLENBQW1CQyxJQUE5QjtBQUFBLGNBQW9Da3hDLE9BQU8sR0FBRzEzQyxVQUFVLENBQUN3RyxJQUFELEVBQU9xRCxJQUFQLEVBQWF4TCxPQUFiLENBQXhEOztBQUNBLGNBQUl3TCxJQUFJLElBQUlDLEtBQVosRUFDRTtBQUFFbWxCLGtCQUFNLENBQUN4dUIsSUFBUCxDQUFZLElBQUk0Z0MsS0FBSixDQUFVNXdCLEdBQUcsQ0FBQ2xLLElBQUQsRUFBT214QyxPQUFQLENBQWIsRUFBOEJqbkMsR0FBRyxDQUFDbEssSUFBRCxFQUFPbXhDLE9BQVAsQ0FBakMsQ0FBWjtBQUFpRSxXQURyRSxNQUVLLElBQUlseEMsSUFBSSxDQUFDek0sTUFBTCxHQUFjMjlDLE9BQWxCLEVBQ0g7QUFBRXpvQixrQkFBTSxDQUFDeHVCLElBQVAsQ0FBWSxJQUFJNGdDLEtBQUosQ0FBVTV3QixHQUFHLENBQUNsSyxJQUFELEVBQU9teEMsT0FBUCxDQUFiLEVBQThCam5DLEdBQUcsQ0FBQ2xLLElBQUQsRUFBT3ZHLFVBQVUsQ0FBQ3dHLElBQUQsRUFBT3NELEtBQVAsRUFBY3pMLE9BQWQsQ0FBakIsQ0FBakMsQ0FBWjtBQUEwRjtBQUMvRjs7QUFDRCxZQUFJLENBQUM0d0IsTUFBTSxDQUFDbDFCLE1BQVosRUFBb0I7QUFBRWsxQixnQkFBTSxDQUFDeHVCLElBQVAsQ0FBWSxJQUFJNGdDLEtBQUosQ0FBVWhtQyxLQUFWLEVBQWlCQSxLQUFqQixDQUFaO0FBQXVDOztBQUM3RDJyQyxvQkFBWSxDQUFDajRCLEdBQUQsRUFBTXd5QixrQkFBa0IsQ0FBQ2g2QixFQUFELEVBQUtrM0MsUUFBUSxDQUFDeHZCLE1BQVQsQ0FBZ0JwMUIsS0FBaEIsQ0FBc0IsQ0FBdEIsRUFBeUIya0QsUUFBekIsRUFBbUN6M0MsTUFBbkMsQ0FBMENrb0IsTUFBMUMsQ0FBTCxFQUF3RHV2QixRQUF4RCxDQUF4QixFQUNDO0FBQUMxK0MsZ0JBQU0sRUFBRSxRQUFUO0FBQW1CRixnQkFBTSxFQUFFO0FBQTNCLFNBREQsQ0FBWjtBQUVBMkgsVUFBRSxDQUFDdXNCLGNBQUgsQ0FBa0I1ekIsR0FBbEI7QUFDRCxPQWpCRCxNQWlCTztBQUNMLFlBQUk0K0MsUUFBUSxHQUFHUCxRQUFmO0FBQ0EsWUFBSXBqRCxLQUFLLEdBQUdrakQsWUFBWSxDQUFDOTJDLEVBQUQsRUFBS3JILEdBQUwsRUFBVXc5QyxRQUFRLENBQUNILElBQW5CLENBQXhCO0FBQ0EsWUFBSWh4QixNQUFNLEdBQUd1eUIsUUFBUSxDQUFDdnlCLE1BQXRCO0FBQUEsWUFBOEIrQyxJQUE5Qjs7QUFDQSxZQUFJNWUsR0FBRyxDQUFDdlYsS0FBSyxDQUFDb3hCLE1BQVAsRUFBZUEsTUFBZixDQUFILEdBQTRCLENBQWhDLEVBQW1DO0FBQ2pDK0MsY0FBSSxHQUFHbjBCLEtBQUssQ0FBQ20wQixJQUFiO0FBQ0EvQyxnQkFBTSxHQUFHeGIsTUFBTSxDQUFDK3RDLFFBQVEsQ0FBQ244QyxJQUFULEVBQUQsRUFBa0J4SCxLQUFLLENBQUNveEIsTUFBeEIsQ0FBZjtBQUNELFNBSEQsTUFHTztBQUNMK0MsY0FBSSxHQUFHbjBCLEtBQUssQ0FBQ294QixNQUFiO0FBQ0FBLGdCQUFNLEdBQUd6YixNQUFNLENBQUNndUMsUUFBUSxDQUFDbDhDLEVBQVQsRUFBRCxFQUFnQnpILEtBQUssQ0FBQ20wQixJQUF0QixDQUFmO0FBQ0Q7O0FBQ0QsWUFBSXl2QixRQUFRLEdBQUdOLFFBQVEsQ0FBQ3h2QixNQUFULENBQWdCcDFCLEtBQWhCLENBQXNCLENBQXRCLENBQWY7QUFDQWtsRCxnQkFBUSxDQUFDUCxRQUFELENBQVIsR0FBcUJRLFlBQVksQ0FBQ3ozQyxFQUFELEVBQUssSUFBSTg1QixLQUFKLENBQVVwd0IsUUFBTyxDQUFDbEMsR0FBRCxFQUFNd2QsTUFBTixDQUFqQixFQUFnQytDLElBQWhDLENBQUwsQ0FBakM7QUFDQTBYLG9CQUFZLENBQUNqNEIsR0FBRCxFQUFNd3lCLGtCQUFrQixDQUFDaDZCLEVBQUQsRUFBS3czQyxRQUFMLEVBQWVQLFFBQWYsQ0FBeEIsRUFBa0QzK0MsU0FBbEQsQ0FBWjtBQUNEO0FBQ0Y7O0FBRUQsUUFBSW8vQyxVQUFVLEdBQUd0ckMsT0FBTyxDQUFDaVEsT0FBUixDQUFnQmphLHFCQUFoQixFQUFqQixDQXBGb0QsQ0FxRnBEO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFFBQUl1MUMsT0FBTyxHQUFHLENBQWQ7O0FBRUEsYUFBU25pQixNQUFULENBQWdCOWlDLENBQWhCLEVBQW1CO0FBQ2pCLFVBQUlrbEQsUUFBUSxHQUFHLEVBQUVELE9BQWpCO0FBQ0EsVUFBSXg3QyxHQUFHLEdBQUdzcEIsWUFBWSxDQUFDemxCLEVBQUQsRUFBS3ROLENBQUwsRUFBUSxJQUFSLEVBQWN5akQsUUFBUSxDQUFDSCxJQUFULElBQWlCLFdBQS9CLENBQXRCOztBQUNBLFVBQUksQ0FBQzc1QyxHQUFMLEVBQVU7QUFBRTtBQUFROztBQUNwQixVQUFJZ04sR0FBRyxDQUFDaE4sR0FBRCxFQUFNZzdDLE9BQU4sQ0FBSCxJQUFxQixDQUF6QixFQUE0QjtBQUMxQm4zQyxVQUFFLENBQUNRLEtBQUgsQ0FBU3VxQixLQUFULEdBQWlCaDJCLFNBQVMsRUFBMUI7QUFDQXFpRCxnQkFBUSxDQUFDajdDLEdBQUQsQ0FBUjtBQUNBLFlBQUkwNEIsT0FBTyxHQUFHL0ksWUFBWSxDQUFDMWYsT0FBRCxFQUFVNUUsR0FBVixDQUExQjs7QUFDQSxZQUFJckwsR0FBRyxDQUFDNkMsSUFBSixJQUFZNjFCLE9BQU8sQ0FBQ3g1QixFQUFwQixJQUEwQmMsR0FBRyxDQUFDNkMsSUFBSixHQUFXNjFCLE9BQU8sQ0FBQ3o1QixJQUFqRCxFQUNFO0FBQUV4RCxvQkFBVSxDQUFDbThCLFNBQVMsQ0FBQy96QixFQUFELEVBQUssWUFBWTtBQUFDLGdCQUFJMjNDLE9BQU8sSUFBSUMsUUFBZixFQUF5QjtBQUFFcGlCLG9CQUFNLENBQUM5aUMsQ0FBRCxDQUFOO0FBQVk7QUFBQyxXQUExRCxDQUFWLEVBQXVFLEdBQXZFLENBQVY7QUFBd0Y7QUFDN0YsT0FORCxNQU1PO0FBQ0wsWUFBSTJ3QixPQUFPLEdBQUczd0IsQ0FBQyxDQUFDb3pCLE9BQUYsR0FBWTR4QixVQUFVLENBQUNsNUIsR0FBdkIsR0FBNkIsQ0FBQyxFQUE5QixHQUFtQzlyQixDQUFDLENBQUNvekIsT0FBRixHQUFZNHhCLFVBQVUsQ0FBQ241QixNQUF2QixHQUFnQyxFQUFoQyxHQUFxQyxDQUF0Rjs7QUFDQSxZQUFJOEUsT0FBSixFQUFhO0FBQUV6ckIsb0JBQVUsQ0FBQ204QixTQUFTLENBQUMvekIsRUFBRCxFQUFLLFlBQVk7QUFDbEQsZ0JBQUkyM0MsT0FBTyxJQUFJQyxRQUFmLEVBQXlCO0FBQUU7QUFBUTs7QUFDbkN4ckMsbUJBQU8sQ0FBQ3NSLFFBQVIsQ0FBaUJxRSxTQUFqQixJQUE4QnNCLE9BQTlCO0FBQ0FtUyxrQkFBTSxDQUFDOWlDLENBQUQsQ0FBTjtBQUNELFdBSmtDLENBQVYsRUFJckIsRUFKcUIsQ0FBVjtBQUlMO0FBQ1g7QUFDRjs7QUFFRCxhQUFTbXFDLElBQVQsQ0FBY25xQyxDQUFkLEVBQWlCO0FBQ2ZzTixRQUFFLENBQUNrRixLQUFILENBQVN3d0MsYUFBVCxHQUF5QixLQUF6QjtBQUNBaUMsYUFBTyxHQUFHemdDLFFBQVYsQ0FGZSxDQUdmO0FBQ0E7QUFDQTs7QUFDQSxVQUFJeGtCLENBQUosRUFBTztBQUNMbU8sd0JBQWdCLENBQUNuTyxDQUFELENBQWhCO0FBQ0EwWixlQUFPLENBQUNzSyxLQUFSLENBQWNxVSxLQUFkO0FBQ0Q7O0FBQ0RyckIsU0FBRyxDQUFDME0sT0FBTyxDQUFDaVEsT0FBUixDQUFnQnBaLGFBQWpCLEVBQWdDLFdBQWhDLEVBQTZDNDBDLElBQTdDLENBQUg7QUFDQW40QyxTQUFHLENBQUMwTSxPQUFPLENBQUNpUSxPQUFSLENBQWdCcFosYUFBakIsRUFBZ0MsU0FBaEMsRUFBMkMweEMsRUFBM0MsQ0FBSDtBQUNBbnRDLFNBQUcsQ0FBQzAyQixPQUFKLENBQVliLGFBQVosR0FBNEIsSUFBNUI7QUFDRDs7QUFFRCxRQUFJd2EsSUFBSSxHQUFHOWpCLFNBQVMsQ0FBQy96QixFQUFELEVBQUssVUFBVXROLENBQVYsRUFBYTtBQUNwQyxVQUFJQSxDQUFDLENBQUNvbEQsT0FBRixLQUFjLENBQWQsSUFBbUIsQ0FBQ3oyQyxRQUFRLENBQUMzTyxDQUFELENBQWhDLEVBQXFDO0FBQUVtcUMsWUFBSSxDQUFDbnFDLENBQUQsQ0FBSjtBQUFVLE9BQWpELE1BQ0s7QUFBRThpQyxjQUFNLENBQUM5aUMsQ0FBRCxDQUFOO0FBQVk7QUFDcEIsS0FIbUIsQ0FBcEI7QUFJQSxRQUFJaWlELEVBQUUsR0FBRzVnQixTQUFTLENBQUMvekIsRUFBRCxFQUFLNjhCLElBQUwsQ0FBbEI7QUFDQTc4QixNQUFFLENBQUNrRixLQUFILENBQVN3d0MsYUFBVCxHQUF5QmYsRUFBekI7QUFDQXgxQyxNQUFFLENBQUNpTixPQUFPLENBQUNpUSxPQUFSLENBQWdCcFosYUFBakIsRUFBZ0MsV0FBaEMsRUFBNkM0MEMsSUFBN0MsQ0FBRjtBQUNBMTRDLE1BQUUsQ0FBQ2lOLE9BQU8sQ0FBQ2lRLE9BQVIsQ0FBZ0JwWixhQUFqQixFQUFnQyxTQUFoQyxFQUEyQzB4QyxFQUEzQyxDQUFGO0FBQ0QsR0EvM09rQixDQWk0T25CO0FBQ0E7OztBQUNBLFdBQVM4QyxZQUFULENBQXNCejNDLEVBQXRCLEVBQTBCcE0sS0FBMUIsRUFBaUM7QUFDL0IsUUFBSW94QixNQUFNLEdBQUdweEIsS0FBSyxDQUFDb3hCLE1BQW5CO0FBQ0EsUUFBSStDLElBQUksR0FBR24wQixLQUFLLENBQUNtMEIsSUFBakI7QUFDQSxRQUFJZ3dCLFVBQVUsR0FBR3h3QyxPQUFPLENBQUN2SCxFQUFFLENBQUN3SCxHQUFKLEVBQVN3ZCxNQUFNLENBQUNobUIsSUFBaEIsQ0FBeEI7O0FBQ0EsUUFBSW1LLEdBQUcsQ0FBQzZiLE1BQUQsRUFBUytDLElBQVQsQ0FBSCxJQUFxQixDQUFyQixJQUEwQi9DLE1BQU0sQ0FBQzlvQixNQUFQLElBQWlCNnJCLElBQUksQ0FBQzdyQixNQUFwRCxFQUE0RDtBQUFFLGFBQU90SSxLQUFQO0FBQWM7O0FBQzVFLFFBQUkrSCxLQUFLLEdBQUdvRCxRQUFRLENBQUNnNUMsVUFBRCxDQUFwQjs7QUFDQSxRQUFJLENBQUNwOEMsS0FBTCxFQUFZO0FBQUUsYUFBTy9ILEtBQVA7QUFBYzs7QUFDNUIsUUFBSXJCLEtBQUssR0FBRzBKLGFBQWEsQ0FBQ04sS0FBRCxFQUFRcXBCLE1BQU0sQ0FBQzVxQixFQUFmLEVBQW1CNHFCLE1BQU0sQ0FBQzlvQixNQUExQixDQUF6QjtBQUFBLFFBQTRETCxJQUFJLEdBQUdGLEtBQUssQ0FBQ3BKLEtBQUQsQ0FBeEU7O0FBQ0EsUUFBSXNKLElBQUksQ0FBQ1QsSUFBTCxJQUFhNHBCLE1BQU0sQ0FBQzVxQixFQUFwQixJQUEwQnlCLElBQUksQ0FBQ1IsRUFBTCxJQUFXMnBCLE1BQU0sQ0FBQzVxQixFQUFoRCxFQUFvRDtBQUFFLGFBQU94RyxLQUFQO0FBQWM7O0FBQ3BFLFFBQUlva0QsUUFBUSxHQUFHemxELEtBQUssSUFBS3NKLElBQUksQ0FBQ1QsSUFBTCxJQUFhNHBCLE1BQU0sQ0FBQzVxQixFQUFyQixLQUE2QnlCLElBQUksQ0FBQ0UsS0FBTCxJQUFjLENBQTNDLElBQWdELENBQWhELEdBQW9ELENBQXhELENBQXBCOztBQUNBLFFBQUlpOEMsUUFBUSxJQUFJLENBQVosSUFBaUJBLFFBQVEsSUFBSXI4QyxLQUFLLENBQUNuSixNQUF2QyxFQUErQztBQUFFLGFBQU9vQixLQUFQO0FBQWMsS0FWaEMsQ0FZL0I7QUFDQTs7O0FBQ0EsUUFBSTIwQixRQUFKOztBQUNBLFFBQUlSLElBQUksQ0FBQy9vQixJQUFMLElBQWFnbUIsTUFBTSxDQUFDaG1CLElBQXhCLEVBQThCO0FBQzVCdXBCLGNBQVEsR0FBRyxDQUFDUixJQUFJLENBQUMvb0IsSUFBTCxHQUFZZ21CLE1BQU0sQ0FBQ2htQixJQUFwQixLQUE2QmdCLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT3pLLFNBQVAsSUFBb0IsS0FBcEIsR0FBNEIsQ0FBNUIsR0FBZ0MsQ0FBQyxDQUE5RCxJQUFtRSxDQUE5RTtBQUNELEtBRkQsTUFFTztBQUNMLFVBQUlrN0MsU0FBUyxHQUFHaDhDLGFBQWEsQ0FBQ04sS0FBRCxFQUFRb3NCLElBQUksQ0FBQzN0QixFQUFiLEVBQWlCMnRCLElBQUksQ0FBQzdyQixNQUF0QixDQUE3QjtBQUNBLFVBQUlsQixHQUFHLEdBQUdpOUMsU0FBUyxHQUFHMWxELEtBQVosSUFBcUIsQ0FBQ3cxQixJQUFJLENBQUMzdEIsRUFBTCxHQUFVNHFCLE1BQU0sQ0FBQzVxQixFQUFsQixLQUF5QnlCLElBQUksQ0FBQ0UsS0FBTCxJQUFjLENBQWQsR0FBa0IsQ0FBQyxDQUFuQixHQUF1QixDQUFoRCxDQUEvQjs7QUFDQSxVQUFJazhDLFNBQVMsSUFBSUQsUUFBUSxHQUFHLENBQXhCLElBQTZCQyxTQUFTLElBQUlELFFBQTlDLEVBQ0U7QUFBRXp2QixnQkFBUSxHQUFHdnRCLEdBQUcsR0FBRyxDQUFqQjtBQUFxQixPQUR6QixNQUdFO0FBQUV1dEIsZ0JBQVEsR0FBR3Z0QixHQUFHLEdBQUcsQ0FBakI7QUFBcUI7QUFDMUI7O0FBRUQsUUFBSWs5QyxPQUFPLEdBQUd2OEMsS0FBSyxDQUFDcThDLFFBQVEsSUFBSXp2QixRQUFRLEdBQUcsQ0FBQyxDQUFKLEdBQVEsQ0FBcEIsQ0FBVCxDQUFuQjtBQUNBLFFBQUludEIsSUFBSSxHQUFHbXRCLFFBQVEsS0FBSzJ2QixPQUFPLENBQUNuOEMsS0FBUixJQUFpQixDQUF0QixDQUFuQjtBQUNBLFFBQUkzQixFQUFFLEdBQUdnQixJQUFJLEdBQUc4OEMsT0FBTyxDQUFDOThDLElBQVgsR0FBa0I4OEMsT0FBTyxDQUFDNzhDLEVBQXZDO0FBQUEsUUFBMkNhLE1BQU0sR0FBR2QsSUFBSSxHQUFHLE9BQUgsR0FBYSxRQUFyRTtBQUNBLFdBQU80cEIsTUFBTSxDQUFDNXFCLEVBQVAsSUFBYUEsRUFBYixJQUFtQjRxQixNQUFNLENBQUM5b0IsTUFBUCxJQUFpQkEsTUFBcEMsR0FBNkN0SSxLQUE3QyxHQUFxRCxJQUFJa21DLEtBQUosQ0FBVSxJQUFJNXdCLEdBQUosQ0FBUThiLE1BQU0sQ0FBQ2htQixJQUFmLEVBQXFCNUUsRUFBckIsRUFBeUI4QixNQUF6QixDQUFWLEVBQTRDNnJCLElBQTVDLENBQTVEO0FBQ0QsR0FqNk9rQixDQW82T25CO0FBQ0E7OztBQUNBLFdBQVNvd0IsV0FBVCxDQUFxQm40QyxFQUFyQixFQUF5QnROLENBQXpCLEVBQTRCMkssSUFBNUIsRUFBa0MrNkMsT0FBbEMsRUFBMkM7QUFDekMsUUFBSUMsRUFBSixFQUFRQyxFQUFSOztBQUNBLFFBQUk1bEQsQ0FBQyxDQUFDNmxELE9BQU4sRUFBZTtBQUNiRixRQUFFLEdBQUczbEQsQ0FBQyxDQUFDNmxELE9BQUYsQ0FBVSxDQUFWLEVBQWExeUIsT0FBbEI7QUFDQXl5QixRQUFFLEdBQUc1bEQsQ0FBQyxDQUFDNmxELE9BQUYsQ0FBVSxDQUFWLEVBQWF6eUIsT0FBbEI7QUFDRCxLQUhELE1BR087QUFDTCxVQUFJO0FBQUV1eUIsVUFBRSxHQUFHM2xELENBQUMsQ0FBQ216QixPQUFQO0FBQWdCeXlCLFVBQUUsR0FBRzVsRCxDQUFDLENBQUNvekIsT0FBUDtBQUFpQixPQUF2QyxDQUNBLE9BQU1DLEdBQU4sRUFBVztBQUFFLGVBQU8sS0FBUDtBQUFjO0FBQzVCOztBQUNELFFBQUlzeUIsRUFBRSxJQUFJdi9DLElBQUksQ0FBQzJDLEtBQUwsQ0FBV3VFLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV2dRLE9BQVgsQ0FBbUJoYSxxQkFBbkIsR0FBMkNHLEtBQXRELENBQVYsRUFBd0U7QUFBRSxhQUFPLEtBQVA7QUFBYzs7QUFDeEYsUUFBSTYxQyxPQUFKLEVBQWE7QUFBRXYzQyxzQkFBZ0IsQ0FBQ25PLENBQUQsQ0FBaEI7QUFBc0I7O0FBRXJDLFFBQUkwWixPQUFPLEdBQUdwTSxFQUFFLENBQUNvTSxPQUFqQjtBQUNBLFFBQUlvc0MsT0FBTyxHQUFHcHNDLE9BQU8sQ0FBQ3NmLE9BQVIsQ0FBZ0J0cEIscUJBQWhCLEVBQWQ7O0FBRUEsUUFBSWsyQyxFQUFFLEdBQUdFLE9BQU8sQ0FBQ2o2QixNQUFiLElBQXVCLENBQUM3ZCxVQUFVLENBQUNWLEVBQUQsRUFBSzNDLElBQUwsQ0FBdEMsRUFBa0Q7QUFBRSxhQUFPK0Msa0JBQWtCLENBQUMxTixDQUFELENBQXpCO0FBQThCOztBQUNsRjRsRCxNQUFFLElBQUlFLE9BQU8sQ0FBQ2g2QixHQUFSLEdBQWNwUyxPQUFPLENBQUNnVyxVQUE1Qjs7QUFFQSxTQUFLLElBQUkzdUIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VNLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3lPLFdBQVgsQ0FBdUJyb0IsTUFBM0MsRUFBbUQsRUFBRWlCLENBQXJELEVBQXdEO0FBQ3RELFVBQUlnbEQsQ0FBQyxHQUFHcnNDLE9BQU8sQ0FBQ2dRLE9BQVIsQ0FBZ0J4cEIsVUFBaEIsQ0FBMkJhLENBQTNCLENBQVI7O0FBQ0EsVUFBSWdsRCxDQUFDLElBQUlBLENBQUMsQ0FBQ3IyQyxxQkFBRixHQUEwQkcsS0FBMUIsSUFBbUM4MUMsRUFBNUMsRUFBZ0Q7QUFDOUMsWUFBSXI1QyxJQUFJLEdBQUd5SixhQUFZLENBQUN6SSxFQUFFLENBQUN3SCxHQUFKLEVBQVM4d0MsRUFBVCxDQUF2Qjs7QUFDQSxZQUFJditCLE1BQU0sR0FBRy9aLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3lPLFdBQVgsQ0FBdUJwbkIsQ0FBdkIsQ0FBYjtBQUNBb00sY0FBTSxDQUFDRyxFQUFELEVBQUszQyxJQUFMLEVBQVcyQyxFQUFYLEVBQWVoQixJQUFmLEVBQXFCK2EsTUFBTSxDQUFDM25CLFNBQTVCLEVBQXVDTSxDQUF2QyxDQUFOO0FBQ0EsZUFBTzBOLGtCQUFrQixDQUFDMU4sQ0FBRCxDQUF6QjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxXQUFTOGlELGFBQVQsQ0FBdUJ4MUMsRUFBdkIsRUFBMkJ0TixDQUEzQixFQUE4QjtBQUM1QixXQUFPeWxELFdBQVcsQ0FBQ240QyxFQUFELEVBQUt0TixDQUFMLEVBQVEsYUFBUixFQUF1QixJQUF2QixDQUFsQjtBQUNELEdBcjhPa0IsQ0F1OE9uQjtBQUVBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU21qRCxhQUFULENBQXVCNzFDLEVBQXZCLEVBQTJCdE4sQ0FBM0IsRUFBOEI7QUFDNUIsUUFBSTZwQixhQUFhLENBQUN2YyxFQUFFLENBQUNvTSxPQUFKLEVBQWExWixDQUFiLENBQWIsSUFBZ0NnbUQsbUJBQW1CLENBQUMxNEMsRUFBRCxFQUFLdE4sQ0FBTCxDQUF2RCxFQUFnRTtBQUFFO0FBQVE7O0FBQzFFLFFBQUlxTixjQUFjLENBQUNDLEVBQUQsRUFBS3ROLENBQUwsRUFBUSxhQUFSLENBQWxCLEVBQTBDO0FBQUU7QUFBUTs7QUFDcEQsUUFBSSxDQUFDYixpQkFBTCxFQUF3QjtBQUFFbU8sUUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQm0vQixhQUFqQixDQUErQm5qRCxDQUEvQjtBQUFvQztBQUMvRDs7QUFFRCxXQUFTZ21ELG1CQUFULENBQTZCMTRDLEVBQTdCLEVBQWlDdE4sQ0FBakMsRUFBb0M7QUFDbEMsUUFBSSxDQUFDZ08sVUFBVSxDQUFDVixFQUFELEVBQUssbUJBQUwsQ0FBZixFQUEwQztBQUFFLGFBQU8sS0FBUDtBQUFjOztBQUMxRCxXQUFPbTRDLFdBQVcsQ0FBQ240QyxFQUFELEVBQUt0TixDQUFMLEVBQVEsbUJBQVIsRUFBNkIsS0FBN0IsQ0FBbEI7QUFDRDs7QUFFRCxXQUFTaW1ELFlBQVQsQ0FBc0IzNEMsRUFBdEIsRUFBMEI7QUFDeEJBLE1BQUUsQ0FBQ29NLE9BQUgsQ0FBV2lRLE9BQVgsQ0FBbUJqcUIsU0FBbkIsR0FBK0I0TixFQUFFLENBQUNvTSxPQUFILENBQVdpUSxPQUFYLENBQW1CanFCLFNBQW5CLENBQTZCeUwsT0FBN0IsQ0FBcUMsY0FBckMsRUFBcUQsRUFBckQsSUFDN0JtQyxFQUFFLENBQUN1RSxPQUFILENBQVdxMEMsS0FBWCxDQUFpQi82QyxPQUFqQixDQUF5QixZQUF6QixFQUF1QyxRQUF2QyxDQURGO0FBRUF1akIsZUFBVyxDQUFDcGhCLEVBQUQsQ0FBWDtBQUNEOztBQUVELE1BQUk2NEMsSUFBSSxHQUFHO0FBQUMxZ0QsWUFBUSxFQUFFLG9CQUFVO0FBQUMsYUFBTyxpQkFBUDtBQUF5QjtBQUEvQyxHQUFYO0FBRUEsTUFBSTJnRCxRQUFRLEdBQUcsRUFBZjtBQUNBLE1BQUlDLGNBQWMsR0FBRyxFQUFyQjs7QUFFQSxXQUFTQyxhQUFULENBQXVCbFAsVUFBdkIsRUFBbUM7QUFDakMsUUFBSWlQLGNBQWMsR0FBR2pQLFVBQVUsQ0FBQ2lQLGNBQWhDOztBQUVBLGFBQVNoRCxNQUFULENBQWdCaHlDLElBQWhCLEVBQXNCazFDLEtBQXRCLEVBQTZCMVYsTUFBN0IsRUFBcUMyVixTQUFyQyxFQUFnRDtBQUM5Q3BQLGdCQUFVLENBQUNnUCxRQUFYLENBQW9CLzBDLElBQXBCLElBQTRCazFDLEtBQTVCOztBQUNBLFVBQUkxVixNQUFKLEVBQVk7QUFBRXdWLHNCQUFjLENBQUNoMUMsSUFBRCxDQUFkLEdBQ1ptMUMsU0FBUyxHQUFHLFVBQVVsNUMsRUFBVixFQUFjb0YsR0FBZCxFQUFtQjBKLEdBQW5CLEVBQXdCO0FBQUMsY0FBSUEsR0FBRyxJQUFJK3BDLElBQVgsRUFBaUI7QUFBRXRWLGtCQUFNLENBQUN2akMsRUFBRCxFQUFLb0YsR0FBTCxFQUFVMEosR0FBVixDQUFOO0FBQXVCO0FBQUMsU0FBdkUsR0FBMEV5MEIsTUFEdkU7QUFDZ0Y7QUFDL0Y7O0FBRUR1RyxjQUFVLENBQUNxUCxZQUFYLEdBQTBCcEQsTUFBMUIsQ0FUaUMsQ0FXakM7O0FBQ0FqTSxjQUFVLENBQUMrTyxJQUFYLEdBQWtCQSxJQUFsQixDQVppQyxDQWNqQztBQUNBOztBQUNBOUMsVUFBTSxDQUFDLE9BQUQsRUFBVSxFQUFWLEVBQWMsVUFBVS8xQyxFQUFWLEVBQWNvRixHQUFkLEVBQW1CO0FBQUUsYUFBT3BGLEVBQUUsQ0FBQzhtQyxRQUFILENBQVkxaEMsR0FBWixDQUFQO0FBQTBCLEtBQTdELEVBQStELElBQS9ELENBQU47QUFDQTJ3QyxVQUFNLENBQUMsTUFBRCxFQUFTLElBQVQsRUFBZSxVQUFVLzFDLEVBQVYsRUFBY29GLEdBQWQsRUFBbUI7QUFDdENwRixRQUFFLENBQUN3SCxHQUFILENBQU93ekIsVUFBUCxHQUFvQjUxQixHQUFwQjtBQUNBMjFCLGNBQVEsQ0FBQy82QixFQUFELENBQVI7QUFDRCxLQUhLLEVBR0gsSUFIRyxDQUFOO0FBS0ErMUMsVUFBTSxDQUFDLFlBQUQsRUFBZSxDQUFmLEVBQWtCaGIsUUFBbEIsRUFBNEIsSUFBNUIsQ0FBTjtBQUNBZ2IsVUFBTSxDQUFDLGdCQUFELEVBQW1CLEtBQW5CLENBQU47QUFDQUEsVUFBTSxDQUFDLGFBQUQsRUFBZ0IsSUFBaEIsQ0FBTjtBQUNBQSxVQUFNLENBQUMsU0FBRCxFQUFZLENBQVosRUFBZSxVQUFVLzFDLEVBQVYsRUFBYztBQUNqQ2k3QixvQkFBYyxDQUFDajdCLEVBQUQsQ0FBZDtBQUNBb2hCLGlCQUFXLENBQUNwaEIsRUFBRCxDQUFYO0FBQ0FrbUIsZUFBUyxDQUFDbG1CLEVBQUQsQ0FBVDtBQUNELEtBSkssRUFJSCxJQUpHLENBQU47QUFNQSsxQyxVQUFNLENBQUMsZUFBRCxFQUFrQixJQUFsQixFQUF3QixVQUFVLzFDLEVBQVYsRUFBY29GLEdBQWQsRUFBbUI7QUFDL0NwRixRQUFFLENBQUN3SCxHQUFILENBQU9nL0IsT0FBUCxHQUFpQnBoQyxHQUFqQjs7QUFDQSxVQUFJLENBQUNBLEdBQUwsRUFBVTtBQUFFO0FBQVE7O0FBQ3BCLFVBQUlnMEMsU0FBUyxHQUFHLEVBQWhCO0FBQUEsVUFBb0I3d0MsTUFBTSxHQUFHdkksRUFBRSxDQUFDd0gsR0FBSCxDQUFPQyxLQUFwQztBQUNBekgsUUFBRSxDQUFDd0gsR0FBSCxDQUFPVSxJQUFQLENBQVksVUFBVWxKLElBQVYsRUFBZ0I7QUFDMUIsYUFBSyxJQUFJckcsR0FBRyxHQUFHLENBQWYsSUFBb0I7QUFDbEIsY0FBSWlELEtBQUssR0FBR29ELElBQUksQ0FBQ0MsSUFBTCxDQUFVN0gsT0FBVixDQUFrQmdPLEdBQWxCLEVBQXVCek0sR0FBdkIsQ0FBWjs7QUFDQSxjQUFJaUQsS0FBSyxJQUFJLENBQUMsQ0FBZCxFQUFpQjtBQUFFO0FBQU87O0FBQzFCakQsYUFBRyxHQUFHaUQsS0FBSyxHQUFHd0osR0FBRyxDQUFDNVMsTUFBbEI7QUFDQTRtRCxtQkFBUyxDQUFDbGdELElBQVYsQ0FBZWdRLEdBQUcsQ0FBQ1gsTUFBRCxFQUFTM00sS0FBVCxDQUFsQjtBQUNEOztBQUNEMk0sY0FBTTtBQUNQLE9BUkQ7O0FBU0EsV0FBSyxJQUFJOVUsQ0FBQyxHQUFHMmxELFNBQVMsQ0FBQzVtRCxNQUFWLEdBQW1CLENBQWhDLEVBQW1DaUIsQ0FBQyxJQUFJLENBQXhDLEVBQTJDQSxDQUFDLEVBQTVDLEVBQ0U7QUFBRXN2QyxxQkFBWSxDQUFDL2lDLEVBQUUsQ0FBQ3dILEdBQUosRUFBU3BDLEdBQVQsRUFBY2cwQyxTQUFTLENBQUMzbEQsQ0FBRCxDQUF2QixFQUE0QnlWLEdBQUcsQ0FBQ2t3QyxTQUFTLENBQUMzbEQsQ0FBRCxDQUFULENBQWF1TCxJQUFkLEVBQW9CbzZDLFNBQVMsQ0FBQzNsRCxDQUFELENBQVQsQ0FBYTJHLEVBQWIsR0FBa0JnTCxHQUFHLENBQUM1UyxNQUExQyxDQUEvQixDQUFaO0FBQWdHO0FBQ3JHLEtBZkssQ0FBTjtBQWdCQXVqRCxVQUFNLENBQUMsY0FBRCxFQUFpQixtR0FBakIsRUFBc0gsVUFBVS8xQyxFQUFWLEVBQWNvRixHQUFkLEVBQW1CMEosR0FBbkIsRUFBd0I7QUFDbEo5TyxRQUFFLENBQUNrRixLQUFILENBQVMwUSxZQUFULEdBQXdCLElBQUk1akIsTUFBSixDQUFXb1QsR0FBRyxDQUFDM0ssTUFBSixJQUFjMkssR0FBRyxDQUFDblYsSUFBSixDQUFTLElBQVQsSUFBaUIsRUFBakIsR0FBc0IsS0FBcEMsQ0FBWCxFQUF1RCxHQUF2RCxDQUF4Qjs7QUFDQSxVQUFJNmUsR0FBRyxJQUFJK3BDLElBQVgsRUFBaUI7QUFBRTc0QyxVQUFFLENBQUNxNUMsT0FBSDtBQUFlO0FBQ25DLEtBSEssQ0FBTjtBQUlBdEQsVUFBTSxDQUFDLHdCQUFELEVBQTJCM2dDLDZCQUEzQixFQUEwRCxVQUFVcFYsRUFBVixFQUFjO0FBQUUsYUFBT0EsRUFBRSxDQUFDcTVDLE9BQUgsRUFBUDtBQUFzQixLQUFoRyxFQUFrRyxJQUFsRyxDQUFOO0FBQ0F0RCxVQUFNLENBQUMsZUFBRCxFQUFrQixJQUFsQixDQUFOO0FBQ0FBLFVBQU0sQ0FBQyxZQUFELEVBQWUxa0QsTUFBTSxHQUFHLGlCQUFILEdBQXVCLFVBQTVDLEVBQXdELFlBQVk7QUFDeEUsWUFBTSxJQUFJc1csS0FBSixDQUFVLHlEQUFWLENBQU4sQ0FEd0UsQ0FDRztBQUM1RSxLQUZLLEVBRUgsSUFGRyxDQUFOO0FBR0FvdUMsVUFBTSxDQUFDLFlBQUQsRUFBZSxLQUFmLEVBQXNCLFVBQVUvMUMsRUFBVixFQUFjb0YsR0FBZCxFQUFtQjtBQUFFLGFBQU9wRixFQUFFLENBQUNzNUMsYUFBSCxHQUFtQkMsVUFBbkIsR0FBZ0NuMEMsR0FBdkM7QUFBNkMsS0FBeEYsRUFBMEYsSUFBMUYsQ0FBTjtBQUNBMndDLFVBQU0sQ0FBQyxhQUFELEVBQWdCLEtBQWhCLEVBQXVCLFVBQVUvMUMsRUFBVixFQUFjb0YsR0FBZCxFQUFtQjtBQUFFLGFBQU9wRixFQUFFLENBQUNzNUMsYUFBSCxHQUFtQkUsV0FBbkIsR0FBaUNwMEMsR0FBeEM7QUFBOEMsS0FBMUYsRUFBNEYsSUFBNUYsQ0FBTjtBQUNBMndDLFVBQU0sQ0FBQyxnQkFBRCxFQUFtQixLQUFuQixFQUEwQixVQUFVLzFDLEVBQVYsRUFBY29GLEdBQWQsRUFBbUI7QUFBRSxhQUFPcEYsRUFBRSxDQUFDczVDLGFBQUgsR0FBbUJHLGNBQW5CLEdBQW9DcjBDLEdBQTNDO0FBQWlELEtBQWhHLEVBQWtHLElBQWxHLENBQU47QUFDQTJ3QyxVQUFNLENBQUMsaUJBQUQsRUFBb0IsQ0FBQ3ZrRCxPQUFyQixDQUFOO0FBQ0F1a0QsVUFBTSxDQUFDLHVCQUFELEVBQTBCLElBQTFCLENBQU47QUFFQUEsVUFBTSxDQUFDLE9BQUQsRUFBVSxTQUFWLEVBQXFCLFVBQVUvMUMsRUFBVixFQUFjO0FBQ3ZDMjRDLGtCQUFZLENBQUMzNEMsRUFBRCxDQUFaO0FBQ0E4M0IsbUJBQWEsQ0FBQzkzQixFQUFELENBQWI7QUFDRCxLQUhLLEVBR0gsSUFIRyxDQUFOO0FBSUErMUMsVUFBTSxDQUFDLFFBQUQsRUFBVyxTQUFYLEVBQXNCLFVBQVUvMUMsRUFBVixFQUFjb0YsR0FBZCxFQUFtQjBKLEdBQW5CLEVBQXdCO0FBQ2xELFVBQUkzSSxJQUFJLEdBQUc0bkMsU0FBUyxDQUFDM29DLEdBQUQsQ0FBcEI7QUFDQSxVQUFJaEksSUFBSSxHQUFHMFIsR0FBRyxJQUFJK3BDLElBQVAsSUFBZTlLLFNBQVMsQ0FBQ2ovQixHQUFELENBQW5DOztBQUNBLFVBQUkxUixJQUFJLElBQUlBLElBQUksQ0FBQ3M4QyxNQUFqQixFQUF5QjtBQUFFdDhDLFlBQUksQ0FBQ3M4QyxNQUFMLENBQVkxNUMsRUFBWixFQUFnQm1HLElBQWhCO0FBQXdCOztBQUNuRCxVQUFJQSxJQUFJLENBQUN3ekMsTUFBVCxFQUFpQjtBQUFFeHpDLFlBQUksQ0FBQ3d6QyxNQUFMLENBQVkzNUMsRUFBWixFQUFnQjVDLElBQUksSUFBSSxJQUF4QjtBQUFnQztBQUNwRCxLQUxLLENBQU47QUFNQTI0QyxVQUFNLENBQUMsV0FBRCxFQUFjLElBQWQsQ0FBTjtBQUNBQSxVQUFNLENBQUMsZ0JBQUQsRUFBbUIsSUFBbkIsQ0FBTjtBQUVBQSxVQUFNLENBQUMsY0FBRCxFQUFpQixLQUFqQixFQUF3QjZELGVBQXhCLEVBQXlDLElBQXpDLENBQU47QUFDQTdELFVBQU0sQ0FBQyxTQUFELEVBQVksRUFBWixFQUFnQixVQUFVLzFDLEVBQVYsRUFBY29GLEdBQWQsRUFBbUI7QUFDdkNwRixRQUFFLENBQUNvTSxPQUFILENBQVd5TyxXQUFYLEdBQXlCNGMsVUFBVSxDQUFDcnlCLEdBQUQsRUFBTXBGLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVytWLFdBQWpCLENBQW5DO0FBQ0F3ZCxtQkFBYSxDQUFDOTNCLEVBQUQsQ0FBYjtBQUNELEtBSEssRUFHSCxJQUhHLENBQU47QUFJQSsxQyxVQUFNLENBQUMsYUFBRCxFQUFnQixJQUFoQixFQUFzQixVQUFVLzFDLEVBQVYsRUFBY29GLEdBQWQsRUFBbUI7QUFDN0NwRixRQUFFLENBQUNvTSxPQUFILENBQVdnUSxPQUFYLENBQW1CL29CLEtBQW5CLENBQXlCaVAsSUFBekIsR0FBZ0M4QyxHQUFHLEdBQUcrZixvQkFBb0IsQ0FBQ25sQixFQUFFLENBQUNvTSxPQUFKLENBQXBCLEdBQW1DLElBQXRDLEdBQTZDLEdBQWhGO0FBQ0FwTSxRQUFFLENBQUNxNUMsT0FBSDtBQUNELEtBSEssRUFHSCxJQUhHLENBQU47QUFJQXRELFVBQU0sQ0FBQyw0QkFBRCxFQUErQixLQUEvQixFQUFzQyxVQUFVLzFDLEVBQVYsRUFBYztBQUFFLGFBQU8rd0IsZ0JBQWdCLENBQUMvd0IsRUFBRCxDQUF2QjtBQUE4QixLQUFwRixFQUFzRixJQUF0RixDQUFOO0FBQ0ErMUMsVUFBTSxDQUFDLGdCQUFELEVBQW1CLFFBQW5CLEVBQTZCLFVBQVUvMUMsRUFBVixFQUFjO0FBQy9DMnhCLG9CQUFjLENBQUMzeEIsRUFBRCxDQUFkO0FBQ0Erd0Isc0JBQWdCLENBQUMvd0IsRUFBRCxDQUFoQjtBQUNBQSxRQUFFLENBQUNvTSxPQUFILENBQVd3aUIsVUFBWCxDQUFzQkosWUFBdEIsQ0FBbUN4dUIsRUFBRSxDQUFDd0gsR0FBSCxDQUFPdWEsU0FBMUM7QUFDQS9oQixRQUFFLENBQUNvTSxPQUFILENBQVd3aUIsVUFBWCxDQUFzQjFCLGFBQXRCLENBQW9DbHRCLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT21hLFVBQTNDO0FBQ0QsS0FMSyxFQUtILElBTEcsQ0FBTjtBQU1BbzBCLFVBQU0sQ0FBQyxhQUFELEVBQWdCLEtBQWhCLEVBQXVCLFVBQVUvMUMsRUFBVixFQUFjb0YsR0FBZCxFQUFtQjtBQUM5Q3BGLFFBQUUsQ0FBQ29NLE9BQUgsQ0FBV3lPLFdBQVgsR0FBeUI0YyxVQUFVLENBQUN6M0IsRUFBRSxDQUFDdUUsT0FBSCxDQUFXNlgsT0FBWixFQUFxQmhYLEdBQXJCLENBQW5DO0FBQ0EweUIsbUJBQWEsQ0FBQzkzQixFQUFELENBQWI7QUFDRCxLQUhLLEVBR0gsSUFIRyxDQUFOO0FBSUErMUMsVUFBTSxDQUFDLGlCQUFELEVBQW9CLENBQXBCLEVBQXVCamUsYUFBdkIsRUFBc0MsSUFBdEMsQ0FBTjtBQUNBaWUsVUFBTSxDQUFDLHFCQUFELEVBQXdCLFVBQVU4RCxPQUFWLEVBQW1CO0FBQUUsYUFBT0EsT0FBUDtBQUFpQixLQUE5RCxFQUFnRS9oQixhQUFoRSxFQUErRSxJQUEvRSxDQUFOO0FBQ0FpZSxVQUFNLENBQUMseUJBQUQsRUFBNEIsS0FBNUIsRUFBbUM3dUIsZUFBbkMsRUFBb0QsSUFBcEQsQ0FBTjtBQUVBNnVCLFVBQU0sQ0FBQyw2QkFBRCxFQUFnQyxJQUFoQyxDQUFOO0FBQ0FBLFVBQU0sQ0FBQyxpQkFBRCxFQUFvQixJQUFwQixDQUFOO0FBQ0FBLFVBQU0sQ0FBQyx3QkFBRCxFQUEyQixJQUEzQixDQUFOO0FBQ0FBLFVBQU0sQ0FBQyxvQkFBRCxFQUF1QixLQUF2QixDQUFOO0FBRUFBLFVBQU0sQ0FBQyxVQUFELEVBQWEsS0FBYixFQUFvQixVQUFVLzFDLEVBQVYsRUFBY29GLEdBQWQsRUFBbUI7QUFDM0MsVUFBSUEsR0FBRyxJQUFJLFVBQVgsRUFBdUI7QUFDckJ5bEIsY0FBTSxDQUFDN3FCLEVBQUQsQ0FBTjtBQUNBQSxVQUFFLENBQUNvTSxPQUFILENBQVdzSyxLQUFYLENBQWlCb2pDLElBQWpCO0FBQ0Q7O0FBQ0Q5NUMsUUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQnFqQyxlQUFqQixDQUFpQzMwQyxHQUFqQztBQUNELEtBTkssQ0FBTjtBQVFBMndDLFVBQU0sQ0FBQyxtQkFBRCxFQUFzQixJQUF0QixFQUE0QixVQUFVLzFDLEVBQVYsRUFBY29GLEdBQWQsRUFBbUI7QUFDbkRBLFNBQUcsR0FBSUEsR0FBRyxLQUFLLEVBQVQsR0FBZSxJQUFmLEdBQXNCQSxHQUE1QjtBQUNBcEYsUUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQnNqQyx3QkFBakIsQ0FBMEM1MEMsR0FBMUM7QUFDRCxLQUhLLENBQU47QUFLQTJ3QyxVQUFNLENBQUMsY0FBRCxFQUFpQixLQUFqQixFQUF3QixVQUFVLzFDLEVBQVYsRUFBY29GLEdBQWQsRUFBbUI7QUFBQyxVQUFJLENBQUNBLEdBQUwsRUFBVTtBQUFFcEYsVUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQjJVLEtBQWpCO0FBQTJCO0FBQUMsS0FBcEYsRUFBc0YsSUFBdEYsQ0FBTjtBQUNBMHFCLFVBQU0sQ0FBQyxVQUFELEVBQWEsSUFBYixFQUFtQmtFLGVBQW5CLENBQU47QUFDQWxFLFVBQU0sQ0FBQyxvQkFBRCxFQUF1QixJQUF2QixDQUFOO0FBRUFBLFVBQU0sQ0FBQyxpQkFBRCxFQUFvQixHQUFwQixDQUFOO0FBQ0FBLFVBQU0sQ0FBQyxvQkFBRCxFQUF1QixDQUF2QixDQUFOO0FBQ0FBLFVBQU0sQ0FBQyxjQUFELEVBQWlCLENBQWpCLEVBQW9CN3VCLGVBQXBCLEVBQXFDLElBQXJDLENBQU47QUFDQTZ1QixVQUFNLENBQUMsMkJBQUQsRUFBOEIsSUFBOUIsRUFBb0M3dUIsZUFBcEMsRUFBcUQsSUFBckQsQ0FBTjtBQUNBNnVCLFVBQU0sQ0FBQyxVQUFELEVBQWEsR0FBYixDQUFOO0FBQ0FBLFVBQU0sQ0FBQyxXQUFELEVBQWMsR0FBZCxDQUFOO0FBQ0FBLFVBQU0sQ0FBQyxjQUFELEVBQWlCLElBQWpCLEVBQXVCOWEsY0FBdkIsRUFBdUMsSUFBdkMsQ0FBTjtBQUNBOGEsVUFBTSxDQUFDLGNBQUQsRUFBaUIsS0FBakIsRUFBd0I5YSxjQUF4QixFQUF3QyxJQUF4QyxDQUFOO0FBQ0E4YSxVQUFNLENBQUMsY0FBRCxFQUFpQixHQUFqQixDQUFOO0FBQ0FBLFVBQU0sQ0FBQyxXQUFELEVBQWMsR0FBZCxFQUFtQixVQUFVLzFDLEVBQVYsRUFBY29GLEdBQWQsRUFBbUI7QUFBRSxhQUFPcEYsRUFBRSxDQUFDd0gsR0FBSCxDQUFPMDJCLE9BQVAsQ0FBZW5CLFNBQWYsR0FBMkIzM0IsR0FBbEM7QUFBd0MsS0FBaEYsQ0FBTjtBQUNBMndDLFVBQU0sQ0FBQyxtQkFBRCxFQUFzQixJQUF0QixDQUFOO0FBQ0FBLFVBQU0sQ0FBQyxnQkFBRCxFQUFtQixFQUFuQixFQUF1QixVQUFVLzFDLEVBQVYsRUFBYztBQUFFLGFBQU9BLEVBQUUsQ0FBQ3E1QyxPQUFILEVBQVA7QUFBc0IsS0FBN0QsRUFBK0QsSUFBL0QsQ0FBTjtBQUNBdEQsVUFBTSxDQUFDLG9CQUFELEVBQXVCLEtBQXZCLEVBQThCOWEsY0FBOUIsRUFBOEMsSUFBOUMsQ0FBTjtBQUNBOGEsVUFBTSxDQUFDLHFCQUFELEVBQXdCLElBQXhCLEVBQThCLFVBQVUvMUMsRUFBVixFQUFjb0YsR0FBZCxFQUFtQjtBQUNyRCxVQUFJLENBQUNBLEdBQUwsRUFBVTtBQUFFcEYsVUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQndqQyxhQUFqQjtBQUFtQztBQUNoRCxLQUZLLENBQU47QUFJQW5FLFVBQU0sQ0FBQyxVQUFELEVBQWEsSUFBYixFQUFtQixVQUFVLzFDLEVBQVYsRUFBY29GLEdBQWQsRUFBbUI7QUFBRSxhQUFPcEYsRUFBRSxDQUFDb00sT0FBSCxDQUFXc0ssS0FBWCxDQUFpQjg5QixRQUFqQixHQUE0QjlrQixRQUE1QixHQUF1Q3RxQixHQUFHLElBQUksRUFBckQ7QUFBMEQsS0FBbEcsQ0FBTjtBQUNBMndDLFVBQU0sQ0FBQyxXQUFELEVBQWMsSUFBZCxDQUFOO0FBQ0FBLFVBQU0sQ0FBQyxXQUFELEVBQWMsS0FBZCxFQUFxQixVQUFVLzFDLEVBQVYsRUFBY29GLEdBQWQsRUFBbUI7QUFBRSxhQUFPcEYsRUFBRSxDQUFDd0gsR0FBSCxDQUFPMmlDLFlBQVAsQ0FBb0Iva0MsR0FBcEIsQ0FBUDtBQUFrQyxLQUE1RSxFQUE4RSxJQUE5RSxDQUFOO0FBQ0Eyd0MsVUFBTSxDQUFDLFNBQUQsRUFBWSxJQUFaLENBQU47QUFDRDs7QUFFRCxXQUFTa0UsZUFBVCxDQUF5Qmo2QyxFQUF6QixFQUE2QnBLLEtBQTdCLEVBQW9Da1osR0FBcEMsRUFBeUM7QUFDdkMsUUFBSXFyQyxLQUFLLEdBQUdyckMsR0FBRyxJQUFJQSxHQUFHLElBQUkrcEMsSUFBMUI7O0FBQ0EsUUFBSSxDQUFDampELEtBQUQsSUFBVSxDQUFDdWtELEtBQWYsRUFBc0I7QUFDcEIsVUFBSUMsS0FBSyxHQUFHcDZDLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV2l1QyxhQUF2QjtBQUNBLFVBQUlDLE1BQU0sR0FBRzFrRCxLQUFLLEdBQUd1SixFQUFILEdBQVFPLEdBQTFCO0FBQ0E0NkMsWUFBTSxDQUFDdDZDLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NSLFFBQVosRUFBc0IsV0FBdEIsRUFBbUMwOEIsS0FBSyxDQUFDdG1ELEtBQXpDLENBQU47QUFDQXdtRCxZQUFNLENBQUN0NkMsRUFBRSxDQUFDb00sT0FBSCxDQUFXc1IsUUFBWixFQUFzQixXQUF0QixFQUFtQzA4QixLQUFLLENBQUNHLEtBQXpDLENBQU47QUFDQUQsWUFBTSxDQUFDdDZDLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NSLFFBQVosRUFBc0IsVUFBdEIsRUFBa0MwOEIsS0FBSyxDQUFDSSxJQUF4QyxDQUFOO0FBQ0FGLFlBQU0sQ0FBQ3Q2QyxFQUFFLENBQUNvTSxPQUFILENBQVdzUixRQUFaLEVBQXNCLFdBQXRCLEVBQW1DMDhCLEtBQUssQ0FBQ0ssS0FBekMsQ0FBTjtBQUNBSCxZQUFNLENBQUN0NkMsRUFBRSxDQUFDb00sT0FBSCxDQUFXc1IsUUFBWixFQUFzQixNQUF0QixFQUE4QjA4QixLQUFLLENBQUNNLElBQXBDLENBQU47QUFDRDtBQUNGOztBQUVELFdBQVNkLGVBQVQsQ0FBeUI1NUMsRUFBekIsRUFBNkI7QUFDM0IsUUFBSUEsRUFBRSxDQUFDdUUsT0FBSCxDQUFXMlosWUFBZixFQUE2QjtBQUMzQmhwQixjQUFRLENBQUM4SyxFQUFFLENBQUNvTSxPQUFILENBQVdpUSxPQUFaLEVBQXFCLGlCQUFyQixDQUFSO0FBQ0FyYyxRQUFFLENBQUNvTSxPQUFILENBQVdxUSxLQUFYLENBQWlCcHBCLEtBQWpCLENBQXVCdzhCLFFBQXZCLEdBQWtDLEVBQWxDO0FBQ0E3dkIsUUFBRSxDQUFDb00sT0FBSCxDQUFXcWMsVUFBWCxHQUF3QixJQUF4QjtBQUNELEtBSkQsTUFJTztBQUNMeDJCLGFBQU8sQ0FBQytOLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV2lRLE9BQVosRUFBcUIsaUJBQXJCLENBQVA7QUFDQWpKLGlCQUFXLENBQUNwVCxFQUFELENBQVg7QUFDRDs7QUFDRHVsQix1QkFBbUIsQ0FBQ3ZsQixFQUFELENBQW5CO0FBQ0FrbUIsYUFBUyxDQUFDbG1CLEVBQUQsQ0FBVDtBQUNBb2hCLGVBQVcsQ0FBQ3BoQixFQUFELENBQVg7QUFDQXBJLGNBQVUsQ0FBQyxZQUFZO0FBQUUsYUFBT201QixnQkFBZ0IsQ0FBQy93QixFQUFELENBQXZCO0FBQThCLEtBQTdDLEVBQStDLEdBQS9DLENBQVY7QUFDRCxHQTVvUGtCLENBOG9QbkI7QUFDQTs7O0FBRUEsV0FBUzhwQyxVQUFULENBQW9CM3BCLEtBQXBCLEVBQTJCNWIsT0FBM0IsRUFBb0M7QUFDbEMsUUFBSW1nQyxNQUFNLEdBQUcsSUFBYjs7QUFFQSxRQUFJLEVBQUUsZ0JBQWdCb0YsVUFBbEIsQ0FBSixFQUFtQztBQUFFLGFBQU8sSUFBSUEsVUFBSixDQUFlM3BCLEtBQWYsRUFBc0I1YixPQUF0QixDQUFQO0FBQXVDOztBQUU1RSxTQUFLQSxPQUFMLEdBQWVBLE9BQU8sR0FBR0EsT0FBTyxHQUFHak8sT0FBTyxDQUFDaU8sT0FBRCxDQUFWLEdBQXNCLEVBQXRELENBTGtDLENBTWxDOztBQUNBak8sV0FBTyxDQUFDd2lELFFBQUQsRUFBV3YwQyxPQUFYLEVBQW9CLEtBQXBCLENBQVA7QUFFQSxRQUFJaUQsR0FBRyxHQUFHakQsT0FBTyxDQUFDM08sS0FBbEI7O0FBQ0EsUUFBSSxPQUFPNFIsR0FBUCxJQUFjLFFBQWxCLEVBQTRCO0FBQUVBLFNBQUcsR0FBRyxJQUFJKytCLEdBQUosQ0FBUS8rQixHQUFSLEVBQWFqRCxPQUFPLENBQUNQLElBQXJCLEVBQTJCLElBQTNCLEVBQWlDTyxPQUFPLENBQUNzaUMsYUFBekMsRUFBd0R0aUMsT0FBTyxDQUFDeEgsU0FBaEUsQ0FBTjtBQUFtRixLQUFqSCxNQUNLLElBQUl3SCxPQUFPLENBQUNQLElBQVosRUFBa0I7QUFBRXdELFNBQUcsQ0FBQ3d6QixVQUFKLEdBQWlCejJCLE9BQU8sQ0FBQ1AsSUFBekI7QUFBZ0M7O0FBQ3pELFNBQUt3RCxHQUFMLEdBQVdBLEdBQVg7QUFFQSxRQUFJa1AsS0FBSyxHQUFHLElBQUlvekIsVUFBVSxDQUFDNlEsV0FBWCxDQUF1QnAyQyxPQUFPLENBQUNxMkMsVUFBL0IsQ0FBSixDQUErQyxJQUEvQyxDQUFaO0FBQ0EsUUFBSXh1QyxPQUFPLEdBQUcsS0FBS0EsT0FBTCxHQUFlLElBQUkyckIsT0FBSixDQUFZNVgsS0FBWixFQUFtQjNZLEdBQW5CLEVBQXdCa1AsS0FBeEIsRUFBK0JuUyxPQUEvQixDQUE3QjtBQUNBNkgsV0FBTyxDQUFDaVEsT0FBUixDQUFnQnl0QixVQUFoQixHQUE2QixJQUE3QjtBQUNBNk8sZ0JBQVksQ0FBQyxJQUFELENBQVo7O0FBQ0EsUUFBSXAwQyxPQUFPLENBQUMyWixZQUFaLEVBQ0U7QUFBRSxXQUFLOVIsT0FBTCxDQUFhaVEsT0FBYixDQUFxQmpxQixTQUFyQixJQUFrQyxrQkFBbEM7QUFBdUQ7O0FBQzNEdS9CLGtCQUFjLENBQUMsSUFBRCxDQUFkO0FBRUEsU0FBS3pzQixLQUFMLEdBQWE7QUFDWDB1QyxhQUFPLEVBQUUsRUFERTtBQUNHO0FBQ2R6b0MsY0FBUSxFQUFFLEVBRkM7QUFFRztBQUNkTixhQUFPLEVBQUUsQ0FIRTtBQUdHO0FBQ2RwVSxlQUFTLEVBQUUsS0FKQTtBQUtYeTBCLHVCQUFpQixFQUFFLEtBTFI7QUFNWGIsYUFBTyxFQUFFLEtBTkU7QUFPWHNYLG1CQUFhLEVBQUUsS0FQSjtBQU9XO0FBQ3RCa1osbUJBQWEsRUFBRSxDQUFDLENBUkw7QUFRUUMsaUJBQVcsRUFBRSxDQUFDLENBUnRCO0FBUXlCO0FBQ3BDcEYsbUJBQWEsRUFBRSxLQVRKO0FBVVh2cUIsa0JBQVksRUFBRSxLQVZIO0FBV1grSSxlQUFTLEVBQUUsSUFBSTc4QixPQUFKLEVBWEE7QUFXZTtBQUMxQjQ4QyxZQUFNLEVBQUUsSUFaRztBQVlJO0FBQ2ZyK0Isa0JBQVksRUFBRTtBQWJILEtBQWI7O0FBZ0JBLFFBQUlyUixPQUFPLENBQUN3MkMsU0FBUixJQUFxQixDQUFDMXBELE1BQTFCLEVBQWtDO0FBQUUrYSxhQUFPLENBQUNzSyxLQUFSLENBQWNxVSxLQUFkO0FBQXdCLEtBdEMxQixDQXdDbEM7QUFDQTs7O0FBQ0EsUUFBSXo2QixFQUFFLElBQUlDLFVBQVUsR0FBRyxFQUF2QixFQUEyQjtBQUFFcUgsZ0JBQVUsQ0FBQyxZQUFZO0FBQUUsZUFBTzhzQyxNQUFNLENBQUN0NEIsT0FBUCxDQUFlc0ssS0FBZixDQUFxQjJVLEtBQXJCLENBQTJCLElBQTNCLENBQVA7QUFBMEMsT0FBekQsRUFBMkQsRUFBM0QsQ0FBVjtBQUEyRTs7QUFFeEcydkIseUJBQXFCLENBQUMsSUFBRCxDQUFyQjtBQUNBdk8sd0JBQW9COztBQUVwQjFhLG1CQUFjLENBQUMsSUFBRCxDQUFkOztBQUNBLFNBQUt2eEIsS0FBTCxDQUFXMmUsV0FBWCxHQUF5QixJQUF6QjtBQUNBcWQsYUFBUyxDQUFDLElBQUQsRUFBT2gxQixHQUFQLENBQVQ7O0FBRUEsUUFBS2pELE9BQU8sQ0FBQ3cyQyxTQUFSLElBQXFCLENBQUMxcEQsTUFBdkIsSUFBa0MsS0FBS3U1QixRQUFMLEVBQXRDLEVBQ0U7QUFBRWh6QixnQkFBVSxDQUFDLFlBQVk7QUFDdkIsWUFBSThzQyxNQUFNLENBQUM5WixRQUFQLE1BQXFCLENBQUM4WixNQUFNLENBQUN4L0IsS0FBUCxDQUFhbWxCLE9BQXZDLEVBQWdEO0FBQUVXLGlCQUFPLENBQUMwWixNQUFELENBQVA7QUFBa0I7QUFDckUsT0FGVyxFQUVULEVBRlMsQ0FBVjtBQUVPLEtBSFgsTUFLRTtBQUFFN1osWUFBTSxDQUFDLElBQUQsQ0FBTjtBQUFlOztBQUVuQixTQUFLLElBQUkyWixHQUFULElBQWdCdVUsY0FBaEIsRUFBZ0M7QUFBRSxVQUFJQSxjQUFjLENBQUNwaUQsY0FBZixDQUE4QjZ0QyxHQUE5QixDQUFKLEVBQ2hDO0FBQUV1VSxzQkFBYyxDQUFDdlUsR0FBRCxDQUFkLENBQW9CLElBQXBCLEVBQTBCamdDLE9BQU8sQ0FBQ2lnQyxHQUFELENBQWpDLEVBQXdDcVUsSUFBeEM7QUFBZ0Q7QUFBRTs7QUFDdEQzaUIsOEJBQTBCLENBQUMsSUFBRCxDQUExQjs7QUFDQSxRQUFJM3hCLE9BQU8sQ0FBQzAyQyxVQUFaLEVBQXdCO0FBQUUxMkMsYUFBTyxDQUFDMDJDLFVBQVIsQ0FBbUIsSUFBbkI7QUFBMkI7O0FBQ3JELFNBQUssSUFBSXhuRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHeW5ELFNBQVMsQ0FBQzFvRCxNQUE5QixFQUFzQyxFQUFFaUIsQ0FBeEMsRUFBMkM7QUFBRXluRCxlQUFTLENBQUN6bkQsQ0FBRCxDQUFULENBQWEsSUFBYjtBQUFxQjs7QUFDbEU0K0IsaUJBQVksQ0FBQyxJQUFELENBQVosQ0EvRGtDLENBZ0VsQztBQUNBOzs7QUFDQSxRQUFJM2hDLE1BQU0sSUFBSTZULE9BQU8sQ0FBQzJaLFlBQWxCLElBQ0FqQixnQkFBZ0IsQ0FBQzdRLE9BQU8sQ0FBQ3NmLE9BQVQsQ0FBaEIsQ0FBa0N5dkIsYUFBbEMsSUFBbUQsb0JBRHZELEVBRUU7QUFBRS91QyxhQUFPLENBQUNzZixPQUFSLENBQWdCcjRCLEtBQWhCLENBQXNCOG5ELGFBQXRCLEdBQXNDLE1BQXRDO0FBQStDO0FBQ3BELEdBdHRQa0IsQ0F3dFBuQjs7O0FBQ0FyUixZQUFVLENBQUNnUCxRQUFYLEdBQXNCQSxRQUF0QixDQXp0UG1CLENBMHRQbkI7O0FBQ0FoUCxZQUFVLENBQUNpUCxjQUFYLEdBQTRCQSxjQUE1QixDQTN0UG1CLENBNnRQbkI7O0FBQ0EsV0FBU2lDLHFCQUFULENBQStCaDdDLEVBQS9CLEVBQW1DO0FBQ2pDLFFBQUlxVCxDQUFDLEdBQUdyVCxFQUFFLENBQUNvTSxPQUFYO0FBQ0FqTixNQUFFLENBQUNrVSxDQUFDLENBQUNxSyxRQUFILEVBQWEsV0FBYixFQUEwQnFXLFNBQVMsQ0FBQy96QixFQUFELEVBQUtzMUMsV0FBTCxDQUFuQyxDQUFGLENBRmlDLENBR2pDOztBQUNBLFFBQUlobEQsRUFBRSxJQUFJQyxVQUFVLEdBQUcsRUFBdkIsRUFDRTtBQUFFNE8sUUFBRSxDQUFDa1UsQ0FBQyxDQUFDcUssUUFBSCxFQUFhLFVBQWIsRUFBeUJxVyxTQUFTLENBQUMvekIsRUFBRCxFQUFLLFVBQVV0TixDQUFWLEVBQWE7QUFDdEQsWUFBSXFOLGNBQWMsQ0FBQ0MsRUFBRCxFQUFLdE4sQ0FBTCxDQUFsQixFQUEyQjtBQUFFO0FBQVE7O0FBQ3JDLFlBQUlpRyxHQUFHLEdBQUc4c0IsWUFBWSxDQUFDemxCLEVBQUQsRUFBS3ROLENBQUwsQ0FBdEI7O0FBQ0EsWUFBSSxDQUFDaUcsR0FBRCxJQUFRNjhDLGFBQWEsQ0FBQ3gxQyxFQUFELEVBQUt0TixDQUFMLENBQXJCLElBQWdDNnBCLGFBQWEsQ0FBQ3ZjLEVBQUUsQ0FBQ29NLE9BQUosRUFBYTFaLENBQWIsQ0FBakQsRUFBa0U7QUFBRTtBQUFROztBQUM1RW1PLHdCQUFnQixDQUFDbk8sQ0FBRCxDQUFoQjtBQUNBLFlBQUkwb0QsSUFBSSxHQUFHcDdDLEVBQUUsQ0FBQysyQyxVQUFILENBQWNwK0MsR0FBZCxDQUFYO0FBQ0E2bUMsdUJBQWUsQ0FBQ3gvQixFQUFFLENBQUN3SCxHQUFKLEVBQVM0ekMsSUFBSSxDQUFDcDJCLE1BQWQsRUFBc0JvMkIsSUFBSSxDQUFDcnpCLElBQTNCLENBQWY7QUFDRCxPQVBxQyxDQUFsQyxDQUFGO0FBT0ksS0FSUixNQVVFO0FBQUU1b0IsUUFBRSxDQUFDa1UsQ0FBQyxDQUFDcUssUUFBSCxFQUFhLFVBQWIsRUFBeUIsVUFBVWhyQixDQUFWLEVBQWE7QUFBRSxlQUFPcU4sY0FBYyxDQUFDQyxFQUFELEVBQUt0TixDQUFMLENBQWQsSUFBeUJtTyxnQkFBZ0IsQ0FBQ25PLENBQUQsQ0FBaEQ7QUFBc0QsT0FBOUYsQ0FBRjtBQUFvRyxLQWR2RSxDQWVqQztBQUNBO0FBQ0E7OztBQUNBeU0sTUFBRSxDQUFDa1UsQ0FBQyxDQUFDcUssUUFBSCxFQUFhLGFBQWIsRUFBNEIsVUFBVWhyQixDQUFWLEVBQWE7QUFBRSxhQUFPbWpELGFBQWEsQ0FBQzcxQyxFQUFELEVBQUt0TixDQUFMLENBQXBCO0FBQThCLEtBQXpFLENBQUY7QUFDQXlNLE1BQUUsQ0FBQ2tVLENBQUMsQ0FBQ3FELEtBQUYsQ0FBUTg5QixRQUFSLEVBQUQsRUFBcUIsYUFBckIsRUFBb0MsVUFBVTloRCxDQUFWLEVBQWE7QUFDakQsVUFBSSxDQUFDMmdCLENBQUMsQ0FBQ3FLLFFBQUYsQ0FBVy9vQixRQUFYLENBQW9CakMsQ0FBQyxDQUFDOEQsTUFBdEIsQ0FBTCxFQUFvQztBQUFFcS9DLHFCQUFhLENBQUM3MUMsRUFBRCxFQUFLdE4sQ0FBTCxDQUFiO0FBQXVCO0FBQzlELEtBRkMsQ0FBRixDQW5CaUMsQ0F1QmpDOztBQUNBLFFBQUkyb0QsYUFBSjtBQUFBLFFBQW1CQyxTQUFTLEdBQUc7QUFBQ3ZuRCxTQUFHLEVBQUU7QUFBTixLQUEvQjs7QUFDQSxhQUFTd25ELFdBQVQsR0FBdUI7QUFDckIsVUFBSWxvQyxDQUFDLENBQUM4a0IsV0FBTixFQUFtQjtBQUNqQmtqQixxQkFBYSxHQUFHempELFVBQVUsQ0FBQyxZQUFZO0FBQUUsaUJBQU95YixDQUFDLENBQUM4a0IsV0FBRixHQUFnQixJQUF2QjtBQUE4QixTQUE3QyxFQUErQyxJQUEvQyxDQUExQjtBQUNBbWpCLGlCQUFTLEdBQUdqb0MsQ0FBQyxDQUFDOGtCLFdBQWQ7QUFDQW1qQixpQkFBUyxDQUFDdm5ELEdBQVYsR0FBZ0IsQ0FBQyxJQUFJNEQsSUFBSixFQUFqQjtBQUNEO0FBQ0Y7O0FBQ0QsYUFBUzZqRCxxQkFBVCxDQUErQjlvRCxDQUEvQixFQUFrQztBQUNoQyxVQUFJQSxDQUFDLENBQUM2bEQsT0FBRixDQUFVL2xELE1BQVYsSUFBb0IsQ0FBeEIsRUFBMkI7QUFBRSxlQUFPLEtBQVA7QUFBYzs7QUFDM0MsVUFBSWlwRCxLQUFLLEdBQUcvb0QsQ0FBQyxDQUFDNmxELE9BQUYsQ0FBVSxDQUFWLENBQVo7QUFDQSxhQUFPa0QsS0FBSyxDQUFDQyxPQUFOLElBQWlCLENBQWpCLElBQXNCRCxLQUFLLENBQUNFLE9BQU4sSUFBaUIsQ0FBOUM7QUFDRDs7QUFDRCxhQUFTQyxPQUFULENBQWlCSCxLQUFqQixFQUF3QnY0QixLQUF4QixFQUErQjtBQUM3QixVQUFJQSxLQUFLLENBQUM1Z0IsSUFBTixJQUFjLElBQWxCLEVBQXdCO0FBQUUsZUFBTyxJQUFQO0FBQWE7O0FBQ3ZDLFVBQUlrMkIsRUFBRSxHQUFHdFYsS0FBSyxDQUFDNWdCLElBQU4sR0FBYW01QyxLQUFLLENBQUNuNUMsSUFBNUI7QUFBQSxVQUFrQ28yQixFQUFFLEdBQUd4VixLQUFLLENBQUMxRSxHQUFOLEdBQVlpOUIsS0FBSyxDQUFDajlCLEdBQXpEO0FBQ0EsYUFBT2dhLEVBQUUsR0FBR0EsRUFBTCxHQUFVRSxFQUFFLEdBQUdBLEVBQWYsR0FBb0IsS0FBSyxFQUFoQztBQUNEOztBQUNEdjVCLE1BQUUsQ0FBQ2tVLENBQUMsQ0FBQ3FLLFFBQUgsRUFBYSxZQUFiLEVBQTJCLFVBQVVockIsQ0FBVixFQUFhO0FBQ3hDLFVBQUksQ0FBQ3FOLGNBQWMsQ0FBQ0MsRUFBRCxFQUFLdE4sQ0FBTCxDQUFmLElBQTBCLENBQUM4b0QscUJBQXFCLENBQUM5b0QsQ0FBRCxDQUFoRCxJQUF1RCxDQUFDOGlELGFBQWEsQ0FBQ3gxQyxFQUFELEVBQUt0TixDQUFMLENBQXpFLEVBQWtGO0FBQ2hGMmdCLFNBQUMsQ0FBQ3FELEtBQUYsQ0FBUSs4QixZQUFSO0FBQ0ExN0Msb0JBQVksQ0FBQ3NqRCxhQUFELENBQVo7QUFDQSxZQUFJaEcsR0FBRyxHQUFHLENBQUMsSUFBSTE5QyxJQUFKLEVBQVg7QUFDQTBiLFNBQUMsQ0FBQzhrQixXQUFGLEdBQWdCO0FBQUNya0MsZUFBSyxFQUFFdWhELEdBQVI7QUFBYW1CLGVBQUssRUFBRSxLQUFwQjtBQUNDcDVDLGNBQUksRUFBRWk0QyxHQUFHLEdBQUdpRyxTQUFTLENBQUN2bkQsR0FBaEIsSUFBdUIsR0FBdkIsR0FBNkJ1bkQsU0FBN0IsR0FBeUM7QUFEaEQsU0FBaEI7O0FBRUEsWUFBSTVvRCxDQUFDLENBQUM2bEQsT0FBRixDQUFVL2xELE1BQVYsSUFBb0IsQ0FBeEIsRUFBMkI7QUFDekI2Z0IsV0FBQyxDQUFDOGtCLFdBQUYsQ0FBYzcxQixJQUFkLEdBQXFCNVAsQ0FBQyxDQUFDNmxELE9BQUYsQ0FBVSxDQUFWLEVBQWFzRCxLQUFsQztBQUNBeG9DLFdBQUMsQ0FBQzhrQixXQUFGLENBQWMzWixHQUFkLEdBQW9COXJCLENBQUMsQ0FBQzZsRCxPQUFGLENBQVUsQ0FBVixFQUFhdUQsS0FBakM7QUFDRDtBQUNGO0FBQ0YsS0FaQyxDQUFGO0FBYUEzOEMsTUFBRSxDQUFDa1UsQ0FBQyxDQUFDcUssUUFBSCxFQUFhLFdBQWIsRUFBMEIsWUFBWTtBQUN0QyxVQUFJckssQ0FBQyxDQUFDOGtCLFdBQU4sRUFBbUI7QUFBRTlrQixTQUFDLENBQUM4a0IsV0FBRixDQUFjcWUsS0FBZCxHQUFzQixJQUF0QjtBQUE2QjtBQUNuRCxLQUZDLENBQUY7QUFHQXIzQyxNQUFFLENBQUNrVSxDQUFDLENBQUNxSyxRQUFILEVBQWEsVUFBYixFQUF5QixVQUFVaHJCLENBQVYsRUFBYTtBQUN0QyxVQUFJK29ELEtBQUssR0FBR3BvQyxDQUFDLENBQUM4a0IsV0FBZDs7QUFDQSxVQUFJc2pCLEtBQUssSUFBSSxDQUFDbC9CLGFBQWEsQ0FBQ2xKLENBQUQsRUFBSTNnQixDQUFKLENBQXZCLElBQWlDK29ELEtBQUssQ0FBQ241QyxJQUFOLElBQWMsSUFBL0MsSUFDQSxDQUFDbTVDLEtBQUssQ0FBQ2pGLEtBRFAsSUFDZ0IsSUFBSTcrQyxJQUFKLEtBQVc4akQsS0FBSyxDQUFDM25ELEtBQWpCLEdBQXlCLEdBRDdDLEVBQ2tEO0FBQ2hELFlBQUk2RSxHQUFHLEdBQUdxSCxFQUFFLENBQUN1akIsVUFBSCxDQUFjbFEsQ0FBQyxDQUFDOGtCLFdBQWhCLEVBQTZCLE1BQTdCLENBQVY7QUFBQSxZQUFnRHZrQyxLQUFoRDs7QUFDQSxZQUFJLENBQUM2bkQsS0FBSyxDQUFDcitDLElBQVAsSUFBZXcrQyxPQUFPLENBQUNILEtBQUQsRUFBUUEsS0FBSyxDQUFDcitDLElBQWQsQ0FBMUIsRUFBK0M7QUFDN0M7QUFBRXhKLGlCQUFLLEdBQUcsSUFBSWttQyxLQUFKLENBQVVuaEMsR0FBVixFQUFlQSxHQUFmLENBQVI7QUFBOEIsV0FEbEMsTUFFSyxJQUFJLENBQUM4aUQsS0FBSyxDQUFDcitDLElBQU4sQ0FBV0EsSUFBWixJQUFvQncrQyxPQUFPLENBQUNILEtBQUQsRUFBUUEsS0FBSyxDQUFDcitDLElBQU4sQ0FBV0EsSUFBbkIsQ0FBL0IsRUFBeUQ7QUFDNUQ7QUFBRXhKLGlCQUFLLEdBQUdvTSxFQUFFLENBQUMrMkMsVUFBSCxDQUFjcCtDLEdBQWQsQ0FBUjtBQUE2QixXQUQ1QixNQUVBO0FBQ0g7QUFBRS9FLGlCQUFLLEdBQUcsSUFBSWttQyxLQUFKLENBQVU1d0IsR0FBRyxDQUFDdlEsR0FBRyxDQUFDcUcsSUFBTCxFQUFXLENBQVgsQ0FBYixFQUE0QjBLLFFBQU8sQ0FBQzFKLEVBQUUsQ0FBQ3dILEdBQUosRUFBUzBCLEdBQUcsQ0FBQ3ZRLEdBQUcsQ0FBQ3FHLElBQUosR0FBVyxDQUFaLEVBQWUsQ0FBZixDQUFaLENBQW5DLENBQVI7QUFBNkU7O0FBQ2pGZ0IsVUFBRSxDQUFDeS9CLFlBQUgsQ0FBZ0I3ckMsS0FBSyxDQUFDb3hCLE1BQXRCLEVBQThCcHhCLEtBQUssQ0FBQ20wQixJQUFwQztBQUNBL25CLFVBQUUsQ0FBQytxQixLQUFIO0FBQ0FscUIsd0JBQWdCLENBQUNuTyxDQUFELENBQWhCO0FBQ0Q7O0FBQ0Q2b0QsaUJBQVc7QUFDWixLQWhCQyxDQUFGO0FBaUJBcDhDLE1BQUUsQ0FBQ2tVLENBQUMsQ0FBQ3FLLFFBQUgsRUFBYSxhQUFiLEVBQTRCNjlCLFdBQTVCLENBQUYsQ0EzRWlDLENBNkVqQztBQUNBOztBQUNBcDhDLE1BQUUsQ0FBQ2tVLENBQUMsQ0FBQ3FLLFFBQUgsRUFBYSxRQUFiLEVBQXVCLFlBQVk7QUFDbkMsVUFBSXJLLENBQUMsQ0FBQ3FLLFFBQUYsQ0FBV0csWUFBZixFQUE2QjtBQUMzQm9QLHVCQUFlLENBQUNqdEIsRUFBRCxFQUFLcVQsQ0FBQyxDQUFDcUssUUFBRixDQUFXcUUsU0FBaEIsQ0FBZjtBQUNBbUwscUJBQWEsQ0FBQ2x0QixFQUFELEVBQUtxVCxDQUFDLENBQUNxSyxRQUFGLENBQVdpRSxVQUFoQixFQUE0QixJQUE1QixDQUFiO0FBQ0E5aEIsY0FBTSxDQUFDRyxFQUFELEVBQUssUUFBTCxFQUFlQSxFQUFmLENBQU47QUFDRDtBQUNGLEtBTkMsQ0FBRixDQS9FaUMsQ0F1RmpDOztBQUNBYixNQUFFLENBQUNrVSxDQUFDLENBQUNxSyxRQUFILEVBQWEsWUFBYixFQUEyQixVQUFVaHJCLENBQVYsRUFBYTtBQUFFLGFBQU93bUMsYUFBYSxDQUFDbDVCLEVBQUQsRUFBS3ROLENBQUwsQ0FBcEI7QUFBOEIsS0FBeEUsQ0FBRjtBQUNBeU0sTUFBRSxDQUFDa1UsQ0FBQyxDQUFDcUssUUFBSCxFQUFhLGdCQUFiLEVBQStCLFVBQVVockIsQ0FBVixFQUFhO0FBQUUsYUFBT3dtQyxhQUFhLENBQUNsNUIsRUFBRCxFQUFLdE4sQ0FBTCxDQUFwQjtBQUE4QixLQUE1RSxDQUFGLENBekZpQyxDQTJGakM7O0FBQ0F5TSxNQUFFLENBQUNrVSxDQUFDLENBQUNnSixPQUFILEVBQVksUUFBWixFQUFzQixZQUFZO0FBQUUsYUFBT2hKLENBQUMsQ0FBQ2dKLE9BQUYsQ0FBVTBGLFNBQVYsR0FBc0IxTyxDQUFDLENBQUNnSixPQUFGLENBQVVzRixVQUFWLEdBQXVCLENBQXBEO0FBQXdELEtBQTVGLENBQUY7QUFFQXRPLEtBQUMsQ0FBQ2duQyxhQUFGLEdBQWtCO0FBQ2hCRSxXQUFLLEVBQUUsZUFBVTduRCxDQUFWLEVBQWE7QUFBQyxZQUFJLENBQUNxTixjQUFjLENBQUNDLEVBQUQsRUFBS3ROLENBQUwsQ0FBbkIsRUFBNEI7QUFBRXdPLGdCQUFNLENBQUN4TyxDQUFELENBQU47QUFBWTtBQUFDLE9BRGhEO0FBRWhCOG5ELFVBQUksRUFBRSxjQUFVOW5ELENBQVYsRUFBYTtBQUFDLFlBQUksQ0FBQ3FOLGNBQWMsQ0FBQ0MsRUFBRCxFQUFLdE4sQ0FBTCxDQUFuQixFQUE0QjtBQUFFdTVDLG9CQUFVLENBQUNqc0MsRUFBRCxFQUFLdE4sQ0FBTCxDQUFWO0FBQW1Cd08sZ0JBQU0sQ0FBQ3hPLENBQUQsQ0FBTjtBQUFZO0FBQUMsT0FGbEU7QUFHaEJvQixXQUFLLEVBQUUsZUFBVXBCLENBQVYsRUFBYTtBQUFFLGVBQU9nNUMsV0FBVyxDQUFDMXJDLEVBQUQsRUFBS3ROLENBQUwsQ0FBbEI7QUFBNEIsT0FIbEM7QUFJaEJnb0QsVUFBSSxFQUFFM21CLFNBQVMsQ0FBQy96QixFQUFELEVBQUtzcUMsTUFBTCxDQUpDO0FBS2hCbVEsV0FBSyxFQUFFLGVBQVUvbkQsQ0FBVixFQUFhO0FBQUMsWUFBSSxDQUFDcU4sY0FBYyxDQUFDQyxFQUFELEVBQUt0TixDQUFMLENBQW5CLEVBQTRCO0FBQUU2M0MseUJBQWUsQ0FBQ3ZxQyxFQUFELENBQWY7QUFBc0I7QUFBQztBQUwxRCxLQUFsQjtBQVFBLFFBQUkrN0MsR0FBRyxHQUFHMW9DLENBQUMsQ0FBQ3FELEtBQUYsQ0FBUTg5QixRQUFSLEVBQVY7QUFDQXIxQyxNQUFFLENBQUM0OEMsR0FBRCxFQUFNLE9BQU4sRUFBZSxVQUFVcnBELENBQVYsRUFBYTtBQUFFLGFBQU9raUQsT0FBTyxDQUFDeitDLElBQVIsQ0FBYTZKLEVBQWIsRUFBaUJ0TixDQUFqQixDQUFQO0FBQTZCLEtBQTNELENBQUY7QUFDQXlNLE1BQUUsQ0FBQzQ4QyxHQUFELEVBQU0sU0FBTixFQUFpQmhvQixTQUFTLENBQUMvekIsRUFBRCxFQUFLdTBDLFNBQUwsQ0FBMUIsQ0FBRjtBQUNBcDFDLE1BQUUsQ0FBQzQ4QyxHQUFELEVBQU0sVUFBTixFQUFrQmhvQixTQUFTLENBQUMvekIsRUFBRCxFQUFLNjBDLFVBQUwsQ0FBM0IsQ0FBRjtBQUNBMTFDLE1BQUUsQ0FBQzQ4QyxHQUFELEVBQU0sT0FBTixFQUFlLFVBQVVycEQsQ0FBVixFQUFhO0FBQUUsYUFBT3M0QixPQUFPLENBQUNockIsRUFBRCxFQUFLdE4sQ0FBTCxDQUFkO0FBQXdCLEtBQXRELENBQUY7QUFDQXlNLE1BQUUsQ0FBQzQ4QyxHQUFELEVBQU0sTUFBTixFQUFjLFVBQVVycEQsQ0FBVixFQUFhO0FBQUUsYUFBT200QixNQUFNLENBQUM3cUIsRUFBRCxFQUFLdE4sQ0FBTCxDQUFiO0FBQXVCLEtBQXBELENBQUY7QUFDRDs7QUFFRCxNQUFJd29ELFNBQVMsR0FBRyxFQUFoQjs7QUFDQXBSLFlBQVUsQ0FBQ2tTLGNBQVgsR0FBNEIsVUFBVWptRCxDQUFWLEVBQWE7QUFBRSxXQUFPbWxELFNBQVMsQ0FBQ2hpRCxJQUFWLENBQWVuRCxDQUFmLENBQVA7QUFBMkIsR0FBdEUsQ0E3MFBtQixDQSswUG5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFdBQVNrOUMsVUFBVCxDQUFvQmp6QyxFQUFwQixFQUF3QjlJLENBQXhCLEVBQTJCK2tELEdBQTNCLEVBQWdDQyxVQUFoQyxFQUE0QztBQUMxQyxRQUFJMTBDLEdBQUcsR0FBR3hILEVBQUUsQ0FBQ3dILEdBQWI7QUFBQSxRQUFrQnRDLEtBQWxCOztBQUNBLFFBQUkrMkMsR0FBRyxJQUFJLElBQVgsRUFBaUI7QUFBRUEsU0FBRyxHQUFHLEtBQU47QUFBYzs7QUFDakMsUUFBSUEsR0FBRyxJQUFJLE9BQVgsRUFBb0I7QUFDbEI7QUFDQTtBQUNBLFVBQUksQ0FBQ3owQyxHQUFHLENBQUN4RCxJQUFKLENBQVNtNEMsTUFBZCxFQUFzQjtBQUFFRixXQUFHLEdBQUcsTUFBTjtBQUFlLE9BQXZDLE1BQ0s7QUFBRS8yQyxhQUFLLEdBQUcwRyxnQkFBZ0IsQ0FBQzVMLEVBQUQsRUFBSzlJLENBQUwsQ0FBaEIsQ0FBd0JnTyxLQUFoQztBQUF3QztBQUNoRDs7QUFFRCxRQUFJcE8sT0FBTyxHQUFHa0osRUFBRSxDQUFDdUUsT0FBSCxDQUFXek4sT0FBekI7QUFDQSxRQUFJa0ksSUFBSSxHQUFHdUksT0FBTyxDQUFDQyxHQUFELEVBQU10USxDQUFOLENBQWxCO0FBQUEsUUFBNEJrbEQsUUFBUSxHQUFHeGxELFdBQVcsQ0FBQ29JLElBQUksQ0FBQ0MsSUFBTixFQUFZLElBQVosRUFBa0JuSSxPQUFsQixDQUFsRDs7QUFDQSxRQUFJa0ksSUFBSSxDQUFDK00sVUFBVCxFQUFxQjtBQUFFL00sVUFBSSxDQUFDK00sVUFBTCxHQUFrQixJQUFsQjtBQUF5Qjs7QUFDaEQsUUFBSXN3QyxjQUFjLEdBQUdyOUMsSUFBSSxDQUFDQyxJQUFMLENBQVV2TixLQUFWLENBQWdCLE1BQWhCLEVBQXdCLENBQXhCLENBQXJCO0FBQUEsUUFBaURrVixXQUFqRDs7QUFDQSxRQUFJLENBQUNzMUMsVUFBRCxJQUFlLENBQUMsS0FBS2pzRCxJQUFMLENBQVUrTyxJQUFJLENBQUNDLElBQWYsQ0FBcEIsRUFBMEM7QUFDeEMySCxpQkFBVyxHQUFHLENBQWQ7QUFDQXExQyxTQUFHLEdBQUcsS0FBTjtBQUNELEtBSEQsTUFHTyxJQUFJQSxHQUFHLElBQUksT0FBWCxFQUFvQjtBQUN6QnIxQyxpQkFBVyxHQUFHWSxHQUFHLENBQUN4RCxJQUFKLENBQVNtNEMsTUFBVCxDQUFnQmozQyxLQUFoQixFQUF1QmxHLElBQUksQ0FBQ0MsSUFBTCxDQUFVM00sS0FBVixDQUFnQitwRCxjQUFjLENBQUM3cEQsTUFBL0IsQ0FBdkIsRUFBK0R3TSxJQUFJLENBQUNDLElBQXBFLENBQWQ7O0FBQ0EsVUFBSTJILFdBQVcsSUFBSTFPLElBQWYsSUFBdUIwTyxXQUFXLEdBQUcsR0FBekMsRUFBOEM7QUFDNUMsWUFBSSxDQUFDczFDLFVBQUwsRUFBaUI7QUFBRTtBQUFROztBQUMzQkQsV0FBRyxHQUFHLE1BQU47QUFDRDtBQUNGOztBQUNELFFBQUlBLEdBQUcsSUFBSSxNQUFYLEVBQW1CO0FBQ2pCLFVBQUkva0QsQ0FBQyxHQUFHc1EsR0FBRyxDQUFDQyxLQUFaLEVBQW1CO0FBQUViLG1CQUFXLEdBQUdoUSxXQUFXLENBQUMyUSxPQUFPLENBQUNDLEdBQUQsRUFBTXRRLENBQUMsR0FBQyxDQUFSLENBQVAsQ0FBa0IrSCxJQUFuQixFQUF5QixJQUF6QixFQUErQm5JLE9BQS9CLENBQXpCO0FBQW1FLE9BQXhGLE1BQ0s7QUFBRThQLG1CQUFXLEdBQUcsQ0FBZDtBQUFrQjtBQUMxQixLQUhELE1BR08sSUFBSXExQyxHQUFHLElBQUksS0FBWCxFQUFrQjtBQUN2QnIxQyxpQkFBVyxHQUFHdzFDLFFBQVEsR0FBR3A4QyxFQUFFLENBQUN1RSxPQUFILENBQVcrM0MsVUFBcEM7QUFDRCxLQUZNLE1BRUEsSUFBSUwsR0FBRyxJQUFJLFVBQVgsRUFBdUI7QUFDNUJyMUMsaUJBQVcsR0FBR3cxQyxRQUFRLEdBQUdwOEMsRUFBRSxDQUFDdUUsT0FBSCxDQUFXKzNDLFVBQXBDO0FBQ0QsS0FGTSxNQUVBLElBQUksT0FBT0wsR0FBUCxJQUFjLFFBQWxCLEVBQTRCO0FBQ2pDcjFDLGlCQUFXLEdBQUd3MUMsUUFBUSxHQUFHSCxHQUF6QjtBQUNEOztBQUNEcjFDLGVBQVcsR0FBRzlOLElBQUksQ0FBQ2dELEdBQUwsQ0FBUyxDQUFULEVBQVk4SyxXQUFaLENBQWQ7QUFFQSxRQUFJMjFDLFlBQVksR0FBRyxFQUFuQjtBQUFBLFFBQXVCNWpELEdBQUcsR0FBRyxDQUE3Qjs7QUFDQSxRQUFJcUgsRUFBRSxDQUFDdUUsT0FBSCxDQUFXaTRDLGNBQWYsRUFDRTtBQUFFLFdBQUssSUFBSS9vRCxDQUFDLEdBQUdxRixJQUFJLENBQUMyQyxLQUFMLENBQVdtTCxXQUFXLEdBQUc5UCxPQUF6QixDQUFiLEVBQWdEckQsQ0FBaEQsRUFBbUQsRUFBRUEsQ0FBckQsRUFBd0Q7QUFBQ2tGLFdBQUcsSUFBSTdCLE9BQVA7QUFBZ0J5bEQsb0JBQVksSUFBSSxJQUFoQjtBQUFzQjtBQUFFOztBQUNyRyxRQUFJNWpELEdBQUcsR0FBR2lPLFdBQVYsRUFBdUI7QUFBRTIxQyxrQkFBWSxJQUFJdGpELFFBQVEsQ0FBQzJOLFdBQVcsR0FBR2pPLEdBQWYsQ0FBeEI7QUFBOEM7O0FBRXZFLFFBQUk0akQsWUFBWSxJQUFJRixjQUFwQixFQUFvQztBQUNsQ3RaLG1CQUFZLENBQUN2N0IsR0FBRCxFQUFNKzBDLFlBQU4sRUFBb0JyekMsR0FBRyxDQUFDaFMsQ0FBRCxFQUFJLENBQUosQ0FBdkIsRUFBK0JnUyxHQUFHLENBQUNoUyxDQUFELEVBQUltbEQsY0FBYyxDQUFDN3BELE1BQW5CLENBQWxDLEVBQThELFFBQTlELENBQVo7O0FBQ0F3TSxVQUFJLENBQUMrTSxVQUFMLEdBQWtCLElBQWxCO0FBQ0EsYUFBTyxJQUFQO0FBQ0QsS0FKRCxNQUlPO0FBQ0w7QUFDQTtBQUNBLFdBQUssSUFBSTVPLEdBQUcsR0FBRyxDQUFmLEVBQWtCQSxHQUFHLEdBQUdxSyxHQUFHLENBQUNpZ0IsR0FBSixDQUFRQyxNQUFSLENBQWVsMUIsTUFBdkMsRUFBK0MySyxHQUFHLEVBQWxELEVBQXNEO0FBQ3BELFlBQUl2SixLQUFLLEdBQUc0VCxHQUFHLENBQUNpZ0IsR0FBSixDQUFRQyxNQUFSLENBQWV2cUIsR0FBZixDQUFaOztBQUNBLFlBQUl2SixLQUFLLENBQUNtMEIsSUFBTixDQUFXL29CLElBQVgsSUFBbUI5SCxDQUFuQixJQUF3QnRELEtBQUssQ0FBQ20wQixJQUFOLENBQVczdEIsRUFBWCxHQUFnQmlpRCxjQUFjLENBQUM3cEQsTUFBM0QsRUFBbUU7QUFDakUsY0FBSWlxRCxLQUFLLEdBQUd2ekMsR0FBRyxDQUFDaFMsQ0FBRCxFQUFJbWxELGNBQWMsQ0FBQzdwRCxNQUFuQixDQUFmO0FBQ0FxdEMsNkJBQW1CLENBQUNyNEIsR0FBRCxFQUFNckssR0FBTixFQUFXLElBQUkyOEIsS0FBSixDQUFVMmlCLEtBQVYsRUFBaUJBLEtBQWpCLENBQVgsQ0FBbkI7QUFDQTtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEdBNzRQa0IsQ0ErNFBuQjtBQUNBO0FBQ0E7OztBQUNBLE1BQUlDLFVBQVUsR0FBRyxJQUFqQjs7QUFFQSxXQUFTQyxhQUFULENBQXVCQyxhQUF2QixFQUFzQztBQUNwQ0YsY0FBVSxHQUFHRSxhQUFiO0FBQ0Q7O0FBRUQsV0FBU0MsY0FBVCxDQUF3Qjc4QyxFQUF4QixFQUE0Qjg4QyxRQUE1QixFQUFzQ0MsT0FBdEMsRUFBK0N0MUIsR0FBL0MsRUFBb0RsdkIsTUFBcEQsRUFBNEQ7QUFDMUQsUUFBSWlQLEdBQUcsR0FBR3hILEVBQUUsQ0FBQ3dILEdBQWI7QUFDQXhILE1BQUUsQ0FBQ29NLE9BQUgsQ0FBV21mLEtBQVgsR0FBbUIsS0FBbkI7O0FBQ0EsUUFBSSxDQUFDOUQsR0FBTCxFQUFVO0FBQUVBLFNBQUcsR0FBR2pnQixHQUFHLENBQUNpZ0IsR0FBVjtBQUFnQjs7QUFFNUIsUUFBSXUxQixNQUFNLEdBQUcsQ0FBQyxJQUFJcmxELElBQUosRUFBRCxHQUFZLEdBQXpCO0FBQ0EsUUFBSXNsRCxLQUFLLEdBQUcxa0QsTUFBTSxJQUFJLE9BQVYsSUFBcUJ5SCxFQUFFLENBQUNrRixLQUFILENBQVMyMUMsYUFBVCxHQUF5Qm1DLE1BQTFEO0FBQ0EsUUFBSUUsU0FBUyxHQUFHMTZDLGNBQWMsQ0FBQ3M2QyxRQUFELENBQTlCO0FBQUEsUUFBMENLLFVBQVUsR0FBRyxJQUF2RCxDQVAwRCxDQVExRDs7QUFDQSxRQUFJRixLQUFLLElBQUl4MUIsR0FBRyxDQUFDQyxNQUFKLENBQVdsMUIsTUFBWCxHQUFvQixDQUFqQyxFQUFvQztBQUNsQyxVQUFJa3FELFVBQVUsSUFBSUEsVUFBVSxDQUFDejlDLElBQVgsQ0FBZ0IybkMsSUFBaEIsQ0FBcUIsSUFBckIsS0FBOEJrVyxRQUFoRCxFQUEwRDtBQUN4RCxZQUFJcjFCLEdBQUcsQ0FBQ0MsTUFBSixDQUFXbDFCLE1BQVgsR0FBb0JrcUQsVUFBVSxDQUFDejlDLElBQVgsQ0FBZ0J6TSxNQUFwQyxJQUE4QyxDQUFsRCxFQUFxRDtBQUNuRDJxRCxvQkFBVSxHQUFHLEVBQWI7O0FBQ0EsZUFBSyxJQUFJMXBELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdpcEQsVUFBVSxDQUFDejlDLElBQVgsQ0FBZ0J6TSxNQUFwQyxFQUE0Q2lCLENBQUMsRUFBN0MsRUFDRTtBQUFFMHBELHNCQUFVLENBQUNqa0QsSUFBWCxDQUFnQnNPLEdBQUcsQ0FBQ3k3QixVQUFKLENBQWV5WixVQUFVLENBQUN6OUMsSUFBWCxDQUFnQnhMLENBQWhCLENBQWYsQ0FBaEI7QUFBc0Q7QUFDM0Q7QUFDRixPQU5ELE1BTU8sSUFBSXlwRCxTQUFTLENBQUMxcUQsTUFBVixJQUFvQmkxQixHQUFHLENBQUNDLE1BQUosQ0FBV2wxQixNQUEvQixJQUF5Q3dOLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVzY0QyxzQkFBeEQsRUFBZ0Y7QUFDckZELGtCQUFVLEdBQUc5akQsR0FBRyxDQUFDNmpELFNBQUQsRUFBWSxVQUFVeDZDLENBQVYsRUFBYTtBQUFFLGlCQUFPLENBQUNBLENBQUQsQ0FBUDtBQUFhLFNBQXhDLENBQWhCO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJc3ZCLFdBQVcsR0FBR2h5QixFQUFFLENBQUNRLEtBQUgsQ0FBU3d4QixXQUEzQixDQXJCMEQsQ0FzQjFEOztBQUNBLFNBQUssSUFBSTcwQixHQUFHLEdBQUdzcUIsR0FBRyxDQUFDQyxNQUFKLENBQVdsMUIsTUFBWCxHQUFvQixDQUFuQyxFQUFzQzJLLEdBQUcsSUFBSSxDQUE3QyxFQUFnREEsR0FBRyxFQUFuRCxFQUF1RDtBQUNyRCxVQUFJdkosS0FBSyxHQUFHNnpCLEdBQUcsQ0FBQ0MsTUFBSixDQUFXdnFCLEdBQVgsQ0FBWjtBQUNBLFVBQUkvQixJQUFJLEdBQUd4SCxLQUFLLENBQUN3SCxJQUFOLEVBQVg7QUFBQSxVQUF5QkMsRUFBRSxHQUFHekgsS0FBSyxDQUFDeUgsRUFBTixFQUE5Qjs7QUFDQSxVQUFJekgsS0FBSyxDQUFDZzBCLEtBQU4sRUFBSixFQUFtQjtBQUNqQixZQUFJbTFCLE9BQU8sSUFBSUEsT0FBTyxHQUFHLENBQXpCLEVBQTRCO0FBQzFCO0FBQUUzaEQsZ0JBQUksR0FBRzhOLEdBQUcsQ0FBQzlOLElBQUksQ0FBQzRELElBQU4sRUFBWTVELElBQUksQ0FBQ2hCLEVBQUwsR0FBVTJpRCxPQUF0QixDQUFWO0FBQTJDLFdBRC9DLE1BRUssSUFBSS84QyxFQUFFLENBQUNrRixLQUFILENBQVN6TyxTQUFULElBQXNCLENBQUN3bUQsS0FBM0IsRUFBa0M7QUFDckM7QUFBRTVoRCxjQUFFLEdBQUc2TixHQUFHLENBQUM3TixFQUFFLENBQUMyRCxJQUFKLEVBQVVsRyxJQUFJLENBQUNDLEdBQUwsQ0FBU3dPLE9BQU8sQ0FBQ0MsR0FBRCxFQUFNbk0sRUFBRSxDQUFDMkQsSUFBVCxDQUFQLENBQXNCQyxJQUF0QixDQUEyQnpNLE1BQXBDLEVBQTRDNkksRUFBRSxDQUFDakIsRUFBSCxHQUFRakIsR0FBRyxDQUFDK2pELFNBQUQsQ0FBSCxDQUFlMXFELE1BQW5FLENBQVYsQ0FBUjtBQUFnRyxXQUQvRixNQUVBLElBQUl5cUQsS0FBSyxJQUFJUCxVQUFULElBQXVCQSxVQUFVLENBQUNXLFFBQWxDLElBQThDWCxVQUFVLENBQUN6OUMsSUFBWCxDQUFnQjJuQyxJQUFoQixDQUFxQixJQUFyQixLQUE4QnNXLFNBQVMsQ0FBQ3RXLElBQVYsQ0FBZSxJQUFmLENBQWhGLEVBQ0g7QUFBRXhyQyxjQUFJLEdBQUdDLEVBQUUsR0FBRzZOLEdBQUcsQ0FBQzlOLElBQUksQ0FBQzRELElBQU4sRUFBWSxDQUFaLENBQWY7QUFBZ0M7QUFDckM7O0FBQ0QsVUFBSXMrQyxXQUFXLEdBQUc7QUFBQ2xpRCxZQUFJLEVBQUVBLElBQVA7QUFBYUMsVUFBRSxFQUFFQSxFQUFqQjtBQUFxQjRELFlBQUksRUFBRWsrQyxVQUFVLEdBQUdBLFVBQVUsQ0FBQ2hnRCxHQUFHLEdBQUdnZ0QsVUFBVSxDQUFDM3FELE1BQWxCLENBQWIsR0FBeUMwcUQsU0FBOUU7QUFDQzNrRCxjQUFNLEVBQUVBLE1BQU0sS0FBSzBrRCxLQUFLLEdBQUcsT0FBSCxHQUFhajlDLEVBQUUsQ0FBQ2tGLEtBQUgsQ0FBUzQxQyxXQUFULEdBQXVCa0MsTUFBdkIsR0FBZ0MsS0FBaEMsR0FBd0MsUUFBL0Q7QUFEZixPQUFsQjtBQUVBdmIsZ0JBQVUsQ0FBQ3poQyxFQUFFLENBQUN3SCxHQUFKLEVBQVM4MUMsV0FBVCxDQUFWO0FBQ0E3a0MsaUJBQVcsQ0FBQ3pZLEVBQUQsRUFBSyxXQUFMLEVBQWtCQSxFQUFsQixFQUFzQnM5QyxXQUF0QixDQUFYO0FBQ0Q7O0FBQ0QsUUFBSVIsUUFBUSxJQUFJLENBQUNHLEtBQWpCLEVBQ0U7QUFBRU0scUJBQWUsQ0FBQ3Y5QyxFQUFELEVBQUs4OEMsUUFBTCxDQUFmO0FBQWdDOztBQUVwQy91Qix1QkFBbUIsQ0FBQy90QixFQUFELENBQW5COztBQUNBLFFBQUlBLEVBQUUsQ0FBQ1EsS0FBSCxDQUFTd3hCLFdBQVQsR0FBdUIsQ0FBM0IsRUFBOEI7QUFBRWh5QixRQUFFLENBQUNRLEtBQUgsQ0FBU3d4QixXQUFULEdBQXVCQSxXQUF2QjtBQUFxQzs7QUFDckVoeUIsTUFBRSxDQUFDUSxLQUFILENBQVN5eEIsTUFBVCxHQUFrQixJQUFsQjtBQUNBanlCLE1BQUUsQ0FBQ2tGLEtBQUgsQ0FBUzIxQyxhQUFULEdBQXlCNzZDLEVBQUUsQ0FBQ2tGLEtBQUgsQ0FBUzQxQyxXQUFULEdBQXVCLENBQUMsQ0FBakQ7QUFDRDs7QUFFRCxXQUFTMEMsV0FBVCxDQUFxQjlxRCxDQUFyQixFQUF3QnNOLEVBQXhCLEVBQTRCO0FBQzFCLFFBQUl5OUMsTUFBTSxHQUFHL3FELENBQUMsQ0FBQ2dyRCxhQUFGLElBQW1CaHJELENBQUMsQ0FBQ2dyRCxhQUFGLENBQWdCbFMsT0FBaEIsQ0FBd0IsTUFBeEIsQ0FBaEM7O0FBQ0EsUUFBSWlTLE1BQUosRUFBWTtBQUNWL3FELE9BQUMsQ0FBQ3dOLGNBQUY7O0FBQ0EsVUFBSSxDQUFDRixFQUFFLENBQUMwcUMsVUFBSCxFQUFELElBQW9CLENBQUMxcUMsRUFBRSxDQUFDdUUsT0FBSCxDQUFXbzVDLFlBQXBDLEVBQ0U7QUFBRTdwQixlQUFPLENBQUM5ekIsRUFBRCxFQUFLLFlBQVk7QUFBRSxpQkFBTzY4QyxjQUFjLENBQUM3OEMsRUFBRCxFQUFLeTlDLE1BQUwsRUFBYSxDQUFiLEVBQWdCLElBQWhCLEVBQXNCLE9BQXRCLENBQXJCO0FBQXNELFNBQXpFLENBQVA7QUFBb0Y7O0FBQ3hGLGFBQU8sSUFBUDtBQUNEO0FBQ0Y7O0FBRUQsV0FBU0YsZUFBVCxDQUF5QnY5QyxFQUF6QixFQUE2Qjg4QyxRQUE3QixFQUF1QztBQUNyQztBQUNBLFFBQUksQ0FBQzk4QyxFQUFFLENBQUN1RSxPQUFILENBQVdxNUMsYUFBWixJQUE2QixDQUFDNTlDLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBV3M1QyxXQUE3QyxFQUEwRDtBQUFFO0FBQVE7O0FBQ3BFLFFBQUlwMkIsR0FBRyxHQUFHem5CLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT2lnQixHQUFqQjs7QUFFQSxTQUFLLElBQUloMEIsQ0FBQyxHQUFHZzBCLEdBQUcsQ0FBQ0MsTUFBSixDQUFXbDFCLE1BQVgsR0FBb0IsQ0FBakMsRUFBb0NpQixDQUFDLElBQUksQ0FBekMsRUFBNENBLENBQUMsRUFBN0MsRUFBaUQ7QUFDL0MsVUFBSUcsS0FBSyxHQUFHNnpCLEdBQUcsQ0FBQ0MsTUFBSixDQUFXajBCLENBQVgsQ0FBWjs7QUFDQSxVQUFJRyxLQUFLLENBQUNtMEIsSUFBTixDQUFXM3RCLEVBQVgsR0FBZ0IsR0FBaEIsSUFBd0IzRyxDQUFDLElBQUlnMEIsR0FBRyxDQUFDQyxNQUFKLENBQVdqMEIsQ0FBQyxHQUFHLENBQWYsRUFBa0JzMEIsSUFBbEIsQ0FBdUIvb0IsSUFBdkIsSUFBK0JwTCxLQUFLLENBQUNtMEIsSUFBTixDQUFXL29CLElBQTNFLEVBQWtGO0FBQUU7QUFBVTs7QUFDOUYsVUFBSWdGLElBQUksR0FBR2hFLEVBQUUsQ0FBQzg5QyxTQUFILENBQWFscUQsS0FBSyxDQUFDbTBCLElBQW5CLENBQVg7QUFDQSxVQUFJamEsUUFBUSxHQUFHLEtBQWY7O0FBQ0EsVUFBSTlKLElBQUksQ0FBQzQ1QyxhQUFULEVBQXdCO0FBQ3RCLGFBQUssSUFBSTkvQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHa0csSUFBSSxDQUFDNDVDLGFBQUwsQ0FBbUJwckQsTUFBdkMsRUFBK0NzTCxDQUFDLEVBQWhELEVBQ0U7QUFBRSxjQUFJZy9DLFFBQVEsQ0FBQzFsRCxPQUFULENBQWlCNE0sSUFBSSxDQUFDNDVDLGFBQUwsQ0FBbUIzaUQsTUFBbkIsQ0FBMEI2QyxDQUExQixDQUFqQixJQUFpRCxDQUFDLENBQXRELEVBQXlEO0FBQ3pEZ1Esb0JBQVEsR0FBR21sQyxVQUFVLENBQUNqekMsRUFBRCxFQUFLcE0sS0FBSyxDQUFDbTBCLElBQU4sQ0FBVy9vQixJQUFoQixFQUFzQixPQUF0QixDQUFyQjtBQUNBO0FBQ0Q7QUFBRTtBQUNOLE9BTkQsTUFNTyxJQUFJZ0YsSUFBSSxDQUFDKzVDLGFBQVQsRUFBd0I7QUFDN0IsWUFBSS81QyxJQUFJLENBQUMrNUMsYUFBTCxDQUFtQjl0RCxJQUFuQixDQUF3QnNYLE9BQU8sQ0FBQ3ZILEVBQUUsQ0FBQ3dILEdBQUosRUFBUzVULEtBQUssQ0FBQ20wQixJQUFOLENBQVcvb0IsSUFBcEIsQ0FBUCxDQUFpQ0MsSUFBakMsQ0FBc0MzTSxLQUF0QyxDQUE0QyxDQUE1QyxFQUErQ3NCLEtBQUssQ0FBQ20wQixJQUFOLENBQVczdEIsRUFBMUQsQ0FBeEIsQ0FBSixFQUNFO0FBQUUwVCxrQkFBUSxHQUFHbWxDLFVBQVUsQ0FBQ2p6QyxFQUFELEVBQUtwTSxLQUFLLENBQUNtMEIsSUFBTixDQUFXL29CLElBQWhCLEVBQXNCLE9BQXRCLENBQXJCO0FBQXNEO0FBQzNEOztBQUNELFVBQUk4TyxRQUFKLEVBQWM7QUFBRTJLLG1CQUFXLENBQUN6WSxFQUFELEVBQUssZUFBTCxFQUFzQkEsRUFBdEIsRUFBMEJwTSxLQUFLLENBQUNtMEIsSUFBTixDQUFXL29CLElBQXJDLENBQVg7QUFBd0Q7QUFDekU7QUFDRjs7QUFFRCxXQUFTZy9DLGNBQVQsQ0FBd0JoK0MsRUFBeEIsRUFBNEI7QUFDMUIsUUFBSWYsSUFBSSxHQUFHLEVBQVg7QUFBQSxRQUFleW9CLE1BQU0sR0FBRyxFQUF4Qjs7QUFDQSxTQUFLLElBQUlqMEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VNLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT2lnQixHQUFQLENBQVdDLE1BQVgsQ0FBa0JsMUIsTUFBdEMsRUFBOENpQixDQUFDLEVBQS9DLEVBQW1EO0FBQ2pELFVBQUl1TCxJQUFJLEdBQUdnQixFQUFFLENBQUN3SCxHQUFILENBQU9pZ0IsR0FBUCxDQUFXQyxNQUFYLENBQWtCajBCLENBQWxCLEVBQXFCczBCLElBQXJCLENBQTBCL29CLElBQXJDO0FBQ0EsVUFBSWkvQyxTQUFTLEdBQUc7QUFBQ2o1QixjQUFNLEVBQUU5YixHQUFHLENBQUNsSyxJQUFELEVBQU8sQ0FBUCxDQUFaO0FBQXVCK29CLFlBQUksRUFBRTdlLEdBQUcsQ0FBQ2xLLElBQUksR0FBRyxDQUFSLEVBQVcsQ0FBWDtBQUFoQyxPQUFoQjtBQUNBMG9CLFlBQU0sQ0FBQ3h1QixJQUFQLENBQVkra0QsU0FBWjtBQUNBaC9DLFVBQUksQ0FBQy9GLElBQUwsQ0FBVThHLEVBQUUsQ0FBQyttQyxRQUFILENBQVlrWCxTQUFTLENBQUNqNUIsTUFBdEIsRUFBOEJpNUIsU0FBUyxDQUFDbDJCLElBQXhDLENBQVY7QUFDRDs7QUFDRCxXQUFPO0FBQUM5b0IsVUFBSSxFQUFFQSxJQUFQO0FBQWF5b0IsWUFBTSxFQUFFQTtBQUFyQixLQUFQO0FBQ0Q7O0FBRUQsV0FBU3cyQixtQkFBVCxDQUE2QkMsS0FBN0IsRUFBb0M1RSxVQUFwQyxFQUFnREMsV0FBaEQsRUFBNkRDLGNBQTdELEVBQTZFO0FBQzNFMEUsU0FBSyxDQUFDeHFELFlBQU4sQ0FBbUIsYUFBbkIsRUFBa0M2bEQsV0FBVyxHQUFHLEVBQUgsR0FBUSxLQUFyRDtBQUNBMkUsU0FBSyxDQUFDeHFELFlBQU4sQ0FBbUIsZ0JBQW5CLEVBQXFDOGxELGNBQWMsR0FBRyxFQUFILEdBQVEsS0FBM0Q7QUFDQTBFLFNBQUssQ0FBQ3hxRCxZQUFOLENBQW1CLFlBQW5CLEVBQWlDLENBQUMsQ0FBQzRsRCxVQUFuQztBQUNEOztBQUVELFdBQVM2RSxjQUFULEdBQTBCO0FBQ3hCLFFBQUlwN0MsRUFBRSxHQUFHOVAsR0FBRyxDQUFDLFVBQUQsRUFBYSxJQUFiLEVBQW1CLElBQW5CLEVBQXlCLHNGQUF6QixDQUFaO0FBQ0EsUUFBSXdPLEdBQUcsR0FBR3hPLEdBQUcsQ0FBQyxLQUFELEVBQVEsQ0FBQzhQLEVBQUQsQ0FBUixFQUFjLElBQWQsRUFBb0IsZ0VBQXBCLENBQWIsQ0FGd0IsQ0FHeEI7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsUUFBSXRTLE1BQUosRUFBWTtBQUFFc1MsUUFBRSxDQUFDM1AsS0FBSCxDQUFTdW9CLEtBQVQsR0FBaUIsUUFBakI7QUFBNEIsS0FBMUMsTUFDSztBQUFFNVksUUFBRSxDQUFDclAsWUFBSCxDQUFnQixNQUFoQixFQUF3QixLQUF4QjtBQUFpQyxLQVJoQixDQVN4Qjs7O0FBQ0EsUUFBSXpDLEdBQUosRUFBUztBQUFFOFIsUUFBRSxDQUFDM1AsS0FBSCxDQUFTZ3JELE1BQVQsR0FBa0IsaUJBQWxCO0FBQXNDOztBQUNqREgsdUJBQW1CLENBQUNsN0MsRUFBRCxDQUFuQjtBQUNBLFdBQU90QixHQUFQO0FBQ0QsR0F4Z1FrQixDQTBnUW5CO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUEsV0FBUzQ4QyxnQkFBVCxDQUEwQnhVLFVBQTFCLEVBQXNDO0FBQ3BDLFFBQUlpUCxjQUFjLEdBQUdqUCxVQUFVLENBQUNpUCxjQUFoQztBQUVBLFFBQUl3RixPQUFPLEdBQUd6VSxVQUFVLENBQUN5VSxPQUFYLEdBQXFCLEVBQW5DO0FBRUF6VSxjQUFVLENBQUM1ekMsU0FBWCxHQUF1QjtBQUNyQnd3QyxpQkFBVyxFQUFFb0QsVUFEUTtBQUVyQi9lLFdBQUssRUFBRSxpQkFBVTtBQUFDam9CLGNBQU0sQ0FBQ2lvQixLQUFQO0FBQWdCLGFBQUszZSxPQUFMLENBQWFzSyxLQUFiLENBQW1CcVUsS0FBbkI7QUFBNEIsT0FGekM7QUFJckJ5ekIsZUFBUyxFQUFFLG1CQUFTekksTUFBVCxFQUFpQm5nRCxLQUFqQixFQUF3QjtBQUNqQyxZQUFJMk8sT0FBTyxHQUFHLEtBQUtBLE9BQW5CO0FBQUEsWUFBNEJ1SyxHQUFHLEdBQUd2SyxPQUFPLENBQUN3eEMsTUFBRCxDQUF6Qzs7QUFDQSxZQUFJeHhDLE9BQU8sQ0FBQ3d4QyxNQUFELENBQVAsSUFBbUJuZ0QsS0FBbkIsSUFBNEJtZ0QsTUFBTSxJQUFJLE1BQTFDLEVBQWtEO0FBQUU7QUFBUTs7QUFDNUR4eEMsZUFBTyxDQUFDd3hDLE1BQUQsQ0FBUCxHQUFrQm5nRCxLQUFsQjs7QUFDQSxZQUFJbWpELGNBQWMsQ0FBQ3BpRCxjQUFmLENBQThCby9DLE1BQTlCLENBQUosRUFDRTtBQUFFaGlCLG1CQUFTLENBQUMsSUFBRCxFQUFPZ2xCLGNBQWMsQ0FBQ2hELE1BQUQsQ0FBckIsQ0FBVCxDQUF3QyxJQUF4QyxFQUE4Q25nRCxLQUE5QyxFQUFxRGtaLEdBQXJEO0FBQTREOztBQUNoRWpQLGNBQU0sQ0FBQyxJQUFELEVBQU8sY0FBUCxFQUF1QixJQUF2QixFQUE2QmsyQyxNQUE3QixDQUFOO0FBQ0QsT0FYb0I7QUFhckJ2aEMsZUFBUyxFQUFFLG1CQUFTdWhDLE1BQVQsRUFBaUI7QUFBQyxlQUFPLEtBQUt4eEMsT0FBTCxDQUFhd3hDLE1BQWIsQ0FBUDtBQUE0QixPQWJwQztBQWNyQjBJLFlBQU0sRUFBRSxrQkFBVztBQUFDLGVBQU8sS0FBS2ozQyxHQUFaO0FBQWdCLE9BZGY7QUFnQnJCazNDLGVBQVMsRUFBRSxtQkFBU3JsRCxHQUFULEVBQWNrbEIsTUFBZCxFQUFzQjtBQUMvQixhQUFLclosS0FBTCxDQUFXMHVDLE9BQVgsQ0FBbUJyMUIsTUFBTSxHQUFHLE1BQUgsR0FBWSxTQUFyQyxFQUFnRHd2QixTQUFTLENBQUMxMEMsR0FBRCxDQUF6RDtBQUNELE9BbEJvQjtBQW1CckJzbEQsa0JBQVksRUFBRSxzQkFBU3RsRCxHQUFULEVBQWM7QUFDMUIsWUFBSTJiLElBQUksR0FBRyxLQUFLOVAsS0FBTCxDQUFXMHVDLE9BQXRCOztBQUNBLGFBQUssSUFBSW5nRCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdWhCLElBQUksQ0FBQ3hpQixNQUF6QixFQUFpQyxFQUFFaUIsQ0FBbkMsRUFDRTtBQUFFLGNBQUl1aEIsSUFBSSxDQUFDdmhCLENBQUQsQ0FBSixJQUFXNEYsR0FBWCxJQUFrQjJiLElBQUksQ0FBQ3ZoQixDQUFELENBQUosQ0FBUXNRLElBQVIsSUFBZ0IxSyxHQUF0QyxFQUEyQztBQUMzQzJiLGdCQUFJLENBQUN0YixNQUFMLENBQVlqRyxDQUFaLEVBQWUsQ0FBZjtBQUNBLG1CQUFPLElBQVA7QUFDRDtBQUFFO0FBQ04sT0ExQm9CO0FBNEJyQm1yRCxnQkFBVSxFQUFFNXFCLFFBQVEsQ0FBQyxVQUFTNXZCLElBQVQsRUFBZUcsT0FBZixFQUF3QjtBQUMzQyxZQUFJUCxJQUFJLEdBQUdJLElBQUksQ0FBQzBJLEtBQUwsR0FBYTFJLElBQWIsR0FBb0IwbEMsVUFBVSxDQUFDeGxDLE9BQVgsQ0FBbUIsS0FBS0MsT0FBeEIsRUFBaUNILElBQWpDLENBQS9COztBQUNBLFlBQUlKLElBQUksQ0FBQ3VCLFVBQVQsRUFBcUI7QUFBRSxnQkFBTSxJQUFJb0MsS0FBSixDQUFVLCtCQUFWLENBQU47QUFBa0Q7O0FBQ3pFcE8sb0JBQVksQ0FBQyxLQUFLMkwsS0FBTCxDQUFXaUcsUUFBWixFQUNDO0FBQUNuSCxjQUFJLEVBQUVBLElBQVA7QUFBYTY2QyxrQkFBUSxFQUFFejZDLElBQXZCO0FBQTZCaUgsZ0JBQU0sRUFBRTlHLE9BQU8sSUFBSUEsT0FBTyxDQUFDOEcsTUFBeEQ7QUFDQzVSLGtCQUFRLEVBQUc4SyxPQUFPLElBQUlBLE9BQU8sQ0FBQzlLLFFBQXBCLElBQWlDO0FBRDVDLFNBREQsRUFHQyxVQUFVeVIsT0FBVixFQUFtQjtBQUFFLGlCQUFPQSxPQUFPLENBQUN6UixRQUFmO0FBQTBCLFNBSGhELENBQVo7QUFJQSxhQUFLeUwsS0FBTCxDQUFXMkYsT0FBWDtBQUNBcWIsaUJBQVMsQ0FBQyxJQUFELENBQVQ7QUFDRCxPQVRtQixDQTVCQztBQXNDckI0NEIsbUJBQWEsRUFBRTlxQixRQUFRLENBQUMsVUFBUzV2QixJQUFULEVBQWU7QUFDckMsWUFBSStHLFFBQVEsR0FBRyxLQUFLakcsS0FBTCxDQUFXaUcsUUFBMUI7O0FBQ0EsYUFBSyxJQUFJMVgsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzBYLFFBQVEsQ0FBQzNZLE1BQTdCLEVBQXFDLEVBQUVpQixDQUF2QyxFQUEwQztBQUN4QyxjQUFJMEksR0FBRyxHQUFHZ1AsUUFBUSxDQUFDMVgsQ0FBRCxDQUFSLENBQVlvckQsUUFBdEI7O0FBQ0EsY0FBSTFpRCxHQUFHLElBQUlpSSxJQUFQLElBQWUsT0FBT0EsSUFBUCxJQUFlLFFBQWYsSUFBMkJqSSxHQUFHLENBQUM0SCxJQUFKLElBQVlLLElBQTFELEVBQWdFO0FBQzlEK0csb0JBQVEsQ0FBQ3pSLE1BQVQsQ0FBZ0JqRyxDQUFoQixFQUFtQixDQUFuQjtBQUNBLGlCQUFLeVIsS0FBTCxDQUFXMkYsT0FBWDtBQUNBcWIscUJBQVMsQ0FBQyxJQUFELENBQVQ7QUFDQTtBQUNEO0FBQ0Y7QUFDRixPQVhzQixDQXRDRjtBQW1EckIrc0IsZ0JBQVUsRUFBRWpmLFFBQVEsQ0FBQyxVQUFTOThCLENBQVQsRUFBWThELEdBQVosRUFBaUJraEQsVUFBakIsRUFBNkI7QUFDaEQsWUFBSSxPQUFPbGhELEdBQVAsSUFBYyxRQUFkLElBQTBCLE9BQU9BLEdBQVAsSUFBYyxRQUE1QyxFQUFzRDtBQUNwRCxjQUFJQSxHQUFHLElBQUksSUFBWCxFQUFpQjtBQUFFQSxlQUFHLEdBQUcsS0FBS3VKLE9BQUwsQ0FBYXM1QyxXQUFiLEdBQTJCLE9BQTNCLEdBQXFDLE1BQTNDO0FBQW9ELFdBQXZFLE1BQ0s7QUFBRTdpRCxlQUFHLEdBQUdBLEdBQUcsR0FBRyxLQUFILEdBQVcsVUFBcEI7QUFBaUM7QUFDekM7O0FBQ0QsWUFBSTZOLE1BQU0sQ0FBQyxLQUFLckIsR0FBTixFQUFXdFEsQ0FBWCxDQUFWLEVBQXlCO0FBQUUrN0Msb0JBQVUsQ0FBQyxJQUFELEVBQU8vN0MsQ0FBUCxFQUFVOEQsR0FBVixFQUFla2hELFVBQWYsQ0FBVjtBQUF1QztBQUNuRSxPQU5tQixDQW5EQztBQTBEckI1SixxQkFBZSxFQUFFdGUsUUFBUSxDQUFDLFVBQVNpb0IsR0FBVCxFQUFjO0FBQ3RDLFlBQUl2MEIsTUFBTSxHQUFHLEtBQUtsZ0IsR0FBTCxDQUFTaWdCLEdBQVQsQ0FBYUMsTUFBMUI7QUFBQSxZQUFrQzN6QixHQUFHLEdBQUcsQ0FBQyxDQUF6Qzs7QUFDQSxhQUFLLElBQUlOLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdpMEIsTUFBTSxDQUFDbDFCLE1BQTNCLEVBQW1DaUIsQ0FBQyxFQUFwQyxFQUF3QztBQUN0QyxjQUFJRyxLQUFLLEdBQUc4ekIsTUFBTSxDQUFDajBCLENBQUQsQ0FBbEI7O0FBQ0EsY0FBSSxDQUFDRyxLQUFLLENBQUNnMEIsS0FBTixFQUFMLEVBQW9CO0FBQ2xCLGdCQUFJeHNCLElBQUksR0FBR3hILEtBQUssQ0FBQ3dILElBQU4sRUFBWDtBQUFBLGdCQUF5QkMsRUFBRSxHQUFHekgsS0FBSyxDQUFDeUgsRUFBTixFQUE5QjtBQUNBLGdCQUFJdkgsS0FBSyxHQUFHZ0YsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTL0gsR0FBVCxFQUFjcUgsSUFBSSxDQUFDNEQsSUFBbkIsQ0FBWjtBQUNBakwsZUFBRyxHQUFHK0UsSUFBSSxDQUFDQyxHQUFMLENBQVMsS0FBSzhaLFFBQUwsRUFBVCxFQUEwQnhYLEVBQUUsQ0FBQzJELElBQUgsSUFBVzNELEVBQUUsQ0FBQ2pCLEVBQUgsR0FBUSxDQUFSLEdBQVksQ0FBdkIsQ0FBMUIsSUFBdUQsQ0FBN0Q7O0FBQ0EsaUJBQUssSUFBSTBELENBQUMsR0FBR2hLLEtBQWIsRUFBb0JnSyxDQUFDLEdBQUcvSixHQUF4QixFQUE2QixFQUFFK0osQ0FBL0IsRUFDRTtBQUFFbTFDLHdCQUFVLENBQUMsSUFBRCxFQUFPbjFDLENBQVAsRUFBVW0rQyxHQUFWLENBQVY7QUFBMkI7O0FBQy9CLGdCQUFJOEMsU0FBUyxHQUFHLEtBQUt2M0MsR0FBTCxDQUFTaWdCLEdBQVQsQ0FBYUMsTUFBN0I7O0FBQ0EsZ0JBQUl0c0IsSUFBSSxDQUFDaEIsRUFBTCxJQUFXLENBQVgsSUFBZ0JzdEIsTUFBTSxDQUFDbDFCLE1BQVAsSUFBaUJ1c0QsU0FBUyxDQUFDdnNELE1BQTNDLElBQXFEdXNELFNBQVMsQ0FBQ3RyRCxDQUFELENBQVQsQ0FBYTJILElBQWIsR0FBb0JoQixFQUFwQixHQUF5QixDQUFsRixFQUNFO0FBQUV5bEMsaUNBQW1CLENBQUMsS0FBS3I0QixHQUFOLEVBQVcvVCxDQUFYLEVBQWMsSUFBSXFtQyxLQUFKLENBQVUxK0IsSUFBVixFQUFnQjJqRCxTQUFTLENBQUN0ckQsQ0FBRCxDQUFULENBQWE0SCxFQUFiLEVBQWhCLENBQWQsRUFBa0RqRCxjQUFsRCxDQUFuQjtBQUF1RjtBQUM1RixXQVRELE1BU08sSUFBSXhFLEtBQUssQ0FBQ20wQixJQUFOLENBQVcvb0IsSUFBWCxHQUFrQmpMLEdBQXRCLEVBQTJCO0FBQ2hDay9DLHNCQUFVLENBQUMsSUFBRCxFQUFPci9DLEtBQUssQ0FBQ20wQixJQUFOLENBQVcvb0IsSUFBbEIsRUFBd0JpOUMsR0FBeEIsRUFBNkIsSUFBN0IsQ0FBVjtBQUNBbG9ELGVBQUcsR0FBR0gsS0FBSyxDQUFDbTBCLElBQU4sQ0FBVy9vQixJQUFqQjs7QUFDQSxnQkFBSXZMLENBQUMsSUFBSSxLQUFLK1QsR0FBTCxDQUFTaWdCLEdBQVQsQ0FBYUUsU0FBdEIsRUFBaUM7QUFBRW9HLGlDQUFtQixDQUFDLElBQUQsQ0FBbkI7QUFBNEI7QUFDaEU7QUFDRjtBQUNGLE9BbkJ3QixDQTFESjtBQStFckI7QUFDQTtBQUNBaXhCLGdCQUFVLEVBQUUsb0JBQVNybUQsR0FBVCxFQUFjd1QsT0FBZCxFQUF1QjtBQUNqQyxlQUFPYSxTQUFTLENBQUMsSUFBRCxFQUFPclUsR0FBUCxFQUFZd1QsT0FBWixDQUFoQjtBQUNELE9BbkZvQjtBQXFGckI4eUMsbUJBQWEsRUFBRSx1QkFBU2pnRCxJQUFULEVBQWVtTixPQUFmLEVBQXdCO0FBQ3JDLGVBQU9hLFNBQVMsQ0FBQyxJQUFELEVBQU85RCxHQUFHLENBQUNsSyxJQUFELENBQVYsRUFBa0JtTixPQUFsQixFQUEyQixJQUEzQixDQUFoQjtBQUNELE9BdkZvQjtBQXlGckIreUMsb0JBQWMsRUFBRSx3QkFBU3ZtRCxHQUFULEVBQWM7QUFDNUJBLFdBQUcsR0FBRytRLFFBQU8sQ0FBQyxLQUFLbEMsR0FBTixFQUFXN08sR0FBWCxDQUFiO0FBQ0EsWUFBSTJTLE1BQU0sR0FBR0ksYUFBYSxDQUFDLElBQUQsRUFBT25FLE9BQU8sQ0FBQyxLQUFLQyxHQUFOLEVBQVc3TyxHQUFHLENBQUNxRyxJQUFmLENBQWQsQ0FBMUI7QUFDQSxZQUFJWixNQUFNLEdBQUcsQ0FBYjtBQUFBLFlBQWdCL0wsS0FBSyxHQUFHLENBQUNpWixNQUFNLENBQUM5WSxNQUFQLEdBQWdCLENBQWpCLElBQXNCLENBQTlDO0FBQUEsWUFBaUQ0SCxFQUFFLEdBQUd6QixHQUFHLENBQUN5QixFQUExRDtBQUNBLFlBQUlpRCxJQUFKOztBQUNBLFlBQUlqRCxFQUFFLElBQUksQ0FBVixFQUFhO0FBQUVpRCxjQUFJLEdBQUdpTyxNQUFNLENBQUMsQ0FBRCxDQUFiO0FBQW1CLFNBQWxDLE1BQ0s7QUFBRSxtQkFBUztBQUNkLGdCQUFJL1AsR0FBRyxHQUFJNkMsTUFBTSxHQUFHL0wsS0FBVixJQUFvQixDQUE5Qjs7QUFDQSxnQkFBSSxDQUFDa0osR0FBRyxHQUFHK1AsTUFBTSxDQUFDL1AsR0FBRyxHQUFHLENBQU4sR0FBVSxDQUFYLENBQVQsR0FBeUIsQ0FBN0IsS0FBbUNuQixFQUF2QyxFQUEyQztBQUFFL0gsbUJBQUssR0FBR2tKLEdBQVI7QUFBYyxhQUEzRCxNQUNLLElBQUkrUCxNQUFNLENBQUMvUCxHQUFHLEdBQUcsQ0FBTixHQUFVLENBQVgsQ0FBTixHQUFzQm5CLEVBQTFCLEVBQThCO0FBQUVnRSxvQkFBTSxHQUFHN0MsR0FBRyxHQUFHLENBQWY7QUFBbUIsYUFBbkQsTUFDQTtBQUFFOEIsa0JBQUksR0FBR2lPLE1BQU0sQ0FBQy9QLEdBQUcsR0FBRyxDQUFOLEdBQVUsQ0FBWCxDQUFiO0FBQTRCO0FBQU87QUFDM0M7QUFBRTs7QUFDSCxZQUFJZ3JCLEdBQUcsR0FBR2xwQixJQUFJLEdBQUdBLElBQUksQ0FBQ2pHLE9BQUwsQ0FBYSxVQUFiLENBQUgsR0FBOEIsQ0FBQyxDQUE3QztBQUNBLGVBQU9tdkIsR0FBRyxHQUFHLENBQU4sR0FBVWxwQixJQUFWLEdBQWlCa3BCLEdBQUcsSUFBSSxDQUFQLEdBQVcsSUFBWCxHQUFrQmxwQixJQUFJLENBQUMvSyxLQUFMLENBQVcsQ0FBWCxFQUFjaTBCLEdBQUcsR0FBRyxDQUFwQixDQUExQztBQUNELE9BdkdvQjtBQXlHckJ1M0IsZUFBUyxFQUFFLG1CQUFTbmxELEdBQVQsRUFBYztBQUN2QixZQUFJcUwsSUFBSSxHQUFHLEtBQUt3RCxHQUFMLENBQVN4RCxJQUFwQjs7QUFDQSxZQUFJLENBQUNBLElBQUksQ0FBQ3FCLFNBQVYsRUFBcUI7QUFBRSxpQkFBT3JCLElBQVA7QUFBYTs7QUFDcEMsZUFBTzhsQyxVQUFVLENBQUN6a0MsU0FBWCxDQUFxQnJCLElBQXJCLEVBQTJCLEtBQUtnN0MsVUFBTCxDQUFnQnJtRCxHQUFoQixFQUFxQnVNLEtBQWhELEVBQXVEbEIsSUFBOUQ7QUFDRCxPQTdHb0I7QUErR3JCbTdDLGVBQVMsRUFBRSxtQkFBU3htRCxHQUFULEVBQWMwRSxJQUFkLEVBQW9CO0FBQzdCLGVBQU8sS0FBSytoRCxVQUFMLENBQWdCem1ELEdBQWhCLEVBQXFCMEUsSUFBckIsRUFBMkIsQ0FBM0IsQ0FBUDtBQUNELE9BakhvQjtBQW1IckIraEQsZ0JBQVUsRUFBRSxvQkFBU3ptRCxHQUFULEVBQWMwRSxJQUFkLEVBQW9CO0FBQzlCLFlBQUl6QixLQUFLLEdBQUcsRUFBWjs7QUFDQSxZQUFJLENBQUMyaUQsT0FBTyxDQUFDNW5ELGNBQVIsQ0FBdUIwRyxJQUF2QixDQUFMLEVBQW1DO0FBQUUsaUJBQU96QixLQUFQO0FBQWM7O0FBQ25ELFlBQUl5akQsSUFBSSxHQUFHZCxPQUFPLENBQUNsaEQsSUFBRCxDQUFsQjtBQUFBLFlBQTBCMkcsSUFBSSxHQUFHLEtBQUs4NUMsU0FBTCxDQUFlbmxELEdBQWYsQ0FBakM7O0FBQ0EsWUFBSSxPQUFPcUwsSUFBSSxDQUFDM0csSUFBRCxDQUFYLElBQXFCLFFBQXpCLEVBQW1DO0FBQ2pDLGNBQUlnaUQsSUFBSSxDQUFDcjdDLElBQUksQ0FBQzNHLElBQUQsQ0FBTCxDQUFSLEVBQXNCO0FBQUV6QixpQkFBSyxDQUFDMUMsSUFBTixDQUFXbW1ELElBQUksQ0FBQ3I3QyxJQUFJLENBQUMzRyxJQUFELENBQUwsQ0FBZjtBQUErQjtBQUN4RCxTQUZELE1BRU8sSUFBSTJHLElBQUksQ0FBQzNHLElBQUQsQ0FBUixFQUFnQjtBQUNyQixlQUFLLElBQUk1SixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHdVEsSUFBSSxDQUFDM0csSUFBRCxDQUFKLENBQVc3SyxNQUEvQixFQUF1Q2lCLENBQUMsRUFBeEMsRUFBNEM7QUFDMUMsZ0JBQUkyUixHQUFHLEdBQUdpNkMsSUFBSSxDQUFDcjdDLElBQUksQ0FBQzNHLElBQUQsQ0FBSixDQUFXNUosQ0FBWCxDQUFELENBQWQ7O0FBQ0EsZ0JBQUkyUixHQUFKLEVBQVM7QUFBRXhKLG1CQUFLLENBQUMxQyxJQUFOLENBQVdrTSxHQUFYO0FBQWtCO0FBQzlCO0FBQ0YsU0FMTSxNQUtBLElBQUlwQixJQUFJLENBQUNZLFVBQUwsSUFBbUJ5NkMsSUFBSSxDQUFDcjdDLElBQUksQ0FBQ1ksVUFBTixDQUEzQixFQUE4QztBQUNuRGhKLGVBQUssQ0FBQzFDLElBQU4sQ0FBV21tRCxJQUFJLENBQUNyN0MsSUFBSSxDQUFDWSxVQUFOLENBQWY7QUFDRCxTQUZNLE1BRUEsSUFBSXk2QyxJQUFJLENBQUNyN0MsSUFBSSxDQUFDRCxJQUFOLENBQVIsRUFBcUI7QUFDMUJuSSxlQUFLLENBQUMxQyxJQUFOLENBQVdtbUQsSUFBSSxDQUFDcjdDLElBQUksQ0FBQ0QsSUFBTixDQUFmO0FBQ0Q7O0FBQ0QsYUFBSyxJQUFJNUcsR0FBRyxHQUFHLENBQWYsRUFBa0JBLEdBQUcsR0FBR2tpRCxJQUFJLENBQUNDLE9BQUwsQ0FBYTlzRCxNQUFyQyxFQUE2QzJLLEdBQUcsRUFBaEQsRUFBb0Q7QUFDbEQsY0FBSWhCLEdBQUcsR0FBR2tqRCxJQUFJLENBQUNDLE9BQUwsQ0FBYW5pRCxHQUFiLENBQVY7O0FBQ0EsY0FBSWhCLEdBQUcsQ0FBQ2hCLElBQUosQ0FBUzZJLElBQVQsRUFBZSxJQUFmLEtBQXdCNU0sT0FBTyxDQUFDd0UsS0FBRCxFQUFRTyxHQUFHLENBQUNpSixHQUFaLENBQVAsSUFBMkIsQ0FBQyxDQUF4RCxFQUNFO0FBQUV4SixpQkFBSyxDQUFDMUMsSUFBTixDQUFXaUQsR0FBRyxDQUFDaUosR0FBZjtBQUFzQjtBQUMzQjs7QUFDRCxlQUFPeEosS0FBUDtBQUNELE9BeklvQjtBQTJJckIyakQsbUJBQWEsRUFBRSx1QkFBU3ZnRCxJQUFULEVBQWVtTixPQUFmLEVBQXdCO0FBQ3JDLFlBQUkzRSxHQUFHLEdBQUcsS0FBS0EsR0FBZjtBQUNBeEksWUFBSSxHQUFHeUssUUFBUSxDQUFDakMsR0FBRCxFQUFNeEksSUFBSSxJQUFJLElBQVIsR0FBZXdJLEdBQUcsQ0FBQ0MsS0FBSixHQUFZRCxHQUFHLENBQUNFLElBQWhCLEdBQXVCLENBQXRDLEdBQXlDMUksSUFBL0MsQ0FBZjtBQUNBLGVBQU80TSxnQkFBZ0IsQ0FBQyxJQUFELEVBQU81TSxJQUFJLEdBQUcsQ0FBZCxFQUFpQm1OLE9BQWpCLENBQWhCLENBQTBDakgsS0FBakQ7QUFDRCxPQS9Jb0I7QUFpSnJCMGQsa0JBQVksRUFBRSxzQkFBUzl1QixLQUFULEVBQWdCa1EsSUFBaEIsRUFBc0I7QUFDbEMsWUFBSXJMLEdBQUo7QUFBQSxZQUFTL0UsS0FBSyxHQUFHLEtBQUs0VCxHQUFMLENBQVNpZ0IsR0FBVCxDQUFhSixPQUFiLEVBQWpCOztBQUNBLFlBQUl2ekIsS0FBSyxJQUFJLElBQWIsRUFBbUI7QUFBRTZFLGFBQUcsR0FBRy9FLEtBQUssQ0FBQ20wQixJQUFaO0FBQW1CLFNBQXhDLE1BQ0ssSUFBSSxRQUFPajBCLEtBQVAsS0FBZ0IsUUFBcEIsRUFBOEI7QUFBRTZFLGFBQUcsR0FBRytRLFFBQU8sQ0FBQyxLQUFLbEMsR0FBTixFQUFXMVQsS0FBWCxDQUFiO0FBQWlDLFNBQWpFLE1BQ0E7QUFBRTZFLGFBQUcsR0FBRzdFLEtBQUssR0FBR0YsS0FBSyxDQUFDd0gsSUFBTixFQUFILEdBQWtCeEgsS0FBSyxDQUFDeUgsRUFBTixFQUE3QjtBQUEwQzs7QUFDakQsZUFBT3VuQixhQUFZLENBQUMsSUFBRCxFQUFPanFCLEdBQVAsRUFBWXFMLElBQUksSUFBSSxNQUFwQixDQUFuQjtBQUNELE9BdkpvQjtBQXlKckIyZSxnQkFBVSxFQUFFLG9CQUFTaHFCLEdBQVQsRUFBY3FMLElBQWQsRUFBb0I7QUFDOUIsZUFBTzJlLFdBQVUsQ0FBQyxJQUFELEVBQU9qWixRQUFPLENBQUMsS0FBS2xDLEdBQU4sRUFBVzdPLEdBQVgsQ0FBZCxFQUErQnFMLElBQUksSUFBSSxNQUF2QyxDQUFqQjtBQUNELE9BM0pvQjtBQTZKckJ1ZixnQkFBVSxFQUFFLG9CQUFTZixNQUFULEVBQWlCeGUsSUFBakIsRUFBdUI7QUFDakN3ZSxjQUFNLEdBQUdELGVBQWUsQ0FBQyxJQUFELEVBQU9DLE1BQVAsRUFBZXhlLElBQUksSUFBSSxNQUF2QixDQUF4QjtBQUNBLGVBQU91ZixXQUFVLENBQUMsSUFBRCxFQUFPZixNQUFNLENBQUNsZ0IsSUFBZCxFQUFvQmtnQixNQUFNLENBQUNoRSxHQUEzQixDQUFqQjtBQUNELE9BaEtvQjtBQWtLckIvVixrQkFBWSxFQUFFLHNCQUFTSixNQUFULEVBQWlCckUsSUFBakIsRUFBdUI7QUFDbkNxRSxjQUFNLEdBQUdrYSxlQUFlLENBQUMsSUFBRCxFQUFPO0FBQUMvRCxhQUFHLEVBQUVuVyxNQUFOO0FBQWMvRixjQUFJLEVBQUU7QUFBcEIsU0FBUCxFQUErQjBCLElBQUksSUFBSSxNQUF2QyxDQUFmLENBQThEd2EsR0FBdkU7QUFDQSxlQUFPL1YsYUFBWSxDQUFDLEtBQUtqQixHQUFOLEVBQVdhLE1BQU0sR0FBRyxLQUFLK0QsT0FBTCxDQUFhZ1csVUFBakMsQ0FBbkI7QUFDRCxPQXJLb0I7QUFzS3JCblAsa0JBQVksRUFBRSxzQkFBU2pVLElBQVQsRUFBZWdGLElBQWYsRUFBcUJrZSxjQUFyQixFQUFxQztBQUNqRCxZQUFJbnVCLEdBQUcsR0FBRyxLQUFWO0FBQUEsWUFBaUJtZixPQUFqQjs7QUFDQSxZQUFJLE9BQU9sVSxJQUFQLElBQWUsUUFBbkIsRUFBNkI7QUFDM0IsY0FBSTJLLElBQUksR0FBRyxLQUFLbkMsR0FBTCxDQUFTQyxLQUFULEdBQWlCLEtBQUtELEdBQUwsQ0FBU0UsSUFBMUIsR0FBaUMsQ0FBNUM7O0FBQ0EsY0FBSTFJLElBQUksR0FBRyxLQUFLd0ksR0FBTCxDQUFTQyxLQUFwQixFQUEyQjtBQUFFekksZ0JBQUksR0FBRyxLQUFLd0ksR0FBTCxDQUFTQyxLQUFoQjtBQUF3QixXQUFyRCxNQUNLLElBQUl6SSxJQUFJLEdBQUcySyxJQUFYLEVBQWlCO0FBQUUzSyxnQkFBSSxHQUFHMkssSUFBUDtBQUFhNVYsZUFBRyxHQUFHLElBQU47QUFBYTs7QUFDbERtZixpQkFBTyxHQUFHM0wsT0FBTyxDQUFDLEtBQUtDLEdBQU4sRUFBV3hJLElBQVgsQ0FBakI7QUFDRCxTQUxELE1BS087QUFDTGtVLGlCQUFPLEdBQUdsVSxJQUFWO0FBQ0Q7O0FBQ0QsZUFBT2lqQixlQUFlLENBQUMsSUFBRCxFQUFPL08sT0FBUCxFQUFnQjtBQUFDc0wsYUFBRyxFQUFFLENBQU47QUFBU2xjLGNBQUksRUFBRTtBQUFmLFNBQWhCLEVBQW1DMEIsSUFBSSxJQUFJLE1BQTNDLEVBQW1Ea2UsY0FBYyxJQUFJbnVCLEdBQXJFLENBQWYsQ0FBeUZ5cUIsR0FBekYsSUFDSnpxQixHQUFHLEdBQUcsS0FBS3lULEdBQUwsQ0FBU2EsTUFBVCxHQUFrQjRLLGFBQVksQ0FBQ0MsT0FBRCxDQUFqQyxHQUE2QyxDQUQ1QyxDQUFQO0FBRUQsT0FsTG9CO0FBb0xyQnNzQyx1QkFBaUIsRUFBRSw2QkFBVztBQUFFLGVBQU96NkIsVUFBVSxDQUFDLEtBQUszWSxPQUFOLENBQWpCO0FBQWlDLE9BcEw1QztBQXFMckJxekMsc0JBQWdCLEVBQUUsNEJBQVc7QUFBRSxlQUFPbi9CLFNBQVMsQ0FBQyxLQUFLbFUsT0FBTixDQUFoQjtBQUFnQyxPQXJMMUM7QUF1THJCc3pDLGlCQUFXLEVBQUUsdUJBQVc7QUFBRSxlQUFPO0FBQUN0a0QsY0FBSSxFQUFFLEtBQUtnUixPQUFMLENBQWFHLFFBQXBCO0FBQThCbFIsWUFBRSxFQUFFLEtBQUsrUSxPQUFMLENBQWFJO0FBQS9DLFNBQVA7QUFBOEQsT0F2TG5FO0FBeUxyQm16QyxlQUFTLEVBQUUsbUJBQVNobkQsR0FBVCxFQUFjekcsSUFBZCxFQUFvQm1HLE1BQXBCLEVBQTRCbTNCLElBQTVCLEVBQWtDQyxLQUFsQyxFQUF5QztBQUNsRCxZQUFJcmpCLE9BQU8sR0FBRyxLQUFLQSxPQUFuQjtBQUNBelQsV0FBRyxHQUFHaXFCLGFBQVksQ0FBQyxJQUFELEVBQU9sWixRQUFPLENBQUMsS0FBS2xDLEdBQU4sRUFBVzdPLEdBQVgsQ0FBZCxDQUFsQjtBQUNBLFlBQUk2bEIsR0FBRyxHQUFHN2xCLEdBQUcsQ0FBQzRsQixNQUFkO0FBQUEsWUFBc0JqYyxJQUFJLEdBQUczSixHQUFHLENBQUMySixJQUFqQztBQUNBcFEsWUFBSSxDQUFDbUIsS0FBTCxDQUFXMm9CLFFBQVgsR0FBc0IsVUFBdEI7QUFDQTlwQixZQUFJLENBQUN5QixZQUFMLENBQWtCLGtCQUFsQixFQUFzQyxNQUF0QztBQUNBLGFBQUt5WSxPQUFMLENBQWFzSyxLQUFiLENBQW1CRSxhQUFuQixDQUFpQzFrQixJQUFqQztBQUNBa2EsZUFBTyxDQUFDcVEsS0FBUixDQUFjeHBCLFdBQWQsQ0FBMEJmLElBQTFCOztBQUNBLFlBQUlzOUIsSUFBSSxJQUFJLE1BQVosRUFBb0I7QUFDbEJoUixhQUFHLEdBQUc3bEIsR0FBRyxDQUFDNmxCLEdBQVY7QUFDRCxTQUZELE1BRU8sSUFBSWdSLElBQUksSUFBSSxPQUFSLElBQW1CQSxJQUFJLElBQUksTUFBL0IsRUFBdUM7QUFDNUMsY0FBSW93QixNQUFNLEdBQUc5bUQsSUFBSSxDQUFDZ0QsR0FBTCxDQUFTc1EsT0FBTyxDQUFDaVEsT0FBUixDQUFnQndCLFlBQXpCLEVBQXVDLEtBQUtyVyxHQUFMLENBQVNhLE1BQWhELENBQWI7QUFBQSxjQUNBdzNDLE1BQU0sR0FBRy9tRCxJQUFJLENBQUNnRCxHQUFMLENBQVNzUSxPQUFPLENBQUNxUSxLQUFSLENBQWNILFdBQXZCLEVBQW9DbFEsT0FBTyxDQUFDd1EsU0FBUixDQUFrQk4sV0FBdEQsQ0FEVCxDQUQ0QyxDQUc1Qzs7QUFDQSxjQUFJLENBQUNrVCxJQUFJLElBQUksT0FBUixJQUFtQjcyQixHQUFHLENBQUM0bEIsTUFBSixHQUFhcnNCLElBQUksQ0FBQzRQLFlBQWxCLEdBQWlDODlDLE1BQXJELEtBQWdFam5ELEdBQUcsQ0FBQzZsQixHQUFKLEdBQVV0c0IsSUFBSSxDQUFDNFAsWUFBbkYsRUFDRTtBQUFFMGMsZUFBRyxHQUFHN2xCLEdBQUcsQ0FBQzZsQixHQUFKLEdBQVV0c0IsSUFBSSxDQUFDNFAsWUFBckI7QUFBb0MsV0FEeEMsTUFFSyxJQUFJbkosR0FBRyxDQUFDNGxCLE1BQUosR0FBYXJzQixJQUFJLENBQUM0UCxZQUFsQixJQUFrQzg5QyxNQUF0QyxFQUNIO0FBQUVwaEMsZUFBRyxHQUFHN2xCLEdBQUcsQ0FBQzRsQixNQUFWO0FBQW1COztBQUN2QixjQUFJamMsSUFBSSxHQUFHcFEsSUFBSSxDQUFDNlAsV0FBWixHQUEwQjg5QyxNQUE5QixFQUNFO0FBQUV2OUMsZ0JBQUksR0FBR3U5QyxNQUFNLEdBQUczdEQsSUFBSSxDQUFDNlAsV0FBckI7QUFBbUM7QUFDeEM7O0FBQ0Q3UCxZQUFJLENBQUNtQixLQUFMLENBQVdtckIsR0FBWCxHQUFpQkEsR0FBRyxHQUFHLElBQXZCO0FBQ0F0c0IsWUFBSSxDQUFDbUIsS0FBTCxDQUFXaVAsSUFBWCxHQUFrQnBRLElBQUksQ0FBQ21CLEtBQUwsQ0FBV2tQLEtBQVgsR0FBbUIsRUFBckM7O0FBQ0EsWUFBSWt0QixLQUFLLElBQUksT0FBYixFQUFzQjtBQUNwQm50QixjQUFJLEdBQUc4SixPQUFPLENBQUNxUSxLQUFSLENBQWNILFdBQWQsR0FBNEJwcUIsSUFBSSxDQUFDNlAsV0FBeEM7QUFDQTdQLGNBQUksQ0FBQ21CLEtBQUwsQ0FBV2tQLEtBQVgsR0FBbUIsS0FBbkI7QUFDRCxTQUhELE1BR087QUFDTCxjQUFJa3RCLEtBQUssSUFBSSxNQUFiLEVBQXFCO0FBQUVudEIsZ0JBQUksR0FBRyxDQUFQO0FBQVcsV0FBbEMsTUFDSyxJQUFJbXRCLEtBQUssSUFBSSxRQUFiLEVBQXVCO0FBQUVudEIsZ0JBQUksR0FBRyxDQUFDOEosT0FBTyxDQUFDcVEsS0FBUixDQUFjSCxXQUFkLEdBQTRCcHFCLElBQUksQ0FBQzZQLFdBQWxDLElBQWlELENBQXhEO0FBQTREOztBQUMxRjdQLGNBQUksQ0FBQ21CLEtBQUwsQ0FBV2lQLElBQVgsR0FBa0JBLElBQUksR0FBRyxJQUF6QjtBQUNEOztBQUNELFlBQUlqSyxNQUFKLEVBQ0U7QUFBRWswQix3QkFBYyxDQUFDLElBQUQsRUFBTztBQUFDanFCLGdCQUFJLEVBQUVBLElBQVA7QUFBYWtjLGVBQUcsRUFBRUEsR0FBbEI7QUFBdUJqYyxpQkFBSyxFQUFFRCxJQUFJLEdBQUdwUSxJQUFJLENBQUM2UCxXQUExQztBQUF1RHdjLGtCQUFNLEVBQUVDLEdBQUcsR0FBR3RzQixJQUFJLENBQUM0UDtBQUExRSxXQUFQLENBQWQ7QUFBZ0g7QUFDckgsT0ExTm9CO0FBNE5yQmcrQyxzQkFBZ0IsRUFBRTlyQixRQUFRLENBQUN1Z0IsU0FBRCxDQTVOTDtBQTZOckJ3TCx1QkFBaUIsRUFBRS9yQixRQUFRLENBQUM2Z0IsVUFBRCxDQTdOTjtBQThOckJtTCxvQkFBYyxFQUFFcEwsT0E5Tks7QUErTnJCcUwsd0JBQWtCLEVBQUVqc0IsUUFBUSxDQUFDc2hCLFdBQUQsQ0EvTlA7QUFpT3JCekMsaUJBQVcsRUFBRSxxQkFBU3JGLEdBQVQsRUFBYztBQUN6QixZQUFJcUMsUUFBUSxDQUFDbDVDLGNBQVQsQ0FBd0I2MkMsR0FBeEIsQ0FBSixFQUNFO0FBQUUsaUJBQU9xQyxRQUFRLENBQUNyQyxHQUFELENBQVIsQ0FBY3IzQyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLElBQXpCLENBQVA7QUFBdUM7QUFDNUMsT0FwT29CO0FBc09yQm9uRCxxQkFBZSxFQUFFdnBCLFFBQVEsQ0FBQyxVQUFTLzBCLElBQVQsRUFBZTtBQUFFcytDLHVCQUFlLENBQUMsSUFBRCxFQUFPdCtDLElBQVAsQ0FBZjtBQUE4QixPQUFoRCxDQXRPSjtBQXdPckJpaEQsY0FBUSxFQUFFLGtCQUFTOWtELElBQVQsRUFBZStrRCxNQUFmLEVBQXVCbkssSUFBdkIsRUFBNkI5RyxRQUE3QixFQUF1QztBQUMvQyxZQUFJbDBDLEdBQUcsR0FBRyxDQUFWOztBQUNBLFlBQUltbEQsTUFBTSxHQUFHLENBQWIsRUFBZ0I7QUFBRW5sRCxhQUFHLEdBQUcsQ0FBQyxDQUFQO0FBQVVtbEQsZ0JBQU0sR0FBRyxDQUFDQSxNQUFWO0FBQW1COztBQUMvQyxZQUFJaGtELEdBQUcsR0FBR3VOLFFBQU8sQ0FBQyxLQUFLbEMsR0FBTixFQUFXcE0sSUFBWCxDQUFqQjs7QUFDQSxhQUFLLElBQUkzSCxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMHNELE1BQXBCLEVBQTRCLEVBQUUxc0QsQ0FBOUIsRUFBaUM7QUFDL0IwSSxhQUFHLEdBQUcrakQsU0FBUSxDQUFDLEtBQUsxNEMsR0FBTixFQUFXckwsR0FBWCxFQUFnQm5CLEdBQWhCLEVBQXFCZzdDLElBQXJCLEVBQTJCOUcsUUFBM0IsQ0FBZDs7QUFDQSxjQUFJL3lDLEdBQUcsQ0FBQ2lrRCxPQUFSLEVBQWlCO0FBQUU7QUFBTztBQUMzQjs7QUFDRCxlQUFPamtELEdBQVA7QUFDRCxPQWpQb0I7QUFtUHJCbTFDLFdBQUssRUFBRXRkLFFBQVEsQ0FBQyxVQUFTaDVCLEdBQVQsRUFBY2c3QyxJQUFkLEVBQW9CO0FBQ2xDLFlBQUl0UixNQUFNLEdBQUcsSUFBYjtBQUVBLGFBQUs0QyxrQkFBTCxDQUF3QixVQUFVMXpDLEtBQVYsRUFBaUI7QUFDdkMsY0FBSTh3QyxNQUFNLENBQUN0NEIsT0FBUCxDQUFlbWYsS0FBZixJQUF3Qm1aLE1BQU0sQ0FBQ2w5QixHQUFQLENBQVdndUIsTUFBbkMsSUFBNkM1aEMsS0FBSyxDQUFDZzBCLEtBQU4sRUFBakQsRUFDRTtBQUFFLG1CQUFPczRCLFNBQVEsQ0FBQ3hiLE1BQU0sQ0FBQ2w5QixHQUFSLEVBQWE1VCxLQUFLLENBQUNtMEIsSUFBbkIsRUFBeUIvc0IsR0FBekIsRUFBOEJnN0MsSUFBOUIsRUFBb0N0UixNQUFNLENBQUNuZ0MsT0FBUCxDQUFlODdDLGVBQW5ELENBQWY7QUFBb0YsV0FEeEYsTUFHRTtBQUFFLG1CQUFPcmxELEdBQUcsR0FBRyxDQUFOLEdBQVVwSCxLQUFLLENBQUN3SCxJQUFOLEVBQVYsR0FBeUJ4SCxLQUFLLENBQUN5SCxFQUFOLEVBQWhDO0FBQTRDO0FBQ2pELFNBTEQsRUFLRzdDLFFBTEg7QUFNRCxPQVRjLENBblBNO0FBOFByQnU1QyxhQUFPLEVBQUUvZCxRQUFRLENBQUMsVUFBU2g1QixHQUFULEVBQWNnN0MsSUFBZCxFQUFvQjtBQUNwQyxZQUFJdnVCLEdBQUcsR0FBRyxLQUFLamdCLEdBQUwsQ0FBU2lnQixHQUFuQjtBQUFBLFlBQXdCamdCLEdBQUcsR0FBRyxLQUFLQSxHQUFuQzs7QUFDQSxZQUFJaWdCLEdBQUcsQ0FBQ3NTLGlCQUFKLEVBQUosRUFDRTtBQUFFdnlCLGFBQUcsQ0FBQ2tnQyxnQkFBSixDQUFxQixFQUFyQixFQUF5QixJQUF6QixFQUErQixTQUEvQjtBQUE0QyxTQURoRCxNQUdFO0FBQUVnSCw2QkFBbUIsQ0FBQyxJQUFELEVBQU8sVUFBVTk2QyxLQUFWLEVBQWlCO0FBQzNDLGdCQUFJc3ZCLEtBQUssR0FBR2c5QixTQUFRLENBQUMxNEMsR0FBRCxFQUFNNVQsS0FBSyxDQUFDbTBCLElBQVosRUFBa0Ivc0IsR0FBbEIsRUFBdUJnN0MsSUFBdkIsRUFBNkIsS0FBN0IsQ0FBcEI7O0FBQ0EsbUJBQU9oN0MsR0FBRyxHQUFHLENBQU4sR0FBVTtBQUFDSSxrQkFBSSxFQUFFOG5CLEtBQVA7QUFBYzduQixnQkFBRSxFQUFFekgsS0FBSyxDQUFDbTBCO0FBQXhCLGFBQVYsR0FBMEM7QUFBQzNzQixrQkFBSSxFQUFFeEgsS0FBSyxDQUFDbTBCLElBQWI7QUFBbUIxc0IsZ0JBQUUsRUFBRTZuQjtBQUF2QixhQUFqRDtBQUNELFdBSG9CLENBQW5CO0FBR0c7QUFDUixPQVRnQixDQTlQSTtBQXlRckJvOUIsY0FBUSxFQUFFLGtCQUFTbGxELElBQVQsRUFBZStrRCxNQUFmLEVBQXVCbkssSUFBdkIsRUFBNkJ1SyxVQUE3QixFQUF5QztBQUNqRCxZQUFJdmxELEdBQUcsR0FBRyxDQUFWO0FBQUEsWUFBYXNPLENBQUMsR0FBR2kzQyxVQUFqQjs7QUFDQSxZQUFJSixNQUFNLEdBQUcsQ0FBYixFQUFnQjtBQUFFbmxELGFBQUcsR0FBRyxDQUFDLENBQVA7QUFBVW1sRCxnQkFBTSxHQUFHLENBQUNBLE1BQVY7QUFBbUI7O0FBQy9DLFlBQUloa0QsR0FBRyxHQUFHdU4sUUFBTyxDQUFDLEtBQUtsQyxHQUFOLEVBQVdwTSxJQUFYLENBQWpCOztBQUNBLGFBQUssSUFBSTNILENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcwc0QsTUFBcEIsRUFBNEIsRUFBRTFzRCxDQUE5QixFQUFpQztBQUMvQixjQUFJK3VCLE1BQU0sR0FBR0ksYUFBWSxDQUFDLElBQUQsRUFBT3ptQixHQUFQLEVBQVksS0FBWixDQUF6Qjs7QUFDQSxjQUFJbU4sQ0FBQyxJQUFJLElBQVQsRUFBZTtBQUFFQSxhQUFDLEdBQUdrWixNQUFNLENBQUNsZ0IsSUFBWDtBQUFrQixXQUFuQyxNQUNLO0FBQUVrZ0Isa0JBQU0sQ0FBQ2xnQixJQUFQLEdBQWNnSCxDQUFkO0FBQWtCOztBQUN6Qm5OLGFBQUcsR0FBR21rRCxTQUFRLENBQUMsSUFBRCxFQUFPOTlCLE1BQVAsRUFBZXhuQixHQUFmLEVBQW9CZzdDLElBQXBCLENBQWQ7O0FBQ0EsY0FBSTc1QyxHQUFHLENBQUNpa0QsT0FBUixFQUFpQjtBQUFFO0FBQU87QUFDM0I7O0FBQ0QsZUFBT2prRCxHQUFQO0FBQ0QsT0FyUm9CO0FBdVJyQjgwQyxXQUFLLEVBQUVqZCxRQUFRLENBQUMsVUFBU2g1QixHQUFULEVBQWNnN0MsSUFBZCxFQUFvQjtBQUNsQyxZQUFJdFIsTUFBTSxHQUFHLElBQWI7QUFFQSxZQUFJbDlCLEdBQUcsR0FBRyxLQUFLQSxHQUFmO0FBQUEsWUFBb0JnNUMsS0FBSyxHQUFHLEVBQTVCO0FBQ0EsWUFBSWhzRCxRQUFRLEdBQUcsQ0FBQyxLQUFLNFgsT0FBTCxDQUFhbWYsS0FBZCxJQUF1QixDQUFDL2pCLEdBQUcsQ0FBQ2d1QixNQUE1QixJQUFzQ2h1QixHQUFHLENBQUNpZ0IsR0FBSixDQUFRc1MsaUJBQVIsRUFBckQ7QUFDQXZ5QixXQUFHLENBQUM4L0Isa0JBQUosQ0FBdUIsVUFBVTF6QyxLQUFWLEVBQWlCO0FBQ3RDLGNBQUlZLFFBQUosRUFDRTtBQUFFLG1CQUFPd0csR0FBRyxHQUFHLENBQU4sR0FBVXBILEtBQUssQ0FBQ3dILElBQU4sRUFBVixHQUF5QnhILEtBQUssQ0FBQ3lILEVBQU4sRUFBaEM7QUFBNEM7O0FBQ2hELGNBQUlvbEQsT0FBTyxHQUFHNzlCLGFBQVksQ0FBQzhoQixNQUFELEVBQVM5d0MsS0FBSyxDQUFDbTBCLElBQWYsRUFBcUIsS0FBckIsQ0FBMUI7O0FBQ0EsY0FBSW4wQixLQUFLLENBQUMyc0QsVUFBTixJQUFvQixJQUF4QixFQUE4QjtBQUFFRSxtQkFBTyxDQUFDbitDLElBQVIsR0FBZTFPLEtBQUssQ0FBQzJzRCxVQUFyQjtBQUFrQzs7QUFDbEVDLGVBQUssQ0FBQ3RuRCxJQUFOLENBQVd1bkQsT0FBTyxDQUFDbitDLElBQW5COztBQUNBLGNBQUkzSixHQUFHLEdBQUcybkQsU0FBUSxDQUFDNWIsTUFBRCxFQUFTK2IsT0FBVCxFQUFrQnpsRCxHQUFsQixFQUF1Qmc3QyxJQUF2QixDQUFsQjs7QUFDQSxjQUFJQSxJQUFJLElBQUksTUFBUixJQUFrQnBpRCxLQUFLLElBQUk0VCxHQUFHLENBQUNpZ0IsR0FBSixDQUFRSixPQUFSLEVBQS9CLEVBQ0U7QUFBRXdHLDBCQUFjLENBQUM2VyxNQUFELEVBQVMvaEIsV0FBVSxDQUFDK2hCLE1BQUQsRUFBUy9yQyxHQUFULEVBQWMsS0FBZCxDQUFWLENBQStCNmxCLEdBQS9CLEdBQXFDaWlDLE9BQU8sQ0FBQ2ppQyxHQUF0RCxDQUFkO0FBQTJFOztBQUMvRSxpQkFBTzdsQixHQUFQO0FBQ0QsU0FWRCxFQVVHSCxRQVZIOztBQVdBLFlBQUlnb0QsS0FBSyxDQUFDaHVELE1BQVYsRUFBa0I7QUFBRSxlQUFLLElBQUlpQixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHK1QsR0FBRyxDQUFDaWdCLEdBQUosQ0FBUUMsTUFBUixDQUFlbDFCLE1BQW5DLEVBQTJDaUIsQ0FBQyxFQUE1QyxFQUNsQjtBQUFFK1QsZUFBRyxDQUFDaWdCLEdBQUosQ0FBUUMsTUFBUixDQUFlajBCLENBQWYsRUFBa0I4c0QsVUFBbEIsR0FBK0JDLEtBQUssQ0FBQy9zRCxDQUFELENBQXBDO0FBQTBDO0FBQUU7QUFDakQsT0FsQmMsQ0F2Uk07QUEyU3JCO0FBQ0FzakQsZ0JBQVUsRUFBRSxvQkFBU3ArQyxHQUFULEVBQWM7QUFDeEIsWUFBSTZPLEdBQUcsR0FBRyxLQUFLQSxHQUFmO0FBQUEsWUFBb0J4SSxJQUFJLEdBQUd1SSxPQUFPLENBQUNDLEdBQUQsRUFBTTdPLEdBQUcsQ0FBQ3FHLElBQVYsQ0FBUCxDQUF1QkMsSUFBbEQ7QUFDQSxZQUFJbkwsS0FBSyxHQUFHNkUsR0FBRyxDQUFDeUIsRUFBaEI7QUFBQSxZQUFvQnJHLEdBQUcsR0FBRzRFLEdBQUcsQ0FBQ3lCLEVBQTlCOztBQUNBLFlBQUk0RSxJQUFKLEVBQVU7QUFDUixjQUFJeEUsTUFBTSxHQUFHLEtBQUsya0QsU0FBTCxDQUFleG1ELEdBQWYsRUFBb0IsV0FBcEIsQ0FBYjs7QUFDQSxjQUFJLENBQUNBLEdBQUcsQ0FBQ3VELE1BQUosSUFBYyxRQUFkLElBQTBCbkksR0FBRyxJQUFJaUwsSUFBSSxDQUFDeE0sTUFBdkMsS0FBa0RzQixLQUF0RCxFQUE2RDtBQUFFLGNBQUVBLEtBQUY7QUFBVSxXQUF6RSxNQUErRTtBQUFFLGNBQUVDLEdBQUY7QUFBUTs7QUFDekYsY0FBSTJzRCxTQUFTLEdBQUcxaEQsSUFBSSxDQUFDL0QsTUFBTCxDQUFZbkgsS0FBWixDQUFoQjtBQUNBLGNBQUk2c0QsS0FBSyxHQUFHcG1ELFVBQVUsQ0FBQ21tRCxTQUFELEVBQVlsbUQsTUFBWixDQUFWLEdBQ1IsVUFBVUosRUFBVixFQUFjO0FBQUUsbUJBQU9HLFVBQVUsQ0FBQ0gsRUFBRCxFQUFLSSxNQUFMLENBQWpCO0FBQWdDLFdBRHhDLEdBRVIsS0FBS3ZLLElBQUwsQ0FBVXl3RCxTQUFWLElBQXVCLFVBQVV0bUQsRUFBVixFQUFjO0FBQUUsbUJBQU8sS0FBS25LLElBQUwsQ0FBVW1LLEVBQVYsQ0FBUDtBQUF1QixXQUE5RCxHQUNBLFVBQVVBLEVBQVYsRUFBYztBQUFFLG1CQUFRLENBQUMsS0FBS25LLElBQUwsQ0FBVW1LLEVBQVYsQ0FBRCxJQUFrQixDQUFDRyxVQUFVLENBQUNILEVBQUQsQ0FBckM7QUFBNkMsV0FIakU7O0FBSUEsaUJBQU90RyxLQUFLLEdBQUcsQ0FBUixJQUFhNnNELEtBQUssQ0FBQzNoRCxJQUFJLENBQUMvRCxNQUFMLENBQVluSCxLQUFLLEdBQUcsQ0FBcEIsQ0FBRCxDQUF6QixFQUFtRDtBQUFFLGNBQUVBLEtBQUY7QUFBVTs7QUFDL0QsaUJBQU9DLEdBQUcsR0FBR2lMLElBQUksQ0FBQ3hNLE1BQVgsSUFBcUJtdUQsS0FBSyxDQUFDM2hELElBQUksQ0FBQy9ELE1BQUwsQ0FBWWxILEdBQVosQ0FBRCxDQUFqQyxFQUFxRDtBQUFFLGNBQUVBLEdBQUY7QUFBUTtBQUNoRTs7QUFDRCxlQUFPLElBQUkrbEMsS0FBSixDQUFVNXdCLEdBQUcsQ0FBQ3ZRLEdBQUcsQ0FBQ3FHLElBQUwsRUFBV2xMLEtBQVgsQ0FBYixFQUFnQ29WLEdBQUcsQ0FBQ3ZRLEdBQUcsQ0FBQ3FHLElBQUwsRUFBV2pMLEdBQVgsQ0FBbkMsQ0FBUDtBQUNELE9BM1RvQjtBQTZUckJvL0MscUJBQWUsRUFBRSx5QkFBU3Y5QyxLQUFULEVBQWdCO0FBQy9CLFlBQUlBLEtBQUssSUFBSSxJQUFULElBQWlCQSxLQUFLLElBQUksS0FBS3NQLEtBQUwsQ0FBV3pPLFNBQXpDLEVBQW9EO0FBQUU7QUFBUTs7QUFDOUQsWUFBSSxLQUFLeU8sS0FBTCxDQUFXek8sU0FBWCxHQUF1QixDQUFDLEtBQUt5TyxLQUFMLENBQVd6TyxTQUF2QyxFQUNFO0FBQUV2QixrQkFBUSxDQUFDLEtBQUtrWCxPQUFMLENBQWFvZSxTQUFkLEVBQXlCLHNCQUF6QixDQUFSO0FBQTJELFNBRC9ELE1BR0U7QUFBRXY0QixpQkFBTyxDQUFDLEtBQUttYSxPQUFMLENBQWFvZSxTQUFkLEVBQXlCLHNCQUF6QixDQUFQO0FBQTBEOztBQUU5RDNxQixjQUFNLENBQUMsSUFBRCxFQUFPLGlCQUFQLEVBQTBCLElBQTFCLEVBQWdDLEtBQUtxRixLQUFMLENBQVd6TyxTQUEzQyxDQUFOO0FBQ0QsT0FyVW9CO0FBc1VyQm0wQixjQUFRLEVBQUUsb0JBQVc7QUFBRSxlQUFPLEtBQUt4ZSxPQUFMLENBQWFzSyxLQUFiLENBQW1CODlCLFFBQW5CLE1BQWlDei9DLFNBQVMsRUFBakQ7QUFBcUQsT0F0VXZEO0FBdVVyQjIxQyxnQkFBVSxFQUFFLHNCQUFXO0FBQUUsZUFBTyxDQUFDLEVBQUUsS0FBS25tQyxPQUFMLENBQWFtTSxRQUFiLElBQXlCLEtBQUtsSixHQUFMLENBQVM0NUIsUUFBcEMsQ0FBUjtBQUF1RCxPQXZVM0Q7QUF5VXJCd2YsY0FBUSxFQUFFNXNCLFFBQVEsQ0FBQyxVQUFVMXFCLENBQVYsRUFBYWthLENBQWIsRUFBZ0I7QUFBRTJLLHNCQUFjLENBQUMsSUFBRCxFQUFPN2tCLENBQVAsRUFBVWthLENBQVYsQ0FBZDtBQUE2QixPQUFoRCxDQXpVRztBQTBVckJxOUIsbUJBQWEsRUFBRSx5QkFBVztBQUN4QixZQUFJbmpDLFFBQVEsR0FBRyxLQUFLdFIsT0FBTCxDQUFhc1IsUUFBNUI7QUFDQSxlQUFPO0FBQUNwYixjQUFJLEVBQUVvYixRQUFRLENBQUNpRSxVQUFoQjtBQUE0Qm5ELGFBQUcsRUFBRWQsUUFBUSxDQUFDcUUsU0FBMUM7QUFDQzFaLGdCQUFNLEVBQUVxVixRQUFRLENBQUNpUixZQUFULEdBQXdCcFIsU0FBUyxDQUFDLElBQUQsQ0FBakMsR0FBMEMsS0FBS25SLE9BQUwsQ0FBYTBSLFNBRGhFO0FBRUNsQyxlQUFLLEVBQUU4QixRQUFRLENBQUNvUixXQUFULEdBQXVCdlIsU0FBUyxDQUFDLElBQUQsQ0FBaEMsR0FBeUMsS0FBS25SLE9BQUwsQ0FBYXVSLFFBRjlEO0FBR0NFLHNCQUFZLEVBQUVELGFBQWEsQ0FBQyxJQUFELENBSDVCO0FBR29DdEIscUJBQVcsRUFBRW1CLFlBQVksQ0FBQyxJQUFEO0FBSDdELFNBQVA7QUFJRCxPQWhWb0I7QUFrVnJCOE8sb0JBQWMsRUFBRXlILFFBQVEsQ0FBQyxVQUFTcGdDLEtBQVQsRUFBZ0I2NEIsTUFBaEIsRUFBd0I7QUFDL0MsWUFBSTc0QixLQUFLLElBQUksSUFBYixFQUFtQjtBQUNqQkEsZUFBSyxHQUFHO0FBQUN3SCxnQkFBSSxFQUFFLEtBQUtvTSxHQUFMLENBQVNpZ0IsR0FBVCxDQUFhSixPQUFiLEdBQXVCVSxJQUE5QjtBQUFvQzFzQixjQUFFLEVBQUU7QUFBeEMsV0FBUjs7QUFDQSxjQUFJb3hCLE1BQU0sSUFBSSxJQUFkLEVBQW9CO0FBQUVBLGtCQUFNLEdBQUcsS0FBS2xvQixPQUFMLENBQWEycEIsa0JBQXRCO0FBQTJDO0FBQ2xFLFNBSEQsTUFHTyxJQUFJLE9BQU90NkIsS0FBUCxJQUFnQixRQUFwQixFQUE4QjtBQUNuQ0EsZUFBSyxHQUFHO0FBQUN3SCxnQkFBSSxFQUFFOE4sR0FBRyxDQUFDdFYsS0FBRCxFQUFRLENBQVIsQ0FBVjtBQUFzQnlILGNBQUUsRUFBRTtBQUExQixXQUFSO0FBQ0QsU0FGTSxNQUVBLElBQUl6SCxLQUFLLENBQUN3SCxJQUFOLElBQWMsSUFBbEIsRUFBd0I7QUFDN0J4SCxlQUFLLEdBQUc7QUFBQ3dILGdCQUFJLEVBQUV4SCxLQUFQO0FBQWN5SCxjQUFFLEVBQUU7QUFBbEIsV0FBUjtBQUNEOztBQUNELFlBQUksQ0FBQ3pILEtBQUssQ0FBQ3lILEVBQVgsRUFBZTtBQUFFekgsZUFBSyxDQUFDeUgsRUFBTixHQUFXekgsS0FBSyxDQUFDd0gsSUFBakI7QUFBd0I7O0FBQ3pDeEgsYUFBSyxDQUFDNjRCLE1BQU4sR0FBZUEsTUFBTSxJQUFJLENBQXpCOztBQUVBLFlBQUk3NEIsS0FBSyxDQUFDd0gsSUFBTixDQUFXNEQsSUFBWCxJQUFtQixJQUF2QixFQUE2QjtBQUMzQm92Qix1QkFBYSxDQUFDLElBQUQsRUFBT3g2QixLQUFQLENBQWI7QUFDRCxTQUZELE1BRU87QUFDTHk2Qiw2QkFBbUIsQ0FBQyxJQUFELEVBQU96NkIsS0FBSyxDQUFDd0gsSUFBYixFQUFtQnhILEtBQUssQ0FBQ3lILEVBQXpCLEVBQTZCekgsS0FBSyxDQUFDNjRCLE1BQW5DLENBQW5CO0FBQ0Q7QUFDRixPQWpCdUIsQ0FsVkg7QUFxV3JCb2dCLGFBQU8sRUFBRTdZLFFBQVEsQ0FBQyxVQUFTcFksS0FBVCxFQUFnQnZULE1BQWhCLEVBQXdCO0FBQ3hDLFlBQUlxOEIsTUFBTSxHQUFHLElBQWI7O0FBRUEsWUFBSW9jLFNBQVMsR0FBRyxTQUFaQSxTQUFZLENBQVUxN0MsR0FBVixFQUFlO0FBQUUsaUJBQU8sT0FBT0EsR0FBUCxJQUFjLFFBQWQsSUFBMEIsUUFBUW5WLElBQVIsQ0FBYThZLE1BQU0sQ0FBQzNELEdBQUQsQ0FBbkIsQ0FBMUIsR0FBc0RBLEdBQUcsR0FBRyxJQUE1RCxHQUFtRUEsR0FBMUU7QUFBZ0YsU0FBakg7O0FBQ0EsWUFBSXdXLEtBQUssSUFBSSxJQUFiLEVBQW1CO0FBQUUsZUFBS3hQLE9BQUwsQ0FBYWlRLE9BQWIsQ0FBcUJocEIsS0FBckIsQ0FBMkJ1b0IsS0FBM0IsR0FBbUNrbEMsU0FBUyxDQUFDbGxDLEtBQUQsQ0FBNUM7QUFBc0Q7O0FBQzNFLFlBQUl2VCxNQUFNLElBQUksSUFBZCxFQUFvQjtBQUFFLGVBQUsrRCxPQUFMLENBQWFpUSxPQUFiLENBQXFCaHBCLEtBQXJCLENBQTJCZ1YsTUFBM0IsR0FBb0N5NEMsU0FBUyxDQUFDejRDLE1BQUQsQ0FBN0M7QUFBd0Q7O0FBQzlFLFlBQUksS0FBSzlELE9BQUwsQ0FBYTJaLFlBQWpCLEVBQStCO0FBQUVnRCxtQ0FBeUIsQ0FBQyxJQUFELENBQXpCO0FBQWtDOztBQUNuRSxZQUFJM1ksTUFBTSxHQUFHLEtBQUs2RCxPQUFMLENBQWFHLFFBQTFCO0FBQ0EsYUFBSy9FLEdBQUwsQ0FBU1UsSUFBVCxDQUFjSyxNQUFkLEVBQXNCLEtBQUs2RCxPQUFMLENBQWFJLE1BQW5DLEVBQTJDLFVBQVV4TixJQUFWLEVBQWdCO0FBQ3pELGNBQUlBLElBQUksQ0FBQ3NjLE9BQVQsRUFBa0I7QUFBRSxpQkFBSyxJQUFJN25CLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1TCxJQUFJLENBQUNzYyxPQUFMLENBQWE5b0IsTUFBakMsRUFBeUNpQixDQUFDLEVBQTFDLEVBQ2xCO0FBQUUsa0JBQUl1TCxJQUFJLENBQUNzYyxPQUFMLENBQWE3bkIsQ0FBYixFQUFnQmtvQixTQUFwQixFQUErQjtBQUFFaUwsNkJBQWEsQ0FBQzhkLE1BQUQsRUFBU244QixNQUFULEVBQWlCLFFBQWpCLENBQWI7QUFBeUM7QUFBTztBQUFFO0FBQUU7O0FBQ3pGLFlBQUVBLE1BQUY7QUFDRCxTQUpEO0FBS0EsYUFBSy9ILEtBQUwsQ0FBVzJlLFdBQVgsR0FBeUIsSUFBekI7QUFDQXRmLGNBQU0sQ0FBQyxJQUFELEVBQU8sU0FBUCxFQUFrQixJQUFsQixDQUFOO0FBQ0QsT0FmZ0IsQ0FyV0k7QUFzWHJCazBCLGVBQVMsRUFBRSxtQkFBU2grQixDQUFULEVBQVc7QUFBQyxlQUFPKzlCLE9BQU8sQ0FBQyxJQUFELEVBQU8vOUIsQ0FBUCxDQUFkO0FBQXdCLE9BdFgxQjtBQXVYckJnOEIsb0JBQWMsRUFBRSwwQkFBVTtBQUFDLGVBQU9BLGVBQWMsQ0FBQyxJQUFELENBQXJCO0FBQTRCLE9BdlhsQztBQXdYckJNLGtCQUFZLEVBQUUsd0JBQVU7QUFBQyxlQUFPQSxhQUFZLENBQUMsSUFBRCxDQUFuQjtBQUEwQixPQXhYOUI7QUEwWHJCZ25CLGFBQU8sRUFBRXJsQixRQUFRLENBQUMsWUFBVztBQUMzQixZQUFJOFAsU0FBUyxHQUFHLEtBQUsxM0IsT0FBTCxDQUFha1YsZ0JBQTdCO0FBQ0E0RSxpQkFBUyxDQUFDLElBQUQsQ0FBVDtBQUNBLGFBQUsxbEIsS0FBTCxDQUFXMmUsV0FBWCxHQUF5QixJQUF6QjtBQUNBaUMsbUJBQVcsQ0FBQyxJQUFELENBQVg7QUFDQStNLHNCQUFjLENBQUMsSUFBRCxFQUFPLEtBQUszbUIsR0FBTCxDQUFTbWEsVUFBaEIsRUFBNEIsS0FBS25hLEdBQUwsQ0FBU3VhLFNBQXJDLENBQWQ7QUFDQW1WLHlCQUFpQixDQUFDLEtBQUs5cUIsT0FBTixDQUFqQjs7QUFDQSxZQUFJMDNCLFNBQVMsSUFBSSxJQUFiLElBQXFCaHJDLElBQUksQ0FBQzZLLEdBQUwsQ0FBU21nQyxTQUFTLEdBQUcvZSxVQUFVLENBQUMsS0FBSzNZLE9BQU4sQ0FBL0IsSUFBaUQsRUFBdEUsSUFBNEUsS0FBSzdILE9BQUwsQ0FBYTJaLFlBQTdGLEVBQ0U7QUFBRXFILDZCQUFtQixDQUFDLElBQUQsQ0FBbkI7QUFBNEI7O0FBQ2hDMWxCLGNBQU0sQ0FBQyxJQUFELEVBQU8sU0FBUCxFQUFrQixJQUFsQixDQUFOO0FBQ0QsT0FWZ0IsQ0ExWEk7QUFzWXJCa2hELGFBQU8sRUFBRS9zQixRQUFRLENBQUMsVUFBU3hzQixHQUFULEVBQWM7QUFDOUIsWUFBSXNILEdBQUcsR0FBRyxLQUFLdEgsR0FBZjtBQUNBc0gsV0FBRyxDQUFDOU8sRUFBSixHQUFTLElBQVQsQ0FGOEIsQ0FHOUI7O0FBQ0EsWUFBSSxLQUFLa0YsS0FBTCxDQUFXd3dDLGFBQWYsRUFBOEI7QUFBRSxlQUFLeHdDLEtBQUwsQ0FBV3d3QyxhQUFYO0FBQTZCOztBQUM3RGxaLGlCQUFTLENBQUMsSUFBRCxFQUFPaDFCLEdBQVAsQ0FBVDtBQUNBNFosbUJBQVcsQ0FBQyxJQUFELENBQVg7QUFDQSxhQUFLaFYsT0FBTCxDQUFhc0ssS0FBYixDQUFtQjJVLEtBQW5CO0FBQ0E4QyxzQkFBYyxDQUFDLElBQUQsRUFBTzNtQixHQUFHLENBQUNtYSxVQUFYLEVBQXVCbmEsR0FBRyxDQUFDdWEsU0FBM0IsQ0FBZDtBQUNBLGFBQUt2aEIsS0FBTCxDQUFXa3VCLFdBQVgsR0FBeUIsSUFBekI7QUFDQWpXLG1CQUFXLENBQUMsSUFBRCxFQUFPLFNBQVAsRUFBa0IsSUFBbEIsRUFBd0IzSixHQUF4QixDQUFYO0FBQ0EsZUFBT0EsR0FBUDtBQUNELE9BWmdCLENBdFlJO0FBb1pyQmt5QyxZQUFNLEVBQUUsZ0JBQVNDLFVBQVQsRUFBcUI7QUFDM0IsWUFBSUMsT0FBTyxHQUFHLEtBQUszOEMsT0FBTCxDQUFhMjhDLE9BQTNCO0FBQ0EsZUFBT0EsT0FBTyxJQUFJbG5ELE1BQU0sQ0FBQzlELFNBQVAsQ0FBaUJTLGNBQWpCLENBQWdDUixJQUFoQyxDQUFxQytxRCxPQUFyQyxFQUE4Q0QsVUFBOUMsQ0FBWCxHQUF1RUMsT0FBTyxDQUFDRCxVQUFELENBQTlFLEdBQTZGQSxVQUFwRztBQUNELE9BdlpvQjtBQXlackIzSCxtQkFBYSxFQUFFLHlCQUFVO0FBQUMsZUFBTyxLQUFLbHRDLE9BQUwsQ0FBYXNLLEtBQWIsQ0FBbUI4OUIsUUFBbkIsRUFBUDtBQUFxQyxPQXpaMUM7QUEwWnJCMk0sdUJBQWlCLEVBQUUsNkJBQVU7QUFBQyxlQUFPLEtBQUsvMEMsT0FBTCxDQUFhaVEsT0FBcEI7QUFBNEIsT0ExWnJDO0FBMlpyQitrQyx3QkFBa0IsRUFBRSw4QkFBVTtBQUFDLGVBQU8sS0FBS2gxQyxPQUFMLENBQWFzUixRQUFwQjtBQUE2QixPQTNadkM7QUE0WnJCMmpDLHNCQUFnQixFQUFFLDRCQUFVO0FBQUMsZUFBTyxLQUFLajFDLE9BQUwsQ0FBYWdRLE9BQXBCO0FBQTRCO0FBNVpwQyxLQUF2QjtBQThaQXpiLGNBQVUsQ0FBQ21wQyxVQUFELENBQVY7O0FBRUFBLGNBQVUsQ0FBQ3dYLGNBQVgsR0FBNEIsVUFBU2prRCxJQUFULEVBQWUwRyxJQUFmLEVBQXFCbk8sS0FBckIsRUFBNEI7QUFDdEQsVUFBSSxDQUFDMm9ELE9BQU8sQ0FBQzVuRCxjQUFSLENBQXVCMEcsSUFBdkIsQ0FBTCxFQUFtQztBQUFFa2hELGVBQU8sQ0FBQ2xoRCxJQUFELENBQVAsR0FBZ0J5c0MsVUFBVSxDQUFDenNDLElBQUQsQ0FBVixHQUFtQjtBQUFDaWlELGlCQUFPLEVBQUU7QUFBVixTQUFuQztBQUFtRDs7QUFDeEZmLGFBQU8sQ0FBQ2xoRCxJQUFELENBQVAsQ0FBYzBHLElBQWQsSUFBc0JuTyxLQUF0QjtBQUNELEtBSEQ7O0FBSUFrMEMsY0FBVSxDQUFDeVgsb0JBQVgsR0FBa0MsVUFBU2xrRCxJQUFULEVBQWUwRyxJQUFmLEVBQXFCeTlDLFNBQXJCLEVBQWdDNXJELEtBQWhDLEVBQXVDO0FBQ3ZFazBDLGdCQUFVLENBQUN3WCxjQUFYLENBQTBCamtELElBQTFCLEVBQWdDMEcsSUFBaEMsRUFBc0NuTyxLQUF0Qzs7QUFDQTJvRCxhQUFPLENBQUNsaEQsSUFBRCxDQUFQLENBQWNpaUQsT0FBZCxDQUFzQnBtRCxJQUF0QixDQUEyQjtBQUFDaUMsWUFBSSxFQUFFcW1ELFNBQVA7QUFBa0JwOEMsV0FBRyxFQUFFeFA7QUFBdkIsT0FBM0I7QUFDRCxLQUhEO0FBSUQsR0EvN1FrQixDQWk4UW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsV0FBU3NxRCxTQUFULENBQWtCMTRDLEdBQWxCLEVBQXVCN08sR0FBdkIsRUFBNEJxQyxHQUE1QixFQUFpQ2c3QyxJQUFqQyxFQUF1QzlHLFFBQXZDLEVBQWlEO0FBQy9DLFFBQUl2TyxNQUFNLEdBQUdob0MsR0FBYjtBQUNBLFFBQUk4b0QsT0FBTyxHQUFHem1ELEdBQWQ7QUFDQSxRQUFJa1ksT0FBTyxHQUFHM0wsT0FBTyxDQUFDQyxHQUFELEVBQU03TyxHQUFHLENBQUNxRyxJQUFWLENBQXJCO0FBQ0EsUUFBSTBpRCxPQUFPLEdBQUd4UyxRQUFRLElBQUkxbkMsR0FBRyxDQUFDekssU0FBSixJQUFpQixLQUE3QixHQUFxQyxDQUFDL0IsR0FBdEMsR0FBNENBLEdBQTFEOztBQUNBLGFBQVMybUQsWUFBVCxHQUF3QjtBQUN0QixVQUFJai9DLENBQUMsR0FBRy9KLEdBQUcsQ0FBQ3FHLElBQUosR0FBVzBpRCxPQUFuQjs7QUFDQSxVQUFJaC9DLENBQUMsR0FBRzhFLEdBQUcsQ0FBQ0MsS0FBUixJQUFpQi9FLENBQUMsSUFBSThFLEdBQUcsQ0FBQ0MsS0FBSixHQUFZRCxHQUFHLENBQUNFLElBQTFDLEVBQWdEO0FBQUUsZUFBTyxLQUFQO0FBQWM7O0FBQ2hFL08sU0FBRyxHQUFHLElBQUl1USxHQUFKLENBQVF4RyxDQUFSLEVBQVcvSixHQUFHLENBQUN5QixFQUFmLEVBQW1CekIsR0FBRyxDQUFDdUQsTUFBdkIsQ0FBTjtBQUNBLGFBQU9nWCxPQUFPLEdBQUczTCxPQUFPLENBQUNDLEdBQUQsRUFBTTlFLENBQU4sQ0FBeEI7QUFDRDs7QUFDRCxhQUFTay9DLFFBQVQsQ0FBa0JDLFdBQWxCLEVBQStCO0FBQzdCLFVBQUkxN0MsSUFBSjs7QUFDQSxVQUFJNnZDLElBQUksSUFBSSxXQUFaLEVBQXlCO0FBQ3ZCLFlBQUk1N0MsRUFBRSxHQUFHOFksT0FBTyxDQUFDalUsSUFBUixDQUFhcEUsVUFBYixDQUF3QmxDLEdBQUcsQ0FBQ3lCLEVBQUosSUFBVVksR0FBRyxHQUFHLENBQU4sR0FBVSxDQUFWLEdBQWMsQ0FBQyxDQUF6QixDQUF4QixDQUFUOztBQUNBLFlBQUlzaUIsS0FBSyxDQUFDbGpCLEVBQUQsQ0FBVCxFQUFlO0FBQ2IrTCxjQUFJLEdBQUcsSUFBUDtBQUNELFNBRkQsTUFFTztBQUNMLGNBQUkyN0MsTUFBTSxHQUFHOW1ELEdBQUcsR0FBRyxDQUFOLEdBQVVaLEVBQUUsSUFBSSxNQUFOLElBQWdCQSxFQUFFLEdBQUcsTUFBL0IsR0FBd0NBLEVBQUUsSUFBSSxNQUFOLElBQWdCQSxFQUFFLEdBQUcsTUFBMUU7QUFDQStMLGNBQUksR0FBRyxJQUFJK0MsR0FBSixDQUFRdlEsR0FBRyxDQUFDcUcsSUFBWixFQUFrQmxHLElBQUksQ0FBQ2dELEdBQUwsQ0FBUyxDQUFULEVBQVloRCxJQUFJLENBQUNDLEdBQUwsQ0FBU21hLE9BQU8sQ0FBQ2pVLElBQVIsQ0FBYXpNLE1BQXRCLEVBQThCbUcsR0FBRyxDQUFDeUIsRUFBSixHQUFTWSxHQUFHLElBQUk4bUQsTUFBTSxHQUFHLENBQUgsR0FBTyxDQUFqQixDQUExQyxDQUFaLENBQWxCLEVBQStGLENBQUM5bUQsR0FBaEcsQ0FBUDtBQUNEO0FBQ0YsT0FSRCxNQVFPLElBQUlrMEMsUUFBSixFQUFjO0FBQ25CL29DLFlBQUksR0FBR2twQyxZQUFZLENBQUM3bkMsR0FBRyxDQUFDeEgsRUFBTCxFQUFTa1QsT0FBVCxFQUFrQnZhLEdBQWxCLEVBQXVCcUMsR0FBdkIsQ0FBbkI7QUFDRCxPQUZNLE1BRUE7QUFDTG1MLFlBQUksR0FBRzZvQyxhQUFhLENBQUM5N0IsT0FBRCxFQUFVdmEsR0FBVixFQUFlcUMsR0FBZixDQUFwQjtBQUNEOztBQUNELFVBQUltTCxJQUFJLElBQUksSUFBWixFQUFrQjtBQUNoQixZQUFJLENBQUMwN0MsV0FBRCxJQUFnQkYsWUFBWSxFQUFoQyxFQUNFO0FBQUVocEQsYUFBRyxHQUFHczJDLFNBQVMsQ0FBQ0MsUUFBRCxFQUFXMW5DLEdBQUcsQ0FBQ3hILEVBQWYsRUFBbUJrVCxPQUFuQixFQUE0QnZhLEdBQUcsQ0FBQ3FHLElBQWhDLEVBQXNDMGlELE9BQXRDLENBQWY7QUFBZ0UsU0FEcEUsTUFHRTtBQUFFLGlCQUFPLEtBQVA7QUFBYztBQUNuQixPQUxELE1BS087QUFDTC9vRCxXQUFHLEdBQUd3TixJQUFOO0FBQ0Q7O0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQsUUFBSTZ2QyxJQUFJLElBQUksTUFBUixJQUFrQkEsSUFBSSxJQUFJLFdBQTlCLEVBQTJDO0FBQ3pDNEwsY0FBUTtBQUNULEtBRkQsTUFFTyxJQUFJNUwsSUFBSSxJQUFJLFFBQVosRUFBc0I7QUFDM0I0TCxjQUFRLENBQUMsSUFBRCxDQUFSO0FBQ0QsS0FGTSxNQUVBLElBQUk1TCxJQUFJLElBQUksTUFBUixJQUFrQkEsSUFBSSxJQUFJLE9BQTlCLEVBQXVDO0FBQzVDLFVBQUkrTCxPQUFPLEdBQUcsSUFBZDtBQUFBLFVBQW9CNXBDLEtBQUssR0FBRzY5QixJQUFJLElBQUksT0FBcEM7QUFDQSxVQUFJeDdDLE1BQU0sR0FBR2dOLEdBQUcsQ0FBQ3hILEVBQUosSUFBVXdILEdBQUcsQ0FBQ3hILEVBQUosQ0FBT20vQyxTQUFQLENBQWlCeG1ELEdBQWpCLEVBQXNCLFdBQXRCLENBQXZCOztBQUNBLFdBQUssSUFBSThPLEtBQUssR0FBRyxJQUFqQixHQUF3QkEsS0FBSyxHQUFHLEtBQWhDLEVBQXVDO0FBQ3JDLFlBQUl6TSxHQUFHLEdBQUcsQ0FBTixJQUFXLENBQUM0bUQsUUFBUSxDQUFDLENBQUNuNkMsS0FBRixDQUF4QixFQUFrQztBQUFFO0FBQU87O0FBQzNDLFlBQUl0TCxHQUFHLEdBQUcrVyxPQUFPLENBQUNqVSxJQUFSLENBQWFoRSxNQUFiLENBQW9CdEMsR0FBRyxDQUFDeUIsRUFBeEIsS0FBK0IsSUFBekM7QUFDQSxZQUFJaUQsSUFBSSxHQUFHOUMsVUFBVSxDQUFDNEIsR0FBRCxFQUFNM0IsTUFBTixDQUFWLEdBQTBCLEdBQTFCLEdBQ1AyZCxLQUFLLElBQUloYyxHQUFHLElBQUksSUFBaEIsR0FBdUIsR0FBdkIsR0FDQSxDQUFDZ2MsS0FBRCxJQUFVLEtBQUtsb0IsSUFBTCxDQUFVa00sR0FBVixDQUFWLEdBQTJCLElBQTNCLEdBQ0EsR0FISjs7QUFJQSxZQUFJZ2MsS0FBSyxJQUFJLENBQUMxUSxLQUFWLElBQW1CLENBQUNwSyxJQUF4QixFQUE4QjtBQUFFQSxjQUFJLEdBQUcsR0FBUDtBQUFhOztBQUM3QyxZQUFJMGtELE9BQU8sSUFBSUEsT0FBTyxJQUFJMWtELElBQTFCLEVBQWdDO0FBQzlCLGNBQUlyQyxHQUFHLEdBQUcsQ0FBVixFQUFhO0FBQUNBLGVBQUcsR0FBRyxDQUFOO0FBQVM0bUQsb0JBQVE7QUFBSWpwRCxlQUFHLENBQUN1RCxNQUFKLEdBQWEsT0FBYjtBQUFzQjs7QUFDekQ7QUFDRDs7QUFFRCxZQUFJbUIsSUFBSixFQUFVO0FBQUUwa0QsaUJBQU8sR0FBRzFrRCxJQUFWO0FBQWlCOztBQUM3QixZQUFJckMsR0FBRyxHQUFHLENBQU4sSUFBVyxDQUFDNG1ELFFBQVEsQ0FBQyxDQUFDbjZDLEtBQUYsQ0FBeEIsRUFBa0M7QUFBRTtBQUFPO0FBQzVDO0FBQ0Y7O0FBQ0QsUUFBSWhGLE1BQU0sR0FBRys5QixVQUFVLENBQUNoNUIsR0FBRCxFQUFNN08sR0FBTixFQUFXZ29DLE1BQVgsRUFBbUI4Z0IsT0FBbkIsRUFBNEIsSUFBNUIsQ0FBdkI7O0FBQ0EsUUFBSXI0QyxjQUFjLENBQUN1M0IsTUFBRCxFQUFTbCtCLE1BQVQsQ0FBbEIsRUFBb0M7QUFBRUEsWUFBTSxDQUFDMjlDLE9BQVAsR0FBaUIsSUFBakI7QUFBd0I7O0FBQzlELFdBQU8zOUMsTUFBUDtBQUNELEdBMWdSa0IsQ0E0Z1JuQjtBQUNBO0FBQ0E7OztBQUNBLFdBQVM2OUMsU0FBVCxDQUFrQnRnRCxFQUFsQixFQUFzQnJILEdBQXRCLEVBQTJCcUMsR0FBM0IsRUFBZ0NnN0MsSUFBaEMsRUFBc0M7QUFDcEMsUUFBSXh1QyxHQUFHLEdBQUd4SCxFQUFFLENBQUN3SCxHQUFiO0FBQUEsUUFBa0I4QixDQUFDLEdBQUczUSxHQUFHLENBQUMySixJQUExQjtBQUFBLFFBQWdDa2hCLENBQWhDOztBQUNBLFFBQUl3eUIsSUFBSSxJQUFJLE1BQVosRUFBb0I7QUFDbEIsVUFBSWdNLFFBQVEsR0FBR2xwRCxJQUFJLENBQUNDLEdBQUwsQ0FBU2lILEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV2lRLE9BQVgsQ0FBbUJ3QixZQUE1QixFQUEwQy9hLE1BQU0sQ0FBQ3VwQixXQUFQLElBQXNCNzdCLFFBQVEsQ0FBQ2t4QixlQUFULENBQXlCN0QsWUFBekYsQ0FBZjtBQUNBLFVBQUlva0MsVUFBVSxHQUFHbnBELElBQUksQ0FBQ2dELEdBQUwsQ0FBU2ttRCxRQUFRLEdBQUcsS0FBS2o5QixVQUFVLENBQUMva0IsRUFBRSxDQUFDb00sT0FBSixDQUFuQyxFQUFpRCxDQUFqRCxDQUFqQjtBQUNBb1gsT0FBQyxHQUFHLENBQUN4b0IsR0FBRyxHQUFHLENBQU4sR0FBVXJDLEdBQUcsQ0FBQzRsQixNQUFkLEdBQXVCNWxCLEdBQUcsQ0FBQzZsQixHQUE1QixJQUFtQ3hqQixHQUFHLEdBQUdpbkQsVUFBN0M7QUFFRCxLQUxELE1BS08sSUFBSWpNLElBQUksSUFBSSxNQUFaLEVBQW9CO0FBQ3pCeHlCLE9BQUMsR0FBR3hvQixHQUFHLEdBQUcsQ0FBTixHQUFVckMsR0FBRyxDQUFDNGxCLE1BQUosR0FBYSxDQUF2QixHQUEyQjVsQixHQUFHLENBQUM2bEIsR0FBSixHQUFVLENBQXpDO0FBQ0Q7O0FBQ0QsUUFBSWhvQixNQUFKOztBQUNBLGFBQVM7QUFDUEEsWUFBTSxHQUFHK3NCLFdBQVUsQ0FBQ3ZqQixFQUFELEVBQUtzSixDQUFMLEVBQVFrYSxDQUFSLENBQW5COztBQUNBLFVBQUksQ0FBQ2h0QixNQUFNLENBQUM2c0IsT0FBWixFQUFxQjtBQUFFO0FBQU87O0FBQzlCLFVBQUlyb0IsR0FBRyxHQUFHLENBQU4sR0FBVXdvQixDQUFDLElBQUksQ0FBZixHQUFtQkEsQ0FBQyxJQUFJaGMsR0FBRyxDQUFDYSxNQUFoQyxFQUF3QztBQUFFN1IsY0FBTSxDQUFDNHBELE9BQVAsR0FBaUIsSUFBakI7QUFBdUI7QUFBTzs7QUFDeEU1OEIsT0FBQyxJQUFJeG9CLEdBQUcsR0FBRyxDQUFYO0FBQ0Q7O0FBQ0QsV0FBT3hFLE1BQVA7QUFDRCxHQWppUmtCLENBbWlSbkI7OztBQUVBLE1BQUkwckQsb0JBQW9CLEdBQUcsU0FBdkJBLG9CQUF1QixDQUFTbGlELEVBQVQsRUFBYTtBQUN0QyxTQUFLQSxFQUFMLEdBQVVBLEVBQVY7QUFDQSxTQUFLbWlELGNBQUwsR0FBc0IsS0FBS0MsZ0JBQUwsR0FBd0IsS0FBS0MsYUFBTCxHQUFxQixLQUFLQyxlQUFMLEdBQXVCLElBQTFGO0FBQ0EsU0FBS0MsT0FBTCxHQUFlLElBQUlsckQsT0FBSixFQUFmO0FBQ0EsU0FBS21yRCxTQUFMLEdBQWlCLElBQWpCO0FBQ0EsU0FBS0MsV0FBTCxHQUFtQixLQUFuQjtBQUNBLFNBQUtDLGNBQUwsR0FBc0IsSUFBdEI7QUFDRCxHQVBEOztBQVNBUixzQkFBb0IsQ0FBQ2hzRCxTQUFyQixDQUErQmtpQyxJQUEvQixHQUFzQyxVQUFVaHNCLE9BQVYsRUFBbUI7QUFDckQsUUFBSXM0QixNQUFNLEdBQUcsSUFBYjtBQUVGLFFBQUlodUIsS0FBSyxHQUFHLElBQVo7QUFBQSxRQUFrQjFXLEVBQUUsR0FBRzBXLEtBQUssQ0FBQzFXLEVBQTdCO0FBQ0EsUUFBSTBCLEdBQUcsR0FBR2dWLEtBQUssQ0FBQ2hWLEdBQU4sR0FBWTBLLE9BQU8sQ0FBQ3NmLE9BQTlCO0FBQ0F3eUIsdUJBQW1CLENBQUN4OEMsR0FBRCxFQUFNMUIsRUFBRSxDQUFDdUUsT0FBSCxDQUFXZzFDLFVBQWpCLEVBQTZCdjVDLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBV2kxQyxXQUF4QyxFQUFxRHg1QyxFQUFFLENBQUN1RSxPQUFILENBQVdrMUMsY0FBaEUsQ0FBbkI7O0FBRUEsYUFBU2tKLGNBQVQsQ0FBd0Jqd0QsQ0FBeEIsRUFBMkI7QUFDekIsV0FBSyxJQUFJcTRDLENBQUMsR0FBR3I0QyxDQUFDLENBQUM4RCxNQUFmLEVBQXVCdTBDLENBQXZCLEVBQTBCQSxDQUFDLEdBQUdBLENBQUMsQ0FBQ3gyQyxVQUFoQyxFQUE0QztBQUMxQyxZQUFJdzJDLENBQUMsSUFBSXJwQyxHQUFULEVBQWM7QUFBRSxpQkFBTyxJQUFQO0FBQWE7O0FBQzdCLFlBQUksaUNBQWlDelIsSUFBakMsQ0FBc0M4NkMsQ0FBQyxDQUFDMzRDLFNBQXhDLENBQUosRUFBd0Q7QUFBRTtBQUFPO0FBQ2xFOztBQUNELGFBQU8sS0FBUDtBQUNEOztBQUVEK00sTUFBRSxDQUFDdUMsR0FBRCxFQUFNLE9BQU4sRUFBZSxVQUFVaFAsQ0FBVixFQUFhO0FBQzVCLFVBQUksQ0FBQ2l3RCxjQUFjLENBQUNqd0QsQ0FBRCxDQUFmLElBQXNCcU4sY0FBYyxDQUFDQyxFQUFELEVBQUt0TixDQUFMLENBQXBDLElBQStDOHFELFdBQVcsQ0FBQzlxRCxDQUFELEVBQUlzTixFQUFKLENBQTlELEVBQXVFO0FBQUU7QUFBUSxPQURyRCxDQUU1Qjs7O0FBQ0EsVUFBSXpQLFVBQVUsSUFBSSxFQUFsQixFQUFzQjtBQUFFcUgsa0JBQVUsQ0FBQ204QixTQUFTLENBQUMvekIsRUFBRCxFQUFLLFlBQVk7QUFBRSxpQkFBTzBrQyxNQUFNLENBQUNrZSxhQUFQLEVBQVA7QUFBZ0MsU0FBbkQsQ0FBVixFQUFnRSxFQUFoRSxDQUFWO0FBQWdGO0FBQ3pHLEtBSkMsQ0FBRjtBQU1BempELE1BQUUsQ0FBQ3VDLEdBQUQsRUFBTSxrQkFBTixFQUEwQixVQUFVaFAsQ0FBVixFQUFhO0FBQ3ZDZ3lDLFlBQU0sQ0FBQzhkLFNBQVAsR0FBbUI7QUFBQ3JsQyxZQUFJLEVBQUV6cUIsQ0FBQyxDQUFDeXFCLElBQVQ7QUFBZTBmLFlBQUksRUFBRTtBQUFyQixPQUFuQjtBQUNELEtBRkMsQ0FBRjtBQUdBMTlCLE1BQUUsQ0FBQ3VDLEdBQUQsRUFBTSxtQkFBTixFQUEyQixVQUFVaFAsQ0FBVixFQUFhO0FBQ3hDLFVBQUksQ0FBQ2d5QyxNQUFNLENBQUM4ZCxTQUFaLEVBQXVCO0FBQUU5ZCxjQUFNLENBQUM4ZCxTQUFQLEdBQW1CO0FBQUNybEMsY0FBSSxFQUFFenFCLENBQUMsQ0FBQ3lxQixJQUFUO0FBQWUwZixjQUFJLEVBQUU7QUFBckIsU0FBbkI7QUFBaUQ7QUFDM0UsS0FGQyxDQUFGO0FBR0ExOUIsTUFBRSxDQUFDdUMsR0FBRCxFQUFNLGdCQUFOLEVBQXdCLFVBQVVoUCxDQUFWLEVBQWE7QUFDckMsVUFBSWd5QyxNQUFNLENBQUM4ZCxTQUFYLEVBQXNCO0FBQ3BCLFlBQUk5dkQsQ0FBQyxDQUFDeXFCLElBQUYsSUFBVXVuQixNQUFNLENBQUM4ZCxTQUFQLENBQWlCcmxDLElBQS9CLEVBQXFDO0FBQUV1bkIsZ0JBQU0sQ0FBQ21lLGVBQVA7QUFBMkI7O0FBQ2xFbmUsY0FBTSxDQUFDOGQsU0FBUCxDQUFpQjNsQixJQUFqQixHQUF3QixJQUF4QjtBQUNEO0FBQ0YsS0FMQyxDQUFGO0FBT0ExOUIsTUFBRSxDQUFDdUMsR0FBRCxFQUFNLFlBQU4sRUFBb0IsWUFBWTtBQUFFLGFBQU9nVixLQUFLLENBQUNvc0MsbUJBQU4sRUFBUDtBQUFxQyxLQUF2RSxDQUFGO0FBRUEzakQsTUFBRSxDQUFDdUMsR0FBRCxFQUFNLE9BQU4sRUFBZSxZQUFZO0FBQzNCLFVBQUksQ0FBQ2dqQyxNQUFNLENBQUM4ZCxTQUFaLEVBQXVCO0FBQUU5ZCxjQUFNLENBQUNtZSxlQUFQO0FBQTJCO0FBQ3JELEtBRkMsQ0FBRjs7QUFJQSxhQUFTRSxTQUFULENBQW1CcndELENBQW5CLEVBQXNCO0FBQ3BCLFVBQUksQ0FBQ2l3RCxjQUFjLENBQUNqd0QsQ0FBRCxDQUFmLElBQXNCcU4sY0FBYyxDQUFDQyxFQUFELEVBQUt0TixDQUFMLENBQXhDLEVBQWlEO0FBQUU7QUFBUTs7QUFDM0QsVUFBSXNOLEVBQUUsQ0FBQys1QixpQkFBSCxFQUFKLEVBQTRCO0FBQzFCNGlCLHFCQUFhLENBQUM7QUFBQ1Usa0JBQVEsRUFBRSxLQUFYO0FBQWtCcCtDLGNBQUksRUFBRWUsRUFBRSxDQUFDeW5DLGFBQUg7QUFBeEIsU0FBRCxDQUFiOztBQUNBLFlBQUkvMEMsQ0FBQyxDQUFDMkssSUFBRixJQUFVLEtBQWQsRUFBcUI7QUFBRTJDLFlBQUUsQ0FBQzBuQyxnQkFBSCxDQUFvQixFQUFwQixFQUF3QixJQUF4QixFQUE4QixLQUE5QjtBQUF1QztBQUMvRCxPQUhELE1BR08sSUFBSSxDQUFDMW5DLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBV3krQyxlQUFoQixFQUFpQztBQUN0QztBQUNELE9BRk0sTUFFQTtBQUNMLFlBQUl0N0IsTUFBTSxHQUFHczJCLGNBQWMsQ0FBQ2grQyxFQUFELENBQTNCO0FBQ0EyOEMscUJBQWEsQ0FBQztBQUFDVSxrQkFBUSxFQUFFLElBQVg7QUFBaUJwK0MsY0FBSSxFQUFFeW9CLE1BQU0sQ0FBQ3pvQjtBQUE5QixTQUFELENBQWI7O0FBQ0EsWUFBSXZNLENBQUMsQ0FBQzJLLElBQUYsSUFBVSxLQUFkLEVBQXFCO0FBQ25CMkMsWUFBRSxDQUFDK3pCLFNBQUgsQ0FBYSxZQUFZO0FBQ3ZCL3pCLGNBQUUsQ0FBQ3VuQyxhQUFILENBQWlCN2YsTUFBTSxDQUFDQSxNQUF4QixFQUFnQyxDQUFoQyxFQUFtQ3R2QixjQUFuQztBQUNBNEgsY0FBRSxDQUFDMG5DLGdCQUFILENBQW9CLEVBQXBCLEVBQXdCLElBQXhCLEVBQThCLEtBQTlCO0FBQ0QsV0FIRDtBQUlEO0FBQ0Y7O0FBQ0QsVUFBSWgxQyxDQUFDLENBQUNnckQsYUFBTixFQUFxQjtBQUNuQmhyRCxTQUFDLENBQUNnckQsYUFBRixDQUFnQnVGLFNBQWhCO0FBQ0EsWUFBSTd2RCxPQUFPLEdBQUdzcEQsVUFBVSxDQUFDejlDLElBQVgsQ0FBZ0IybkMsSUFBaEIsQ0FBcUIsSUFBckIsQ0FBZCxDQUZtQixDQUduQjs7QUFDQWwwQyxTQUFDLENBQUNnckQsYUFBRixDQUFnQi9SLE9BQWhCLENBQXdCLE1BQXhCLEVBQWdDdjRDLE9BQWhDOztBQUNBLFlBQUlWLENBQUMsQ0FBQ2dyRCxhQUFGLENBQWdCbFMsT0FBaEIsQ0FBd0IsTUFBeEIsS0FBbUNwNEMsT0FBdkMsRUFBZ0Q7QUFDOUNWLFdBQUMsQ0FBQ3dOLGNBQUY7QUFDQTtBQUNEO0FBQ0YsT0ExQm1CLENBMkJwQjs7O0FBQ0EsVUFBSWdqRCxNQUFNLEdBQUc5RSxjQUFjLEVBQTNCO0FBQUEsVUFBK0JwN0MsRUFBRSxHQUFHa2dELE1BQU0sQ0FBQ3B3RCxVQUEzQztBQUNBa04sUUFBRSxDQUFDb00sT0FBSCxDQUFXd1EsU0FBWCxDQUFxQmxELFlBQXJCLENBQWtDd3BDLE1BQWxDLEVBQTBDbGpELEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3dRLFNBQVgsQ0FBcUI5cEIsVUFBL0Q7QUFDQWtRLFFBQUUsQ0FBQ3BOLEtBQUgsR0FBVzhtRCxVQUFVLENBQUN6OUMsSUFBWCxDQUFnQjJuQyxJQUFoQixDQUFxQixJQUFyQixDQUFYO0FBQ0EsVUFBSXVjLFFBQVEsR0FBRzN5RCxRQUFRLENBQUN3RSxhQUF4QjtBQUNBUSxpQkFBVyxDQUFDd04sRUFBRCxDQUFYO0FBQ0FwTCxnQkFBVSxDQUFDLFlBQVk7QUFDckJvSSxVQUFFLENBQUNvTSxPQUFILENBQVd3USxTQUFYLENBQXFCL3BCLFdBQXJCLENBQWlDcXdELE1BQWpDO0FBQ0FDLGdCQUFRLENBQUNwNEIsS0FBVDs7QUFDQSxZQUFJbzRCLFFBQVEsSUFBSXpoRCxHQUFoQixFQUFxQjtBQUFFZ1YsZUFBSyxDQUFDMHNDLG9CQUFOO0FBQStCO0FBQ3ZELE9BSlMsRUFJUCxFQUpPLENBQVY7QUFLRDs7QUFDRGprRCxNQUFFLENBQUN1QyxHQUFELEVBQU0sTUFBTixFQUFjcWhELFNBQWQsQ0FBRjtBQUNBNWpELE1BQUUsQ0FBQ3VDLEdBQUQsRUFBTSxLQUFOLEVBQWFxaEQsU0FBYixDQUFGO0FBQ0QsR0FqRkQ7O0FBbUZBYixzQkFBb0IsQ0FBQ2hzRCxTQUFyQixDQUErQjhqRCx3QkFBL0IsR0FBMEQsVUFBVXFKLEtBQVYsRUFBaUI7QUFDekU7QUFDQSxRQUFHQSxLQUFILEVBQVU7QUFDUixXQUFLM2hELEdBQUwsQ0FBUy9OLFlBQVQsQ0FBc0IsWUFBdEIsRUFBb0MwdkQsS0FBcEM7QUFDRCxLQUZELE1BRU87QUFDTCxXQUFLM2hELEdBQUwsQ0FBUzRoRCxlQUFULENBQXlCLFlBQXpCO0FBQ0Q7QUFDRixHQVBEOztBQVNBcEIsc0JBQW9CLENBQUNoc0QsU0FBckIsQ0FBK0JreEIsZ0JBQS9CLEdBQWtELFlBQVk7QUFDNUQsUUFBSTNrQixNQUFNLEdBQUcya0IsZ0JBQWdCLENBQUMsS0FBS3BuQixFQUFOLEVBQVUsS0FBVixDQUE3QjtBQUNBeUMsVUFBTSxDQUFDc29CLEtBQVAsR0FBZXY2QixRQUFRLENBQUN3RSxhQUFULElBQTBCLEtBQUswTSxHQUE5QztBQUNBLFdBQU9lLE1BQVA7QUFDRCxHQUpEOztBQU1BeS9DLHNCQUFvQixDQUFDaHNELFNBQXJCLENBQStCaXhCLGFBQS9CLEdBQStDLFVBQVU3aEIsSUFBVixFQUFnQit0QixTQUFoQixFQUEyQjtBQUN4RSxRQUFJLENBQUMvdEIsSUFBRCxJQUFTLENBQUMsS0FBS3RGLEVBQUwsQ0FBUW9NLE9BQVIsQ0FBZ0J1TCxJQUFoQixDQUFxQm5sQixNQUFuQyxFQUEyQztBQUFFO0FBQVE7O0FBQ3JELFFBQUk4UyxJQUFJLENBQUN5bEIsS0FBTCxJQUFjc0ksU0FBbEIsRUFBNkI7QUFBRSxXQUFLK3ZCLG9CQUFMO0FBQThCOztBQUM3RCxTQUFLRyxzQkFBTCxDQUE0QmorQyxJQUE1QjtBQUNELEdBSkQ7O0FBTUE0OEMsc0JBQW9CLENBQUNoc0QsU0FBckIsQ0FBK0I2TSxZQUEvQixHQUE4QyxZQUFZO0FBQ3hELFdBQU8sS0FBSy9DLEVBQUwsQ0FBUW9NLE9BQVIsQ0FBZ0JpUSxPQUFoQixDQUF3QnBaLGFBQXhCLENBQXNDRixZQUF0QyxFQUFQO0FBQ0QsR0FGRDs7QUFJQW0vQyxzQkFBb0IsQ0FBQ2hzRCxTQUFyQixDQUErQmt0RCxvQkFBL0IsR0FBc0QsWUFBWTtBQUNoRSxRQUFJMzdCLEdBQUcsR0FBRyxLQUFLMWtCLFlBQUwsRUFBVjtBQUFBLFFBQStCL0MsRUFBRSxHQUFHLEtBQUtBLEVBQXpDO0FBQUEsUUFBNkNtNkIsSUFBSSxHQUFHbjZCLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT2lnQixHQUFQLENBQVdKLE9BQVgsRUFBcEQ7QUFDQSxRQUFJanNCLElBQUksR0FBRysrQixJQUFJLENBQUMvK0IsSUFBTCxFQUFYO0FBQUEsUUFBd0JDLEVBQUUsR0FBRzgrQixJQUFJLENBQUM5K0IsRUFBTCxFQUE3Qjs7QUFFQSxRQUFJMkUsRUFBRSxDQUFDb00sT0FBSCxDQUFXSSxNQUFYLElBQXFCeE0sRUFBRSxDQUFDb00sT0FBSCxDQUFXRyxRQUFoQyxJQUE0Q25SLElBQUksQ0FBQzRELElBQUwsSUFBYWdCLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV0ksTUFBcEUsSUFBOEVuUixFQUFFLENBQUMyRCxJQUFILEdBQVVnQixFQUFFLENBQUNvTSxPQUFILENBQVdHLFFBQXZHLEVBQWlIO0FBQy9Ha2IsU0FBRyxDQUFDc08sZUFBSjtBQUNBO0FBQ0Q7O0FBRUQsUUFBSXl0QixTQUFTLEdBQUdDLFFBQVEsQ0FBQ3pqRCxFQUFELEVBQUt5bkIsR0FBRyxDQUFDOE4sVUFBVCxFQUFxQjlOLEdBQUcsQ0FBQ2dPLFlBQXpCLENBQXhCO0FBQ0EsUUFBSWl1QixRQUFRLEdBQUdELFFBQVEsQ0FBQ3pqRCxFQUFELEVBQUt5bkIsR0FBRyxDQUFDaU8sU0FBVCxFQUFvQmpPLEdBQUcsQ0FBQ2tPLFdBQXhCLENBQXZCOztBQUNBLFFBQUk2dEIsU0FBUyxJQUFJLENBQUNBLFNBQVMsQ0FBQ0csR0FBeEIsSUFBK0JELFFBQS9CLElBQTJDLENBQUNBLFFBQVEsQ0FBQ0MsR0FBckQsSUFDQXg2QyxHQUFHLENBQUNLLE1BQU0sQ0FBQ2c2QyxTQUFELEVBQVlFLFFBQVosQ0FBUCxFQUE4QnRvRCxJQUE5QixDQUFILElBQTBDLENBRDFDLElBRUErTixHQUFHLENBQUNJLE1BQU0sQ0FBQ2k2QyxTQUFELEVBQVlFLFFBQVosQ0FBUCxFQUE4QnJvRCxFQUE5QixDQUFILElBQXdDLENBRjVDLEVBR0U7QUFBRTtBQUFROztBQUVaLFFBQUlzYyxJQUFJLEdBQUczWCxFQUFFLENBQUNvTSxPQUFILENBQVd1TCxJQUF0QjtBQUNBLFFBQUk3akIsS0FBSyxHQUFJc0gsSUFBSSxDQUFDNEQsSUFBTCxJQUFhZ0IsRUFBRSxDQUFDb00sT0FBSCxDQUFXRyxRQUF4QixJQUFvQ3EzQyxRQUFRLENBQUM1akQsRUFBRCxFQUFLNUUsSUFBTCxDQUE3QyxJQUNSO0FBQUNsSixVQUFJLEVBQUV5bEIsSUFBSSxDQUFDLENBQUQsQ0FBSixDQUFROVYsT0FBUixDQUFnQnhJLEdBQWhCLENBQW9CLENBQXBCLENBQVA7QUFBK0IwVyxZQUFNLEVBQUU7QUFBdkMsS0FESjtBQUVBLFFBQUloYyxHQUFHLEdBQUdzSCxFQUFFLENBQUMyRCxJQUFILEdBQVVnQixFQUFFLENBQUNvTSxPQUFILENBQVdJLE1BQXJCLElBQStCbzNDLFFBQVEsQ0FBQzVqRCxFQUFELEVBQUszRSxFQUFMLENBQWpEOztBQUNBLFFBQUksQ0FBQ3RILEdBQUwsRUFBVTtBQUNSLFVBQUk4TixPQUFPLEdBQUc4VixJQUFJLENBQUNBLElBQUksQ0FBQ25sQixNQUFMLEdBQWMsQ0FBZixDQUFKLENBQXNCcVAsT0FBcEM7QUFDQSxVQUFJeEksR0FBRyxHQUFHd0ksT0FBTyxDQUFDbVQsSUFBUixHQUFlblQsT0FBTyxDQUFDbVQsSUFBUixDQUFhblQsT0FBTyxDQUFDbVQsSUFBUixDQUFheGlCLE1BQWIsR0FBc0IsQ0FBbkMsQ0FBZixHQUF1RHFQLE9BQU8sQ0FBQ3hJLEdBQXpFO0FBQ0F0RixTQUFHLEdBQUc7QUFBQzdCLFlBQUksRUFBRW1ILEdBQUcsQ0FBQ0EsR0FBRyxDQUFDN0csTUFBSixHQUFhLENBQWQsQ0FBVjtBQUE0QnVkLGNBQU0sRUFBRTFXLEdBQUcsQ0FBQ0EsR0FBRyxDQUFDN0csTUFBSixHQUFhLENBQWQsQ0FBSCxHQUFzQjZHLEdBQUcsQ0FBQ0EsR0FBRyxDQUFDN0csTUFBSixHQUFhLENBQWQ7QUFBN0QsT0FBTjtBQUNEOztBQUVELFFBQUksQ0FBQ3NCLEtBQUQsSUFBVSxDQUFDQyxHQUFmLEVBQW9CO0FBQ2xCMHpCLFNBQUcsQ0FBQ3NPLGVBQUo7QUFDQTtBQUNEOztBQUVELFFBQUlqbkIsR0FBRyxHQUFHMlksR0FBRyxDQUFDbzhCLFVBQUosSUFBa0JwOEIsR0FBRyxDQUFDcThCLFVBQUosQ0FBZSxDQUFmLENBQTVCO0FBQUEsUUFBK0NDLEdBQS9DOztBQUNBLFFBQUk7QUFBRUEsU0FBRyxHQUFHbndELEtBQUssQ0FBQ0UsS0FBSyxDQUFDNUIsSUFBUCxFQUFhNEIsS0FBSyxDQUFDaWMsTUFBbkIsRUFBMkJoYyxHQUFHLENBQUNnYyxNQUEvQixFQUF1Q2hjLEdBQUcsQ0FBQzdCLElBQTNDLENBQVg7QUFBOEQsS0FBcEUsQ0FDQSxPQUFNUSxDQUFOLEVBQVMsQ0FBRSxDQWpDcUQsQ0FpQ3BEOzs7QUFDWixRQUFJcXhELEdBQUosRUFBUztBQUNQLFVBQUksQ0FBQy96RCxLQUFELElBQVVnUSxFQUFFLENBQUNrRixLQUFILENBQVNtbEIsT0FBdkIsRUFBZ0M7QUFDOUI1QyxXQUFHLENBQUNqekIsUUFBSixDQUFhVixLQUFLLENBQUM1QixJQUFuQixFQUF5QjRCLEtBQUssQ0FBQ2ljLE1BQS9COztBQUNBLFlBQUksQ0FBQ2cwQyxHQUFHLENBQUMveEMsU0FBVCxFQUFvQjtBQUNsQnlWLGFBQUcsQ0FBQ3NPLGVBQUo7QUFDQXRPLGFBQUcsQ0FBQ3VPLFFBQUosQ0FBYSt0QixHQUFiO0FBQ0Q7QUFDRixPQU5ELE1BTU87QUFDTHQ4QixXQUFHLENBQUNzTyxlQUFKO0FBQ0F0TyxXQUFHLENBQUN1TyxRQUFKLENBQWErdEIsR0FBYjtBQUNEOztBQUNELFVBQUlqMUMsR0FBRyxJQUFJMlksR0FBRyxDQUFDOE4sVUFBSixJQUFrQixJQUE3QixFQUFtQztBQUFFOU4sV0FBRyxDQUFDdU8sUUFBSixDQUFhbG5CLEdBQWI7QUFBb0IsT0FBekQsTUFDSyxJQUFJOWUsS0FBSixFQUFXO0FBQUUsYUFBS2cwRCxnQkFBTDtBQUEwQjtBQUM3Qzs7QUFDRCxTQUFLQyxpQkFBTDtBQUNELEdBakREOztBQW1EQS9CLHNCQUFvQixDQUFDaHNELFNBQXJCLENBQStCOHRELGdCQUEvQixHQUFrRCxZQUFZO0FBQzFELFFBQUl0ZixNQUFNLEdBQUcsSUFBYjtBQUVGM3NDLGdCQUFZLENBQUMsS0FBSzBxRCxXQUFOLENBQVo7QUFDQSxTQUFLQSxXQUFMLEdBQW1CN3FELFVBQVUsQ0FBQyxZQUFZO0FBQ3hDOHNDLFlBQU0sQ0FBQytkLFdBQVAsR0FBcUIsS0FBckI7O0FBQ0EsVUFBSS9kLE1BQU0sQ0FBQ3ZTLGdCQUFQLEVBQUosRUFDRTtBQUFFdVMsY0FBTSxDQUFDMWtDLEVBQVAsQ0FBVSt6QixTQUFWLENBQW9CLFlBQVk7QUFBRSxpQkFBTzJRLE1BQU0sQ0FBQzFrQyxFQUFQLENBQVVRLEtBQVYsQ0FBZ0IyeEIsZ0JBQWhCLEdBQW1DLElBQTFDO0FBQWlELFNBQW5GO0FBQXVGO0FBQzVGLEtBSjRCLEVBSTFCLEVBSjBCLENBQTdCO0FBS0QsR0FURDs7QUFXQSt2QixzQkFBb0IsQ0FBQ2hzRCxTQUFyQixDQUErQnF0RCxzQkFBL0IsR0FBd0QsVUFBVWorQyxJQUFWLEVBQWdCO0FBQ3RFdlMsd0JBQW9CLENBQUMsS0FBS2lOLEVBQUwsQ0FBUW9NLE9BQVIsQ0FBZ0JvZSxTQUFqQixFQUE0QmxsQixJQUFJLENBQUNpaUIsT0FBakMsQ0FBcEI7QUFDQXgwQix3QkFBb0IsQ0FBQyxLQUFLaU4sRUFBTCxDQUFRb00sT0FBUixDQUFnQnNxQixZQUFqQixFQUErQnB4QixJQUFJLENBQUNwQyxTQUFwQyxDQUFwQjtBQUNELEdBSEQ7O0FBS0FnL0Msc0JBQW9CLENBQUNoc0QsU0FBckIsQ0FBK0IrdEQsaUJBQS9CLEdBQW1ELFlBQVk7QUFDN0QsUUFBSXg4QixHQUFHLEdBQUcsS0FBSzFrQixZQUFMLEVBQVY7QUFDQSxTQUFLby9DLGNBQUwsR0FBc0IxNkIsR0FBRyxDQUFDOE4sVUFBMUI7QUFBc0MsU0FBSzZzQixnQkFBTCxHQUF3QjM2QixHQUFHLENBQUNnTyxZQUE1QjtBQUN0QyxTQUFLNHNCLGFBQUwsR0FBcUI1NkIsR0FBRyxDQUFDaU8sU0FBekI7QUFBb0MsU0FBSzRzQixlQUFMLEdBQXVCNzZCLEdBQUcsQ0FBQ2tPLFdBQTNCO0FBQ3JDLEdBSkQ7O0FBTUF1c0Isc0JBQW9CLENBQUNoc0QsU0FBckIsQ0FBK0JndUQsaUJBQS9CLEdBQW1ELFlBQVk7QUFDN0QsUUFBSXo4QixHQUFHLEdBQUcsS0FBSzFrQixZQUFMLEVBQVY7O0FBQ0EsUUFBSSxDQUFDMGtCLEdBQUcsQ0FBQ284QixVQUFULEVBQXFCO0FBQUUsYUFBTyxLQUFQO0FBQWM7O0FBQ3JDLFFBQUkzeEQsSUFBSSxHQUFHdTFCLEdBQUcsQ0FBQ3E4QixVQUFKLENBQWUsQ0FBZixFQUFrQkssdUJBQTdCO0FBQ0EsV0FBT3h2RCxRQUFRLENBQUMsS0FBSytNLEdBQU4sRUFBV3hQLElBQVgsQ0FBZjtBQUNELEdBTEQ7O0FBT0Fnd0Qsc0JBQW9CLENBQUNoc0QsU0FBckIsQ0FBK0I2MEIsS0FBL0IsR0FBdUMsWUFBWTtBQUNqRCxRQUFJLEtBQUsvcUIsRUFBTCxDQUFRdUUsT0FBUixDQUFnQm1NLFFBQWhCLElBQTRCLFVBQWhDLEVBQTRDO0FBQzFDLFVBQUksQ0FBQyxLQUFLd3pDLGlCQUFMLEVBQUQsSUFBNkIxekQsUUFBUSxDQUFDd0UsYUFBVCxJQUEwQixLQUFLME0sR0FBaEUsRUFDRTtBQUFFLGFBQUt5bEIsYUFBTCxDQUFtQixLQUFLQyxnQkFBTCxFQUFuQixFQUE0QyxJQUE1QztBQUFvRDs7QUFDeEQsV0FBSzFsQixHQUFMLENBQVNxcEIsS0FBVDtBQUNEO0FBQ0YsR0FORDs7QUFPQW0zQixzQkFBb0IsQ0FBQ2hzRCxTQUFyQixDQUErQjRqRCxJQUEvQixHQUFzQyxZQUFZO0FBQUUsU0FBS3A0QyxHQUFMLENBQVNvNEMsSUFBVDtBQUFrQixHQUF0RTs7QUFDQW9JLHNCQUFvQixDQUFDaHNELFNBQXJCLENBQStCcytDLFFBQS9CLEdBQTBDLFlBQVk7QUFBRSxXQUFPLEtBQUs5eUMsR0FBWjtBQUFpQixHQUF6RTs7QUFFQXdnRCxzQkFBb0IsQ0FBQ2hzRCxTQUFyQixDQUErQnEvQyxhQUEvQixHQUErQyxZQUFZO0FBQUUsV0FBTyxJQUFQO0FBQWEsR0FBMUU7O0FBRUEyTSxzQkFBb0IsQ0FBQ2hzRCxTQUFyQixDQUErQm8xQixhQUEvQixHQUErQyxZQUFZO0FBQ3pELFFBQUk1VSxLQUFLLEdBQUcsSUFBWjs7QUFDQSxRQUFJLEtBQUt3dEMsaUJBQUwsRUFBSixFQUNFO0FBQUUsV0FBS0UsYUFBTDtBQUF1QixLQUQzQixNQUdFO0FBQUV0d0IsYUFBTyxDQUFDLEtBQUs5ekIsRUFBTixFQUFVLFlBQVk7QUFBRSxlQUFPMFcsS0FBSyxDQUFDMVcsRUFBTixDQUFTUSxLQUFULENBQWUyeEIsZ0JBQWYsR0FBa0MsSUFBekM7QUFBZ0QsT0FBeEUsQ0FBUDtBQUFtRjs7QUFFdkYsYUFBU2t5QixJQUFULEdBQWdCO0FBQ2QsVUFBSTN0QyxLQUFLLENBQUMxVyxFQUFOLENBQVNrRixLQUFULENBQWVtbEIsT0FBbkIsRUFBNEI7QUFDMUIzVCxhQUFLLENBQUMwdEMsYUFBTjtBQUNBMXRDLGFBQUssQ0FBQzZyQyxPQUFOLENBQWMxcUQsR0FBZCxDQUFrQjZlLEtBQUssQ0FBQzFXLEVBQU4sQ0FBU3VFLE9BQVQsQ0FBaUIrL0MsWUFBbkMsRUFBaURELElBQWpEO0FBQ0Q7QUFDRjs7QUFDRCxTQUFLOUIsT0FBTCxDQUFhMXFELEdBQWIsQ0FBaUIsS0FBS21JLEVBQUwsQ0FBUXVFLE9BQVIsQ0FBZ0IrL0MsWUFBakMsRUFBK0NELElBQS9DO0FBQ0QsR0FkRDs7QUFnQkFuQyxzQkFBb0IsQ0FBQ2hzRCxTQUFyQixDQUErQmk4QixnQkFBL0IsR0FBa0QsWUFBWTtBQUM1RCxRQUFJMUssR0FBRyxHQUFHLEtBQUsxa0IsWUFBTCxFQUFWO0FBQ0EsV0FBTzBrQixHQUFHLENBQUM4TixVQUFKLElBQWtCLEtBQUs0c0IsY0FBdkIsSUFBeUMxNkIsR0FBRyxDQUFDZ08sWUFBSixJQUFvQixLQUFLMnNCLGdCQUFsRSxJQUNMMzZCLEdBQUcsQ0FBQ2lPLFNBQUosSUFBaUIsS0FBSzJzQixhQURqQixJQUNrQzU2QixHQUFHLENBQUNrTyxXQUFKLElBQW1CLEtBQUsyc0IsZUFEakU7QUFFRCxHQUpEOztBQU1BSixzQkFBb0IsQ0FBQ2hzRCxTQUFyQixDQUErQmt1RCxhQUEvQixHQUErQyxZQUFZO0FBQ3pELFFBQUksS0FBSzFCLGNBQUwsSUFBdUIsSUFBdkIsSUFBK0IsS0FBS0QsV0FBcEMsSUFBbUQsQ0FBQyxLQUFLdHdCLGdCQUFMLEVBQXhELEVBQWlGO0FBQUU7QUFBUTs7QUFDM0YsUUFBSTFLLEdBQUcsR0FBRyxLQUFLMWtCLFlBQUwsRUFBVjtBQUFBLFFBQStCL0MsRUFBRSxHQUFHLEtBQUtBLEVBQXpDLENBRnlELENBR3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxRQUFJNU8sT0FBTyxJQUFJUixNQUFYLElBQXFCLEtBQUtvUCxFQUFMLENBQVFvTSxPQUFSLENBQWdCeU8sV0FBaEIsQ0FBNEJyb0IsTUFBakQsSUFBMkQreEQsVUFBVSxDQUFDOThCLEdBQUcsQ0FBQzhOLFVBQUwsQ0FBekUsRUFBMkY7QUFDekYsV0FBS3YxQixFQUFMLENBQVE4L0MsZ0JBQVIsQ0FBeUI7QUFBQ3ppRCxZQUFJLEVBQUUsU0FBUDtBQUFrQjZ3QyxlQUFPLEVBQUUsQ0FBM0I7QUFBOEJodUMsc0JBQWMsRUFBRXBILElBQUksQ0FBQzZLO0FBQW5ELE9BQXpCO0FBQ0EsV0FBS20yQyxJQUFMO0FBQ0EsV0FBSy91QixLQUFMO0FBQ0E7QUFDRDs7QUFDRCxRQUFJLEtBQUt5M0IsU0FBVCxFQUFvQjtBQUFFO0FBQVE7O0FBQzlCLFNBQUt5QixpQkFBTDtBQUNBLFFBQUlqL0IsTUFBTSxHQUFHeStCLFFBQVEsQ0FBQ3pqRCxFQUFELEVBQUt5bkIsR0FBRyxDQUFDOE4sVUFBVCxFQUFxQjlOLEdBQUcsQ0FBQ2dPLFlBQXpCLENBQXJCO0FBQ0EsUUFBSTFOLElBQUksR0FBRzA3QixRQUFRLENBQUN6akQsRUFBRCxFQUFLeW5CLEdBQUcsQ0FBQ2lPLFNBQVQsRUFBb0JqTyxHQUFHLENBQUNrTyxXQUF4QixDQUFuQjs7QUFDQSxRQUFJM1EsTUFBTSxJQUFJK0MsSUFBZCxFQUFvQjtBQUFFK0wsYUFBTyxDQUFDOXpCLEVBQUQsRUFBSyxZQUFZO0FBQzVDeS9CLG9CQUFZLENBQUN6L0IsRUFBRSxDQUFDd0gsR0FBSixFQUFTOHlCLGVBQWUsQ0FBQ3RWLE1BQUQsRUFBUytDLElBQVQsQ0FBeEIsRUFBd0MzdkIsY0FBeEMsQ0FBWjs7QUFDQSxZQUFJNHNCLE1BQU0sQ0FBQzIrQixHQUFQLElBQWM1N0IsSUFBSSxDQUFDNDdCLEdBQXZCLEVBQTRCO0FBQUUzakQsWUFBRSxDQUFDUSxLQUFILENBQVMyeEIsZ0JBQVQsR0FBNEIsSUFBNUI7QUFBbUM7QUFDbEUsT0FINEIsQ0FBUDtBQUdqQjtBQUNOLEdBdkJEOztBQXlCQSt2QixzQkFBb0IsQ0FBQ2hzRCxTQUFyQixDQUErQnN1RCxXQUEvQixHQUE2QyxZQUFZO0FBQ3ZELFFBQUksS0FBSzlCLGNBQUwsSUFBdUIsSUFBM0IsRUFBaUM7QUFDL0IzcUQsa0JBQVksQ0FBQyxLQUFLMnFELGNBQU4sQ0FBWjtBQUNBLFdBQUtBLGNBQUwsR0FBc0IsSUFBdEI7QUFDRDs7QUFFRCxRQUFJMWlELEVBQUUsR0FBRyxLQUFLQSxFQUFkO0FBQUEsUUFBa0JvTSxPQUFPLEdBQUdwTSxFQUFFLENBQUNvTSxPQUEvQjtBQUFBLFFBQXdDcWIsR0FBRyxHQUFHem5CLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT2lnQixHQUFQLENBQVdKLE9BQVgsRUFBOUM7QUFDQSxRQUFJanNCLElBQUksR0FBR3FzQixHQUFHLENBQUNyc0IsSUFBSixFQUFYO0FBQUEsUUFBdUJDLEVBQUUsR0FBR29zQixHQUFHLENBQUNwc0IsRUFBSixFQUE1Qjs7QUFDQSxRQUFJRCxJQUFJLENBQUNoQixFQUFMLElBQVcsQ0FBWCxJQUFnQmdCLElBQUksQ0FBQzRELElBQUwsR0FBWWdCLEVBQUUsQ0FBQ3U3QixTQUFILEVBQWhDLEVBQ0U7QUFBRW5nQyxVQUFJLEdBQUc4TixHQUFHLENBQUM5TixJQUFJLENBQUM0RCxJQUFMLEdBQVksQ0FBYixFQUFnQnVJLE9BQU8sQ0FBQ3ZILEVBQUUsQ0FBQ3dILEdBQUosRUFBU3BNLElBQUksQ0FBQzRELElBQUwsR0FBWSxDQUFyQixDQUFQLENBQStCeE0sTUFBL0MsQ0FBVjtBQUFtRTs7QUFDdkUsUUFBSTZJLEVBQUUsQ0FBQ2pCLEVBQUgsSUFBU21OLE9BQU8sQ0FBQ3ZILEVBQUUsQ0FBQ3dILEdBQUosRUFBU25NLEVBQUUsQ0FBQzJELElBQVosQ0FBUCxDQUF5QkMsSUFBekIsQ0FBOEJ6TSxNQUF2QyxJQUFpRDZJLEVBQUUsQ0FBQzJELElBQUgsR0FBVWdCLEVBQUUsQ0FBQzZTLFFBQUgsRUFBL0QsRUFDRTtBQUFFeFgsUUFBRSxHQUFHNk4sR0FBRyxDQUFDN04sRUFBRSxDQUFDMkQsSUFBSCxHQUFVLENBQVgsRUFBYyxDQUFkLENBQVI7QUFBMkI7O0FBQy9CLFFBQUk1RCxJQUFJLENBQUM0RCxJQUFMLEdBQVlvTixPQUFPLENBQUNHLFFBQXBCLElBQWdDbFIsRUFBRSxDQUFDMkQsSUFBSCxHQUFVb04sT0FBTyxDQUFDSSxNQUFSLEdBQWlCLENBQS9ELEVBQWtFO0FBQUUsYUFBTyxLQUFQO0FBQWM7O0FBRWxGLFFBQUlpNEMsU0FBSixFQUFlMTZCLFFBQWYsRUFBeUIyNkIsUUFBekI7O0FBQ0EsUUFBSXRwRCxJQUFJLENBQUM0RCxJQUFMLElBQWFvTixPQUFPLENBQUNHLFFBQXJCLElBQWlDLENBQUNrNEMsU0FBUyxHQUFHeGxDLGFBQWEsQ0FBQ2pmLEVBQUQsRUFBSzVFLElBQUksQ0FBQzRELElBQVYsQ0FBMUIsS0FBOEMsQ0FBbkYsRUFBc0Y7QUFDcEYrcUIsY0FBUSxHQUFHeGhCLE1BQU0sQ0FBQzZELE9BQU8sQ0FBQ3VMLElBQVIsQ0FBYSxDQUFiLEVBQWdCM1ksSUFBakIsQ0FBakI7QUFDQTBsRCxjQUFRLEdBQUd0NEMsT0FBTyxDQUFDdUwsSUFBUixDQUFhLENBQWIsRUFBZ0J6bEIsSUFBM0I7QUFDRCxLQUhELE1BR087QUFDTDYzQixjQUFRLEdBQUd4aEIsTUFBTSxDQUFDNkQsT0FBTyxDQUFDdUwsSUFBUixDQUFhOHNDLFNBQWIsRUFBd0J6bEQsSUFBekIsQ0FBakI7QUFDQTBsRCxjQUFRLEdBQUd0NEMsT0FBTyxDQUFDdUwsSUFBUixDQUFhOHNDLFNBQVMsR0FBRyxDQUF6QixFQUE0QnZ5RCxJQUE1QixDQUFpQytvQixXQUE1QztBQUNEOztBQUNELFFBQUkwcEMsT0FBTyxHQUFHMWxDLGFBQWEsQ0FBQ2pmLEVBQUQsRUFBSzNFLEVBQUUsQ0FBQzJELElBQVIsQ0FBM0I7QUFDQSxRQUFJZ3JCLE1BQUosRUFBWTQ2QixNQUFaOztBQUNBLFFBQUlELE9BQU8sSUFBSXY0QyxPQUFPLENBQUN1TCxJQUFSLENBQWFubEIsTUFBYixHQUFzQixDQUFyQyxFQUF3QztBQUN0Q3czQixZQUFNLEdBQUc1ZCxPQUFPLENBQUNJLE1BQVIsR0FBaUIsQ0FBMUI7QUFDQW80QyxZQUFNLEdBQUd4NEMsT0FBTyxDQUFDc2YsT0FBUixDQUFnQnhXLFNBQXpCO0FBQ0QsS0FIRCxNQUdPO0FBQ0w4VSxZQUFNLEdBQUd6aEIsTUFBTSxDQUFDNkQsT0FBTyxDQUFDdUwsSUFBUixDQUFhZ3RDLE9BQU8sR0FBRyxDQUF2QixFQUEwQjNsRCxJQUEzQixDQUFOLEdBQXlDLENBQWxEO0FBQ0E0bEQsWUFBTSxHQUFHeDRDLE9BQU8sQ0FBQ3VMLElBQVIsQ0FBYWd0QyxPQUFPLEdBQUcsQ0FBdkIsRUFBMEJ6eUQsSUFBMUIsQ0FBK0IyeUQsZUFBeEM7QUFDRDs7QUFFRCxRQUFJLENBQUNILFFBQUwsRUFBZTtBQUFFLGFBQU8sS0FBUDtBQUFjOztBQUMvQixRQUFJSSxPQUFPLEdBQUc5a0QsRUFBRSxDQUFDd0gsR0FBSCxDQUFPeTdCLFVBQVAsQ0FBa0I4aEIsY0FBYyxDQUFDL2tELEVBQUQsRUFBSzBrRCxRQUFMLEVBQWVFLE1BQWYsRUFBdUI3NkIsUUFBdkIsRUFBaUNDLE1BQWpDLENBQWhDLENBQWQ7QUFDQSxRQUFJZzdCLE9BQU8sR0FBRy84QyxVQUFVLENBQUNqSSxFQUFFLENBQUN3SCxHQUFKLEVBQVMwQixHQUFHLENBQUM2Z0IsUUFBRCxFQUFXLENBQVgsQ0FBWixFQUEyQjdnQixHQUFHLENBQUM4Z0IsTUFBRCxFQUFTemlCLE9BQU8sQ0FBQ3ZILEVBQUUsQ0FBQ3dILEdBQUosRUFBU3dpQixNQUFULENBQVAsQ0FBd0IvcUIsSUFBeEIsQ0FBNkJ6TSxNQUF0QyxDQUE5QixDQUF4Qjs7QUFDQSxXQUFPc3lELE9BQU8sQ0FBQ3R5RCxNQUFSLEdBQWlCLENBQWpCLElBQXNCd3lELE9BQU8sQ0FBQ3h5RCxNQUFSLEdBQWlCLENBQTlDLEVBQWlEO0FBQy9DLFVBQUkyRyxHQUFHLENBQUMyckQsT0FBRCxDQUFILElBQWdCM3JELEdBQUcsQ0FBQzZyRCxPQUFELENBQXZCLEVBQWtDO0FBQUVGLGVBQU8sQ0FBQ2xuQixHQUFSO0FBQWVvbkIsZUFBTyxDQUFDcG5CLEdBQVI7QUFBZTVULGNBQU07QUFBSyxPQUE3RSxNQUNLLElBQUk4NkIsT0FBTyxDQUFDLENBQUQsQ0FBUCxJQUFjRSxPQUFPLENBQUMsQ0FBRCxDQUF6QixFQUE4QjtBQUFFRixlQUFPLENBQUN2NUIsS0FBUjtBQUFpQnk1QixlQUFPLENBQUN6NUIsS0FBUjtBQUFpQnhCLGdCQUFRO0FBQUssT0FBL0UsTUFDQTtBQUFFO0FBQU87QUFDZjs7QUFFRCxRQUFJazdCLFFBQVEsR0FBRyxDQUFmO0FBQUEsUUFBa0JDLE1BQU0sR0FBRyxDQUEzQjtBQUNBLFFBQUkxM0IsTUFBTSxHQUFHczNCLE9BQU8sQ0FBQyxDQUFELENBQXBCO0FBQUEsUUFBeUJLLE1BQU0sR0FBR0gsT0FBTyxDQUFDLENBQUQsQ0FBekM7QUFBQSxRQUE4Q0ksV0FBVyxHQUFHdHNELElBQUksQ0FBQ0MsR0FBTCxDQUFTeTBCLE1BQU0sQ0FBQ2g3QixNQUFoQixFQUF3QjJ5RCxNQUFNLENBQUMzeUQsTUFBL0IsQ0FBNUQ7O0FBQ0EsV0FBT3l5RCxRQUFRLEdBQUdHLFdBQVgsSUFBMEI1M0IsTUFBTSxDQUFDM3lCLFVBQVAsQ0FBa0JvcUQsUUFBbEIsS0FBK0JFLE1BQU0sQ0FBQ3RxRCxVQUFQLENBQWtCb3FELFFBQWxCLENBQWhFLEVBQ0U7QUFBRSxRQUFFQSxRQUFGO0FBQWE7O0FBQ2pCLFFBQUlJLE1BQU0sR0FBR2xzRCxHQUFHLENBQUMyckQsT0FBRCxDQUFoQjtBQUFBLFFBQTJCUSxNQUFNLEdBQUduc0QsR0FBRyxDQUFDNnJELE9BQUQsQ0FBdkM7QUFDQSxRQUFJTyxTQUFTLEdBQUd6c0QsSUFBSSxDQUFDQyxHQUFMLENBQVNzc0QsTUFBTSxDQUFDN3lELE1BQVAsSUFBaUJzeUQsT0FBTyxDQUFDdHlELE1BQVIsSUFBa0IsQ0FBbEIsR0FBc0J5eUQsUUFBdEIsR0FBaUMsQ0FBbEQsQ0FBVCxFQUNTSyxNQUFNLENBQUM5eUQsTUFBUCxJQUFpQnd5RCxPQUFPLENBQUN4eUQsTUFBUixJQUFrQixDQUFsQixHQUFzQnl5RCxRQUF0QixHQUFpQyxDQUFsRCxDQURULENBQWhCOztBQUVBLFdBQU9DLE1BQU0sR0FBR0ssU0FBVCxJQUNBRixNQUFNLENBQUN4cUQsVUFBUCxDQUFrQndxRCxNQUFNLENBQUM3eUQsTUFBUCxHQUFnQjB5RCxNQUFoQixHQUF5QixDQUEzQyxLQUFpREksTUFBTSxDQUFDenFELFVBQVAsQ0FBa0J5cUQsTUFBTSxDQUFDOXlELE1BQVAsR0FBZ0IweUQsTUFBaEIsR0FBeUIsQ0FBM0MsQ0FEeEQsRUFFRTtBQUFFLFFBQUVBLE1BQUY7QUFBVyxLQWxEd0MsQ0FtRHZEOzs7QUFDQSxRQUFJSixPQUFPLENBQUN0eUQsTUFBUixJQUFrQixDQUFsQixJQUF1Qnd5RCxPQUFPLENBQUN4eUQsTUFBUixJQUFrQixDQUF6QyxJQUE4Q3UzQixRQUFRLElBQUkzdUIsSUFBSSxDQUFDNEQsSUFBbkUsRUFBeUU7QUFDdkUsYUFBT2ltRCxRQUFRLElBQUlBLFFBQVEsR0FBRzdwRCxJQUFJLENBQUNoQixFQUE1QixJQUNBaXJELE1BQU0sQ0FBQ3hxRCxVQUFQLENBQWtCd3FELE1BQU0sQ0FBQzd5RCxNQUFQLEdBQWdCMHlELE1BQWhCLEdBQXlCLENBQTNDLEtBQWlESSxNQUFNLENBQUN6cUQsVUFBUCxDQUFrQnlxRCxNQUFNLENBQUM5eUQsTUFBUCxHQUFnQjB5RCxNQUFoQixHQUF5QixDQUEzQyxDQUR4RCxFQUN1RztBQUNyR0QsZ0JBQVE7QUFDUkMsY0FBTTtBQUNQO0FBQ0Y7O0FBRURKLFdBQU8sQ0FBQ0EsT0FBTyxDQUFDdHlELE1BQVIsR0FBaUIsQ0FBbEIsQ0FBUCxHQUE4QjZ5RCxNQUFNLENBQUMveUQsS0FBUCxDQUFhLENBQWIsRUFBZ0IreUQsTUFBTSxDQUFDN3lELE1BQVAsR0FBZ0IweUQsTUFBaEMsRUFBd0NybkQsT0FBeEMsQ0FBZ0QsVUFBaEQsRUFBNEQsRUFBNUQsQ0FBOUI7QUFDQWluRCxXQUFPLENBQUMsQ0FBRCxDQUFQLEdBQWFBLE9BQU8sQ0FBQyxDQUFELENBQVAsQ0FBV3h5RCxLQUFYLENBQWlCMnlELFFBQWpCLEVBQTJCcG5ELE9BQTNCLENBQW1DLFVBQW5DLEVBQStDLEVBQS9DLENBQWI7QUFFQSxRQUFJMm5ELE1BQU0sR0FBR3Q4QyxHQUFHLENBQUM2Z0IsUUFBRCxFQUFXazdCLFFBQVgsQ0FBaEI7QUFDQSxRQUFJUSxJQUFJLEdBQUd2OEMsR0FBRyxDQUFDOGdCLE1BQUQsRUFBU2c3QixPQUFPLENBQUN4eUQsTUFBUixHQUFpQjJHLEdBQUcsQ0FBQzZyRCxPQUFELENBQUgsQ0FBYXh5RCxNQUFiLEdBQXNCMHlELE1BQXZDLEdBQWdELENBQXpELENBQWQ7O0FBQ0EsUUFBSUosT0FBTyxDQUFDdHlELE1BQVIsR0FBaUIsQ0FBakIsSUFBc0JzeUQsT0FBTyxDQUFDLENBQUQsQ0FBN0IsSUFBb0MzN0MsR0FBRyxDQUFDcThDLE1BQUQsRUFBU0MsSUFBVCxDQUEzQyxFQUEyRDtBQUN6RDFpQixtQkFBWSxDQUFDL2lDLEVBQUUsQ0FBQ3dILEdBQUosRUFBU3M5QyxPQUFULEVBQWtCVSxNQUFsQixFQUEwQkMsSUFBMUIsRUFBZ0MsUUFBaEMsQ0FBWjs7QUFDQSxhQUFPLElBQVA7QUFDRDtBQUNGLEdBckVEOztBQXVFQXZELHNCQUFvQixDQUFDaHNELFNBQXJCLENBQStCdTlDLFlBQS9CLEdBQThDLFlBQVk7QUFDeEQsU0FBS3FQLG1CQUFMO0FBQ0QsR0FGRDs7QUFHQVosc0JBQW9CLENBQUNoc0QsU0FBckIsQ0FBK0JtMUIsS0FBL0IsR0FBdUMsWUFBWTtBQUNqRCxTQUFLeTNCLG1CQUFMO0FBQ0QsR0FGRDs7QUFHQVosc0JBQW9CLENBQUNoc0QsU0FBckIsQ0FBK0I0c0QsbUJBQS9CLEdBQXFELFlBQVk7QUFDL0QsUUFBSSxDQUFDLEtBQUtOLFNBQVYsRUFBcUI7QUFBRTtBQUFROztBQUMvQnpxRCxnQkFBWSxDQUFDLEtBQUsycUQsY0FBTixDQUFaO0FBQ0EsU0FBS0YsU0FBTCxHQUFpQixJQUFqQjtBQUNBLFNBQUtJLGFBQUw7QUFDQSxTQUFLbGhELEdBQUwsQ0FBU280QyxJQUFUO0FBQ0EsU0FBS3A0QyxHQUFMLENBQVNxcEIsS0FBVDtBQUNELEdBUEQ7O0FBUUFtM0Isc0JBQW9CLENBQUNoc0QsU0FBckIsQ0FBK0Iyc0QsZUFBL0IsR0FBaUQsWUFBWTtBQUN6RCxRQUFJbmUsTUFBTSxHQUFHLElBQWI7O0FBRUYsUUFBSSxLQUFLZ2UsY0FBTCxJQUF1QixJQUEzQixFQUFpQztBQUFFO0FBQVE7O0FBQzNDLFNBQUtBLGNBQUwsR0FBc0I5cUQsVUFBVSxDQUFDLFlBQVk7QUFDM0M4c0MsWUFBTSxDQUFDZ2UsY0FBUCxHQUF3QixJQUF4Qjs7QUFDQSxVQUFJaGUsTUFBTSxDQUFDOGQsU0FBWCxFQUFzQjtBQUNwQixZQUFJOWQsTUFBTSxDQUFDOGQsU0FBUCxDQUFpQjNsQixJQUFyQixFQUEyQjtBQUFFNkgsZ0JBQU0sQ0FBQzhkLFNBQVAsR0FBbUIsSUFBbkI7QUFBMEIsU0FBdkQsTUFDSztBQUFFO0FBQVE7QUFDaEI7O0FBQ0Q5ZCxZQUFNLENBQUNrZSxhQUFQO0FBQ0QsS0FQK0IsRUFPN0IsRUFQNkIsQ0FBaEM7QUFRRCxHQVpEOztBQWNBVixzQkFBb0IsQ0FBQ2hzRCxTQUFyQixDQUErQjBzRCxhQUEvQixHQUErQyxZQUFZO0FBQ3ZELFFBQUlsZSxNQUFNLEdBQUcsSUFBYjs7QUFFRixRQUFJLEtBQUsxa0MsRUFBTCxDQUFRMHFDLFVBQVIsTUFBd0IsQ0FBQyxLQUFLOFosV0FBTCxFQUE3QixFQUNFO0FBQUUxd0IsYUFBTyxDQUFDLEtBQUs5ekIsRUFBTixFQUFVLFlBQVk7QUFBRSxlQUFPa21CLFNBQVMsQ0FBQ3dlLE1BQU0sQ0FBQzFrQyxFQUFSLENBQWhCO0FBQThCLE9BQXRELENBQVA7QUFBaUU7QUFDdEUsR0FMRDs7QUFPQWtpRCxzQkFBb0IsQ0FBQ2hzRCxTQUFyQixDQUErQjBnQixhQUEvQixHQUErQyxVQUFVMWtCLElBQVYsRUFBZ0I7QUFDN0RBLFFBQUksQ0FBQ3d6RCxlQUFMLEdBQXVCLE9BQXZCO0FBQ0QsR0FGRDs7QUFJQXhELHNCQUFvQixDQUFDaHNELFNBQXJCLENBQStCMitDLFVBQS9CLEdBQTRDLFVBQVVuaUQsQ0FBVixFQUFhO0FBQ3ZELFFBQUlBLENBQUMsQ0FBQ29pRCxRQUFGLElBQWMsQ0FBZCxJQUFtQixLQUFLME4sU0FBNUIsRUFBdUM7QUFBRTtBQUFROztBQUNqRDl2RCxLQUFDLENBQUN3TixjQUFGOztBQUNBLFFBQUksQ0FBQyxLQUFLRixFQUFMLENBQVEwcUMsVUFBUixFQUFMLEVBQ0U7QUFBRTNXLGVBQVMsQ0FBQyxLQUFLL3pCLEVBQU4sRUFBVTY4QyxjQUFWLENBQVQsQ0FBbUMsS0FBSzc4QyxFQUF4QyxFQUE0QytJLE1BQU0sQ0FBQ2drQyxZQUFQLENBQW9CcjZDLENBQUMsQ0FBQ29pRCxRQUFGLElBQWMsSUFBZCxHQUFxQnBpRCxDQUFDLENBQUN3N0MsT0FBdkIsR0FBaUN4N0MsQ0FBQyxDQUFDb2lELFFBQXZELENBQTVDLEVBQThHLENBQTlHO0FBQW1IO0FBQ3hILEdBTEQ7O0FBT0FvTixzQkFBb0IsQ0FBQ2hzRCxTQUFyQixDQUErQjZqRCxlQUEvQixHQUFpRCxVQUFVMzBDLEdBQVYsRUFBZTtBQUM5RCxTQUFLMUQsR0FBTCxDQUFTZ2tELGVBQVQsR0FBMkIzOEMsTUFBTSxDQUFDM0QsR0FBRyxJQUFJLFVBQVIsQ0FBakM7QUFDRCxHQUZEOztBQUlBODhDLHNCQUFvQixDQUFDaHNELFNBQXJCLENBQStCMi9DLGFBQS9CLEdBQStDLFlBQVksQ0FBRSxDQUE3RDs7QUFDQXFNLHNCQUFvQixDQUFDaHNELFNBQXJCLENBQStCZ2tELGFBQS9CLEdBQStDLFlBQVksQ0FBRSxDQUE3RDs7QUFFQWdJLHNCQUFvQixDQUFDaHNELFNBQXJCLENBQStCeWdCLHFCQUEvQixHQUF1RCxJQUF2RDs7QUFFQSxXQUFTaXRDLFFBQVQsQ0FBa0I1akQsRUFBbEIsRUFBc0JySCxHQUF0QixFQUEyQjtBQUN6QixRQUFJZ2YsSUFBSSxHQUFHcUgsZUFBZSxDQUFDaGYsRUFBRCxFQUFLckgsR0FBRyxDQUFDcUcsSUFBVCxDQUExQjs7QUFDQSxRQUFJLENBQUMyWSxJQUFELElBQVNBLElBQUksQ0FBQ0gsTUFBbEIsRUFBMEI7QUFBRSxhQUFPLElBQVA7QUFBYTs7QUFDekMsUUFBSXhZLElBQUksR0FBR3VJLE9BQU8sQ0FBQ3ZILEVBQUUsQ0FBQ3dILEdBQUosRUFBUzdPLEdBQUcsQ0FBQ3FHLElBQWIsQ0FBbEI7QUFDQSxRQUFJc0csSUFBSSxHQUFHbVosZUFBZSxDQUFDOUcsSUFBRCxFQUFPM1ksSUFBUCxFQUFhckcsR0FBRyxDQUFDcUcsSUFBakIsQ0FBMUI7QUFFQSxRQUFJckQsS0FBSyxHQUFHb0QsUUFBUSxDQUFDQyxJQUFELEVBQU9nQixFQUFFLENBQUN3SCxHQUFILENBQU96SyxTQUFkLENBQXBCO0FBQUEsUUFBOENrc0IsSUFBSSxHQUFHLE1BQXJEOztBQUNBLFFBQUl0dEIsS0FBSixFQUFXO0FBQ1QsVUFBSXFuQixPQUFPLEdBQUcvbUIsYUFBYSxDQUFDTixLQUFELEVBQVFoRCxHQUFHLENBQUN5QixFQUFaLENBQTNCO0FBQ0E2dUIsVUFBSSxHQUFHakcsT0FBTyxHQUFHLENBQVYsR0FBYyxPQUFkLEdBQXdCLE1BQS9CO0FBQ0Q7O0FBQ0QsUUFBSXZnQixNQUFNLEdBQUdvZCxzQkFBc0IsQ0FBQ3ZhLElBQUksQ0FBQ2pNLEdBQU4sRUFBV1YsR0FBRyxDQUFDeUIsRUFBZixFQUFtQjZ1QixJQUFuQixDQUFuQztBQUNBeG1CLFVBQU0sQ0FBQ3NOLE1BQVAsR0FBZ0J0TixNQUFNLENBQUNqTyxRQUFQLElBQW1CLE9BQW5CLEdBQTZCaU8sTUFBTSxDQUFDMU8sR0FBcEMsR0FBMEMwTyxNQUFNLENBQUMzTyxLQUFqRTtBQUNBLFdBQU8yTyxNQUFQO0FBQ0Q7O0FBRUQsV0FBUzhoRCxVQUFULENBQW9CcnlELElBQXBCLEVBQTBCO0FBQ3hCLFNBQUssSUFBSXl6RCxJQUFJLEdBQUd6ekQsSUFBaEIsRUFBc0J5ekQsSUFBdEIsRUFBNEJBLElBQUksR0FBR0EsSUFBSSxDQUFDcHhELFVBQXhDLEVBQ0U7QUFBRSxVQUFJLDRCQUE0QnRFLElBQTVCLENBQWlDMDFELElBQUksQ0FBQ3Z6RCxTQUF0QyxDQUFKLEVBQXNEO0FBQUUsZUFBTyxJQUFQO0FBQWE7QUFBRTs7QUFDM0UsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsV0FBU3d6RCxNQUFULENBQWdCanRELEdBQWhCLEVBQXFCZ3JELEdBQXJCLEVBQTBCO0FBQUUsUUFBSUEsR0FBSixFQUFTO0FBQUVockQsU0FBRyxDQUFDZ3JELEdBQUosR0FBVSxJQUFWO0FBQWlCOztBQUFDLFdBQU9ockQsR0FBUDtBQUFZOztBQUVyRSxXQUFTb3NELGNBQVQsQ0FBd0Iva0QsRUFBeEIsRUFBNEI1RSxJQUE1QixFQUFrQ0MsRUFBbEMsRUFBc0MwdUIsUUFBdEMsRUFBZ0RDLE1BQWhELEVBQXdEO0FBQ3RELFFBQUkvcUIsSUFBSSxHQUFHLEVBQVg7QUFBQSxRQUFlNG1ELE9BQU8sR0FBRyxLQUF6QjtBQUFBLFFBQWdDcmYsT0FBTyxHQUFHeG1DLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT3EvQixhQUFQLEVBQTFDO0FBQUEsUUFBa0VpZixjQUFjLEdBQUcsS0FBbkY7O0FBQ0EsYUFBU0MsZUFBVCxDQUF5Qnp1RCxFQUF6QixFQUE2QjtBQUFFLGFBQU8sVUFBVStXLE1BQVYsRUFBa0I7QUFBRSxlQUFPQSxNQUFNLENBQUMvVyxFQUFQLElBQWFBLEVBQXBCO0FBQXlCLE9BQXBEO0FBQXNEOztBQUNyRixhQUFTMHVELEtBQVQsR0FBaUI7QUFDZixVQUFJSCxPQUFKLEVBQWE7QUFDWDVtRCxZQUFJLElBQUl1bkMsT0FBUjs7QUFDQSxZQUFJc2YsY0FBSixFQUFvQjtBQUFFN21ELGNBQUksSUFBSXVuQyxPQUFSO0FBQWtCOztBQUN4Q3FmLGVBQU8sR0FBR0MsY0FBYyxHQUFHLEtBQTNCO0FBQ0Q7QUFDRjs7QUFDRCxhQUFTRyxPQUFULENBQWlCbHJELEdBQWpCLEVBQXNCO0FBQ3BCLFVBQUlBLEdBQUosRUFBUztBQUNQaXJELGFBQUs7QUFDTC9tRCxZQUFJLElBQUlsRSxHQUFSO0FBQ0Q7QUFDRjs7QUFDRCxhQUFTbXJELElBQVQsQ0FBY2gwRCxJQUFkLEVBQW9CO0FBQ2xCLFVBQUlBLElBQUksQ0FBQzJDLFFBQUwsSUFBaUIsQ0FBckIsRUFBd0I7QUFDdEIsWUFBSXN4RCxNQUFNLEdBQUdqMEQsSUFBSSxDQUFDc3FCLFlBQUwsQ0FBa0IsU0FBbEIsQ0FBYjs7QUFDQSxZQUFJMnBDLE1BQUosRUFBWTtBQUNWRixpQkFBTyxDQUFDRSxNQUFELENBQVA7QUFDQTtBQUNEOztBQUNELFlBQUlDLFFBQVEsR0FBR2wwRCxJQUFJLENBQUNzcUIsWUFBTCxDQUFrQixXQUFsQixDQUFmO0FBQUEsWUFBK0M1b0IsS0FBL0M7O0FBQ0EsWUFBSXd5RCxRQUFKLEVBQWM7QUFDWixjQUFJeHFELEtBQUssR0FBR29FLEVBQUUsQ0FBQytsQyxTQUFILENBQWE3OEIsR0FBRyxDQUFDNmdCLFFBQUQsRUFBVyxDQUFYLENBQWhCLEVBQStCN2dCLEdBQUcsQ0FBQzhnQixNQUFNLEdBQUcsQ0FBVixFQUFhLENBQWIsQ0FBbEMsRUFBbUQrN0IsZUFBZSxDQUFDLENBQUNLLFFBQUYsQ0FBbEUsQ0FBWjs7QUFDQSxjQUFJeHFELEtBQUssQ0FBQ3BKLE1BQU4sS0FBaUJvQixLQUFLLEdBQUdnSSxLQUFLLENBQUMsQ0FBRCxDQUFMLENBQVNpVixJQUFULENBQWMsQ0FBZCxDQUF6QixDQUFKLEVBQ0U7QUFBRW8xQyxtQkFBTyxDQUFDaCtDLFVBQVUsQ0FBQ2pJLEVBQUUsQ0FBQ3dILEdBQUosRUFBUzVULEtBQUssQ0FBQ3dILElBQWYsRUFBcUJ4SCxLQUFLLENBQUN5SCxFQUEzQixDQUFWLENBQXlDdXJDLElBQXpDLENBQThDSixPQUE5QyxDQUFELENBQVA7QUFBa0U7O0FBQ3RFO0FBQ0Q7O0FBQ0QsWUFBSXQwQyxJQUFJLENBQUNzcUIsWUFBTCxDQUFrQixpQkFBbEIsS0FBd0MsT0FBNUMsRUFBcUQ7QUFBRTtBQUFROztBQUMvRCxZQUFJNnBDLE9BQU8sR0FBRyw2QkFBNkJwMkQsSUFBN0IsQ0FBa0NpQyxJQUFJLENBQUM0akMsUUFBdkMsQ0FBZDs7QUFDQSxZQUFJLENBQUMsUUFBUTdsQyxJQUFSLENBQWFpQyxJQUFJLENBQUM0akMsUUFBbEIsQ0FBRCxJQUFnQzVqQyxJQUFJLENBQUNvMEQsV0FBTCxDQUFpQjl6RCxNQUFqQixJQUEyQixDQUEvRCxFQUFrRTtBQUFFO0FBQVE7O0FBRTVFLFlBQUk2ekQsT0FBSixFQUFhO0FBQUVMLGVBQUs7QUFBSzs7QUFDekIsYUFBSyxJQUFJdnlELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd2QixJQUFJLENBQUNVLFVBQUwsQ0FBZ0JKLE1BQXBDLEVBQTRDaUIsQ0FBQyxFQUE3QyxFQUNFO0FBQUV5eUQsY0FBSSxDQUFDaDBELElBQUksQ0FBQ1UsVUFBTCxDQUFnQmEsQ0FBaEIsQ0FBRCxDQUFKO0FBQTJCOztBQUUvQixZQUFJLGFBQWF4RCxJQUFiLENBQWtCaUMsSUFBSSxDQUFDNGpDLFFBQXZCLENBQUosRUFBc0M7QUFBRWd3Qix3QkFBYyxHQUFHLElBQWpCO0FBQXdCOztBQUNoRSxZQUFJTyxPQUFKLEVBQWE7QUFBRVIsaUJBQU8sR0FBRyxJQUFWO0FBQWlCO0FBQ2pDLE9BdkJELE1BdUJPLElBQUkzekQsSUFBSSxDQUFDMkMsUUFBTCxJQUFpQixDQUFyQixFQUF3QjtBQUM3Qm94RCxlQUFPLENBQUMvekQsSUFBSSxDQUFDcTBELFNBQUwsQ0FBZTFvRCxPQUFmLENBQXVCLFNBQXZCLEVBQWtDLEVBQWxDLEVBQXNDQSxPQUF0QyxDQUE4QyxTQUE5QyxFQUF5RCxHQUF6RCxDQUFELENBQVA7QUFDRDtBQUNGOztBQUNELGFBQVM7QUFDUHFvRCxVQUFJLENBQUM5cUQsSUFBRCxDQUFKOztBQUNBLFVBQUlBLElBQUksSUFBSUMsRUFBWixFQUFnQjtBQUFFO0FBQU87O0FBQ3pCRCxVQUFJLEdBQUdBLElBQUksQ0FBQzZmLFdBQVo7QUFDQTZxQyxvQkFBYyxHQUFHLEtBQWpCO0FBQ0Q7O0FBQ0QsV0FBTzdtRCxJQUFQO0FBQ0Q7O0FBRUQsV0FBU3drRCxRQUFULENBQWtCempELEVBQWxCLEVBQXNCOU4sSUFBdEIsRUFBNEI2ZCxNQUE1QixFQUFvQztBQUNsQyxRQUFJeTJDLFFBQUo7O0FBQ0EsUUFBSXQwRCxJQUFJLElBQUk4TixFQUFFLENBQUNvTSxPQUFILENBQVdzZixPQUF2QixFQUFnQztBQUM5Qjg2QixjQUFRLEdBQUd4bUQsRUFBRSxDQUFDb00sT0FBSCxDQUFXc2YsT0FBWCxDQUFtQjk0QixVQUFuQixDQUE4Qm1kLE1BQTlCLENBQVg7O0FBQ0EsVUFBSSxDQUFDeTJDLFFBQUwsRUFBZTtBQUFFLGVBQU9aLE1BQU0sQ0FBQzVsRCxFQUFFLENBQUMwSixPQUFILENBQVdSLEdBQUcsQ0FBQ2xKLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV0ksTUFBWCxHQUFvQixDQUFyQixDQUFkLENBQUQsRUFBeUMsSUFBekMsQ0FBYjtBQUE2RDs7QUFDOUV0YSxVQUFJLEdBQUcsSUFBUDtBQUFhNmQsWUFBTSxHQUFHLENBQVQ7QUFDZCxLQUpELE1BSU87QUFDTCxXQUFLeTJDLFFBQVEsR0FBR3QwRCxJQUFoQixHQUF1QnMwRCxRQUFRLEdBQUdBLFFBQVEsQ0FBQ2p5RCxVQUEzQyxFQUF1RDtBQUNyRCxZQUFJLENBQUNpeUQsUUFBRCxJQUFhQSxRQUFRLElBQUl4bUQsRUFBRSxDQUFDb00sT0FBSCxDQUFXc2YsT0FBeEMsRUFBaUQ7QUFBRSxpQkFBTyxJQUFQO0FBQWE7O0FBQ2hFLFlBQUk4NkIsUUFBUSxDQUFDanlELFVBQVQsSUFBdUJpeUQsUUFBUSxDQUFDanlELFVBQVQsSUFBdUJ5TCxFQUFFLENBQUNvTSxPQUFILENBQVdzZixPQUE3RCxFQUFzRTtBQUFFO0FBQU87QUFDaEY7QUFDRjs7QUFDRCxTQUFLLElBQUlqNEIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VNLEVBQUUsQ0FBQ29NLE9BQUgsQ0FBV3VMLElBQVgsQ0FBZ0JubEIsTUFBcEMsRUFBNENpQixDQUFDLEVBQTdDLEVBQWlEO0FBQy9DLFVBQUkwZ0IsUUFBUSxHQUFHblUsRUFBRSxDQUFDb00sT0FBSCxDQUFXdUwsSUFBWCxDQUFnQmxrQixDQUFoQixDQUFmOztBQUNBLFVBQUkwZ0IsUUFBUSxDQUFDamlCLElBQVQsSUFBaUJzMEQsUUFBckIsRUFDRTtBQUFFLGVBQU9DLG9CQUFvQixDQUFDdHlDLFFBQUQsRUFBV2ppQixJQUFYLEVBQWlCNmQsTUFBakIsQ0FBM0I7QUFBcUQ7QUFDMUQ7QUFDRjs7QUFFRCxXQUFTMDJDLG9CQUFULENBQThCdHlDLFFBQTlCLEVBQXdDamlCLElBQXhDLEVBQThDNmQsTUFBOUMsRUFBc0Q7QUFDcEQsUUFBSXNNLE9BQU8sR0FBR2xJLFFBQVEsQ0FBQ2xWLElBQVQsQ0FBY25NLFVBQTVCO0FBQUEsUUFBd0M2d0QsR0FBRyxHQUFHLEtBQTlDOztBQUNBLFFBQUksQ0FBQ3p4RCxJQUFELElBQVMsQ0FBQ3lDLFFBQVEsQ0FBQzBuQixPQUFELEVBQVVucUIsSUFBVixDQUF0QixFQUF1QztBQUFFLGFBQU8wekQsTUFBTSxDQUFDMThDLEdBQUcsQ0FBQ1gsTUFBTSxDQUFDNEwsUUFBUSxDQUFDblYsSUFBVixDQUFQLEVBQXdCLENBQXhCLENBQUosRUFBZ0MsSUFBaEMsQ0FBYjtBQUFvRDs7QUFDN0YsUUFBSTlNLElBQUksSUFBSW1xQixPQUFaLEVBQXFCO0FBQ25Cc25DLFNBQUcsR0FBRyxJQUFOO0FBQ0F6eEQsVUFBSSxHQUFHbXFCLE9BQU8sQ0FBQ3pwQixVQUFSLENBQW1CbWQsTUFBbkIsQ0FBUDtBQUNBQSxZQUFNLEdBQUcsQ0FBVDs7QUFDQSxVQUFJLENBQUM3ZCxJQUFMLEVBQVc7QUFDVCxZQUFJOE0sSUFBSSxHQUFHbVYsUUFBUSxDQUFDTSxJQUFULEdBQWdCdGIsR0FBRyxDQUFDZ2IsUUFBUSxDQUFDTSxJQUFWLENBQW5CLEdBQXFDTixRQUFRLENBQUNuVixJQUF6RDtBQUNBLGVBQU80bUQsTUFBTSxDQUFDMThDLEdBQUcsQ0FBQ1gsTUFBTSxDQUFDdkosSUFBRCxDQUFQLEVBQWVBLElBQUksQ0FBQ0MsSUFBTCxDQUFVek0sTUFBekIsQ0FBSixFQUFzQ214RCxHQUF0QyxDQUFiO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJK0MsUUFBUSxHQUFHeDBELElBQUksQ0FBQzJDLFFBQUwsSUFBaUIsQ0FBakIsR0FBcUIzQyxJQUFyQixHQUE0QixJQUEzQztBQUFBLFFBQWlEeTBELE9BQU8sR0FBR3owRCxJQUEzRDs7QUFDQSxRQUFJLENBQUN3MEQsUUFBRCxJQUFheDBELElBQUksQ0FBQ1UsVUFBTCxDQUFnQkosTUFBaEIsSUFBMEIsQ0FBdkMsSUFBNENOLElBQUksQ0FBQ1ksVUFBTCxDQUFnQitCLFFBQWhCLElBQTRCLENBQTVFLEVBQStFO0FBQzdFNnhELGNBQVEsR0FBR3gwRCxJQUFJLENBQUNZLFVBQWhCOztBQUNBLFVBQUlpZCxNQUFKLEVBQVk7QUFBRUEsY0FBTSxHQUFHMjJDLFFBQVEsQ0FBQ0gsU0FBVCxDQUFtQi96RCxNQUE1QjtBQUFxQztBQUNwRDs7QUFDRCxXQUFPbTBELE9BQU8sQ0FBQ3B5RCxVQUFSLElBQXNCOG5CLE9BQTdCLEVBQXNDO0FBQUVzcUMsYUFBTyxHQUFHQSxPQUFPLENBQUNweUQsVUFBbEI7QUFBK0I7O0FBQ3ZFLFFBQUlzTixPQUFPLEdBQUdzUyxRQUFRLENBQUN0UyxPQUF2QjtBQUFBLFFBQWdDbVQsSUFBSSxHQUFHblQsT0FBTyxDQUFDbVQsSUFBL0M7O0FBRUEsYUFBU25FLElBQVQsQ0FBYzYxQyxRQUFkLEVBQXdCQyxPQUF4QixFQUFpQzUyQyxNQUFqQyxFQUF5QztBQUN2QyxXQUFLLElBQUl0YyxDQUFDLEdBQUcsQ0FBQyxDQUFkLEVBQWlCQSxDQUFDLElBQUl1aEIsSUFBSSxHQUFHQSxJQUFJLENBQUN4aUIsTUFBUixHQUFpQixDQUF6QixDQUFsQixFQUErQ2lCLENBQUMsRUFBaEQsRUFBb0Q7QUFDbEQsWUFBSTRGLEdBQUcsR0FBRzVGLENBQUMsR0FBRyxDQUFKLEdBQVFvTyxPQUFPLENBQUN4SSxHQUFoQixHQUFzQjJiLElBQUksQ0FBQ3ZoQixDQUFELENBQXBDOztBQUNBLGFBQUssSUFBSXFLLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd6RSxHQUFHLENBQUM3RyxNQUF4QixFQUFnQ3NMLENBQUMsSUFBSSxDQUFyQyxFQUF3QztBQUN0QyxjQUFJOG9ELE9BQU8sR0FBR3Z0RCxHQUFHLENBQUN5RSxDQUFDLEdBQUcsQ0FBTCxDQUFqQjs7QUFDQSxjQUFJOG9ELE9BQU8sSUFBSUYsUUFBWCxJQUF1QkUsT0FBTyxJQUFJRCxPQUF0QyxFQUErQztBQUM3QyxnQkFBSTNuRCxJQUFJLEdBQUd1SixNQUFNLENBQUM5VSxDQUFDLEdBQUcsQ0FBSixHQUFRMGdCLFFBQVEsQ0FBQ25WLElBQWpCLEdBQXdCbVYsUUFBUSxDQUFDTSxJQUFULENBQWNoaEIsQ0FBZCxDQUF6QixDQUFqQjtBQUNBLGdCQUFJMkcsRUFBRSxHQUFHZixHQUFHLENBQUN5RSxDQUFELENBQUgsR0FBU2lTLE1BQWxCOztBQUNBLGdCQUFJQSxNQUFNLEdBQUcsQ0FBVCxJQUFjNjJDLE9BQU8sSUFBSUYsUUFBN0IsRUFBdUM7QUFBRXRzRCxnQkFBRSxHQUFHZixHQUFHLENBQUN5RSxDQUFDLElBQUlpUyxNQUFNLEdBQUcsQ0FBSCxHQUFPLENBQWpCLENBQUYsQ0FBUjtBQUFpQzs7QUFDMUUsbUJBQU83RyxHQUFHLENBQUNsSyxJQUFELEVBQU81RSxFQUFQLENBQVY7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFDRCxRQUFJd0IsS0FBSyxHQUFHaVYsSUFBSSxDQUFDNjFDLFFBQUQsRUFBV0MsT0FBWCxFQUFvQjUyQyxNQUFwQixDQUFoQjs7QUFDQSxRQUFJblUsS0FBSixFQUFXO0FBQUUsYUFBT2dxRCxNQUFNLENBQUNocUQsS0FBRCxFQUFRK25ELEdBQVIsQ0FBYjtBQUEyQixLQXBDWSxDQXNDcEQ7OztBQUNBLFNBQUssSUFBSXR4RCxLQUFLLEdBQUdzMEQsT0FBTyxDQUFDMXJDLFdBQXBCLEVBQWlDNEosSUFBSSxHQUFHNmhDLFFBQVEsR0FBR0EsUUFBUSxDQUFDSCxTQUFULENBQW1CL3pELE1BQW5CLEdBQTRCdWQsTUFBL0IsR0FBd0MsQ0FBN0YsRUFBZ0cxZCxLQUFoRyxFQUF1R0EsS0FBSyxHQUFHQSxLQUFLLENBQUM0b0IsV0FBckgsRUFBa0k7QUFDaElyZixXQUFLLEdBQUdpVixJQUFJLENBQUN4ZSxLQUFELEVBQVFBLEtBQUssQ0FBQ1MsVUFBZCxFQUEwQixDQUExQixDQUFaOztBQUNBLFVBQUk4SSxLQUFKLEVBQ0U7QUFBRSxlQUFPZ3FELE1BQU0sQ0FBQzE4QyxHQUFHLENBQUN0TixLQUFLLENBQUNvRCxJQUFQLEVBQWFwRCxLQUFLLENBQUN4QixFQUFOLEdBQVd5cUIsSUFBeEIsQ0FBSixFQUFtQzgrQixHQUFuQyxDQUFiO0FBQXNELE9BRDFELE1BR0U7QUFBRTkrQixZQUFJLElBQUl4eUIsS0FBSyxDQUFDaTBELFdBQU4sQ0FBa0I5ekQsTUFBMUI7QUFBbUM7QUFDeEM7O0FBQ0QsU0FBSyxJQUFJNEwsTUFBTSxHQUFHdW9ELE9BQU8sQ0FBQzlCLGVBQXJCLEVBQXNDZ0MsTUFBTSxHQUFHOTJDLE1BQXBELEVBQTREM1IsTUFBNUQsRUFBb0VBLE1BQU0sR0FBR0EsTUFBTSxDQUFDeW1ELGVBQXBGLEVBQXFHO0FBQ25HanBELFdBQUssR0FBR2lWLElBQUksQ0FBQ3pTLE1BQUQsRUFBU0EsTUFBTSxDQUFDdEwsVUFBaEIsRUFBNEIsQ0FBQyxDQUE3QixDQUFaOztBQUNBLFVBQUk4SSxLQUFKLEVBQ0U7QUFBRSxlQUFPZ3FELE1BQU0sQ0FBQzE4QyxHQUFHLENBQUN0TixLQUFLLENBQUNvRCxJQUFQLEVBQWFwRCxLQUFLLENBQUN4QixFQUFOLEdBQVd5c0QsTUFBeEIsQ0FBSixFQUFxQ2xELEdBQXJDLENBQWI7QUFBd0QsT0FENUQsTUFHRTtBQUFFa0QsY0FBTSxJQUFJem9ELE1BQU0sQ0FBQ2tvRCxXQUFQLENBQW1COXpELE1BQTdCO0FBQXNDO0FBQzNDO0FBQ0YsR0F4alNrQixDQTBqU25COzs7QUFFQSxNQUFJczBELGFBQWEsR0FBRyxTQUFoQkEsYUFBZ0IsQ0FBUzltRCxFQUFULEVBQWE7QUFDL0IsU0FBS0EsRUFBTCxHQUFVQSxFQUFWLENBRCtCLENBRS9COztBQUNBLFNBQUsrbUQsU0FBTCxHQUFpQixFQUFqQixDQUgrQixDQUsvQjtBQUNBO0FBQ0E7O0FBQ0EsU0FBS0MsV0FBTCxHQUFtQixLQUFuQixDQVIrQixDQVMvQjs7QUFDQSxTQUFLekUsT0FBTCxHQUFlLElBQUlsckQsT0FBSixFQUFmLENBVitCLENBVy9COztBQUNBLFNBQUt3TCxZQUFMLEdBQW9CLEtBQXBCO0FBQ0EsU0FBSzIvQyxTQUFMLEdBQWlCLElBQWpCO0FBQ0QsR0FkRDs7QUFnQkFzRSxlQUFhLENBQUM1d0QsU0FBZCxDQUF3QmtpQyxJQUF4QixHQUErQixVQUFVaHNCLE9BQVYsRUFBbUI7QUFDOUMsUUFBSXM0QixNQUFNLEdBQUcsSUFBYjtBQUVGLFFBQUlodUIsS0FBSyxHQUFHLElBQVo7QUFBQSxRQUFrQjFXLEVBQUUsR0FBRyxLQUFLQSxFQUE1QjtBQUNBLFNBQUtpbkQsV0FBTCxDQUFpQjc2QyxPQUFqQjtBQUNBLFFBQUlwSixFQUFFLEdBQUcsS0FBS2trRCxRQUFkO0FBRUE5NkMsV0FBTyxDQUFDaVEsT0FBUixDQUFnQjNDLFlBQWhCLENBQTZCLEtBQUsyQyxPQUFsQyxFQUEyQ2pRLE9BQU8sQ0FBQ2lRLE9BQVIsQ0FBZ0J2cEIsVUFBM0QsRUFQZ0QsQ0FTaEQ7O0FBQ0EsUUFBSTVCLEdBQUosRUFBUztBQUFFOFIsUUFBRSxDQUFDM1AsS0FBSCxDQUFTdW9CLEtBQVQsR0FBaUIsS0FBakI7QUFBeUI7O0FBRXBDemMsTUFBRSxDQUFDNkQsRUFBRCxFQUFLLE9BQUwsRUFBYyxZQUFZO0FBQzFCLFVBQUkxUyxFQUFFLElBQUlDLFVBQVUsSUFBSSxDQUFwQixJQUF5Qm0wQyxNQUFNLENBQUM3aEMsWUFBcEMsRUFBa0Q7QUFBRTZoQyxjQUFNLENBQUM3aEMsWUFBUCxHQUFzQixJQUF0QjtBQUE2Qjs7QUFDakY2VCxXQUFLLENBQUMydEMsSUFBTjtBQUNELEtBSEMsQ0FBRjtBQUtBbGxELE1BQUUsQ0FBQzZELEVBQUQsRUFBSyxPQUFMLEVBQWMsVUFBVXRRLENBQVYsRUFBYTtBQUMzQixVQUFJcU4sY0FBYyxDQUFDQyxFQUFELEVBQUt0TixDQUFMLENBQWQsSUFBeUI4cUQsV0FBVyxDQUFDOXFELENBQUQsRUFBSXNOLEVBQUosQ0FBeEMsRUFBaUQ7QUFBRTtBQUFROztBQUUzREEsUUFBRSxDQUFDa0YsS0FBSCxDQUFTMjFDLGFBQVQsR0FBeUIsQ0FBQyxJQUFJbGpELElBQUosRUFBMUI7QUFDQStlLFdBQUssQ0FBQ3l3QyxRQUFOO0FBQ0QsS0FMQyxDQUFGOztBQU9BLGFBQVNDLGNBQVQsQ0FBd0IxMEQsQ0FBeEIsRUFBMkI7QUFDekIsVUFBSXFOLGNBQWMsQ0FBQ0MsRUFBRCxFQUFLdE4sQ0FBTCxDQUFsQixFQUEyQjtBQUFFO0FBQVE7O0FBQ3JDLFVBQUlzTixFQUFFLENBQUMrNUIsaUJBQUgsRUFBSixFQUE0QjtBQUMxQjRpQixxQkFBYSxDQUFDO0FBQUNVLGtCQUFRLEVBQUUsS0FBWDtBQUFrQnArQyxjQUFJLEVBQUVlLEVBQUUsQ0FBQ3luQyxhQUFIO0FBQXhCLFNBQUQsQ0FBYjtBQUNELE9BRkQsTUFFTyxJQUFJLENBQUN6bkMsRUFBRSxDQUFDdUUsT0FBSCxDQUFXeStDLGVBQWhCLEVBQWlDO0FBQ3RDO0FBQ0QsT0FGTSxNQUVBO0FBQ0wsWUFBSXQ3QixNQUFNLEdBQUdzMkIsY0FBYyxDQUFDaCtDLEVBQUQsQ0FBM0I7QUFDQTI4QyxxQkFBYSxDQUFDO0FBQUNVLGtCQUFRLEVBQUUsSUFBWDtBQUFpQnArQyxjQUFJLEVBQUV5b0IsTUFBTSxDQUFDem9CO0FBQTlCLFNBQUQsQ0FBYjs7QUFDQSxZQUFJdk0sQ0FBQyxDQUFDMkssSUFBRixJQUFVLEtBQWQsRUFBcUI7QUFDbkIyQyxZQUFFLENBQUN1bkMsYUFBSCxDQUFpQjdmLE1BQU0sQ0FBQ0EsTUFBeEIsRUFBZ0MsSUFBaEMsRUFBc0N0dkIsY0FBdEM7QUFDRCxTQUZELE1BRU87QUFDTHNlLGVBQUssQ0FBQ3F3QyxTQUFOLEdBQWtCLEVBQWxCO0FBQ0EvakQsWUFBRSxDQUFDcE4sS0FBSCxHQUFXOHhCLE1BQU0sQ0FBQ3pvQixJQUFQLENBQVkybkMsSUFBWixDQUFpQixJQUFqQixDQUFYO0FBQ0FweEMscUJBQVcsQ0FBQ3dOLEVBQUQsQ0FBWDtBQUNEO0FBQ0Y7O0FBQ0QsVUFBSXRRLENBQUMsQ0FBQzJLLElBQUYsSUFBVSxLQUFkLEVBQXFCO0FBQUUyQyxVQUFFLENBQUNrRixLQUFILENBQVM0MUMsV0FBVCxHQUF1QixDQUFDLElBQUluakQsSUFBSixFQUF4QjtBQUFtQztBQUMzRDs7QUFDRHdILE1BQUUsQ0FBQzZELEVBQUQsRUFBSyxLQUFMLEVBQVlva0QsY0FBWixDQUFGO0FBQ0Fqb0QsTUFBRSxDQUFDNkQsRUFBRCxFQUFLLE1BQUwsRUFBYW9rRCxjQUFiLENBQUY7QUFFQWpvRCxNQUFFLENBQUNpTixPQUFPLENBQUNzUixRQUFULEVBQW1CLE9BQW5CLEVBQTRCLFVBQVVockIsQ0FBVixFQUFhO0FBQ3pDLFVBQUk2cEIsYUFBYSxDQUFDblEsT0FBRCxFQUFVMVosQ0FBVixDQUFiLElBQTZCcU4sY0FBYyxDQUFDQyxFQUFELEVBQUt0TixDQUFMLENBQS9DLEVBQXdEO0FBQUU7QUFBUTs7QUFDbEUsVUFBSSxDQUFDc1EsRUFBRSxDQUFDcWtELGFBQVIsRUFBdUI7QUFDckJybkQsVUFBRSxDQUFDa0YsS0FBSCxDQUFTMjFDLGFBQVQsR0FBeUIsQ0FBQyxJQUFJbGpELElBQUosRUFBMUI7QUFDQStlLGFBQUssQ0FBQ3FVLEtBQU47QUFDQTtBQUNELE9BTndDLENBUXpDOzs7QUFDQSxVQUFJcVUsS0FBSyxHQUFHLElBQUlrb0IsS0FBSixDQUFVLE9BQVYsQ0FBWjtBQUNBbG9CLFdBQUssQ0FBQ3NlLGFBQU4sR0FBc0JockQsQ0FBQyxDQUFDZ3JELGFBQXhCO0FBQ0ExNkMsUUFBRSxDQUFDcWtELGFBQUgsQ0FBaUJqb0IsS0FBakI7QUFDRCxLQVpDLENBQUYsQ0E5Q2dELENBNERoRDs7QUFDQWpnQyxNQUFFLENBQUNpTixPQUFPLENBQUN3USxTQUFULEVBQW9CLGFBQXBCLEVBQW1DLFVBQVVscUIsQ0FBVixFQUFhO0FBQ2hELFVBQUksQ0FBQzZwQixhQUFhLENBQUNuUSxPQUFELEVBQVUxWixDQUFWLENBQWxCLEVBQWdDO0FBQUVtTyx3QkFBZ0IsQ0FBQ25PLENBQUQsQ0FBaEI7QUFBc0I7QUFDekQsS0FGQyxDQUFGO0FBSUF5TSxNQUFFLENBQUM2RCxFQUFELEVBQUssa0JBQUwsRUFBeUIsWUFBWTtBQUNyQyxVQUFJbFAsS0FBSyxHQUFHa00sRUFBRSxDQUFDZ3VCLFNBQUgsQ0FBYSxNQUFiLENBQVo7O0FBQ0EsVUFBSXRYLEtBQUssQ0FBQzhyQyxTQUFWLEVBQXFCO0FBQUU5ckMsYUFBSyxDQUFDOHJDLFNBQU4sQ0FBZ0I1dUQsS0FBaEIsQ0FBc0JpOUIsS0FBdEI7QUFBZ0M7O0FBQ3ZEbmEsV0FBSyxDQUFDOHJDLFNBQU4sR0FBa0I7QUFDaEIxdUQsYUFBSyxFQUFFQSxLQURTO0FBRWhCRixhQUFLLEVBQUVvTSxFQUFFLENBQUNvbEMsUUFBSCxDQUFZdHhDLEtBQVosRUFBbUJrTSxFQUFFLENBQUNndUIsU0FBSCxDQUFhLElBQWIsQ0FBbkIsRUFBdUM7QUFBQzU3QixtQkFBUyxFQUFFO0FBQVosU0FBdkM7QUFGUyxPQUFsQjtBQUlELEtBUEMsQ0FBRjtBQVFBK00sTUFBRSxDQUFDNkQsRUFBRCxFQUFLLGdCQUFMLEVBQXVCLFlBQVk7QUFDbkMsVUFBSTBULEtBQUssQ0FBQzhyQyxTQUFWLEVBQXFCO0FBQ25COXJDLGFBQUssQ0FBQzJ0QyxJQUFOO0FBQ0EzdEMsYUFBSyxDQUFDOHJDLFNBQU4sQ0FBZ0I1dUQsS0FBaEIsQ0FBc0JpOUIsS0FBdEI7QUFDQW5hLGFBQUssQ0FBQzhyQyxTQUFOLEdBQWtCLElBQWxCO0FBQ0Q7QUFDRixLQU5DLENBQUY7QUFPRCxHQWhGRDs7QUFrRkFzRSxlQUFhLENBQUM1d0QsU0FBZCxDQUF3Qit3RCxXQUF4QixHQUFzQyxVQUFVTSxRQUFWLEVBQW9CO0FBQ3hEO0FBQ0EsU0FBS2xyQyxPQUFMLEdBQWUraEMsY0FBYyxFQUE3QixDQUZ3RCxDQUd4RDtBQUNBOztBQUNBLFNBQUs4SSxRQUFMLEdBQWdCLEtBQUs3cUMsT0FBTCxDQUFhdnBCLFVBQTdCO0FBQ0QsR0FORDs7QUFRQWcwRCxlQUFhLENBQUM1d0QsU0FBZCxDQUF3QjhqRCx3QkFBeEIsR0FBbUQsVUFBVXFKLEtBQVYsRUFBaUI7QUFDbEU7QUFDQSxRQUFHQSxLQUFILEVBQVU7QUFDUixXQUFLNkQsUUFBTCxDQUFjdnpELFlBQWQsQ0FBMkIsWUFBM0IsRUFBeUMwdkQsS0FBekM7QUFDRCxLQUZELE1BRU87QUFDTCxXQUFLNkQsUUFBTCxDQUFjNUQsZUFBZCxDQUE4QixZQUE5QjtBQUNEO0FBQ0YsR0FQRDs7QUFTQXdELGVBQWEsQ0FBQzV3RCxTQUFkLENBQXdCa3hCLGdCQUF4QixHQUEyQyxZQUFZO0FBQ3JEO0FBQ0EsUUFBSXBuQixFQUFFLEdBQUcsS0FBS0EsRUFBZDtBQUFBLFFBQWtCb00sT0FBTyxHQUFHcE0sRUFBRSxDQUFDb00sT0FBL0I7QUFBQSxRQUF3QzVFLEdBQUcsR0FBR3hILEVBQUUsQ0FBQ3dILEdBQWpEO0FBQ0EsUUFBSS9FLE1BQU0sR0FBRzJrQixnQkFBZ0IsQ0FBQ3BuQixFQUFELENBQTdCLENBSHFELENBS3JEOztBQUNBLFFBQUlBLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBV2lqRCxtQkFBZixFQUFvQztBQUNsQyxVQUFJL0csT0FBTyxHQUFHNzlCLGFBQVksQ0FBQzVpQixFQUFELEVBQUt3SCxHQUFHLENBQUNpZ0IsR0FBSixDQUFRSixPQUFSLEdBQWtCVSxJQUF2QixFQUE2QixLQUE3QixDQUExQjs7QUFDQSxVQUFJMC9CLE9BQU8sR0FBR3I3QyxPQUFPLENBQUNpUSxPQUFSLENBQWdCamEscUJBQWhCLEVBQWQ7QUFBQSxVQUF1RHNsRCxPQUFPLEdBQUd0N0MsT0FBTyxDQUFDc2YsT0FBUixDQUFnQnRwQixxQkFBaEIsRUFBakU7QUFDQUssWUFBTSxDQUFDa2xELEtBQVAsR0FBZTd1RCxJQUFJLENBQUNnRCxHQUFMLENBQVMsQ0FBVCxFQUFZaEQsSUFBSSxDQUFDQyxHQUFMLENBQVNxVCxPQUFPLENBQUNpUSxPQUFSLENBQWdCd0IsWUFBaEIsR0FBK0IsRUFBeEMsRUFDUzRpQyxPQUFPLENBQUNqaUMsR0FBUixHQUFja3BDLE9BQU8sQ0FBQ2xwQyxHQUF0QixHQUE0QmlwQyxPQUFPLENBQUNqcEMsR0FEN0MsQ0FBWixDQUFmO0FBRUEvYixZQUFNLENBQUNtbEQsTUFBUCxHQUFnQjl1RCxJQUFJLENBQUNnRCxHQUFMLENBQVMsQ0FBVCxFQUFZaEQsSUFBSSxDQUFDQyxHQUFMLENBQVNxVCxPQUFPLENBQUNpUSxPQUFSLENBQWdCQyxXQUFoQixHQUE4QixFQUF2QyxFQUNTbWtDLE9BQU8sQ0FBQ24rQyxJQUFSLEdBQWVvbEQsT0FBTyxDQUFDcGxELElBQXZCLEdBQThCbWxELE9BQU8sQ0FBQ25sRCxJQUQvQyxDQUFaLENBQWhCO0FBRUQ7O0FBRUQsV0FBT0csTUFBUDtBQUNELEdBaEJEOztBQWtCQXFrRCxlQUFhLENBQUM1d0QsU0FBZCxDQUF3Qml4QixhQUF4QixHQUF3QyxVQUFVMGdDLEtBQVYsRUFBaUI7QUFDdkQsUUFBSTduRCxFQUFFLEdBQUcsS0FBS0EsRUFBZDtBQUFBLFFBQWtCb00sT0FBTyxHQUFHcE0sRUFBRSxDQUFDb00sT0FBL0I7QUFDQXJaLHdCQUFvQixDQUFDcVosT0FBTyxDQUFDb2UsU0FBVCxFQUFvQnE5QixLQUFLLENBQUN0Z0MsT0FBMUIsQ0FBcEI7QUFDQXgwQix3QkFBb0IsQ0FBQ3FaLE9BQU8sQ0FBQ3NxQixZQUFULEVBQXVCbXhCLEtBQUssQ0FBQzNrRCxTQUE3QixDQUFwQjs7QUFDQSxRQUFJMmtELEtBQUssQ0FBQ0YsS0FBTixJQUFlLElBQW5CLEVBQXlCO0FBQ3ZCLFdBQUt0ckMsT0FBTCxDQUFhaHBCLEtBQWIsQ0FBbUJtckIsR0FBbkIsR0FBeUJxcEMsS0FBSyxDQUFDRixLQUFOLEdBQWMsSUFBdkM7QUFDQSxXQUFLdHJDLE9BQUwsQ0FBYWhwQixLQUFiLENBQW1CaVAsSUFBbkIsR0FBMEJ1bEQsS0FBSyxDQUFDRCxNQUFOLEdBQWUsSUFBekM7QUFDRDtBQUNGLEdBUkQsQ0Fqc1NtQixDQTJzU25CO0FBQ0E7OztBQUNBZCxlQUFhLENBQUM1d0QsU0FBZCxDQUF3Qm0xQixLQUF4QixHQUFnQyxVQUFVNEcsTUFBVixFQUFrQjtBQUNoRCxRQUFJLEtBQUs2MUIsa0JBQUwsSUFBMkIsS0FBS3RGLFNBQXBDLEVBQStDO0FBQUU7QUFBUTs7QUFDekQsUUFBSXhpRCxFQUFFLEdBQUcsS0FBS0EsRUFBZDs7QUFDQSxRQUFJQSxFQUFFLENBQUMrNUIsaUJBQUgsRUFBSixFQUE0QjtBQUMxQixXQUFLZ3RCLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxVQUFJM3pELE9BQU8sR0FBRzRNLEVBQUUsQ0FBQytDLFlBQUgsRUFBZDtBQUNBLFdBQUtta0QsUUFBTCxDQUFjdHhELEtBQWQsR0FBc0J4QyxPQUF0Qjs7QUFDQSxVQUFJNE0sRUFBRSxDQUFDa0YsS0FBSCxDQUFTbWxCLE9BQWIsRUFBc0I7QUFBRTcwQixtQkFBVyxDQUFDLEtBQUsweEQsUUFBTixDQUFYO0FBQTZCOztBQUNyRCxVQUFJNTJELEVBQUUsSUFBSUMsVUFBVSxJQUFJLENBQXhCLEVBQTJCO0FBQUUsYUFBS3NTLFlBQUwsR0FBb0J6UCxPQUFwQjtBQUE4QjtBQUM1RCxLQU5ELE1BTU8sSUFBSSxDQUFDNitCLE1BQUwsRUFBYTtBQUNsQixXQUFLODBCLFNBQUwsR0FBaUIsS0FBS0csUUFBTCxDQUFjdHhELEtBQWQsR0FBc0IsRUFBdkM7O0FBQ0EsVUFBSXRGLEVBQUUsSUFBSUMsVUFBVSxJQUFJLENBQXhCLEVBQTJCO0FBQUUsYUFBS3NTLFlBQUwsR0FBb0IsSUFBcEI7QUFBMkI7QUFDekQ7QUFDRixHQWJEOztBQWVBaWtELGVBQWEsQ0FBQzV3RCxTQUFkLENBQXdCcytDLFFBQXhCLEdBQW1DLFlBQVk7QUFBRSxXQUFPLEtBQUswUyxRQUFaO0FBQXNCLEdBQXZFOztBQUVBSixlQUFhLENBQUM1d0QsU0FBZCxDQUF3QnEvQyxhQUF4QixHQUF3QyxZQUFZO0FBQUUsV0FBTyxLQUFQO0FBQWMsR0FBcEU7O0FBRUF1UixlQUFhLENBQUM1d0QsU0FBZCxDQUF3QjYwQixLQUF4QixHQUFnQyxZQUFZO0FBQzFDLFFBQUksS0FBSy9xQixFQUFMLENBQVF1RSxPQUFSLENBQWdCbU0sUUFBaEIsSUFBNEIsVUFBNUIsS0FBMkMsQ0FBQ3JmLE1BQUQsSUFBVzBELFNBQVMsTUFBTSxLQUFLbXlELFFBQTFFLENBQUosRUFBeUY7QUFDdkYsVUFBSTtBQUFFLGFBQUtBLFFBQUwsQ0FBY244QixLQUFkO0FBQXdCLE9BQTlCLENBQ0EsT0FBT3I0QixDQUFQLEVBQVUsQ0FBRSxDQUYyRSxDQUUxRTs7QUFDZDtBQUNGLEdBTEQ7O0FBT0FvMEQsZUFBYSxDQUFDNXdELFNBQWQsQ0FBd0I0akQsSUFBeEIsR0FBK0IsWUFBWTtBQUFFLFNBQUtvTixRQUFMLENBQWNwTixJQUFkO0FBQXVCLEdBQXBFOztBQUVBZ04sZUFBYSxDQUFDNXdELFNBQWQsQ0FBd0Jna0QsYUFBeEIsR0FBd0MsWUFBWTtBQUNsRCxTQUFLNzlCLE9BQUwsQ0FBYWhwQixLQUFiLENBQW1CbXJCLEdBQW5CLEdBQXlCLEtBQUtuQyxPQUFMLENBQWFocEIsS0FBYixDQUFtQmlQLElBQW5CLEdBQTBCLENBQW5EO0FBQ0QsR0FGRDs7QUFJQXdrRCxlQUFhLENBQUM1d0QsU0FBZCxDQUF3Qm8xQixhQUF4QixHQUF3QyxZQUFZO0FBQUUsU0FBS3k4QixRQUFMO0FBQWtCLEdBQXhFLENBN3VTbUIsQ0ErdVNuQjtBQUNBOzs7QUFDQWpCLGVBQWEsQ0FBQzV3RCxTQUFkLENBQXdCNnhELFFBQXhCLEdBQW1DLFlBQVk7QUFDM0MsUUFBSXJqQixNQUFNLEdBQUcsSUFBYjs7QUFFRixRQUFJLEtBQUtzaUIsV0FBVCxFQUFzQjtBQUFFO0FBQVE7O0FBQ2hDLFNBQUt6RSxPQUFMLENBQWExcUQsR0FBYixDQUFpQixLQUFLbUksRUFBTCxDQUFRdUUsT0FBUixDQUFnQisvQyxZQUFqQyxFQUErQyxZQUFZO0FBQ3pENWYsWUFBTSxDQUFDMmYsSUFBUDs7QUFDQSxVQUFJM2YsTUFBTSxDQUFDMWtDLEVBQVAsQ0FBVWtGLEtBQVYsQ0FBZ0JtbEIsT0FBcEIsRUFBNkI7QUFBRXFhLGNBQU0sQ0FBQ3FqQixRQUFQO0FBQW9CO0FBQ3BELEtBSEQ7QUFJRCxHQVJELENBanZTbUIsQ0EydlNuQjtBQUNBO0FBQ0E7OztBQUNBakIsZUFBYSxDQUFDNXdELFNBQWQsQ0FBd0JpeEQsUUFBeEIsR0FBbUMsWUFBWTtBQUM3QyxRQUFJYSxNQUFNLEdBQUcsS0FBYjtBQUFBLFFBQW9CdHhDLEtBQUssR0FBRyxJQUE1QjtBQUNBQSxTQUFLLENBQUNzd0MsV0FBTixHQUFvQixJQUFwQjs7QUFDQSxhQUFTbDJDLENBQVQsR0FBYTtBQUNYLFVBQUk2YixPQUFPLEdBQUdqVyxLQUFLLENBQUMydEMsSUFBTixFQUFkOztBQUNBLFVBQUksQ0FBQzEzQixPQUFELElBQVksQ0FBQ3E3QixNQUFqQixFQUF5QjtBQUFDQSxjQUFNLEdBQUcsSUFBVDtBQUFldHhDLGFBQUssQ0FBQzZyQyxPQUFOLENBQWMxcUQsR0FBZCxDQUFrQixFQUFsQixFQUFzQmlaLENBQXRCO0FBQTBCLE9BQW5FLE1BQ0s7QUFBQzRGLGFBQUssQ0FBQ3N3QyxXQUFOLEdBQW9CLEtBQXBCO0FBQTJCdHdDLGFBQUssQ0FBQ3F4QyxRQUFOO0FBQWtCO0FBQ3BEOztBQUNEcnhDLFNBQUssQ0FBQzZyQyxPQUFOLENBQWMxcUQsR0FBZCxDQUFrQixFQUFsQixFQUFzQmlaLENBQXRCO0FBQ0QsR0FURCxDQTl2U21CLENBeXdTbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQWcyQyxlQUFhLENBQUM1d0QsU0FBZCxDQUF3Qm11RCxJQUF4QixHQUErQixZQUFZO0FBQ3ZDLFFBQUkzZixNQUFNLEdBQUcsSUFBYjtBQUVGLFFBQUkxa0MsRUFBRSxHQUFHLEtBQUtBLEVBQWQ7QUFBQSxRQUFrQjBXLEtBQUssR0FBRyxLQUFLd3dDLFFBQS9CO0FBQUEsUUFBeUNILFNBQVMsR0FBRyxLQUFLQSxTQUExRCxDQUh5QyxDQUl6QztBQUNBO0FBQ0E7QUFDQTs7QUFDQSxRQUFJLEtBQUtlLGtCQUFMLElBQTJCLENBQUM5bkQsRUFBRSxDQUFDa0YsS0FBSCxDQUFTbWxCLE9BQXJDLElBQ0N4bkIsWUFBWSxDQUFDNlQsS0FBRCxDQUFaLElBQXVCLENBQUNxd0MsU0FBeEIsSUFBcUMsQ0FBQyxLQUFLdkUsU0FENUMsSUFFQXhpRCxFQUFFLENBQUMwcUMsVUFBSCxFQUZBLElBRW1CMXFDLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBV281QyxZQUY5QixJQUU4QzM5QyxFQUFFLENBQUNrRixLQUFILENBQVMrdUMsTUFGM0QsRUFHRTtBQUFFLGFBQU8sS0FBUDtBQUFjOztBQUVsQixRQUFJaDFDLElBQUksR0FBR3lYLEtBQUssQ0FBQzlnQixLQUFqQixDQWJ5QyxDQWN6Qzs7QUFDQSxRQUFJcUosSUFBSSxJQUFJOG5ELFNBQVIsSUFBcUIsQ0FBQy9tRCxFQUFFLENBQUMrNUIsaUJBQUgsRUFBMUIsRUFBa0Q7QUFBRSxhQUFPLEtBQVA7QUFBYyxLQWZ6QixDQWdCekM7QUFDQTtBQUNBOzs7QUFDQSxRQUFJenBDLEVBQUUsSUFBSUMsVUFBVSxJQUFJLENBQXBCLElBQXlCLEtBQUtzUyxZQUFMLEtBQXNCNUQsSUFBL0MsSUFDQTNOLEdBQUcsSUFBSSxrQkFBa0JyQixJQUFsQixDQUF1QmdQLElBQXZCLENBRFgsRUFDeUM7QUFDdkNlLFFBQUUsQ0FBQ29NLE9BQUgsQ0FBV3NLLEtBQVgsQ0FBaUIyVSxLQUFqQjtBQUNBLGFBQU8sS0FBUDtBQUNEOztBQUVELFFBQUlyckIsRUFBRSxDQUFDd0gsR0FBSCxDQUFPaWdCLEdBQVAsSUFBY3puQixFQUFFLENBQUNvTSxPQUFILENBQVdnZixpQkFBN0IsRUFBZ0Q7QUFDOUMsVUFBSTNqQixLQUFLLEdBQUd4SSxJQUFJLENBQUNwRSxVQUFMLENBQWdCLENBQWhCLENBQVo7O0FBQ0EsVUFBSTRNLEtBQUssSUFBSSxNQUFULElBQW1CLENBQUNzL0MsU0FBeEIsRUFBbUM7QUFBRUEsaUJBQVMsR0FBRyxRQUFaO0FBQXVCOztBQUM1RCxVQUFJdC9DLEtBQUssSUFBSSxNQUFiLEVBQXFCO0FBQUUsYUFBSzRqQixLQUFMO0FBQWMsZUFBTyxLQUFLcnJCLEVBQUwsQ0FBUTZ5QyxXQUFSLENBQW9CLE1BQXBCLENBQVA7QUFBb0M7QUFDMUUsS0E3QndDLENBOEJ6Qzs7O0FBQ0EsUUFBSW9WLElBQUksR0FBRyxDQUFYO0FBQUEsUUFBY3ZsRCxDQUFDLEdBQUc1SixJQUFJLENBQUNDLEdBQUwsQ0FBU2d1RCxTQUFTLENBQUN2MEQsTUFBbkIsRUFBMkJ5TSxJQUFJLENBQUN6TSxNQUFoQyxDQUFsQjs7QUFDQSxXQUFPeTFELElBQUksR0FBR3ZsRCxDQUFQLElBQVlxa0QsU0FBUyxDQUFDbHNELFVBQVYsQ0FBcUJvdEQsSUFBckIsS0FBOEJocEQsSUFBSSxDQUFDcEUsVUFBTCxDQUFnQm90RCxJQUFoQixDQUFqRCxFQUF3RTtBQUFFLFFBQUVBLElBQUY7QUFBUzs7QUFFbkZuMEIsV0FBTyxDQUFDOXpCLEVBQUQsRUFBSyxZQUFZO0FBQ3RCNjhDLG9CQUFjLENBQUM3OEMsRUFBRCxFQUFLZixJQUFJLENBQUMzTSxLQUFMLENBQVcyMUQsSUFBWCxDQUFMLEVBQXVCbEIsU0FBUyxDQUFDdjBELE1BQVYsR0FBbUJ5MUQsSUFBMUMsRUFDQyxJQURELEVBQ092akIsTUFBTSxDQUFDOGQsU0FBUCxHQUFtQixVQUFuQixHQUFnQyxJQUR2QyxDQUFkLENBRHNCLENBSXRCOztBQUNBLFVBQUl2akQsSUFBSSxDQUFDek0sTUFBTCxHQUFjLElBQWQsSUFBc0J5TSxJQUFJLENBQUM3SCxPQUFMLENBQWEsSUFBYixJQUFxQixDQUFDLENBQWhELEVBQW1EO0FBQUVzZixhQUFLLENBQUM5Z0IsS0FBTixHQUFjOHVDLE1BQU0sQ0FBQ3FpQixTQUFQLEdBQW1CLEVBQWpDO0FBQXNDLE9BQTNGLE1BQ0s7QUFBRXJpQixjQUFNLENBQUNxaUIsU0FBUCxHQUFtQjluRCxJQUFuQjtBQUEwQjs7QUFFakMsVUFBSXlsQyxNQUFNLENBQUM4ZCxTQUFYLEVBQXNCO0FBQ3BCOWQsY0FBTSxDQUFDOGQsU0FBUCxDQUFpQjV1RCxLQUFqQixDQUF1Qmk5QixLQUF2QjtBQUNBNlQsY0FBTSxDQUFDOGQsU0FBUCxDQUFpQjV1RCxLQUFqQixHQUF5Qm9NLEVBQUUsQ0FBQ29sQyxRQUFILENBQVlWLE1BQU0sQ0FBQzhkLFNBQVAsQ0FBaUIxdUQsS0FBN0IsRUFBb0NrTSxFQUFFLENBQUNndUIsU0FBSCxDQUFhLElBQWIsQ0FBcEMsRUFDVTtBQUFDNTdCLG1CQUFTLEVBQUU7QUFBWixTQURWLENBQXpCO0FBRUQ7QUFDRixLQWJNLENBQVA7QUFjQSxXQUFPLElBQVA7QUFDRCxHQWpERDs7QUFtREEwMEQsZUFBYSxDQUFDNXdELFNBQWQsQ0FBd0J1OUMsWUFBeEIsR0FBdUMsWUFBWTtBQUNqRCxRQUFJLEtBQUt1VCxXQUFMLElBQW9CLEtBQUszQyxJQUFMLEVBQXhCLEVBQXFDO0FBQUUsV0FBSzJDLFdBQUwsR0FBbUIsS0FBbkI7QUFBMkI7QUFDbkUsR0FGRDs7QUFJQUYsZUFBYSxDQUFDNXdELFNBQWQsQ0FBd0IyK0MsVUFBeEIsR0FBcUMsWUFBWTtBQUMvQyxRQUFJdmtELEVBQUUsSUFBSUMsVUFBVSxJQUFJLENBQXhCLEVBQTJCO0FBQUUsV0FBS3NTLFlBQUwsR0FBb0IsSUFBcEI7QUFBMkI7O0FBQ3hELFNBQUtza0QsUUFBTDtBQUNELEdBSEQ7O0FBS0FMLGVBQWEsQ0FBQzV3RCxTQUFkLENBQXdCMi9DLGFBQXhCLEdBQXdDLFVBQVVuakQsQ0FBVixFQUFhO0FBQ25ELFFBQUlna0IsS0FBSyxHQUFHLElBQVo7QUFBQSxRQUFrQjFXLEVBQUUsR0FBRzBXLEtBQUssQ0FBQzFXLEVBQTdCO0FBQUEsUUFBaUNvTSxPQUFPLEdBQUdwTSxFQUFFLENBQUNvTSxPQUE5QztBQUFBLFFBQXVEcEosRUFBRSxHQUFHMFQsS0FBSyxDQUFDd3dDLFFBQWxFOztBQUNBLFFBQUl4d0MsS0FBSyxDQUFDb3hDLGtCQUFWLEVBQThCO0FBQUVweEMsV0FBSyxDQUFDb3hDLGtCQUFOO0FBQTZCOztBQUM3RCxRQUFJbnZELEdBQUcsR0FBRzhzQixZQUFZLENBQUN6bEIsRUFBRCxFQUFLdE4sQ0FBTCxDQUF0QjtBQUFBLFFBQStCbTZCLFNBQVMsR0FBR3pnQixPQUFPLENBQUNzUixRQUFSLENBQWlCcUUsU0FBNUQ7O0FBQ0EsUUFBSSxDQUFDcHBCLEdBQUQsSUFBUTlILE1BQVosRUFBb0I7QUFBRTtBQUFRLEtBSnFCLENBSXBCO0FBRS9CO0FBQ0E7OztBQUNBLFFBQUl3NkIsS0FBSyxHQUFHcnJCLEVBQUUsQ0FBQ3VFLE9BQUgsQ0FBVzJqRCwyQkFBdkI7O0FBQ0EsUUFBSTc4QixLQUFLLElBQUlyckIsRUFBRSxDQUFDd0gsR0FBSCxDQUFPaWdCLEdBQVAsQ0FBVzl5QixRQUFYLENBQW9CZ0UsR0FBcEIsS0FBNEIsQ0FBQyxDQUExQyxFQUNFO0FBQUVvN0IsZUFBUyxDQUFDL3pCLEVBQUQsRUFBS3kvQixZQUFMLENBQVQsQ0FBNEJ6L0IsRUFBRSxDQUFDd0gsR0FBL0IsRUFBb0M4eUIsZUFBZSxDQUFDM2hDLEdBQUQsQ0FBbkQsRUFBMERQLGNBQTFEO0FBQTRFOztBQUVoRixRQUFJK3ZELE1BQU0sR0FBR25sRCxFQUFFLENBQUMzUCxLQUFILENBQVNFLE9BQXRCO0FBQUEsUUFBK0I2MEQsYUFBYSxHQUFHMXhDLEtBQUssQ0FBQzJGLE9BQU4sQ0FBY2hwQixLQUFkLENBQW9CRSxPQUFuRTtBQUNBLFFBQUk4MEQsVUFBVSxHQUFHM3hDLEtBQUssQ0FBQzJGLE9BQU4sQ0FBY2lzQyxZQUFkLENBQTJCbG1ELHFCQUEzQixFQUFqQjtBQUNBc1UsU0FBSyxDQUFDMkYsT0FBTixDQUFjaHBCLEtBQWQsQ0FBb0JFLE9BQXBCLEdBQThCLGtCQUE5QjtBQUNBeVAsTUFBRSxDQUFDM1AsS0FBSCxDQUFTRSxPQUFULEdBQW1CLGlFQUFpRWIsQ0FBQyxDQUFDb3pCLE9BQUYsR0FBWXVpQyxVQUFVLENBQUM3cEMsR0FBdkIsR0FBNkIsQ0FBOUYsSUFBbUcsWUFBbkcsSUFBbUg5ckIsQ0FBQyxDQUFDbXpCLE9BQUYsR0FBWXdpQyxVQUFVLENBQUMvbEQsSUFBdkIsR0FBOEIsQ0FBakosSUFBc0osd0NBQXRKLElBQWtNaFMsRUFBRSxHQUFHLDBCQUFILEdBQWdDLGFBQXBPLElBQXFQLG1IQUF4UTtBQUNBLFFBQUlpNEQsVUFBSjs7QUFDQSxRQUFJNzNELE1BQUosRUFBWTtBQUFFNjNELGdCQUFVLEdBQUd6bEQsTUFBTSxDQUFDMGxELE9BQXBCO0FBQThCLEtBakJPLENBaUJOOzs7QUFDN0NwOEMsV0FBTyxDQUFDc0ssS0FBUixDQUFjcVUsS0FBZDs7QUFDQSxRQUFJcjZCLE1BQUosRUFBWTtBQUFFb1MsWUFBTSxDQUFDODlDLFFBQVAsQ0FBZ0IsSUFBaEIsRUFBc0IySCxVQUF0QjtBQUFvQzs7QUFDbERuOEMsV0FBTyxDQUFDc0ssS0FBUixDQUFjMlUsS0FBZCxHQXBCbUQsQ0FxQm5EOztBQUNBLFFBQUksQ0FBQ3JyQixFQUFFLENBQUMrNUIsaUJBQUgsRUFBTCxFQUE2QjtBQUFFLzJCLFFBQUUsQ0FBQ3BOLEtBQUgsR0FBVzhnQixLQUFLLENBQUNxd0MsU0FBTixHQUFrQixHQUE3QjtBQUFtQzs7QUFDbEVyd0MsU0FBSyxDQUFDb3hDLGtCQUFOLEdBQTJCVyxNQUEzQjtBQUNBcjhDLFdBQU8sQ0FBQ2dmLGlCQUFSLEdBQTRCcHJCLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT2lnQixHQUFuQztBQUNBMXZCLGdCQUFZLENBQUNxVSxPQUFPLENBQUNzOEMsa0JBQVQsQ0FBWixDQXpCbUQsQ0EyQm5EO0FBQ0E7QUFDQTs7QUFDQSxhQUFTQyxvQkFBVCxHQUFnQztBQUM5QixVQUFJM2xELEVBQUUsQ0FBQ3ROLGNBQUgsSUFBcUIsSUFBekIsRUFBK0I7QUFDN0IsWUFBSSsxQyxRQUFRLEdBQUd6ckMsRUFBRSxDQUFDKzVCLGlCQUFILEVBQWY7QUFDQSxZQUFJNnVCLE1BQU0sR0FBRyxZQUFZbmQsUUFBUSxHQUFHem9DLEVBQUUsQ0FBQ3BOLEtBQU4sR0FBYyxFQUFsQyxDQUFiO0FBQ0FvTixVQUFFLENBQUNwTixLQUFILEdBQVcsUUFBWCxDQUg2QixDQUdSOztBQUNyQm9OLFVBQUUsQ0FBQ3BOLEtBQUgsR0FBV2d6RCxNQUFYO0FBQ0FseUMsYUFBSyxDQUFDcXdDLFNBQU4sR0FBa0J0YixRQUFRLEdBQUcsRUFBSCxHQUFRLFFBQWxDO0FBQ0F6b0MsVUFBRSxDQUFDdE4sY0FBSCxHQUFvQixDQUFwQjtBQUF1QnNOLFVBQUUsQ0FBQ3JOLFlBQUgsR0FBa0JpekQsTUFBTSxDQUFDcDJELE1BQXpCLENBTk0sQ0FPN0I7QUFDQTs7QUFDQTRaLGVBQU8sQ0FBQ2dmLGlCQUFSLEdBQTRCcHJCLEVBQUUsQ0FBQ3dILEdBQUgsQ0FBT2lnQixHQUFuQztBQUNEO0FBQ0Y7O0FBQ0QsYUFBU2doQyxNQUFULEdBQWtCO0FBQ2hCLFVBQUkveEMsS0FBSyxDQUFDb3hDLGtCQUFOLElBQTRCVyxNQUFoQyxFQUF3QztBQUFFO0FBQVE7O0FBQ2xEL3hDLFdBQUssQ0FBQ294QyxrQkFBTixHQUEyQixLQUEzQjtBQUNBcHhDLFdBQUssQ0FBQzJGLE9BQU4sQ0FBY2hwQixLQUFkLENBQW9CRSxPQUFwQixHQUE4QjYwRCxhQUE5QjtBQUNBcGxELFFBQUUsQ0FBQzNQLEtBQUgsQ0FBU0UsT0FBVCxHQUFtQjQwRCxNQUFuQjs7QUFDQSxVQUFJNzNELEVBQUUsSUFBSUMsVUFBVSxHQUFHLENBQXZCLEVBQTBCO0FBQUU2YixlQUFPLENBQUN3aUIsVUFBUixDQUFtQkosWUFBbkIsQ0FBZ0NwaUIsT0FBTyxDQUFDc1IsUUFBUixDQUFpQnFFLFNBQWpCLEdBQTZCOEssU0FBN0Q7QUFBMEUsT0FMdEYsQ0FPaEI7OztBQUNBLFVBQUk3cEIsRUFBRSxDQUFDdE4sY0FBSCxJQUFxQixJQUF6QixFQUErQjtBQUM3QixZQUFJLENBQUNwRixFQUFELElBQVFBLEVBQUUsSUFBSUMsVUFBVSxHQUFHLENBQS9CLEVBQW1DO0FBQUVvNEQsOEJBQW9CO0FBQUs7O0FBQzlELFlBQUlsMUQsQ0FBQyxHQUFHLENBQVI7QUFBQSxZQUFXNHdELElBQUksR0FBRyxTQUFQQSxJQUFPLEdBQVk7QUFDNUIsY0FBSWo0QyxPQUFPLENBQUNnZixpQkFBUixJQUE2QnByQixFQUFFLENBQUN3SCxHQUFILENBQU9pZ0IsR0FBcEMsSUFBMkN6a0IsRUFBRSxDQUFDdE4sY0FBSCxJQUFxQixDQUFoRSxJQUNBc04sRUFBRSxDQUFDck4sWUFBSCxHQUFrQixDQURsQixJQUN1QitnQixLQUFLLENBQUNxd0MsU0FBTixJQUFtQixRQUQ5QyxFQUN3RDtBQUN0RGh6QixxQkFBUyxDQUFDL3pCLEVBQUQsRUFBS3FoQyxTQUFMLENBQVQsQ0FBeUJyaEMsRUFBekI7QUFDRCxXQUhELE1BR08sSUFBSXZNLENBQUMsS0FBSyxFQUFWLEVBQWM7QUFDbkIyWSxtQkFBTyxDQUFDczhDLGtCQUFSLEdBQTZCOXdELFVBQVUsQ0FBQ3lzRCxJQUFELEVBQU8sR0FBUCxDQUF2QztBQUNELFdBRk0sTUFFQTtBQUNMajRDLG1CQUFPLENBQUNnZixpQkFBUixHQUE0QixJQUE1QjtBQUNBaGYsbUJBQU8sQ0FBQ3NLLEtBQVIsQ0FBYzJVLEtBQWQ7QUFDRDtBQUNGLFNBVkQ7O0FBV0FqZixlQUFPLENBQUNzOEMsa0JBQVIsR0FBNkI5d0QsVUFBVSxDQUFDeXNELElBQUQsRUFBTyxHQUFQLENBQXZDO0FBQ0Q7QUFDRjs7QUFFRCxRQUFJL3pELEVBQUUsSUFBSUMsVUFBVSxJQUFJLENBQXhCLEVBQTJCO0FBQUVvNEQsMEJBQW9CO0FBQUs7O0FBQ3RELFFBQUk5MkQsaUJBQUosRUFBdUI7QUFDckJxUCxZQUFNLENBQUN4TyxDQUFELENBQU47O0FBQ0EsVUFBSW0yRCxPQUFPLEdBQUcsU0FBVkEsT0FBVSxHQUFZO0FBQ3hCbnBELFdBQUcsQ0FBQ29ELE1BQUQsRUFBUyxTQUFULEVBQW9CK2xELE9BQXBCLENBQUg7QUFDQWp4RCxrQkFBVSxDQUFDNndELE1BQUQsRUFBUyxFQUFULENBQVY7QUFDRCxPQUhEOztBQUlBdHBELFFBQUUsQ0FBQzJELE1BQUQsRUFBUyxTQUFULEVBQW9CK2xELE9BQXBCLENBQUY7QUFDRCxLQVBELE1BT087QUFDTGp4RCxnQkFBVSxDQUFDNndELE1BQUQsRUFBUyxFQUFULENBQVY7QUFDRDtBQUNGLEdBL0VEOztBQWlGQTNCLGVBQWEsQ0FBQzV3RCxTQUFkLENBQXdCNmpELGVBQXhCLEdBQTBDLFVBQVUzMEMsR0FBVixFQUFlO0FBQ3ZELFFBQUksQ0FBQ0EsR0FBTCxFQUFVO0FBQUUsV0FBS2ltQixLQUFMO0FBQWU7O0FBQzNCLFNBQUs2N0IsUUFBTCxDQUFjNEIsUUFBZCxHQUF5QjFqRCxHQUFHLElBQUksVUFBaEM7QUFDQSxTQUFLOGhELFFBQUwsQ0FBY3gyQyxRQUFkLEdBQXlCLENBQUMsQ0FBQ3RMLEdBQTNCO0FBQ0QsR0FKRDs7QUFNQTBoRCxlQUFhLENBQUM1d0QsU0FBZCxDQUF3QjBnQixhQUF4QixHQUF3QyxZQUFZLENBQUUsQ0FBdEQ7O0FBRUFrd0MsZUFBYSxDQUFDNXdELFNBQWQsQ0FBd0J5Z0IscUJBQXhCLEdBQWdELEtBQWhEOztBQUVBLFdBQVNveUMsWUFBVCxDQUFzQjdCLFFBQXRCLEVBQWdDM2lELE9BQWhDLEVBQXlDO0FBQ3ZDQSxXQUFPLEdBQUdBLE9BQU8sR0FBR2pPLE9BQU8sQ0FBQ2lPLE9BQUQsQ0FBVixHQUFzQixFQUF2QztBQUNBQSxXQUFPLENBQUMzTyxLQUFSLEdBQWdCc3hELFFBQVEsQ0FBQ3R4RCxLQUF6Qjs7QUFDQSxRQUFJLENBQUMyTyxPQUFPLENBQUN5a0QsUUFBVCxJQUFxQjlCLFFBQVEsQ0FBQ3gzQixRQUFsQyxFQUNFO0FBQUVuckIsYUFBTyxDQUFDeWtELFFBQVIsR0FBbUI5QixRQUFRLENBQUN4M0IsUUFBNUI7QUFBdUM7O0FBQzNDLFFBQUksQ0FBQ25yQixPQUFPLENBQUMwa0QsV0FBVCxJQUF3Qi9CLFFBQVEsQ0FBQytCLFdBQXJDLEVBQ0U7QUFBRTFrRCxhQUFPLENBQUMwa0QsV0FBUixHQUFzQi9CLFFBQVEsQ0FBQytCLFdBQS9CO0FBQTZDLEtBTlYsQ0FPdkM7QUFDQTs7O0FBQ0EsUUFBSTFrRCxPQUFPLENBQUN3MkMsU0FBUixJQUFxQixJQUF6QixFQUErQjtBQUM3QixVQUFJbndCLFFBQVEsR0FBRzcxQixTQUFTLEVBQXhCO0FBQ0F3UCxhQUFPLENBQUN3MkMsU0FBUixHQUFvQm53QixRQUFRLElBQUlzOEIsUUFBWixJQUNsQkEsUUFBUSxDQUFDMXFDLFlBQVQsQ0FBc0IsV0FBdEIsS0FBc0MsSUFBdEMsSUFBOENvTyxRQUFRLElBQUlwNkIsUUFBUSxDQUFDNEQsSUFEckU7QUFFRDs7QUFFRCxhQUFTbVcsSUFBVCxHQUFnQjtBQUFDMjhDLGNBQVEsQ0FBQ3R4RCxLQUFULEdBQWlCb0ssRUFBRSxDQUFDMm1DLFFBQUgsRUFBakI7QUFBZ0M7O0FBRWpELFFBQUl1aUIsVUFBSjs7QUFDQSxRQUFJaEMsUUFBUSxDQUFDaUMsSUFBYixFQUFtQjtBQUNqQmhxRCxRQUFFLENBQUMrbkQsUUFBUSxDQUFDaUMsSUFBVixFQUFnQixRQUFoQixFQUEwQjUrQyxJQUExQixDQUFGLENBRGlCLENBRWpCOztBQUNBLFVBQUksQ0FBQ2hHLE9BQU8sQ0FBQzZrRCxzQkFBYixFQUFxQztBQUNuQyxZQUFJRCxJQUFJLEdBQUdqQyxRQUFRLENBQUNpQyxJQUFwQjtBQUNBRCxrQkFBVSxHQUFHQyxJQUFJLENBQUNFLE1BQWxCOztBQUNBLFlBQUk7QUFDRixjQUFJQyxhQUFhLEdBQUdILElBQUksQ0FBQ0UsTUFBTCxHQUFjLFlBQVk7QUFDNUM5K0MsZ0JBQUk7QUFDSjQrQyxnQkFBSSxDQUFDRSxNQUFMLEdBQWNILFVBQWQ7QUFDQUMsZ0JBQUksQ0FBQ0UsTUFBTDtBQUNBRixnQkFBSSxDQUFDRSxNQUFMLEdBQWNDLGFBQWQ7QUFDRCxXQUxEO0FBTUQsU0FQRCxDQU9FLE9BQU01MkQsQ0FBTixFQUFTLENBQUU7QUFDZDtBQUNGOztBQUVENlIsV0FBTyxDQUFDMDJDLFVBQVIsR0FBcUIsVUFBVWo3QyxFQUFWLEVBQWM7QUFDakNBLFFBQUUsQ0FBQ3VLLElBQUgsR0FBVUEsSUFBVjs7QUFDQXZLLFFBQUUsQ0FBQ3VwRCxXQUFILEdBQWlCLFlBQVk7QUFBRSxlQUFPckMsUUFBUDtBQUFrQixPQUFqRDs7QUFDQWxuRCxRQUFFLENBQUN3cEQsVUFBSCxHQUFnQixZQUFZO0FBQzFCeHBELFVBQUUsQ0FBQ3dwRCxVQUFILEdBQWdCbHNDLEtBQWhCLENBRDBCLENBQ0g7O0FBQ3ZCL1MsWUFBSTtBQUNKMjhDLGdCQUFRLENBQUMzeUQsVUFBVCxDQUFvQjFCLFdBQXBCLENBQWdDbU4sRUFBRSxDQUFDbWhELGlCQUFILEVBQWhDO0FBQ0ErRixnQkFBUSxDQUFDN3pELEtBQVQsQ0FBZStZLE9BQWYsR0FBeUIsRUFBekI7O0FBQ0EsWUFBSTg2QyxRQUFRLENBQUNpQyxJQUFiLEVBQW1CO0FBQ2pCenBELGFBQUcsQ0FBQ3duRCxRQUFRLENBQUNpQyxJQUFWLEVBQWdCLFFBQWhCLEVBQTBCNStDLElBQTFCLENBQUg7O0FBQ0EsY0FBSSxDQUFDaEcsT0FBTyxDQUFDNmtELHNCQUFULElBQW1DLE9BQU9sQyxRQUFRLENBQUNpQyxJQUFULENBQWNFLE1BQXJCLElBQStCLFVBQXRFLEVBQ0U7QUFBRW5DLG9CQUFRLENBQUNpQyxJQUFULENBQWNFLE1BQWQsR0FBdUJILFVBQXZCO0FBQW9DO0FBQ3pDO0FBQ0YsT0FWRDtBQVdELEtBZEQ7O0FBZ0JBaEMsWUFBUSxDQUFDN3pELEtBQVQsQ0FBZStZLE9BQWYsR0FBeUIsTUFBekI7QUFDQSxRQUFJcE0sRUFBRSxHQUFHOHBDLFVBQVUsQ0FBQyxVQUFVNTNDLElBQVYsRUFBZ0I7QUFBRSxhQUFPZzFELFFBQVEsQ0FBQzN5RCxVQUFULENBQW9CbWxCLFlBQXBCLENBQWlDeG5CLElBQWpDLEVBQXVDZzFELFFBQVEsQ0FBQ2pzQyxXQUFoRCxDQUFQO0FBQXNFLEtBQXpGLEVBQ2pCMVcsT0FEaUIsQ0FBbkI7QUFFQSxXQUFPdkUsRUFBUDtBQUNEOztBQUVELFdBQVN5cEQsY0FBVCxDQUF3QjNmLFVBQXhCLEVBQW9DO0FBQ2xDQSxjQUFVLENBQUNwcUMsR0FBWCxHQUFpQkEsR0FBakI7QUFDQW9xQyxjQUFVLENBQUMzcUMsRUFBWCxHQUFnQkEsRUFBaEI7QUFDQTJxQyxjQUFVLENBQUM5USxnQkFBWCxHQUE4QkEsZ0JBQTlCO0FBQ0E4USxjQUFVLENBQUN2RCxHQUFYLEdBQWlCQSxHQUFqQjtBQUNBdUQsY0FBVSxDQUFDN0csVUFBWCxHQUF3QnpnQyxjQUF4QjtBQUNBc25DLGNBQVUsQ0FBQ2x6QyxXQUFYLEdBQXlCQSxXQUF6QjtBQUNBa3pDLGNBQVUsQ0FBQ3J4QyxVQUFYLEdBQXdCQSxVQUF4QjtBQUNBcXhDLGNBQVUsQ0FBQ3Z2QyxVQUFYLEdBQXdCSixlQUF4QjtBQUNBMnZDLGNBQVUsQ0FBQzV4QyxJQUFYLEdBQWtCQSxJQUFsQjtBQUNBNHhDLGNBQVUsQ0FBQ2pxQyxNQUFYLEdBQW9CQSxNQUFwQjtBQUNBaXFDLGNBQVUsQ0FBQ3IyQixJQUFYLEdBQWtCQSxJQUFsQjtBQUNBcTJCLGNBQVUsQ0FBQ3ZQLFNBQVgsR0FBdUJBLFNBQXZCO0FBQ0F1UCxjQUFVLENBQUNwWSxjQUFYLEdBQTRCQSxjQUE1QjtBQUNBb1ksY0FBVSxDQUFDNWdDLEdBQVgsR0FBaUJBLEdBQWpCO0FBQ0E0Z0MsY0FBVSxDQUFDNGYsTUFBWCxHQUFvQnZnRCxHQUFwQjtBQUNBMmdDLGNBQVUsQ0FBQ2xtQyxLQUFYLEdBQW1CQSxLQUFuQjtBQUNBa21DLGNBQVUsQ0FBQ2ptQyxTQUFYLEdBQXVCQSxTQUF2QjtBQUNBaW1DLGNBQVUsQ0FBQ3psQyxXQUFYLEdBQXlCQSxXQUF6QjtBQUNBeWxDLGNBQVUsQ0FBQ3hsQyxPQUFYLEdBQXFCQSxPQUFyQjtBQUNBd2xDLGNBQVUsQ0FBQ3BsQyxjQUFYLEdBQTRCQSxjQUE1QjtBQUNBb2xDLGNBQVUsQ0FBQy9rQyxVQUFYLEdBQXdCQSxVQUF4QjtBQUNBK2tDLGNBQVUsQ0FBQzdrQyxTQUFYLEdBQXVCQSxTQUF2QjtBQUNBNmtDLGNBQVUsQ0FBQ3ZrQyxVQUFYLEdBQXdCQSxVQUF4QjtBQUNBdWtDLGNBQVUsQ0FBQ3prQyxTQUFYLEdBQXVCQSxTQUF2QjtBQUNBeWtDLGNBQVUsQ0FBQytGLFFBQVgsR0FBc0JBLFFBQXRCO0FBQ0EvRixjQUFVLENBQUNrRCxNQUFYLEdBQW9CQSxNQUFwQjtBQUNBbEQsY0FBVSxDQUFDMEUsT0FBWCxHQUFxQkEsT0FBckI7QUFDQTFFLGNBQVUsQ0FBQ21FLGFBQVgsR0FBMkJBLGFBQTNCO0FBQ0FuRSxjQUFVLENBQUNnRSxTQUFYLEdBQXVCQSxTQUF2QjtBQUNBaEUsY0FBVSxDQUFDNEQsZUFBWCxHQUE2QkEsZUFBN0I7QUFDQTVELGNBQVUsQ0FBQ3BrQyxZQUFYLEdBQTBCQSxZQUExQjtBQUNBb2tDLGNBQVUsQ0FBQ25FLGdCQUFYLEdBQThCQSxnQkFBOUI7QUFDQW1FLGNBQVUsQ0FBQzlFLFVBQVgsR0FBd0JBLFVBQXhCO0FBQ0E4RSxjQUFVLENBQUN2RixVQUFYLEdBQXdCQSxVQUF4QjtBQUNBdUYsY0FBVSxDQUFDanBDLGdCQUFYLEdBQThCQSxnQkFBOUI7QUFDQWlwQyxjQUFVLENBQUMvb0MsaUJBQVgsR0FBK0JBLGlCQUEvQjtBQUNBK29DLGNBQVUsQ0FBQzVvQyxNQUFYLEdBQW9CQSxNQUFwQjtBQUNBNG9DLGNBQVUsQ0FBQzUwQyxRQUFYLEdBQXNCQSxRQUF0QjtBQUNBNDBDLGNBQVUsQ0FBQ24xQyxRQUFYLEdBQXNCQSxRQUF0QjtBQUNBbTFDLGNBQVUsQ0FBQzczQyxPQUFYLEdBQXFCQSxPQUFyQjtBQUNBNjNDLGNBQVUsQ0FBQ2dELFFBQVgsR0FBc0JBLFFBQXRCO0FBQ0QsR0F6Z1RrQixDQTJnVG5COzs7QUFFQWtNLGVBQWEsQ0FBQ2xQLFVBQUQsQ0FBYjtBQUVBd1Usa0JBQWdCLENBQUN4VSxVQUFELENBQWhCLENBL2dUbUIsQ0FpaFRuQjs7QUFDQSxNQUFJNmYsWUFBWSxHQUFHLGdEQUFnRHAwRCxLQUFoRCxDQUFzRCxHQUF0RCxDQUFuQjs7QUFDQSxPQUFLLElBQUltQixJQUFULElBQWlCNnZDLEdBQUcsQ0FBQ3J3QyxTQUFyQixFQUFnQztBQUFFLFFBQUlxd0MsR0FBRyxDQUFDcndDLFNBQUosQ0FBY1MsY0FBZCxDQUE2QkQsSUFBN0IsS0FBc0NVLE9BQU8sQ0FBQ3V5RCxZQUFELEVBQWVqekQsSUFBZixDQUFQLEdBQThCLENBQXhFLEVBQ2hDO0FBQUVvekMsZ0JBQVUsQ0FBQzV6QyxTQUFYLENBQXFCUSxJQUFyQixJQUE4QixVQUFTa3pELE1BQVQsRUFBaUI7QUFDL0MsZUFBTyxZQUFXO0FBQUMsaUJBQU9BLE1BQU0sQ0FBQ3Z6RCxLQUFQLENBQWEsS0FBS21SLEdBQWxCLEVBQXVCcFIsU0FBdkIsQ0FBUDtBQUF5QyxTQUE1RDtBQUNELE9BRjhCLENBRTVCbXdDLEdBQUcsQ0FBQ3J3QyxTQUFKLENBQWNRLElBQWQsQ0FGNEIsQ0FBN0I7QUFFd0I7QUFBRTs7QUFFOUJpSyxZQUFVLENBQUM0bEMsR0FBRCxDQUFWO0FBQ0F1RCxZQUFVLENBQUM2USxXQUFYLEdBQXlCO0FBQUMsZ0JBQVltTSxhQUFiO0FBQTRCLHVCQUFtQjVFO0FBQS9DLEdBQXpCLENBemhUbUIsQ0EyaFRuQjtBQUNBO0FBQ0E7O0FBQ0FwWSxZQUFVLENBQUNobUMsVUFBWCxHQUF3QixVQUFTQztBQUFJO0FBQWIsSUFBNEI7QUFDbEQsUUFBSSxDQUFDK2xDLFVBQVUsQ0FBQ2dQLFFBQVgsQ0FBb0I5MEMsSUFBckIsSUFBNkJELElBQUksSUFBSSxNQUF6QyxFQUFpRDtBQUFFK2xDLGdCQUFVLENBQUNnUCxRQUFYLENBQW9COTBDLElBQXBCLEdBQTJCRCxJQUEzQjtBQUFrQzs7QUFDckZELGNBQVUsQ0FBQ3pOLEtBQVgsQ0FBaUIsSUFBakIsRUFBdUJELFNBQXZCO0FBQ0QsR0FIRDs7QUFLQTB6QyxZQUFVLENBQUM1bEMsVUFBWCxHQUF3QkEsVUFBeEIsQ0FuaVRtQixDQXFpVG5COztBQUNBNGxDLFlBQVUsQ0FBQ2htQyxVQUFYLENBQXNCLE1BQXRCLEVBQThCLFlBQVk7QUFBRSxXQUFRO0FBQUNnSixXQUFLLEVBQUUsZUFBVUosTUFBVixFQUFrQjtBQUFFLGVBQU9BLE1BQU0sQ0FBQ2xHLFNBQVAsRUFBUDtBQUE0QjtBQUF4RCxLQUFSO0FBQXFFLEdBQWpIO0FBQ0FzakMsWUFBVSxDQUFDNWxDLFVBQVgsQ0FBc0IsWUFBdEIsRUFBb0MsTUFBcEMsRUF2aVRtQixDQXlpVG5COztBQUVBNGxDLFlBQVUsQ0FBQytmLGVBQVgsR0FBNkIsVUFBVTlsRCxJQUFWLEVBQWdCK2xELElBQWhCLEVBQXNCO0FBQ2pEaGdCLGNBQVUsQ0FBQzV6QyxTQUFYLENBQXFCNk4sSUFBckIsSUFBNkIrbEQsSUFBN0I7QUFDRCxHQUZEOztBQUdBaGdCLFlBQVUsQ0FBQ2lnQixrQkFBWCxHQUFnQyxVQUFVaG1ELElBQVYsRUFBZ0IrbEQsSUFBaEIsRUFBc0I7QUFDcER2akIsT0FBRyxDQUFDcndDLFNBQUosQ0FBYzZOLElBQWQsSUFBc0IrbEQsSUFBdEI7QUFDRCxHQUZEOztBQUlBaGdCLFlBQVUsQ0FBQ2lmLFlBQVgsR0FBMEJBLFlBQTFCO0FBRUFVLGdCQUFjLENBQUMzZixVQUFELENBQWQ7QUFFQUEsWUFBVSxDQUFDa2dCLE9BQVgsR0FBcUIsUUFBckI7QUFFQSxTQUFPbGdCLFVBQVA7QUFFRCxDQTlqVEEsQ0FBRCIsImZpbGUiOiIuL3Jlc291cmNlcy9qcy9jb2RlbWlycm9yLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29kZU1pcnJvciwgY29weXJpZ2h0IChjKSBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCBvdGhlcnNcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIGFuIE1JVCBsaWNlbnNlOiBodHRwczovL2NvZGVtaXJyb3IubmV0L0xJQ0VOU0VcblxuLy8gVGhpcyBpcyBDb2RlTWlycm9yIChodHRwczovL2NvZGVtaXJyb3IubmV0KSwgYSBjb2RlIGVkaXRvclxuLy8gaW1wbGVtZW50ZWQgaW4gSmF2YVNjcmlwdCBvbiB0b3Agb2YgdGhlIGJyb3dzZXIncyBET00uXG4vL1xuLy8gWW91IGNhbiBmaW5kIHNvbWUgdGVjaG5pY2FsIGJhY2tncm91bmQgZm9yIHNvbWUgb2YgdGhlIGNvZGUgYmVsb3dcbi8vIGF0IGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYmxvZy8jY20taW50ZXJuYWxzIC5cblxuKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAoZ2xvYmFsID0gZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5Db2RlTWlycm9yID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIEtsdWRnZXMgZm9yIGJ1Z3MgYW5kIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRoYXQgY2FuJ3QgYmUgZmVhdHVyZVxuICAvLyBkZXRlY3RlZCBhcmUgZW5hYmxlZCBiYXNlZCBvbiB1c2VyQWdlbnQgZXRjIHNuaWZmaW5nLlxuICB2YXIgdXNlckFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgdmFyIHBsYXRmb3JtID0gbmF2aWdhdG9yLnBsYXRmb3JtO1xuXG4gIHZhciBnZWNrbyA9IC9nZWNrb1xcL1xcZC9pLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIGllX3VwdG8xMCA9IC9NU0lFIFxcZC8udGVzdCh1c2VyQWdlbnQpO1xuICB2YXIgaWVfMTF1cCA9IC9UcmlkZW50XFwvKD86WzctOV18XFxkezIsfSlcXC4uKnJ2OihcXGQrKS8uZXhlYyh1c2VyQWdlbnQpO1xuICB2YXIgZWRnZSA9IC9FZGdlXFwvKFxcZCspLy5leGVjKHVzZXJBZ2VudCk7XG4gIHZhciBpZSA9IGllX3VwdG8xMCB8fCBpZV8xMXVwIHx8IGVkZ2U7XG4gIHZhciBpZV92ZXJzaW9uID0gaWUgJiYgKGllX3VwdG8xMCA/IGRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCA2IDogKyhlZGdlIHx8IGllXzExdXApWzFdKTtcbiAgdmFyIHdlYmtpdCA9ICFlZGdlICYmIC9XZWJLaXRcXC8vLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIHF0d2Via2l0ID0gd2Via2l0ICYmIC9RdFxcL1xcZCtcXC5cXGQrLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBjaHJvbWUgPSAhZWRnZSAmJiAvQ2hyb21lXFwvLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBwcmVzdG8gPSAvT3BlcmFcXC8vLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIHNhZmFyaSA9IC9BcHBsZSBDb21wdXRlci8udGVzdChuYXZpZ2F0b3IudmVuZG9yKTtcbiAgdmFyIG1hY19nZU1vdW50YWluTGlvbiA9IC9NYWMgT1MgWCAxXFxkXFxEKFs4LTldfFxcZFxcZClcXEQvLnRlc3QodXNlckFnZW50KTtcbiAgdmFyIHBoYW50b20gPSAvUGhhbnRvbUpTLy50ZXN0KHVzZXJBZ2VudCk7XG5cbiAgdmFyIGlvcyA9IHNhZmFyaSAmJiAoL01vYmlsZVxcL1xcdysvLnRlc3QodXNlckFnZW50KSB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAyKTtcbiAgdmFyIGFuZHJvaWQgPSAvQW5kcm9pZC8udGVzdCh1c2VyQWdlbnQpO1xuICAvLyBUaGlzIGlzIHdvZWZ1bGx5IGluY29tcGxldGUuIFN1Z2dlc3Rpb25zIGZvciBhbHRlcm5hdGl2ZSBtZXRob2RzIHdlbGNvbWUuXG4gIHZhciBtb2JpbGUgPSBpb3MgfHwgYW5kcm9pZCB8fCAvd2ViT1N8QmxhY2tCZXJyeXxPcGVyYSBNaW5pfE9wZXJhIE1vYml8SUVNb2JpbGUvaS50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciBtYWMgPSBpb3MgfHwgL01hYy8udGVzdChwbGF0Zm9ybSk7XG4gIHZhciBjaHJvbWVPUyA9IC9cXGJDck9TXFxiLy50ZXN0KHVzZXJBZ2VudCk7XG4gIHZhciB3aW5kb3dzID0gL3dpbi9pLnRlc3QocGxhdGZvcm0pO1xuXG4gIHZhciBwcmVzdG9fdmVyc2lvbiA9IHByZXN0byAmJiB1c2VyQWdlbnQubWF0Y2goL1ZlcnNpb25cXC8oXFxkKlxcLlxcZCopLyk7XG4gIGlmIChwcmVzdG9fdmVyc2lvbikgeyBwcmVzdG9fdmVyc2lvbiA9IE51bWJlcihwcmVzdG9fdmVyc2lvblsxXSk7IH1cbiAgaWYgKHByZXN0b192ZXJzaW9uICYmIHByZXN0b192ZXJzaW9uID49IDE1KSB7IHByZXN0byA9IGZhbHNlOyB3ZWJraXQgPSB0cnVlOyB9XG4gIC8vIFNvbWUgYnJvd3NlcnMgdXNlIHRoZSB3cm9uZyBldmVudCBwcm9wZXJ0aWVzIHRvIHNpZ25hbCBjbWQvY3RybCBvbiBPUyBYXG4gIHZhciBmbGlwQ3RybENtZCA9IG1hYyAmJiAocXR3ZWJraXQgfHwgcHJlc3RvICYmIChwcmVzdG9fdmVyc2lvbiA9PSBudWxsIHx8IHByZXN0b192ZXJzaW9uIDwgMTIuMTEpKTtcbiAgdmFyIGNhcHR1cmVSaWdodENsaWNrID0gZ2Vja28gfHwgKGllICYmIGllX3ZlcnNpb24gPj0gOSk7XG5cbiAgZnVuY3Rpb24gY2xhc3NUZXN0KGNscykgeyByZXR1cm4gbmV3IFJlZ0V4cChcIihefFxcXFxzKVwiICsgY2xzICsgXCIoPzokfFxcXFxzKVxcXFxzKlwiKSB9XG5cbiAgdmFyIHJtQ2xhc3MgPSBmdW5jdGlvbihub2RlLCBjbHMpIHtcbiAgICB2YXIgY3VycmVudCA9IG5vZGUuY2xhc3NOYW1lO1xuICAgIHZhciBtYXRjaCA9IGNsYXNzVGVzdChjbHMpLmV4ZWMoY3VycmVudCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICB2YXIgYWZ0ZXIgPSBjdXJyZW50LnNsaWNlKG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgIG5vZGUuY2xhc3NOYW1lID0gY3VycmVudC5zbGljZSgwLCBtYXRjaC5pbmRleCkgKyAoYWZ0ZXIgPyBtYXRjaFsxXSArIGFmdGVyIDogXCJcIik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuKGUpIHtcbiAgICBmb3IgKHZhciBjb3VudCA9IGUuY2hpbGROb2Rlcy5sZW5ndGg7IGNvdW50ID4gMDsgLS1jb3VudClcbiAgICAgIHsgZS5yZW1vdmVDaGlsZChlLmZpcnN0Q2hpbGQpOyB9XG4gICAgcmV0dXJuIGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHBhcmVudCwgZSkge1xuICAgIHJldHVybiByZW1vdmVDaGlsZHJlbihwYXJlbnQpLmFwcGVuZENoaWxkKGUpXG4gIH1cblxuICBmdW5jdGlvbiBlbHQodGFnLCBjb250ZW50LCBjbGFzc05hbWUsIHN0eWxlKSB7XG4gICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKGNsYXNzTmFtZSkgeyBlLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTsgfVxuICAgIGlmIChzdHlsZSkgeyBlLnN0eWxlLmNzc1RleHQgPSBzdHlsZTsgfVxuICAgIGlmICh0eXBlb2YgY29udGVudCA9PSBcInN0cmluZ1wiKSB7IGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCkpOyB9XG4gICAgZWxzZSBpZiAoY29udGVudCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnQubGVuZ3RoOyArK2kpIHsgZS5hcHBlbmRDaGlsZChjb250ZW50W2ldKTsgfSB9XG4gICAgcmV0dXJuIGVcbiAgfVxuICAvLyB3cmFwcGVyIGZvciBlbHQsIHdoaWNoIHJlbW92ZXMgdGhlIGVsdCBmcm9tIHRoZSBhY2Nlc3NpYmlsaXR5IHRyZWVcbiAgZnVuY3Rpb24gZWx0UCh0YWcsIGNvbnRlbnQsIGNsYXNzTmFtZSwgc3R5bGUpIHtcbiAgICB2YXIgZSA9IGVsdCh0YWcsIGNvbnRlbnQsIGNsYXNzTmFtZSwgc3R5bGUpO1xuICAgIGUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICByZXR1cm4gZVxuICB9XG5cbiAgdmFyIHJhbmdlO1xuICBpZiAoZG9jdW1lbnQuY3JlYXRlUmFuZ2UpIHsgcmFuZ2UgPSBmdW5jdGlvbihub2RlLCBzdGFydCwgZW5kLCBlbmROb2RlKSB7XG4gICAgdmFyIHIgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHIuc2V0RW5kKGVuZE5vZGUgfHwgbm9kZSwgZW5kKTtcbiAgICByLnNldFN0YXJ0KG5vZGUsIHN0YXJ0KTtcbiAgICByZXR1cm4gclxuICB9OyB9XG4gIGVsc2UgeyByYW5nZSA9IGZ1bmN0aW9uKG5vZGUsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgciA9IGRvY3VtZW50LmJvZHkuY3JlYXRlVGV4dFJhbmdlKCk7XG4gICAgdHJ5IHsgci5tb3ZlVG9FbGVtZW50VGV4dChub2RlLnBhcmVudE5vZGUpOyB9XG4gICAgY2F0Y2goZSkgeyByZXR1cm4gciB9XG4gICAgci5jb2xsYXBzZSh0cnVlKTtcbiAgICByLm1vdmVFbmQoXCJjaGFyYWN0ZXJcIiwgZW5kKTtcbiAgICByLm1vdmVTdGFydChcImNoYXJhY3RlclwiLCBzdGFydCk7XG4gICAgcmV0dXJuIHJcbiAgfTsgfVxuXG4gIGZ1bmN0aW9uIGNvbnRhaW5zKHBhcmVudCwgY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQubm9kZVR5cGUgPT0gMykgLy8gQW5kcm9pZCBicm93c2VyIGFsd2F5cyByZXR1cm5zIGZhbHNlIHdoZW4gY2hpbGQgaXMgYSB0ZXh0bm9kZVxuICAgICAgeyBjaGlsZCA9IGNoaWxkLnBhcmVudE5vZGU7IH1cbiAgICBpZiAocGFyZW50LmNvbnRhaW5zKVxuICAgICAgeyByZXR1cm4gcGFyZW50LmNvbnRhaW5zKGNoaWxkKSB9XG4gICAgZG8ge1xuICAgICAgaWYgKGNoaWxkLm5vZGVUeXBlID09IDExKSB7IGNoaWxkID0gY2hpbGQuaG9zdDsgfVxuICAgICAgaWYgKGNoaWxkID09IHBhcmVudCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlKVxuICB9XG5cbiAgZnVuY3Rpb24gYWN0aXZlRWx0KCkge1xuICAgIC8vIElFIGFuZCBFZGdlIG1heSB0aHJvdyBhbiBcIlVuc3BlY2lmaWVkIEVycm9yXCIgd2hlbiBhY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudC5cbiAgICAvLyBJRSA8IDEwIHdpbGwgdGhyb3cgd2hlbiBhY2Nlc3NlZCB3aGlsZSB0aGUgcGFnZSBpcyBsb2FkaW5nIG9yIGluIGFuIGlmcmFtZS5cbiAgICAvLyBJRSA+IDkgYW5kIEVkZ2Ugd2lsbCB0aHJvdyB3aGVuIGFjY2Vzc2VkIGluIGFuIGlmcmFtZSBpZiBkb2N1bWVudC5ib2R5IGlzIHVuYXZhaWxhYmxlLlxuICAgIHZhciBhY3RpdmVFbGVtZW50O1xuICAgIHRyeSB7XG4gICAgICBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5ib2R5IHx8IG51bGw7XG4gICAgfVxuICAgIHdoaWxlIChhY3RpdmVFbGVtZW50ICYmIGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdCAmJiBhY3RpdmVFbGVtZW50LnNoYWRvd1Jvb3QuYWN0aXZlRWxlbWVudClcbiAgICAgIHsgYWN0aXZlRWxlbWVudCA9IGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50OyB9XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZENsYXNzKG5vZGUsIGNscykge1xuICAgIHZhciBjdXJyZW50ID0gbm9kZS5jbGFzc05hbWU7XG4gICAgaWYgKCFjbGFzc1Rlc3QoY2xzKS50ZXN0KGN1cnJlbnQpKSB7IG5vZGUuY2xhc3NOYW1lICs9IChjdXJyZW50ID8gXCIgXCIgOiBcIlwiKSArIGNsczsgfVxuICB9XG4gIGZ1bmN0aW9uIGpvaW5DbGFzc2VzKGEsIGIpIHtcbiAgICB2YXIgYXMgPSBhLnNwbGl0KFwiIFwiKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFzLmxlbmd0aDsgaSsrKVxuICAgICAgeyBpZiAoYXNbaV0gJiYgIWNsYXNzVGVzdChhc1tpXSkudGVzdChiKSkgeyBiICs9IFwiIFwiICsgYXNbaV07IH0gfVxuICAgIHJldHVybiBiXG4gIH1cblxuICB2YXIgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IG5vZGUuc2VsZWN0KCk7IH07XG4gIGlmIChpb3MpIC8vIE1vYmlsZSBTYWZhcmkgYXBwYXJlbnRseSBoYXMgYSBidWcgd2hlcmUgc2VsZWN0KCkgaXMgYnJva2VuLlxuICAgIHsgc2VsZWN0SW5wdXQgPSBmdW5jdGlvbihub2RlKSB7IG5vZGUuc2VsZWN0aW9uU3RhcnQgPSAwOyBub2RlLnNlbGVjdGlvbkVuZCA9IG5vZGUudmFsdWUubGVuZ3RoOyB9OyB9XG4gIGVsc2UgaWYgKGllKSAvLyBTdXBwcmVzcyBteXN0ZXJpb3VzIElFMTAgZXJyb3JzXG4gICAgeyBzZWxlY3RJbnB1dCA9IGZ1bmN0aW9uKG5vZGUpIHsgdHJ5IHsgbm9kZS5zZWxlY3QoKTsgfSBjYXRjaChfZSkge30gfTsgfVxuXG4gIGZ1bmN0aW9uIGJpbmQoZikge1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gZi5hcHBseShudWxsLCBhcmdzKX1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcHlPYmoob2JqLCB0YXJnZXQsIG92ZXJ3cml0ZSkge1xuICAgIGlmICghdGFyZ2V0KSB7IHRhcmdldCA9IHt9OyB9XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYmopXG4gICAgICB7IGlmIChvYmouaGFzT3duUHJvcGVydHkocHJvcCkgJiYgKG92ZXJ3cml0ZSAhPT0gZmFsc2UgfHwgIXRhcmdldC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkpXG4gICAgICAgIHsgdGFyZ2V0W3Byb3BdID0gb2JqW3Byb3BdOyB9IH1cbiAgICByZXR1cm4gdGFyZ2V0XG4gIH1cblxuICAvLyBDb3VudHMgdGhlIGNvbHVtbiBvZmZzZXQgaW4gYSBzdHJpbmcsIHRha2luZyB0YWJzIGludG8gYWNjb3VudC5cbiAgLy8gVXNlZCBtb3N0bHkgdG8gZmluZCBpbmRlbnRhdGlvbi5cbiAgZnVuY3Rpb24gY291bnRDb2x1bW4oc3RyaW5nLCBlbmQsIHRhYlNpemUsIHN0YXJ0SW5kZXgsIHN0YXJ0VmFsdWUpIHtcbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgIGVuZCA9IHN0cmluZy5zZWFyY2goL1teXFxzXFx1MDBhMF0vKTtcbiAgICAgIGlmIChlbmQgPT0gLTEpIHsgZW5kID0gc3RyaW5nLmxlbmd0aDsgfVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBuID0gc3RhcnRWYWx1ZSB8fCAwOzspIHtcbiAgICAgIHZhciBuZXh0VGFiID0gc3RyaW5nLmluZGV4T2YoXCJcXHRcIiwgaSk7XG4gICAgICBpZiAobmV4dFRhYiA8IDAgfHwgbmV4dFRhYiA+PSBlbmQpXG4gICAgICAgIHsgcmV0dXJuIG4gKyAoZW5kIC0gaSkgfVxuICAgICAgbiArPSBuZXh0VGFiIC0gaTtcbiAgICAgIG4gKz0gdGFiU2l6ZSAtIChuICUgdGFiU2l6ZSk7XG4gICAgICBpID0gbmV4dFRhYiArIDE7XG4gICAgfVxuICB9XG5cbiAgdmFyIERlbGF5ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmlkID0gbnVsbDtcbiAgICB0aGlzLmYgPSBudWxsO1xuICAgIHRoaXMudGltZSA9IDA7XG4gICAgdGhpcy5oYW5kbGVyID0gYmluZCh0aGlzLm9uVGltZW91dCwgdGhpcyk7XG4gIH07XG4gIERlbGF5ZWQucHJvdG90eXBlLm9uVGltZW91dCA9IGZ1bmN0aW9uIChzZWxmKSB7XG4gICAgc2VsZi5pZCA9IDA7XG4gICAgaWYgKHNlbGYudGltZSA8PSArbmV3IERhdGUpIHtcbiAgICAgIHNlbGYuZigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHNlbGYuaGFuZGxlciwgc2VsZi50aW1lIC0gK25ldyBEYXRlKTtcbiAgICB9XG4gIH07XG4gIERlbGF5ZWQucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChtcywgZikge1xuICAgIHRoaXMuZiA9IGY7XG4gICAgdmFyIHRpbWUgPSArbmV3IERhdGUgKyBtcztcbiAgICBpZiAoIXRoaXMuaWQgfHwgdGltZSA8IHRoaXMudGltZSkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuaWQpO1xuICAgICAgdGhpcy5pZCA9IHNldFRpbWVvdXQodGhpcy5oYW5kbGVyLCBtcyk7XG4gICAgICB0aGlzLnRpbWUgPSB0aW1lO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCBlbHQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKVxuICAgICAgeyBpZiAoYXJyYXlbaV0gPT0gZWx0KSB7IHJldHVybiBpIH0gfVxuICAgIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTnVtYmVyIG9mIHBpeGVscyBhZGRlZCB0byBzY3JvbGxlciBhbmQgc2l6ZXIgdG8gaGlkZSBzY3JvbGxiYXJcbiAgdmFyIHNjcm9sbGVyR2FwID0gNTA7XG5cbiAgLy8gUmV0dXJuZWQgb3IgdGhyb3duIGJ5IHZhcmlvdXMgcHJvdG9jb2xzIHRvIHNpZ25hbCAnSSdtIG5vdFxuICAvLyBoYW5kbGluZyB0aGlzJy5cbiAgdmFyIFBhc3MgPSB7dG9TdHJpbmc6IGZ1bmN0aW9uKCl7cmV0dXJuIFwiQ29kZU1pcnJvci5QYXNzXCJ9fTtcblxuICAvLyBSZXVzZWQgb3B0aW9uIG9iamVjdHMgZm9yIHNldFNlbGVjdGlvbiAmIGZyaWVuZHNcbiAgdmFyIHNlbF9kb250U2Nyb2xsID0ge3Njcm9sbDogZmFsc2V9LCBzZWxfbW91c2UgPSB7b3JpZ2luOiBcIiptb3VzZVwifSwgc2VsX21vdmUgPSB7b3JpZ2luOiBcIittb3ZlXCJ9O1xuXG4gIC8vIFRoZSBpbnZlcnNlIG9mIGNvdW50Q29sdW1uIC0tIGZpbmQgdGhlIG9mZnNldCB0aGF0IGNvcnJlc3BvbmRzIHRvXG4gIC8vIGEgcGFydGljdWxhciBjb2x1bW4uXG4gIGZ1bmN0aW9uIGZpbmRDb2x1bW4oc3RyaW5nLCBnb2FsLCB0YWJTaXplKSB7XG4gICAgZm9yICh2YXIgcG9zID0gMCwgY29sID0gMDs7KSB7XG4gICAgICB2YXIgbmV4dFRhYiA9IHN0cmluZy5pbmRleE9mKFwiXFx0XCIsIHBvcyk7XG4gICAgICBpZiAobmV4dFRhYiA9PSAtMSkgeyBuZXh0VGFiID0gc3RyaW5nLmxlbmd0aDsgfVxuICAgICAgdmFyIHNraXBwZWQgPSBuZXh0VGFiIC0gcG9zO1xuICAgICAgaWYgKG5leHRUYWIgPT0gc3RyaW5nLmxlbmd0aCB8fCBjb2wgKyBza2lwcGVkID49IGdvYWwpXG4gICAgICAgIHsgcmV0dXJuIHBvcyArIE1hdGgubWluKHNraXBwZWQsIGdvYWwgLSBjb2wpIH1cbiAgICAgIGNvbCArPSBuZXh0VGFiIC0gcG9zO1xuICAgICAgY29sICs9IHRhYlNpemUgLSAoY29sICUgdGFiU2l6ZSk7XG4gICAgICBwb3MgPSBuZXh0VGFiICsgMTtcbiAgICAgIGlmIChjb2wgPj0gZ29hbCkgeyByZXR1cm4gcG9zIH1cbiAgICB9XG4gIH1cblxuICB2YXIgc3BhY2VTdHJzID0gW1wiXCJdO1xuICBmdW5jdGlvbiBzcGFjZVN0cihuKSB7XG4gICAgd2hpbGUgKHNwYWNlU3Rycy5sZW5ndGggPD0gbilcbiAgICAgIHsgc3BhY2VTdHJzLnB1c2gobHN0KHNwYWNlU3RycykgKyBcIiBcIik7IH1cbiAgICByZXR1cm4gc3BhY2VTdHJzW25dXG4gIH1cblxuICBmdW5jdGlvbiBsc3QoYXJyKSB7IHJldHVybiBhcnJbYXJyLmxlbmd0aC0xXSB9XG5cbiAgZnVuY3Rpb24gbWFwKGFycmF5LCBmKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHsgb3V0W2ldID0gZihhcnJheVtpXSwgaSk7IH1cbiAgICByZXR1cm4gb3V0XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRTb3J0ZWQoYXJyYXksIHZhbHVlLCBzY29yZSkge1xuICAgIHZhciBwb3MgPSAwLCBwcmlvcml0eSA9IHNjb3JlKHZhbHVlKTtcbiAgICB3aGlsZSAocG9zIDwgYXJyYXkubGVuZ3RoICYmIHNjb3JlKGFycmF5W3Bvc10pIDw9IHByaW9yaXR5KSB7IHBvcysrOyB9XG4gICAgYXJyYXkuc3BsaWNlKHBvcywgMCwgdmFsdWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gbm90aGluZygpIHt9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqKGJhc2UsIHByb3BzKSB7XG4gICAgdmFyIGluc3Q7XG4gICAgaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgICAgIGluc3QgPSBPYmplY3QuY3JlYXRlKGJhc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub3RoaW5nLnByb3RvdHlwZSA9IGJhc2U7XG4gICAgICBpbnN0ID0gbmV3IG5vdGhpbmcoKTtcbiAgICB9XG4gICAgaWYgKHByb3BzKSB7IGNvcHlPYmoocHJvcHMsIGluc3QpOyB9XG4gICAgcmV0dXJuIGluc3RcbiAgfVxuXG4gIHZhciBub25BU0NJSVNpbmdsZUNhc2VXb3JkQ2hhciA9IC9bXFx1MDBkZlxcdTA1ODdcXHUwNTkwLVxcdTA1ZjRcXHUwNjAwLVxcdTA2ZmZcXHUzMDQwLVxcdTMwOWZcXHUzMGEwLVxcdTMwZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhYzAwLVxcdWQ3YWZdLztcbiAgZnVuY3Rpb24gaXNXb3JkQ2hhckJhc2ljKGNoKSB7XG4gICAgcmV0dXJuIC9cXHcvLnRlc3QoY2gpIHx8IGNoID4gXCJcXHg4MFwiICYmXG4gICAgICAoY2gudG9VcHBlckNhc2UoKSAhPSBjaC50b0xvd2VyQ2FzZSgpIHx8IG5vbkFTQ0lJU2luZ2xlQ2FzZVdvcmRDaGFyLnRlc3QoY2gpKVxuICB9XG4gIGZ1bmN0aW9uIGlzV29yZENoYXIoY2gsIGhlbHBlcikge1xuICAgIGlmICghaGVscGVyKSB7IHJldHVybiBpc1dvcmRDaGFyQmFzaWMoY2gpIH1cbiAgICBpZiAoaGVscGVyLnNvdXJjZS5pbmRleE9mKFwiXFxcXHdcIikgPiAtMSAmJiBpc1dvcmRDaGFyQmFzaWMoY2gpKSB7IHJldHVybiB0cnVlIH1cbiAgICByZXR1cm4gaGVscGVyLnRlc3QoY2gpXG4gIH1cblxuICBmdW5jdGlvbiBpc0VtcHR5KG9iaikge1xuICAgIGZvciAodmFyIG4gaW4gb2JqKSB7IGlmIChvYmouaGFzT3duUHJvcGVydHkobikgJiYgb2JqW25dKSB7IHJldHVybiBmYWxzZSB9IH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gRXh0ZW5kaW5nIHVuaWNvZGUgY2hhcmFjdGVycy4gQSBzZXJpZXMgb2YgYSBub24tZXh0ZW5kaW5nIGNoYXIgK1xuICAvLyBhbnkgbnVtYmVyIG9mIGV4dGVuZGluZyBjaGFycyBpcyB0cmVhdGVkIGFzIGEgc2luZ2xlIHVuaXQgYXMgZmFyXG4gIC8vIGFzIGVkaXRpbmcgYW5kIG1lYXN1cmluZyBpcyBjb25jZXJuZWQuIFRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QsXG4gIC8vIHNpbmNlIHNvbWUgc2NyaXB0cy9mb250cy9icm93c2VycyBhbHNvIHRyZWF0IG90aGVyIGNvbmZpZ3VyYXRpb25zXG4gIC8vIG9mIGNvZGUgcG9pbnRzIGFzIGEgZ3JvdXAuXG4gIHZhciBleHRlbmRpbmdDaGFycyA9IC9bXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDY0Yi1cXHUwNjVlXFx1MDY3MFxcdTA2ZDYtXFx1MDZkY1xcdTA2ZGUtXFx1MDZlNFxcdTA2ZTdcXHUwNmU4XFx1MDZlYS1cXHUwNmVkXFx1MDcxMVxcdTA3MzAtXFx1MDc0YVxcdTA3YTYtXFx1MDdiMFxcdTA3ZWItXFx1MDdmM1xcdTA4MTYtXFx1MDgxOVxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA5MDAtXFx1MDkwMlxcdTA5M2NcXHUwOTQxLVxcdTA5NDhcXHUwOTRkXFx1MDk1MS1cXHUwOTU1XFx1MDk2MlxcdTA5NjNcXHUwOTgxXFx1MDliY1xcdTA5YmVcXHUwOWMxLVxcdTA5YzRcXHUwOWNkXFx1MDlkN1xcdTA5ZTJcXHUwOWUzXFx1MGEwMVxcdTBhMDJcXHUwYTNjXFx1MGE0MVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTcwXFx1MGE3MVxcdTBhNzVcXHUwYTgxXFx1MGE4MlxcdTBhYmNcXHUwYWMxLVxcdTBhYzVcXHUwYWM3XFx1MGFjOFxcdTBhY2RcXHUwYWUyXFx1MGFlM1xcdTBiMDFcXHUwYjNjXFx1MGIzZVxcdTBiM2ZcXHUwYjQxLVxcdTBiNDRcXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjYyXFx1MGI2M1xcdTBiODJcXHUwYmJlXFx1MGJjMFxcdTBiY2RcXHUwYmQ3XFx1MGMzZS1cXHUwYzQwXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyXFx1MGM2M1xcdTBjYmNcXHUwY2JmXFx1MGNjMlxcdTBjYzZcXHUwY2NjXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMlxcdTBjZTNcXHUwZDNlXFx1MGQ0MS1cXHUwZDQ0XFx1MGQ0ZFxcdTBkNTdcXHUwZDYyXFx1MGQ2M1xcdTBkY2FcXHUwZGNmXFx1MGRkMi1cXHUwZGQ0XFx1MGRkNlxcdTBkZGZcXHUwZTMxXFx1MGUzNC1cXHUwZTNhXFx1MGU0Ny1cXHUwZTRlXFx1MGViMVxcdTBlYjQtXFx1MGViOVxcdTBlYmJcXHUwZWJjXFx1MGVjOC1cXHUwZWNkXFx1MGYxOFxcdTBmMTlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjcxLVxcdTBmN2VcXHUwZjgwLVxcdTBmODRcXHUwZjg2XFx1MGY4N1xcdTBmOTAtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDJkLVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzYVxcdTEwM2RcXHUxMDNlXFx1MTA1OFxcdTEwNTlcXHUxMDVlLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhkXFx1MTA5ZFxcdTEzNWZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdiNy1cXHUxN2JkXFx1MTdjNlxcdTE3YzktXFx1MTdkM1xcdTE3ZGRcXHUxODBiLVxcdTE4MGRcXHUxOGE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNiXFx1MWExN1xcdTFhMThcXHUxYTU2XFx1MWE1OC1cXHUxYTVlXFx1MWE2MFxcdTFhNjJcXHUxYTY1LVxcdTFhNmNcXHUxYTczLVxcdTFhN2NcXHUxYTdmXFx1MWIwMC1cXHUxYjAzXFx1MWIzNFxcdTFiMzYtXFx1MWIzYVxcdTFiM2NcXHUxYjQyXFx1MWI2Yi1cXHUxYjczXFx1MWI4MFxcdTFiODFcXHUxYmEyLVxcdTFiYTVcXHUxYmE4XFx1MWJhOVxcdTFjMmMtXFx1MWMzM1xcdTFjMzZcXHUxYzM3XFx1MWNkMC1cXHUxY2QyXFx1MWNkNC1cXHUxY2UwXFx1MWNlMi1cXHUxY2U4XFx1MWNlZFxcdTFkYzAtXFx1MWRlNlxcdTFkZmQtXFx1MWRmZlxcdTIwMGNcXHUyMDBkXFx1MjBkMC1cXHUyMGYwXFx1MmNlZi1cXHUyY2YxXFx1MmRlMC1cXHUyZGZmXFx1MzAyYS1cXHUzMDJmXFx1MzA5OVxcdTMwOWFcXHVhNjZmLVxcdWE2NzJcXHVhNjdjXFx1YTY3ZFxcdWE2ZjBcXHVhNmYxXFx1YTgwMlxcdWE4MDZcXHVhODBiXFx1YTgyNVxcdWE4MjZcXHVhOGM0XFx1YThlMC1cXHVhOGYxXFx1YTkyNi1cXHVhOTJkXFx1YTk0Ny1cXHVhOTUxXFx1YTk4MC1cXHVhOTgyXFx1YTliM1xcdWE5YjYtXFx1YTliOVxcdWE5YmNcXHVhYTI5LVxcdWFhMmVcXHVhYTMxXFx1YWEzMlxcdWFhMzVcXHVhYTM2XFx1YWE0M1xcdWFhNGNcXHVhYWIwXFx1YWFiMi1cXHVhYWI0XFx1YWFiN1xcdWFhYjhcXHVhYWJlXFx1YWFiZlxcdWFhYzFcXHVhYmU1XFx1YWJlOFxcdWFiZWRcXHVkYzAwLVxcdWRmZmZcXHVmYjFlXFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmY5ZVxcdWZmOWZdLztcbiAgZnVuY3Rpb24gaXNFeHRlbmRpbmdDaGFyKGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApID49IDc2OCAmJiBleHRlbmRpbmdDaGFycy50ZXN0KGNoKSB9XG5cbiAgLy8gUmV0dXJucyBhIG51bWJlciBmcm9tIHRoZSByYW5nZSBbYDBgOyBgc3RyLmxlbmd0aGBdIHVubGVzcyBgcG9zYCBpcyBvdXRzaWRlIHRoYXQgcmFuZ2UuXG4gIGZ1bmN0aW9uIHNraXBFeHRlbmRpbmdDaGFycyhzdHIsIHBvcywgZGlyKSB7XG4gICAgd2hpbGUgKChkaXIgPCAwID8gcG9zID4gMCA6IHBvcyA8IHN0ci5sZW5ndGgpICYmIGlzRXh0ZW5kaW5nQ2hhcihzdHIuY2hhckF0KHBvcykpKSB7IHBvcyArPSBkaXI7IH1cbiAgICByZXR1cm4gcG9zXG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSB2YWx1ZSBmcm9tIHRoZSByYW5nZSBbYGZyb21gOyBgdG9gXSB0aGF0IHNhdGlzZmllc1xuICAvLyBgcHJlZGAgYW5kIGlzIGNsb3Nlc3QgdG8gYGZyb21gLiBBc3N1bWVzIHRoYXQgYXQgbGVhc3QgYHRvYFxuICAvLyBzYXRpc2ZpZXMgYHByZWRgLiBTdXBwb3J0cyBgZnJvbWAgYmVpbmcgZ3JlYXRlciB0aGFuIGB0b2AuXG4gIGZ1bmN0aW9uIGZpbmRGaXJzdChwcmVkLCBmcm9tLCB0bykge1xuICAgIC8vIEF0IGFueSBwb2ludCB3ZSBhcmUgY2VydGFpbiBgdG9gIHNhdGlzZmllcyBgcHJlZGAsIGRvbid0IGtub3dcbiAgICAvLyB3aGV0aGVyIGBmcm9tYCBkb2VzLlxuICAgIHZhciBkaXIgPSBmcm9tID4gdG8gPyAtMSA6IDE7XG4gICAgZm9yICg7Oykge1xuICAgICAgaWYgKGZyb20gPT0gdG8pIHsgcmV0dXJuIGZyb20gfVxuICAgICAgdmFyIG1pZEYgPSAoZnJvbSArIHRvKSAvIDIsIG1pZCA9IGRpciA8IDAgPyBNYXRoLmNlaWwobWlkRikgOiBNYXRoLmZsb29yKG1pZEYpO1xuICAgICAgaWYgKG1pZCA9PSBmcm9tKSB7IHJldHVybiBwcmVkKG1pZCkgPyBmcm9tIDogdG8gfVxuICAgICAgaWYgKHByZWQobWlkKSkgeyB0byA9IG1pZDsgfVxuICAgICAgZWxzZSB7IGZyb20gPSBtaWQgKyBkaXI7IH1cbiAgICB9XG4gIH1cblxuICAvLyBCSURJIEhFTFBFUlNcblxuICBmdW5jdGlvbiBpdGVyYXRlQmlkaVNlY3Rpb25zKG9yZGVyLCBmcm9tLCB0bywgZikge1xuICAgIGlmICghb3JkZXIpIHsgcmV0dXJuIGYoZnJvbSwgdG8sIFwibHRyXCIsIDApIH1cbiAgICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgcGFydCA9IG9yZGVyW2ldO1xuICAgICAgaWYgKHBhcnQuZnJvbSA8IHRvICYmIHBhcnQudG8gPiBmcm9tIHx8IGZyb20gPT0gdG8gJiYgcGFydC50byA9PSBmcm9tKSB7XG4gICAgICAgIGYoTWF0aC5tYXgocGFydC5mcm9tLCBmcm9tKSwgTWF0aC5taW4ocGFydC50bywgdG8pLCBwYXJ0LmxldmVsID09IDEgPyBcInJ0bFwiIDogXCJsdHJcIiwgaSk7XG4gICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFmb3VuZCkgeyBmKGZyb20sIHRvLCBcImx0clwiKTsgfVxuICB9XG5cbiAgdmFyIGJpZGlPdGhlciA9IG51bGw7XG4gIGZ1bmN0aW9uIGdldEJpZGlQYXJ0QXQob3JkZXIsIGNoLCBzdGlja3kpIHtcbiAgICB2YXIgZm91bmQ7XG4gICAgYmlkaU90aGVyID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgY3VyID0gb3JkZXJbaV07XG4gICAgICBpZiAoY3VyLmZyb20gPCBjaCAmJiBjdXIudG8gPiBjaCkgeyByZXR1cm4gaSB9XG4gICAgICBpZiAoY3VyLnRvID09IGNoKSB7XG4gICAgICAgIGlmIChjdXIuZnJvbSAhPSBjdXIudG8gJiYgc3RpY2t5ID09IFwiYmVmb3JlXCIpIHsgZm91bmQgPSBpOyB9XG4gICAgICAgIGVsc2UgeyBiaWRpT3RoZXIgPSBpOyB9XG4gICAgICB9XG4gICAgICBpZiAoY3VyLmZyb20gPT0gY2gpIHtcbiAgICAgICAgaWYgKGN1ci5mcm9tICE9IGN1ci50byAmJiBzdGlja3kgIT0gXCJiZWZvcmVcIikgeyBmb3VuZCA9IGk7IH1cbiAgICAgICAgZWxzZSB7IGJpZGlPdGhlciA9IGk7IH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kICE9IG51bGwgPyBmb3VuZCA6IGJpZGlPdGhlclxuICB9XG5cbiAgLy8gQmlkaXJlY3Rpb25hbCBvcmRlcmluZyBhbGdvcml0aG1cbiAgLy8gU2VlIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyOS90cjktMTMuaHRtbCBmb3IgdGhlIGFsZ29yaXRobVxuICAvLyB0aGF0IHRoaXMgKHBhcnRpYWxseSkgaW1wbGVtZW50cy5cblxuICAvLyBPbmUtY2hhciBjb2RlcyB1c2VkIGZvciBjaGFyYWN0ZXIgdHlwZXM6XG4gIC8vIEwgKEwpOiAgIExlZnQtdG8tUmlnaHRcbiAgLy8gUiAoUik6ICAgUmlnaHQtdG8tTGVmdFxuICAvLyByIChBTCk6ICBSaWdodC10by1MZWZ0IEFyYWJpY1xuICAvLyAxIChFTik6ICBFdXJvcGVhbiBOdW1iZXJcbiAgLy8gKyAoRVMpOiAgRXVyb3BlYW4gTnVtYmVyIFNlcGFyYXRvclxuICAvLyAlIChFVCk6ICBFdXJvcGVhbiBOdW1iZXIgVGVybWluYXRvclxuICAvLyBuIChBTik6ICBBcmFiaWMgTnVtYmVyXG4gIC8vICwgKENTKTogIENvbW1vbiBOdW1iZXIgU2VwYXJhdG9yXG4gIC8vIG0gKE5TTSk6IE5vbi1TcGFjaW5nIE1hcmtcbiAgLy8gYiAoQk4pOiAgQm91bmRhcnkgTmV1dHJhbFxuICAvLyBzIChCKTogICBQYXJhZ3JhcGggU2VwYXJhdG9yXG4gIC8vIHQgKFMpOiAgIFNlZ21lbnQgU2VwYXJhdG9yXG4gIC8vIHcgKFdTKTogIFdoaXRlc3BhY2VcbiAgLy8gTiAoT04pOiAgT3RoZXIgTmV1dHJhbHNcblxuICAvLyBSZXR1cm5zIG51bGwgaWYgY2hhcmFjdGVycyBhcmUgb3JkZXJlZCBhcyB0aGV5IGFwcGVhclxuICAvLyAobGVmdC10by1yaWdodCksIG9yIGFuIGFycmF5IG9mIHNlY3Rpb25zICh7ZnJvbSwgdG8sIGxldmVsfVxuICAvLyBvYmplY3RzKSBpbiB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBvY2N1ciB2aXN1YWxseS5cbiAgdmFyIGJpZGlPcmRlcmluZyA9IChmdW5jdGlvbigpIHtcbiAgICAvLyBDaGFyYWN0ZXIgdHlwZXMgZm9yIGNvZGVwb2ludHMgMCB0byAweGZmXG4gICAgdmFyIGxvd1R5cGVzID0gXCJiYmJiYmJiYmJ0c3R3c2JiYmJiYmJiYmJiYmJic3NzdHdOTiUlJU5OTk5OTixOLE4xMTExMTExMTExTk5OTk5OTkxMTExMTExMTExMTExMTExMTExMTExMTExMTk5OTk5OTExMTExMTExMTExMTExMTExMTExMTExMTExOTk5OYmJiYmJic2JiYmJiYmJiYmJiYmJiYmJiYmJiYmJiYmJiLE4lJSUlTk5OTkxOTk5OTiUlMTFOTE5OTjFMTk5OTk5MTExMTExMTExMTExMTExMTExMTExMTE5MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTlwiO1xuICAgIC8vIENoYXJhY3RlciB0eXBlcyBmb3IgY29kZXBvaW50cyAweDYwMCB0byAweDZmOVxuICAgIHZhciBhcmFiaWNUeXBlcyA9IFwibm5ubm5uTk5yJSVyLHJOTm1tbW1tbW1tbW1tcnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJybW1tbW1tbW1tbW1tbW1tbW1tbW1tbm5ubm5ubm5ubiVubnJycm1ycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycnJycm1tbW1tbW1uTm1tbW1tbXJybW1ObW1tbXJyMTExMTExMTExMVwiO1xuICAgIGZ1bmN0aW9uIGNoYXJUeXBlKGNvZGUpIHtcbiAgICAgIGlmIChjb2RlIDw9IDB4ZjcpIHsgcmV0dXJuIGxvd1R5cGVzLmNoYXJBdChjb2RlKSB9XG4gICAgICBlbHNlIGlmICgweDU5MCA8PSBjb2RlICYmIGNvZGUgPD0gMHg1ZjQpIHsgcmV0dXJuIFwiUlwiIH1cbiAgICAgIGVsc2UgaWYgKDB4NjAwIDw9IGNvZGUgJiYgY29kZSA8PSAweDZmOSkgeyByZXR1cm4gYXJhYmljVHlwZXMuY2hhckF0KGNvZGUgLSAweDYwMCkgfVxuICAgICAgZWxzZSBpZiAoMHg2ZWUgPD0gY29kZSAmJiBjb2RlIDw9IDB4OGFjKSB7IHJldHVybiBcInJcIiB9XG4gICAgICBlbHNlIGlmICgweDIwMDAgPD0gY29kZSAmJiBjb2RlIDw9IDB4MjAwYikgeyByZXR1cm4gXCJ3XCIgfVxuICAgICAgZWxzZSBpZiAoY29kZSA9PSAweDIwMGMpIHsgcmV0dXJuIFwiYlwiIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gXCJMXCIgfVxuICAgIH1cblxuICAgIHZhciBiaWRpUkUgPSAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY10vO1xuICAgIHZhciBpc05ldXRyYWwgPSAvW3N0d05dLywgaXNTdHJvbmcgPSAvW0xScl0vLCBjb3VudHNBc0xlZnQgPSAvW0xiMW5dLywgY291bnRzQXNOdW0gPSAvWzFuXS87XG5cbiAgICBmdW5jdGlvbiBCaWRpU3BhbihsZXZlbCwgZnJvbSwgdG8pIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgIHRoaXMuZnJvbSA9IGZyb207IHRoaXMudG8gPSB0bztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24oc3RyLCBkaXJlY3Rpb24pIHtcbiAgICAgIHZhciBvdXRlclR5cGUgPSBkaXJlY3Rpb24gPT0gXCJsdHJcIiA/IFwiTFwiIDogXCJSXCI7XG5cbiAgICAgIGlmIChzdHIubGVuZ3RoID09IDAgfHwgZGlyZWN0aW9uID09IFwibHRyXCIgJiYgIWJpZGlSRS50ZXN0KHN0cikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIHZhciBsZW4gPSBzdHIubGVuZ3RoLCB0eXBlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgICAgeyB0eXBlcy5wdXNoKGNoYXJUeXBlKHN0ci5jaGFyQ29kZUF0KGkpKSk7IH1cblxuICAgICAgLy8gVzEuIEV4YW1pbmUgZWFjaCBub24tc3BhY2luZyBtYXJrIChOU00pIGluIHRoZSBsZXZlbCBydW4sIGFuZFxuICAgICAgLy8gY2hhbmdlIHRoZSB0eXBlIG9mIHRoZSBOU00gdG8gdGhlIHR5cGUgb2YgdGhlIHByZXZpb3VzXG4gICAgICAvLyBjaGFyYWN0ZXIuIElmIHRoZSBOU00gaXMgYXQgdGhlIHN0YXJ0IG9mIHRoZSBsZXZlbCBydW4sIGl0IHdpbGxcbiAgICAgIC8vIGdldCB0aGUgdHlwZSBvZiBzb3IuXG4gICAgICBmb3IgKHZhciBpJDEgPSAwLCBwcmV2ID0gb3V0ZXJUeXBlOyBpJDEgPCBsZW47ICsraSQxKSB7XG4gICAgICAgIHZhciB0eXBlID0gdHlwZXNbaSQxXTtcbiAgICAgICAgaWYgKHR5cGUgPT0gXCJtXCIpIHsgdHlwZXNbaSQxXSA9IHByZXY7IH1cbiAgICAgICAgZWxzZSB7IHByZXYgPSB0eXBlOyB9XG4gICAgICB9XG5cbiAgICAgIC8vIFcyLiBTZWFyY2ggYmFja3dhcmRzIGZyb20gZWFjaCBpbnN0YW5jZSBvZiBhIEV1cm9wZWFuIG51bWJlclxuICAgICAgLy8gdW50aWwgdGhlIGZpcnN0IHN0cm9uZyB0eXBlIChSLCBMLCBBTCwgb3Igc29yKSBpcyBmb3VuZC4gSWYgYW5cbiAgICAgIC8vIEFMIGlzIGZvdW5kLCBjaGFuZ2UgdGhlIHR5cGUgb2YgdGhlIEV1cm9wZWFuIG51bWJlciB0byBBcmFiaWNcbiAgICAgIC8vIG51bWJlci5cbiAgICAgIC8vIFczLiBDaGFuZ2UgYWxsIEFMcyB0byBSLlxuICAgICAgZm9yICh2YXIgaSQyID0gMCwgY3VyID0gb3V0ZXJUeXBlOyBpJDIgPCBsZW47ICsraSQyKSB7XG4gICAgICAgIHZhciB0eXBlJDEgPSB0eXBlc1tpJDJdO1xuICAgICAgICBpZiAodHlwZSQxID09IFwiMVwiICYmIGN1ciA9PSBcInJcIikgeyB0eXBlc1tpJDJdID0gXCJuXCI7IH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdHJvbmcudGVzdCh0eXBlJDEpKSB7IGN1ciA9IHR5cGUkMTsgaWYgKHR5cGUkMSA9PSBcInJcIikgeyB0eXBlc1tpJDJdID0gXCJSXCI7IH0gfVxuICAgICAgfVxuXG4gICAgICAvLyBXNC4gQSBzaW5nbGUgRXVyb3BlYW4gc2VwYXJhdG9yIGJldHdlZW4gdHdvIEV1cm9wZWFuIG51bWJlcnNcbiAgICAgIC8vIGNoYW5nZXMgdG8gYSBFdXJvcGVhbiBudW1iZXIuIEEgc2luZ2xlIGNvbW1vbiBzZXBhcmF0b3IgYmV0d2VlblxuICAgICAgLy8gdHdvIG51bWJlcnMgb2YgdGhlIHNhbWUgdHlwZSBjaGFuZ2VzIHRvIHRoYXQgdHlwZS5cbiAgICAgIGZvciAodmFyIGkkMyA9IDEsIHByZXYkMSA9IHR5cGVzWzBdOyBpJDMgPCBsZW4gLSAxOyArK2kkMykge1xuICAgICAgICB2YXIgdHlwZSQyID0gdHlwZXNbaSQzXTtcbiAgICAgICAgaWYgKHR5cGUkMiA9PSBcIitcIiAmJiBwcmV2JDEgPT0gXCIxXCIgJiYgdHlwZXNbaSQzKzFdID09IFwiMVwiKSB7IHR5cGVzW2kkM10gPSBcIjFcIjsgfVxuICAgICAgICBlbHNlIGlmICh0eXBlJDIgPT0gXCIsXCIgJiYgcHJldiQxID09IHR5cGVzW2kkMysxXSAmJlxuICAgICAgICAgICAgICAgICAocHJldiQxID09IFwiMVwiIHx8IHByZXYkMSA9PSBcIm5cIikpIHsgdHlwZXNbaSQzXSA9IHByZXYkMTsgfVxuICAgICAgICBwcmV2JDEgPSB0eXBlJDI7XG4gICAgICB9XG5cbiAgICAgIC8vIFc1LiBBIHNlcXVlbmNlIG9mIEV1cm9wZWFuIHRlcm1pbmF0b3JzIGFkamFjZW50IHRvIEV1cm9wZWFuXG4gICAgICAvLyBudW1iZXJzIGNoYW5nZXMgdG8gYWxsIEV1cm9wZWFuIG51bWJlcnMuXG4gICAgICAvLyBXNi4gT3RoZXJ3aXNlLCBzZXBhcmF0b3JzIGFuZCB0ZXJtaW5hdG9ycyBjaGFuZ2UgdG8gT3RoZXJcbiAgICAgIC8vIE5ldXRyYWwuXG4gICAgICBmb3IgKHZhciBpJDQgPSAwOyBpJDQgPCBsZW47ICsraSQ0KSB7XG4gICAgICAgIHZhciB0eXBlJDMgPSB0eXBlc1tpJDRdO1xuICAgICAgICBpZiAodHlwZSQzID09IFwiLFwiKSB7IHR5cGVzW2kkNF0gPSBcIk5cIjsgfVxuICAgICAgICBlbHNlIGlmICh0eXBlJDMgPT0gXCIlXCIpIHtcbiAgICAgICAgICB2YXIgZW5kID0gKHZvaWQgMCk7XG4gICAgICAgICAgZm9yIChlbmQgPSBpJDQgKyAxOyBlbmQgPCBsZW4gJiYgdHlwZXNbZW5kXSA9PSBcIiVcIjsgKytlbmQpIHt9XG4gICAgICAgICAgdmFyIHJlcGxhY2UgPSAoaSQ0ICYmIHR5cGVzW2kkNC0xXSA9PSBcIiFcIikgfHwgKGVuZCA8IGxlbiAmJiB0eXBlc1tlbmRdID09IFwiMVwiKSA/IFwiMVwiIDogXCJOXCI7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IGkkNDsgaiA8IGVuZDsgKytqKSB7IHR5cGVzW2pdID0gcmVwbGFjZTsgfVxuICAgICAgICAgIGkkNCA9IGVuZCAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVzcuIFNlYXJjaCBiYWNrd2FyZHMgZnJvbSBlYWNoIGluc3RhbmNlIG9mIGEgRXVyb3BlYW4gbnVtYmVyXG4gICAgICAvLyB1bnRpbCB0aGUgZmlyc3Qgc3Ryb25nIHR5cGUgKFIsIEwsIG9yIHNvcikgaXMgZm91bmQuIElmIGFuIEwgaXNcbiAgICAgIC8vIGZvdW5kLCB0aGVuIGNoYW5nZSB0aGUgdHlwZSBvZiB0aGUgRXVyb3BlYW4gbnVtYmVyIHRvIEwuXG4gICAgICBmb3IgKHZhciBpJDUgPSAwLCBjdXIkMSA9IG91dGVyVHlwZTsgaSQ1IDwgbGVuOyArK2kkNSkge1xuICAgICAgICB2YXIgdHlwZSQ0ID0gdHlwZXNbaSQ1XTtcbiAgICAgICAgaWYgKGN1ciQxID09IFwiTFwiICYmIHR5cGUkNCA9PSBcIjFcIikgeyB0eXBlc1tpJDVdID0gXCJMXCI7IH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdHJvbmcudGVzdCh0eXBlJDQpKSB7IGN1ciQxID0gdHlwZSQ0OyB9XG4gICAgICB9XG5cbiAgICAgIC8vIE4xLiBBIHNlcXVlbmNlIG9mIG5ldXRyYWxzIHRha2VzIHRoZSBkaXJlY3Rpb24gb2YgdGhlXG4gICAgICAvLyBzdXJyb3VuZGluZyBzdHJvbmcgdGV4dCBpZiB0aGUgdGV4dCBvbiBib3RoIHNpZGVzIGhhcyB0aGUgc2FtZVxuICAgICAgLy8gZGlyZWN0aW9uLiBFdXJvcGVhbiBhbmQgQXJhYmljIG51bWJlcnMgYWN0IGFzIGlmIHRoZXkgd2VyZSBSIGluXG4gICAgICAvLyB0ZXJtcyBvZiB0aGVpciBpbmZsdWVuY2Ugb24gbmV1dHJhbHMuIFN0YXJ0LW9mLWxldmVsLXJ1biAoc29yKVxuICAgICAgLy8gYW5kIGVuZC1vZi1sZXZlbC1ydW4gKGVvcikgYXJlIHVzZWQgYXQgbGV2ZWwgcnVuIGJvdW5kYXJpZXMuXG4gICAgICAvLyBOMi4gQW55IHJlbWFpbmluZyBuZXV0cmFscyB0YWtlIHRoZSBlbWJlZGRpbmcgZGlyZWN0aW9uLlxuICAgICAgZm9yICh2YXIgaSQ2ID0gMDsgaSQ2IDwgbGVuOyArK2kkNikge1xuICAgICAgICBpZiAoaXNOZXV0cmFsLnRlc3QodHlwZXNbaSQ2XSkpIHtcbiAgICAgICAgICB2YXIgZW5kJDEgPSAodm9pZCAwKTtcbiAgICAgICAgICBmb3IgKGVuZCQxID0gaSQ2ICsgMTsgZW5kJDEgPCBsZW4gJiYgaXNOZXV0cmFsLnRlc3QodHlwZXNbZW5kJDFdKTsgKytlbmQkMSkge31cbiAgICAgICAgICB2YXIgYmVmb3JlID0gKGkkNiA/IHR5cGVzW2kkNi0xXSA6IG91dGVyVHlwZSkgPT0gXCJMXCI7XG4gICAgICAgICAgdmFyIGFmdGVyID0gKGVuZCQxIDwgbGVuID8gdHlwZXNbZW5kJDFdIDogb3V0ZXJUeXBlKSA9PSBcIkxcIjtcbiAgICAgICAgICB2YXIgcmVwbGFjZSQxID0gYmVmb3JlID09IGFmdGVyID8gKGJlZm9yZSA/IFwiTFwiIDogXCJSXCIpIDogb3V0ZXJUeXBlO1xuICAgICAgICAgIGZvciAodmFyIGokMSA9IGkkNjsgaiQxIDwgZW5kJDE7ICsraiQxKSB7IHR5cGVzW2okMV0gPSByZXBsYWNlJDE7IH1cbiAgICAgICAgICBpJDYgPSBlbmQkMSAtIDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSGVyZSB3ZSBkZXBhcnQgZnJvbSB0aGUgZG9jdW1lbnRlZCBhbGdvcml0aG0sIGluIG9yZGVyIHRvIGF2b2lkXG4gICAgICAvLyBidWlsZGluZyB1cCBhbiBhY3R1YWwgbGV2ZWxzIGFycmF5LiBTaW5jZSB0aGVyZSBhcmUgb25seSB0aHJlZVxuICAgICAgLy8gbGV2ZWxzICgwLCAxLCAyKSBpbiBhbiBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXNuJ3QgdGFrZVxuICAgICAgLy8gZXhwbGljaXQgZW1iZWRkaW5nIGludG8gYWNjb3VudCwgd2UgY2FuIGJ1aWxkIHVwIHRoZSBvcmRlciBvblxuICAgICAgLy8gdGhlIGZseSwgd2l0aG91dCBmb2xsb3dpbmcgdGhlIGxldmVsLWJhc2VkIGFsZ29yaXRobS5cbiAgICAgIHZhciBvcmRlciA9IFtdLCBtO1xuICAgICAgZm9yICh2YXIgaSQ3ID0gMDsgaSQ3IDwgbGVuOykge1xuICAgICAgICBpZiAoY291bnRzQXNMZWZ0LnRlc3QodHlwZXNbaSQ3XSkpIHtcbiAgICAgICAgICB2YXIgc3RhcnQgPSBpJDc7XG4gICAgICAgICAgZm9yICgrK2kkNzsgaSQ3IDwgbGVuICYmIGNvdW50c0FzTGVmdC50ZXN0KHR5cGVzW2kkN10pOyArK2kkNykge31cbiAgICAgICAgICBvcmRlci5wdXNoKG5ldyBCaWRpU3BhbigwLCBzdGFydCwgaSQ3KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHBvcyA9IGkkNywgYXQgPSBvcmRlci5sZW5ndGgsIGlzUlRMID0gZGlyZWN0aW9uID09IFwicnRsXCIgPyAxIDogMDtcbiAgICAgICAgICBmb3IgKCsraSQ3OyBpJDcgPCBsZW4gJiYgdHlwZXNbaSQ3XSAhPSBcIkxcIjsgKytpJDcpIHt9XG4gICAgICAgICAgZm9yICh2YXIgaiQyID0gcG9zOyBqJDIgPCBpJDc7KSB7XG4gICAgICAgICAgICBpZiAoY291bnRzQXNOdW0udGVzdCh0eXBlc1tqJDJdKSkge1xuICAgICAgICAgICAgICBpZiAocG9zIDwgaiQyKSB7IG9yZGVyLnNwbGljZShhdCwgMCwgbmV3IEJpZGlTcGFuKDEsIHBvcywgaiQyKSk7IGF0ICs9IGlzUlRMOyB9XG4gICAgICAgICAgICAgIHZhciBuc3RhcnQgPSBqJDI7XG4gICAgICAgICAgICAgIGZvciAoKytqJDI7IGokMiA8IGkkNyAmJiBjb3VudHNBc051bS50ZXN0KHR5cGVzW2okMl0pOyArK2okMikge31cbiAgICAgICAgICAgICAgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMiwgbnN0YXJ0LCBqJDIpKTtcbiAgICAgICAgICAgICAgYXQgKz0gaXNSVEw7XG4gICAgICAgICAgICAgIHBvcyA9IGokMjtcbiAgICAgICAgICAgIH0gZWxzZSB7ICsraiQyOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwb3MgPCBpJDcpIHsgb3JkZXIuc3BsaWNlKGF0LCAwLCBuZXcgQmlkaVNwYW4oMSwgcG9zLCBpJDcpKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZGlyZWN0aW9uID09IFwibHRyXCIpIHtcbiAgICAgICAgaWYgKG9yZGVyWzBdLmxldmVsID09IDEgJiYgKG0gPSBzdHIubWF0Y2goL15cXHMrLykpKSB7XG4gICAgICAgICAgb3JkZXJbMF0uZnJvbSA9IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgIG9yZGVyLnVuc2hpZnQobmV3IEJpZGlTcGFuKDAsIDAsIG1bMF0ubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxzdChvcmRlcikubGV2ZWwgPT0gMSAmJiAobSA9IHN0ci5tYXRjaCgvXFxzKyQvKSkpIHtcbiAgICAgICAgICBsc3Qob3JkZXIpLnRvIC09IG1bMF0ubGVuZ3RoO1xuICAgICAgICAgIG9yZGVyLnB1c2gobmV3IEJpZGlTcGFuKDAsIGxlbiAtIG1bMF0ubGVuZ3RoLCBsZW4pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGlyZWN0aW9uID09IFwicnRsXCIgPyBvcmRlci5yZXZlcnNlKCkgOiBvcmRlclxuICAgIH1cbiAgfSkoKTtcblxuICAvLyBHZXQgdGhlIGJpZGkgb3JkZXJpbmcgZm9yIHRoZSBnaXZlbiBsaW5lIChhbmQgY2FjaGUgaXQpLiBSZXR1cm5zXG4gIC8vIGZhbHNlIGZvciBsaW5lcyB0aGF0IGFyZSBmdWxseSBsZWZ0LXRvLXJpZ2h0LCBhbmQgYW4gYXJyYXkgb2ZcbiAgLy8gQmlkaVNwYW4gb2JqZWN0cyBvdGhlcndpc2UuXG4gIGZ1bmN0aW9uIGdldE9yZGVyKGxpbmUsIGRpcmVjdGlvbikge1xuICAgIHZhciBvcmRlciA9IGxpbmUub3JkZXI7XG4gICAgaWYgKG9yZGVyID09IG51bGwpIHsgb3JkZXIgPSBsaW5lLm9yZGVyID0gYmlkaU9yZGVyaW5nKGxpbmUudGV4dCwgZGlyZWN0aW9uKTsgfVxuICAgIHJldHVybiBvcmRlclxuICB9XG5cbiAgLy8gRVZFTlQgSEFORExJTkdcblxuICAvLyBMaWdodHdlaWdodCBldmVudCBmcmFtZXdvcmsuIG9uL29mZiBhbHNvIHdvcmsgb24gRE9NIG5vZGVzLFxuICAvLyByZWdpc3RlcmluZyBuYXRpdmUgRE9NIGhhbmRsZXJzLlxuXG4gIHZhciBub0hhbmRsZXJzID0gW107XG5cbiAgdmFyIG9uID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSwgZikge1xuICAgIGlmIChlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChlbWl0dGVyLmF0dGFjaEV2ZW50KSB7XG4gICAgICBlbWl0dGVyLmF0dGFjaEV2ZW50KFwib25cIiArIHR5cGUsIGYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbWFwID0gZW1pdHRlci5faGFuZGxlcnMgfHwgKGVtaXR0ZXIuX2hhbmRsZXJzID0ge30pO1xuICAgICAgbWFwW3R5cGVdID0gKG1hcFt0eXBlXSB8fCBub0hhbmRsZXJzKS5jb25jYXQoZik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldEhhbmRsZXJzKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICByZXR1cm4gZW1pdHRlci5faGFuZGxlcnMgJiYgZW1pdHRlci5faGFuZGxlcnNbdHlwZV0gfHwgbm9IYW5kbGVyc1xuICB9XG5cbiAgZnVuY3Rpb24gb2ZmKGVtaXR0ZXIsIHR5cGUsIGYpIHtcbiAgICBpZiAoZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgZiwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZW1pdHRlci5kZXRhY2hFdmVudCkge1xuICAgICAgZW1pdHRlci5kZXRhY2hFdmVudChcIm9uXCIgKyB0eXBlLCBmKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hcCA9IGVtaXR0ZXIuX2hhbmRsZXJzLCBhcnIgPSBtYXAgJiYgbWFwW3R5cGVdO1xuICAgICAgaWYgKGFycikge1xuICAgICAgICB2YXIgaW5kZXggPSBpbmRleE9mKGFyciwgZik7XG4gICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgIHsgbWFwW3R5cGVdID0gYXJyLnNsaWNlKDAsIGluZGV4KS5jb25jYXQoYXJyLnNsaWNlKGluZGV4ICsgMSkpOyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2lnbmFsKGVtaXR0ZXIsIHR5cGUgLyosIHZhbHVlcy4uLiovKSB7XG4gICAgdmFyIGhhbmRsZXJzID0gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSk7XG4gICAgaWYgKCFoYW5kbGVycy5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYW5kbGVycy5sZW5ndGg7ICsraSkgeyBoYW5kbGVyc1tpXS5hcHBseShudWxsLCBhcmdzKTsgfVxuICB9XG5cbiAgLy8gVGhlIERPTSBldmVudHMgdGhhdCBDb2RlTWlycm9yIGhhbmRsZXMgY2FuIGJlIG92ZXJyaWRkZW4gYnlcbiAgLy8gcmVnaXN0ZXJpbmcgYSAobm9uLURPTSkgaGFuZGxlciBvbiB0aGUgZWRpdG9yIGZvciB0aGUgZXZlbnQgbmFtZSxcbiAgLy8gYW5kIHByZXZlbnREZWZhdWx0LWluZyB0aGUgZXZlbnQgaW4gdGhhdCBoYW5kbGVyLlxuICBmdW5jdGlvbiBzaWduYWxET01FdmVudChjbSwgZSwgb3ZlcnJpZGUpIHtcbiAgICBpZiAodHlwZW9mIGUgPT0gXCJzdHJpbmdcIilcbiAgICAgIHsgZSA9IHt0eXBlOiBlLCBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7IHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7IH19OyB9XG4gICAgc2lnbmFsKGNtLCBvdmVycmlkZSB8fCBlLnR5cGUsIGNtLCBlKTtcbiAgICByZXR1cm4gZV9kZWZhdWx0UHJldmVudGVkKGUpIHx8IGUuY29kZW1pcnJvcklnbm9yZVxuICB9XG5cbiAgZnVuY3Rpb24gc2lnbmFsQ3Vyc29yQWN0aXZpdHkoY20pIHtcbiAgICB2YXIgYXJyID0gY20uX2hhbmRsZXJzICYmIGNtLl9oYW5kbGVycy5jdXJzb3JBY3Rpdml0eTtcbiAgICBpZiAoIWFycikgeyByZXR1cm4gfVxuICAgIHZhciBzZXQgPSBjbS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzIHx8IChjbS5jdXJPcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzID0gW10pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7IGlmIChpbmRleE9mKHNldCwgYXJyW2ldKSA9PSAtMSlcbiAgICAgIHsgc2V0LnB1c2goYXJyW2ldKTsgfSB9XG4gIH1cblxuICBmdW5jdGlvbiBoYXNIYW5kbGVyKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICByZXR1cm4gZ2V0SGFuZGxlcnMoZW1pdHRlciwgdHlwZSkubGVuZ3RoID4gMFxuICB9XG5cbiAgLy8gQWRkIG9uIGFuZCBvZmYgbWV0aG9kcyB0byBhIGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlLCB0byBtYWtlXG4gIC8vIHJlZ2lzdGVyaW5nIGV2ZW50cyBvbiBzdWNoIG9iamVjdHMgbW9yZSBjb252ZW5pZW50LlxuICBmdW5jdGlvbiBldmVudE1peGluKGN0b3IpIHtcbiAgICBjdG9yLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKHR5cGUsIGYpIHtvbih0aGlzLCB0eXBlLCBmKTt9O1xuICAgIGN0b3IucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKHR5cGUsIGYpIHtvZmYodGhpcywgdHlwZSwgZik7fTtcbiAgfVxuXG4gIC8vIER1ZSB0byB0aGUgZmFjdCB0aGF0IHdlIHN0aWxsIHN1cHBvcnQganVyYXNzaWMgSUUgdmVyc2lvbnMsIHNvbWVcbiAgLy8gY29tcGF0aWJpbGl0eSB3cmFwcGVycyBhcmUgbmVlZGVkLlxuXG4gIGZ1bmN0aW9uIGVfcHJldmVudERlZmF1bHQoZSkge1xuICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7IGUucHJldmVudERlZmF1bHQoKTsgfVxuICAgIGVsc2UgeyBlLnJldHVyblZhbHVlID0gZmFsc2U7IH1cbiAgfVxuICBmdW5jdGlvbiBlX3N0b3BQcm9wYWdhdGlvbihlKSB7XG4gICAgaWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7IGUuc3RvcFByb3BhZ2F0aW9uKCk7IH1cbiAgICBlbHNlIHsgZS5jYW5jZWxCdWJibGUgPSB0cnVlOyB9XG4gIH1cbiAgZnVuY3Rpb24gZV9kZWZhdWx0UHJldmVudGVkKGUpIHtcbiAgICByZXR1cm4gZS5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBlLmRlZmF1bHRQcmV2ZW50ZWQgOiBlLnJldHVyblZhbHVlID09IGZhbHNlXG4gIH1cbiAgZnVuY3Rpb24gZV9zdG9wKGUpIHtlX3ByZXZlbnREZWZhdWx0KGUpOyBlX3N0b3BQcm9wYWdhdGlvbihlKTt9XG5cbiAgZnVuY3Rpb24gZV90YXJnZXQoZSkge3JldHVybiBlLnRhcmdldCB8fCBlLnNyY0VsZW1lbnR9XG4gIGZ1bmN0aW9uIGVfYnV0dG9uKGUpIHtcbiAgICB2YXIgYiA9IGUud2hpY2g7XG4gICAgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgaWYgKGUuYnV0dG9uICYgMSkgeyBiID0gMTsgfVxuICAgICAgZWxzZSBpZiAoZS5idXR0b24gJiAyKSB7IGIgPSAzOyB9XG4gICAgICBlbHNlIGlmIChlLmJ1dHRvbiAmIDQpIHsgYiA9IDI7IH1cbiAgICB9XG4gICAgaWYgKG1hYyAmJiBlLmN0cmxLZXkgJiYgYiA9PSAxKSB7IGIgPSAzOyB9XG4gICAgcmV0dXJuIGJcbiAgfVxuXG4gIC8vIERldGVjdCBkcmFnLWFuZC1kcm9wXG4gIHZhciBkcmFnQW5kRHJvcCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRoZXJlIGlzICpzb21lKiBraW5kIG9mIGRyYWctYW5kLWRyb3Agc3VwcG9ydCBpbiBJRTYtOCwgYnV0IElcbiAgICAvLyBjb3VsZG4ndCBnZXQgaXQgdG8gd29yayB5ZXQuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIGRpdiA9IGVsdCgnZGl2Jyk7XG4gICAgcmV0dXJuIFwiZHJhZ2dhYmxlXCIgaW4gZGl2IHx8IFwiZHJhZ0Ryb3BcIiBpbiBkaXZcbiAgfSgpO1xuXG4gIHZhciB6d3NwU3VwcG9ydGVkO1xuICBmdW5jdGlvbiB6ZXJvV2lkdGhFbGVtZW50KG1lYXN1cmUpIHtcbiAgICBpZiAoendzcFN1cHBvcnRlZCA9PSBudWxsKSB7XG4gICAgICB2YXIgdGVzdCA9IGVsdChcInNwYW5cIiwgXCJcXHUyMDBiXCIpO1xuICAgICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZWx0KFwic3BhblwiLCBbdGVzdCwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJ4XCIpXSkpO1xuICAgICAgaWYgKG1lYXN1cmUuZmlyc3RDaGlsZC5vZmZzZXRIZWlnaHQgIT0gMClcbiAgICAgICAgeyB6d3NwU3VwcG9ydGVkID0gdGVzdC5vZmZzZXRXaWR0aCA8PSAxICYmIHRlc3Qub2Zmc2V0SGVpZ2h0ID4gMiAmJiAhKGllICYmIGllX3ZlcnNpb24gPCA4KTsgfVxuICAgIH1cbiAgICB2YXIgbm9kZSA9IHp3c3BTdXBwb3J0ZWQgPyBlbHQoXCJzcGFuXCIsIFwiXFx1MjAwYlwiKSA6XG4gICAgICBlbHQoXCJzcGFuXCIsIFwiXFx1MDBhMFwiLCBudWxsLCBcImRpc3BsYXk6IGlubGluZS1ibG9jazsgd2lkdGg6IDFweDsgbWFyZ2luLXJpZ2h0OiAtMXB4XCIpO1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiY20tdGV4dFwiLCBcIlwiKTtcbiAgICByZXR1cm4gbm9kZVxuICB9XG5cbiAgLy8gRmVhdHVyZS1kZXRlY3QgSUUncyBjcnVtbXkgY2xpZW50IHJlY3QgcmVwb3J0aW5nIGZvciBiaWRpIHRleHRcbiAgdmFyIGJhZEJpZGlSZWN0cztcbiAgZnVuY3Rpb24gaGFzQmFkQmlkaVJlY3RzKG1lYXN1cmUpIHtcbiAgICBpZiAoYmFkQmlkaVJlY3RzICE9IG51bGwpIHsgcmV0dXJuIGJhZEJpZGlSZWN0cyB9XG4gICAgdmFyIHR4dCA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKG1lYXN1cmUsIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiQVxcdTA2MmVBXCIpKTtcbiAgICB2YXIgcjAgPSByYW5nZSh0eHQsIDAsIDEpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciByMSA9IHJhbmdlKHR4dCwgMSwgMikuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmVtb3ZlQ2hpbGRyZW4obWVhc3VyZSk7XG4gICAgaWYgKCFyMCB8fCByMC5sZWZ0ID09IHIwLnJpZ2h0KSB7IHJldHVybiBmYWxzZSB9IC8vIFNhZmFyaSByZXR1cm5zIG51bGwgaW4gc29tZSBjYXNlcyAoIzI3ODApXG4gICAgcmV0dXJuIGJhZEJpZGlSZWN0cyA9IChyMS5yaWdodCAtIHIwLnJpZ2h0IDwgMylcbiAgfVxuXG4gIC8vIFNlZSBpZiBcIlwiLnNwbGl0IGlzIHRoZSBicm9rZW4gSUUgdmVyc2lvbiwgaWYgc28sIHByb3ZpZGUgYW5cbiAgLy8gYWx0ZXJuYXRpdmUgd2F5IHRvIHNwbGl0IGxpbmVzLlxuICB2YXIgc3BsaXRMaW5lc0F1dG8gPSBcIlxcblxcbmJcIi5zcGxpdCgvXFxuLykubGVuZ3RoICE9IDMgPyBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgdmFyIHBvcyA9IDAsIHJlc3VsdCA9IFtdLCBsID0gc3RyaW5nLmxlbmd0aDtcbiAgICB3aGlsZSAocG9zIDw9IGwpIHtcbiAgICAgIHZhciBubCA9IHN0cmluZy5pbmRleE9mKFwiXFxuXCIsIHBvcyk7XG4gICAgICBpZiAobmwgPT0gLTEpIHsgbmwgPSBzdHJpbmcubGVuZ3RoOyB9XG4gICAgICB2YXIgbGluZSA9IHN0cmluZy5zbGljZShwb3MsIHN0cmluZy5jaGFyQXQobmwgLSAxKSA9PSBcIlxcclwiID8gbmwgLSAxIDogbmwpO1xuICAgICAgdmFyIHJ0ID0gbGluZS5pbmRleE9mKFwiXFxyXCIpO1xuICAgICAgaWYgKHJ0ICE9IC0xKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUuc2xpY2UoMCwgcnQpKTtcbiAgICAgICAgcG9zICs9IHJ0ICsgMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxpbmUpO1xuICAgICAgICBwb3MgPSBubCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHN0cmluZy5zcGxpdCgvXFxyXFxuP3xcXG4vKTsgfTtcblxuICB2YXIgaGFzU2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiA/IGZ1bmN0aW9uICh0ZSkge1xuICAgIHRyeSB7IHJldHVybiB0ZS5zZWxlY3Rpb25TdGFydCAhPSB0ZS5zZWxlY3Rpb25FbmQgfVxuICAgIGNhdGNoKGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgfSA6IGZ1bmN0aW9uICh0ZSkge1xuICAgIHZhciByYW5nZTtcbiAgICB0cnkge3JhbmdlID0gdGUub3duZXJEb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTt9XG4gICAgY2F0Y2goZSkge31cbiAgICBpZiAoIXJhbmdlIHx8IHJhbmdlLnBhcmVudEVsZW1lbnQoKSAhPSB0ZSkgeyByZXR1cm4gZmFsc2UgfVxuICAgIHJldHVybiByYW5nZS5jb21wYXJlRW5kUG9pbnRzKFwiU3RhcnRUb0VuZFwiLCByYW5nZSkgIT0gMFxuICB9O1xuXG4gIHZhciBoYXNDb3B5RXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gZWx0KFwiZGl2XCIpO1xuICAgIGlmIChcIm9uY29weVwiIGluIGUpIHsgcmV0dXJuIHRydWUgfVxuICAgIGUuc2V0QXR0cmlidXRlKFwib25jb3B5XCIsIFwicmV0dXJuO1wiKTtcbiAgICByZXR1cm4gdHlwZW9mIGUub25jb3B5ID09IFwiZnVuY3Rpb25cIlxuICB9KSgpO1xuXG4gIHZhciBiYWRab29tZWRSZWN0cyA9IG51bGw7XG4gIGZ1bmN0aW9uIGhhc0JhZFpvb21lZFJlY3RzKG1lYXN1cmUpIHtcbiAgICBpZiAoYmFkWm9vbWVkUmVjdHMgIT0gbnVsbCkgeyByZXR1cm4gYmFkWm9vbWVkUmVjdHMgfVxuICAgIHZhciBub2RlID0gcmVtb3ZlQ2hpbGRyZW5BbmRBZGQobWVhc3VyZSwgZWx0KFwic3BhblwiLCBcInhcIikpO1xuICAgIHZhciBub3JtYWwgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBmcm9tUmFuZ2UgPSByYW5nZShub2RlLCAwLCAxKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gYmFkWm9vbWVkUmVjdHMgPSBNYXRoLmFicyhub3JtYWwubGVmdCAtIGZyb21SYW5nZS5sZWZ0KSA+IDFcbiAgfVxuXG4gIC8vIEtub3duIG1vZGVzLCBieSBuYW1lIGFuZCBieSBNSU1FXG4gIHZhciBtb2RlcyA9IHt9LCBtaW1lTW9kZXMgPSB7fTtcblxuICAvLyBFeHRyYSBhcmd1bWVudHMgYXJlIHN0b3JlZCBhcyB0aGUgbW9kZSdzIGRlcGVuZGVuY2llcywgd2hpY2ggaXNcbiAgLy8gdXNlZCBieSAobGVnYWN5KSBtZWNoYW5pc21zIGxpa2UgbG9hZG1vZGUuanMgdG8gYXV0b21hdGljYWxseVxuICAvLyBsb2FkIGEgbW9kZS4gKFByZWZlcnJlZCBtZWNoYW5pc20gaXMgdGhlIHJlcXVpcmUvZGVmaW5lIGNhbGxzLilcbiAgZnVuY3Rpb24gZGVmaW5lTW9kZShuYW1lLCBtb2RlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKVxuICAgICAgeyBtb2RlLmRlcGVuZGVuY2llcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7IH1cbiAgICBtb2Rlc1tuYW1lXSA9IG1vZGU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZpbmVNSU1FKG1pbWUsIHNwZWMpIHtcbiAgICBtaW1lTW9kZXNbbWltZV0gPSBzcGVjO1xuICB9XG5cbiAgLy8gR2l2ZW4gYSBNSU1FIHR5cGUsIGEge25hbWUsIC4uLm9wdGlvbnN9IGNvbmZpZyBvYmplY3QsIG9yIGEgbmFtZVxuICAvLyBzdHJpbmcsIHJldHVybiBhIG1vZGUgY29uZmlnIG9iamVjdC5cbiAgZnVuY3Rpb24gcmVzb2x2ZU1vZGUoc3BlYykge1xuICAgIGlmICh0eXBlb2Ygc3BlYyA9PSBcInN0cmluZ1wiICYmIG1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShzcGVjKSkge1xuICAgICAgc3BlYyA9IG1pbWVNb2Rlc1tzcGVjXTtcbiAgICB9IGVsc2UgaWYgKHNwZWMgJiYgdHlwZW9mIHNwZWMubmFtZSA9PSBcInN0cmluZ1wiICYmIG1pbWVNb2Rlcy5oYXNPd25Qcm9wZXJ0eShzcGVjLm5hbWUpKSB7XG4gICAgICB2YXIgZm91bmQgPSBtaW1lTW9kZXNbc3BlYy5uYW1lXTtcbiAgICAgIGlmICh0eXBlb2YgZm91bmQgPT0gXCJzdHJpbmdcIikgeyBmb3VuZCA9IHtuYW1lOiBmb3VuZH07IH1cbiAgICAgIHNwZWMgPSBjcmVhdGVPYmooZm91bmQsIHNwZWMpO1xuICAgICAgc3BlYy5uYW1lID0gZm91bmQubmFtZTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIgJiYgL15bXFx3XFwtXStcXC9bXFx3XFwtXStcXCt4bWwkLy50ZXN0KHNwZWMpKSB7XG4gICAgICByZXR1cm4gcmVzb2x2ZU1vZGUoXCJhcHBsaWNhdGlvbi94bWxcIilcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIgJiYgL15bXFx3XFwtXStcXC9bXFx3XFwtXStcXCtqc29uJC8udGVzdChzcGVjKSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVNb2RlKFwiYXBwbGljYXRpb24vanNvblwiKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHNwZWMgPT0gXCJzdHJpbmdcIikgeyByZXR1cm4ge25hbWU6IHNwZWN9IH1cbiAgICBlbHNlIHsgcmV0dXJuIHNwZWMgfHwge25hbWU6IFwibnVsbFwifSB9XG4gIH1cblxuICAvLyBHaXZlbiBhIG1vZGUgc3BlYyAoYW55dGhpbmcgdGhhdCByZXNvbHZlTW9kZSBhY2NlcHRzKSwgZmluZCBhbmRcbiAgLy8gaW5pdGlhbGl6ZSBhbiBhY3R1YWwgbW9kZSBvYmplY3QuXG4gIGZ1bmN0aW9uIGdldE1vZGUob3B0aW9ucywgc3BlYykge1xuICAgIHNwZWMgPSByZXNvbHZlTW9kZShzcGVjKTtcbiAgICB2YXIgbWZhY3RvcnkgPSBtb2Rlc1tzcGVjLm5hbWVdO1xuICAgIGlmICghbWZhY3RvcnkpIHsgcmV0dXJuIGdldE1vZGUob3B0aW9ucywgXCJ0ZXh0L3BsYWluXCIpIH1cbiAgICB2YXIgbW9kZU9iaiA9IG1mYWN0b3J5KG9wdGlvbnMsIHNwZWMpO1xuICAgIGlmIChtb2RlRXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eShzcGVjLm5hbWUpKSB7XG4gICAgICB2YXIgZXh0cyA9IG1vZGVFeHRlbnNpb25zW3NwZWMubmFtZV07XG4gICAgICBmb3IgKHZhciBwcm9wIGluIGV4dHMpIHtcbiAgICAgICAgaWYgKCFleHRzLmhhc093blByb3BlcnR5KHByb3ApKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgaWYgKG1vZGVPYmouaGFzT3duUHJvcGVydHkocHJvcCkpIHsgbW9kZU9ialtcIl9cIiArIHByb3BdID0gbW9kZU9ialtwcm9wXTsgfVxuICAgICAgICBtb2RlT2JqW3Byb3BdID0gZXh0c1twcm9wXTtcbiAgICAgIH1cbiAgICB9XG4gICAgbW9kZU9iai5uYW1lID0gc3BlYy5uYW1lO1xuICAgIGlmIChzcGVjLmhlbHBlclR5cGUpIHsgbW9kZU9iai5oZWxwZXJUeXBlID0gc3BlYy5oZWxwZXJUeXBlOyB9XG4gICAgaWYgKHNwZWMubW9kZVByb3BzKSB7IGZvciAodmFyIHByb3AkMSBpbiBzcGVjLm1vZGVQcm9wcylcbiAgICAgIHsgbW9kZU9ialtwcm9wJDFdID0gc3BlYy5tb2RlUHJvcHNbcHJvcCQxXTsgfSB9XG5cbiAgICByZXR1cm4gbW9kZU9ialxuICB9XG5cbiAgLy8gVGhpcyBjYW4gYmUgdXNlZCB0byBhdHRhY2ggcHJvcGVydGllcyB0byBtb2RlIG9iamVjdHMgZnJvbVxuICAvLyBvdXRzaWRlIHRoZSBhY3R1YWwgbW9kZSBkZWZpbml0aW9uLlxuICB2YXIgbW9kZUV4dGVuc2lvbnMgPSB7fTtcbiAgZnVuY3Rpb24gZXh0ZW5kTW9kZShtb2RlLCBwcm9wZXJ0aWVzKSB7XG4gICAgdmFyIGV4dHMgPSBtb2RlRXh0ZW5zaW9ucy5oYXNPd25Qcm9wZXJ0eShtb2RlKSA/IG1vZGVFeHRlbnNpb25zW21vZGVdIDogKG1vZGVFeHRlbnNpb25zW21vZGVdID0ge30pO1xuICAgIGNvcHlPYmoocHJvcGVydGllcywgZXh0cyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5U3RhdGUobW9kZSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IHRydWUpIHsgcmV0dXJuIHN0YXRlIH1cbiAgICBpZiAobW9kZS5jb3B5U3RhdGUpIHsgcmV0dXJuIG1vZGUuY29weVN0YXRlKHN0YXRlKSB9XG4gICAgdmFyIG5zdGF0ZSA9IHt9O1xuICAgIGZvciAodmFyIG4gaW4gc3RhdGUpIHtcbiAgICAgIHZhciB2YWwgPSBzdGF0ZVtuXTtcbiAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheSkgeyB2YWwgPSB2YWwuY29uY2F0KFtdKTsgfVxuICAgICAgbnN0YXRlW25dID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gbnN0YXRlXG4gIH1cblxuICAvLyBHaXZlbiBhIG1vZGUgYW5kIGEgc3RhdGUgKGZvciB0aGF0IG1vZGUpLCBmaW5kIHRoZSBpbm5lciBtb2RlIGFuZFxuICAvLyBzdGF0ZSBhdCB0aGUgcG9zaXRpb24gdGhhdCB0aGUgc3RhdGUgcmVmZXJzIHRvLlxuICBmdW5jdGlvbiBpbm5lck1vZGUobW9kZSwgc3RhdGUpIHtcbiAgICB2YXIgaW5mbztcbiAgICB3aGlsZSAobW9kZS5pbm5lck1vZGUpIHtcbiAgICAgIGluZm8gPSBtb2RlLmlubmVyTW9kZShzdGF0ZSk7XG4gICAgICBpZiAoIWluZm8gfHwgaW5mby5tb2RlID09IG1vZGUpIHsgYnJlYWsgfVxuICAgICAgc3RhdGUgPSBpbmZvLnN0YXRlO1xuICAgICAgbW9kZSA9IGluZm8ubW9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGluZm8gfHwge21vZGU6IG1vZGUsIHN0YXRlOiBzdGF0ZX1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN0YXJ0U3RhdGUobW9kZSwgYTEsIGEyKSB7XG4gICAgcmV0dXJuIG1vZGUuc3RhcnRTdGF0ZSA/IG1vZGUuc3RhcnRTdGF0ZShhMSwgYTIpIDogdHJ1ZVxuICB9XG5cbiAgLy8gU1RSSU5HIFNUUkVBTVxuXG4gIC8vIEZlZCB0byB0aGUgbW9kZSBwYXJzZXJzLCBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIG1ha2VcbiAgLy8gcGFyc2VycyBtb3JlIHN1Y2NpbmN0LlxuXG4gIHZhciBTdHJpbmdTdHJlYW0gPSBmdW5jdGlvbihzdHJpbmcsIHRhYlNpemUsIGxpbmVPcmFjbGUpIHtcbiAgICB0aGlzLnBvcyA9IHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIHRoaXMudGFiU2l6ZSA9IHRhYlNpemUgfHwgODtcbiAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDA7XG4gICAgdGhpcy5saW5lU3RhcnQgPSAwO1xuICAgIHRoaXMubGluZU9yYWNsZSA9IGxpbmVPcmFjbGU7XG4gIH07XG5cbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lb2wgPSBmdW5jdGlvbiAoKSB7cmV0dXJuIHRoaXMucG9zID49IHRoaXMuc3RyaW5nLmxlbmd0aH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuc29sID0gZnVuY3Rpb24gKCkge3JldHVybiB0aGlzLnBvcyA9PSB0aGlzLmxpbmVTdGFydH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUucGVlayA9IGZ1bmN0aW9uICgpIHtyZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSB8fCB1bmRlZmluZWR9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucG9zIDwgdGhpcy5zdHJpbmcubGVuZ3RoKVxuICAgICAgeyByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspIH1cbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5lYXQgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICB2YXIgY2ggPSB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpO1xuICAgIHZhciBvaztcbiAgICBpZiAodHlwZW9mIG1hdGNoID09IFwic3RyaW5nXCIpIHsgb2sgPSBjaCA9PSBtYXRjaDsgfVxuICAgIGVsc2UgeyBvayA9IGNoICYmIChtYXRjaC50ZXN0ID8gbWF0Y2gudGVzdChjaCkgOiBtYXRjaChjaCkpOyB9XG4gICAgaWYgKG9rKSB7Kyt0aGlzLnBvczsgcmV0dXJuIGNofVxuICB9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmVhdFdoaWxlID0gZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgd2hpbGUgKHRoaXMuZWF0KG1hdGNoKSl7fVxuICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuZWF0U3BhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgd2hpbGUgKC9bXFxzXFx1MDBhMF0vLnRlc3QodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKSkpIHsgKyt0aGlzLnBvczsgfVxuICAgIHJldHVybiB0aGlzLnBvcyA+IHN0YXJ0XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuc2tpcFRvRW5kID0gZnVuY3Rpb24gKCkge3RoaXMucG9zID0gdGhpcy5zdHJpbmcubGVuZ3RoO307XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuc2tpcFRvID0gZnVuY3Rpb24gKGNoKSB7XG4gICAgdmFyIGZvdW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihjaCwgdGhpcy5wb3MpO1xuICAgIGlmIChmb3VuZCA+IC0xKSB7dGhpcy5wb3MgPSBmb3VuZDsgcmV0dXJuIHRydWV9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuYmFja1VwID0gZnVuY3Rpb24gKG4pIHt0aGlzLnBvcyAtPSBuO307XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuY29sdW1uID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmxhc3RDb2x1bW5Qb3MgPCB0aGlzLnN0YXJ0KSB7XG4gICAgICB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IGNvdW50Q29sdW1uKHRoaXMuc3RyaW5nLCB0aGlzLnN0YXJ0LCB0aGlzLnRhYlNpemUsIHRoaXMubGFzdENvbHVtblBvcywgdGhpcy5sYXN0Q29sdW1uVmFsdWUpO1xuICAgICAgdGhpcy5sYXN0Q29sdW1uUG9zID0gdGhpcy5zdGFydDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubGFzdENvbHVtblZhbHVlIC0gKHRoaXMubGluZVN0YXJ0ID8gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMubGluZVN0YXJ0LCB0aGlzLnRhYlNpemUpIDogMClcbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5pbmRlbnRhdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIG51bGwsIHRoaXMudGFiU2l6ZSkgLVxuICAgICAgKHRoaXMubGluZVN0YXJ0ID8gY291bnRDb2x1bW4odGhpcy5zdHJpbmcsIHRoaXMubGluZVN0YXJ0LCB0aGlzLnRhYlNpemUpIDogMClcbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5tYXRjaCA9IGZ1bmN0aW9uIChwYXR0ZXJuLCBjb25zdW1lLCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICBpZiAodHlwZW9mIHBhdHRlcm4gPT0gXCJzdHJpbmdcIikge1xuICAgICAgdmFyIGNhc2VkID0gZnVuY3Rpb24gKHN0cikgeyByZXR1cm4gY2FzZUluc2Vuc2l0aXZlID8gc3RyLnRvTG93ZXJDYXNlKCkgOiBzdHI7IH07XG4gICAgICB2YXIgc3Vic3RyID0gdGhpcy5zdHJpbmcuc3Vic3RyKHRoaXMucG9zLCBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgICBpZiAoY2FzZWQoc3Vic3RyKSA9PSBjYXNlZChwYXR0ZXJuKSkge1xuICAgICAgICBpZiAoY29uc3VtZSAhPT0gZmFsc2UpIHsgdGhpcy5wb3MgKz0gcGF0dGVybi5sZW5ndGg7IH1cbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG1hdGNoID0gdGhpcy5zdHJpbmcuc2xpY2UodGhpcy5wb3MpLm1hdGNoKHBhdHRlcm4pO1xuICAgICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4ID4gMCkgeyByZXR1cm4gbnVsbCB9XG4gICAgICBpZiAobWF0Y2ggJiYgY29uc3VtZSAhPT0gZmFsc2UpIHsgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoOyB9XG4gICAgICByZXR1cm4gbWF0Y2hcbiAgICB9XG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uICgpe3JldHVybiB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcyl9O1xuICBTdHJpbmdTdHJlYW0ucHJvdG90eXBlLmhpZGVGaXJzdENoYXJzID0gZnVuY3Rpb24gKG4sIGlubmVyKSB7XG4gICAgdGhpcy5saW5lU3RhcnQgKz0gbjtcbiAgICB0cnkgeyByZXR1cm4gaW5uZXIoKSB9XG4gICAgZmluYWxseSB7IHRoaXMubGluZVN0YXJ0IC09IG47IH1cbiAgfTtcbiAgU3RyaW5nU3RyZWFtLnByb3RvdHlwZS5sb29rQWhlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIHZhciBvcmFjbGUgPSB0aGlzLmxpbmVPcmFjbGU7XG4gICAgcmV0dXJuIG9yYWNsZSAmJiBvcmFjbGUubG9va0FoZWFkKG4pXG4gIH07XG4gIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuYmFzZVRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvcmFjbGUgPSB0aGlzLmxpbmVPcmFjbGU7XG4gICAgcmV0dXJuIG9yYWNsZSAmJiBvcmFjbGUuYmFzZVRva2VuKHRoaXMucG9zKVxuICB9O1xuXG4gIC8vIEZpbmQgdGhlIGxpbmUgb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxpbmUgbnVtYmVyLlxuICBmdW5jdGlvbiBnZXRMaW5lKGRvYywgbikge1xuICAgIG4gLT0gZG9jLmZpcnN0O1xuICAgIGlmIChuIDwgMCB8fCBuID49IGRvYy5zaXplKSB7IHRocm93IG5ldyBFcnJvcihcIlRoZXJlIGlzIG5vIGxpbmUgXCIgKyAobiArIGRvYy5maXJzdCkgKyBcIiBpbiB0aGUgZG9jdW1lbnQuXCIpIH1cbiAgICB2YXIgY2h1bmsgPSBkb2M7XG4gICAgd2hpbGUgKCFjaHVuay5saW5lcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7OyArK2kpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gY2h1bmsuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChuIDwgc3opIHsgY2h1bmsgPSBjaGlsZDsgYnJlYWsgfVxuICAgICAgICBuIC09IHN6O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2h1bmsubGluZXNbbl1cbiAgfVxuXG4gIC8vIEdldCB0aGUgcGFydCBvZiBhIGRvY3VtZW50IGJldHdlZW4gdHdvIHBvc2l0aW9ucywgYXMgYW4gYXJyYXkgb2ZcbiAgLy8gc3RyaW5ncy5cbiAgZnVuY3Rpb24gZ2V0QmV0d2Vlbihkb2MsIHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgb3V0ID0gW10sIG4gPSBzdGFydC5saW5lO1xuICAgIGRvYy5pdGVyKHN0YXJ0LmxpbmUsIGVuZC5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHZhciB0ZXh0ID0gbGluZS50ZXh0O1xuICAgICAgaWYgKG4gPT0gZW5kLmxpbmUpIHsgdGV4dCA9IHRleHQuc2xpY2UoMCwgZW5kLmNoKTsgfVxuICAgICAgaWYgKG4gPT0gc3RhcnQubGluZSkgeyB0ZXh0ID0gdGV4dC5zbGljZShzdGFydC5jaCk7IH1cbiAgICAgIG91dC5wdXNoKHRleHQpO1xuICAgICAgKytuO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXRcbiAgfVxuICAvLyBHZXQgdGhlIGxpbmVzIGJldHdlZW4gZnJvbSBhbmQgdG8sIGFzIGFycmF5IG9mIHN0cmluZ3MuXG4gIGZ1bmN0aW9uIGdldExpbmVzKGRvYywgZnJvbSwgdG8pIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZG9jLml0ZXIoZnJvbSwgdG8sIGZ1bmN0aW9uIChsaW5lKSB7IG91dC5wdXNoKGxpbmUudGV4dCk7IH0pOyAvLyBpdGVyIGFib3J0cyB3aGVuIGNhbGxiYWNrIHJldHVybnMgdHJ1dGh5IHZhbHVlXG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgLy8gVXBkYXRlIHRoZSBoZWlnaHQgb2YgYSBsaW5lLCBwcm9wYWdhdGluZyB0aGUgaGVpZ2h0IGNoYW5nZVxuICAvLyB1cHdhcmRzIHRvIHBhcmVudCBub2Rlcy5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZUhlaWdodChsaW5lLCBoZWlnaHQpIHtcbiAgICB2YXIgZGlmZiA9IGhlaWdodCAtIGxpbmUuaGVpZ2h0O1xuICAgIGlmIChkaWZmKSB7IGZvciAodmFyIG4gPSBsaW5lOyBuOyBuID0gbi5wYXJlbnQpIHsgbi5oZWlnaHQgKz0gZGlmZjsgfSB9XG4gIH1cblxuICAvLyBHaXZlbiBhIGxpbmUgb2JqZWN0LCBmaW5kIGl0cyBsaW5lIG51bWJlciBieSB3YWxraW5nIHVwIHRocm91Z2hcbiAgLy8gaXRzIHBhcmVudCBsaW5rcy5cbiAgZnVuY3Rpb24gbGluZU5vKGxpbmUpIHtcbiAgICBpZiAobGluZS5wYXJlbnQgPT0gbnVsbCkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGN1ciA9IGxpbmUucGFyZW50LCBubyA9IGluZGV4T2YoY3VyLmxpbmVzLCBsaW5lKTtcbiAgICBmb3IgKHZhciBjaHVuayA9IGN1ci5wYXJlbnQ7IGNodW5rOyBjdXIgPSBjaHVuaywgY2h1bmsgPSBjaHVuay5wYXJlbnQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOzsgKytpKSB7XG4gICAgICAgIGlmIChjaHVuay5jaGlsZHJlbltpXSA9PSBjdXIpIHsgYnJlYWsgfVxuICAgICAgICBubyArPSBjaHVuay5jaGlsZHJlbltpXS5jaHVua1NpemUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vICsgY3VyLmZpcnN0XG4gIH1cblxuICAvLyBGaW5kIHRoZSBsaW5lIGF0IHRoZSBnaXZlbiB2ZXJ0aWNhbCBwb3NpdGlvbiwgdXNpbmcgdGhlIGhlaWdodFxuICAvLyBpbmZvcm1hdGlvbiBpbiB0aGUgZG9jdW1lbnQgdHJlZS5cbiAgZnVuY3Rpb24gbGluZUF0SGVpZ2h0KGNodW5rLCBoKSB7XG4gICAgdmFyIG4gPSBjaHVuay5maXJzdDtcbiAgICBvdXRlcjogZG8ge1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2h1bmsuY2hpbGRyZW4ubGVuZ3RoOyArK2kkMSkge1xuICAgICAgICB2YXIgY2hpbGQgPSBjaHVuay5jaGlsZHJlbltpJDFdLCBjaCA9IGNoaWxkLmhlaWdodDtcbiAgICAgICAgaWYgKGggPCBjaCkgeyBjaHVuayA9IGNoaWxkOyBjb250aW51ZSBvdXRlciB9XG4gICAgICAgIGggLT0gY2g7XG4gICAgICAgIG4gKz0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gblxuICAgIH0gd2hpbGUgKCFjaHVuay5saW5lcylcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBjaHVuay5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmUgPSBjaHVuay5saW5lc1tpXSwgbGggPSBsaW5lLmhlaWdodDtcbiAgICAgIGlmIChoIDwgbGgpIHsgYnJlYWsgfVxuICAgICAgaCAtPSBsaDtcbiAgICB9XG4gICAgcmV0dXJuIG4gKyBpXG4gIH1cblxuICBmdW5jdGlvbiBpc0xpbmUoZG9jLCBsKSB7cmV0dXJuIGwgPj0gZG9jLmZpcnN0ICYmIGwgPCBkb2MuZmlyc3QgKyBkb2Muc2l6ZX1cblxuICBmdW5jdGlvbiBsaW5lTnVtYmVyRm9yKG9wdGlvbnMsIGkpIHtcbiAgICByZXR1cm4gU3RyaW5nKG9wdGlvbnMubGluZU51bWJlckZvcm1hdHRlcihpICsgb3B0aW9ucy5maXJzdExpbmVOdW1iZXIpKVxuICB9XG5cbiAgLy8gQSBQb3MgaW5zdGFuY2UgcmVwcmVzZW50cyBhIHBvc2l0aW9uIHdpdGhpbiB0aGUgdGV4dC5cbiAgZnVuY3Rpb24gUG9zKGxpbmUsIGNoLCBzdGlja3kpIHtcbiAgICBpZiAoIHN0aWNreSA9PT0gdm9pZCAwICkgc3RpY2t5ID0gbnVsbDtcblxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQb3MpKSB7IHJldHVybiBuZXcgUG9zKGxpbmUsIGNoLCBzdGlja3kpIH1cbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIHRoaXMuY2ggPSBjaDtcbiAgICB0aGlzLnN0aWNreSA9IHN0aWNreTtcbiAgfVxuXG4gIC8vIENvbXBhcmUgdHdvIHBvc2l0aW9ucywgcmV0dXJuIDAgaWYgdGhleSBhcmUgdGhlIHNhbWUsIGEgbmVnYXRpdmVcbiAgLy8gbnVtYmVyIHdoZW4gYSBpcyBsZXNzLCBhbmQgYSBwb3NpdGl2ZSBudW1iZXIgb3RoZXJ3aXNlLlxuICBmdW5jdGlvbiBjbXAoYSwgYikgeyByZXR1cm4gYS5saW5lIC0gYi5saW5lIHx8IGEuY2ggLSBiLmNoIH1cblxuICBmdW5jdGlvbiBlcXVhbEN1cnNvclBvcyhhLCBiKSB7IHJldHVybiBhLnN0aWNreSA9PSBiLnN0aWNreSAmJiBjbXAoYSwgYikgPT0gMCB9XG5cbiAgZnVuY3Rpb24gY29weVBvcyh4KSB7cmV0dXJuIFBvcyh4LmxpbmUsIHguY2gpfVxuICBmdW5jdGlvbiBtYXhQb3MoYSwgYikgeyByZXR1cm4gY21wKGEsIGIpIDwgMCA/IGIgOiBhIH1cbiAgZnVuY3Rpb24gbWluUG9zKGEsIGIpIHsgcmV0dXJuIGNtcChhLCBiKSA8IDAgPyBhIDogYiB9XG5cbiAgLy8gTW9zdCBvZiB0aGUgZXh0ZXJuYWwgQVBJIGNsaXBzIGdpdmVuIHBvc2l0aW9ucyB0byBtYWtlIHN1cmUgdGhleVxuICAvLyBhY3R1YWxseSBleGlzdCB3aXRoaW4gdGhlIGRvY3VtZW50LlxuICBmdW5jdGlvbiBjbGlwTGluZShkb2MsIG4pIHtyZXR1cm4gTWF0aC5tYXgoZG9jLmZpcnN0LCBNYXRoLm1pbihuLCBkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEpKX1cbiAgZnVuY3Rpb24gY2xpcFBvcyhkb2MsIHBvcykge1xuICAgIGlmIChwb3MubGluZSA8IGRvYy5maXJzdCkgeyByZXR1cm4gUG9zKGRvYy5maXJzdCwgMCkgfVxuICAgIHZhciBsYXN0ID0gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxO1xuICAgIGlmIChwb3MubGluZSA+IGxhc3QpIHsgcmV0dXJuIFBvcyhsYXN0LCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgpIH1cbiAgICByZXR1cm4gY2xpcFRvTGVuKHBvcywgZ2V0TGluZShkb2MsIHBvcy5saW5lKS50ZXh0Lmxlbmd0aClcbiAgfVxuICBmdW5jdGlvbiBjbGlwVG9MZW4ocG9zLCBsaW5lbGVuKSB7XG4gICAgdmFyIGNoID0gcG9zLmNoO1xuICAgIGlmIChjaCA9PSBudWxsIHx8IGNoID4gbGluZWxlbikgeyByZXR1cm4gUG9zKHBvcy5saW5lLCBsaW5lbGVuKSB9XG4gICAgZWxzZSBpZiAoY2ggPCAwKSB7IHJldHVybiBQb3MocG9zLmxpbmUsIDApIH1cbiAgICBlbHNlIHsgcmV0dXJuIHBvcyB9XG4gIH1cbiAgZnVuY3Rpb24gY2xpcFBvc0FycmF5KGRvYywgYXJyYXkpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykgeyBvdXRbaV0gPSBjbGlwUG9zKGRvYywgYXJyYXlbaV0pOyB9XG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgdmFyIFNhdmVkQ29udGV4dCA9IGZ1bmN0aW9uKHN0YXRlLCBsb29rQWhlYWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gIH07XG5cbiAgdmFyIENvbnRleHQgPSBmdW5jdGlvbihkb2MsIHN0YXRlLCBsaW5lLCBsb29rQWhlYWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLm1heExvb2tBaGVhZCA9IGxvb2tBaGVhZCB8fCAwO1xuICAgIHRoaXMuYmFzZVRva2VucyA9IG51bGw7XG4gICAgdGhpcy5iYXNlVG9rZW5Qb3MgPSAxO1xuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLmxvb2tBaGVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgdmFyIGxpbmUgPSB0aGlzLmRvYy5nZXRMaW5lKHRoaXMubGluZSArIG4pO1xuICAgIGlmIChsaW5lICE9IG51bGwgJiYgbiA+IHRoaXMubWF4TG9va0FoZWFkKSB7IHRoaXMubWF4TG9va0FoZWFkID0gbjsgfVxuICAgIHJldHVybiBsaW5lXG4gIH07XG5cbiAgQ29udGV4dC5wcm90b3R5cGUuYmFzZVRva2VuID0gZnVuY3Rpb24gKG4pIHtcbiAgICBpZiAoIXRoaXMuYmFzZVRva2VucykgeyByZXR1cm4gbnVsbCB9XG4gICAgd2hpbGUgKHRoaXMuYmFzZVRva2Vuc1t0aGlzLmJhc2VUb2tlblBvc10gPD0gbilcbiAgICAgIHsgdGhpcy5iYXNlVG9rZW5Qb3MgKz0gMjsgfVxuICAgIHZhciB0eXBlID0gdGhpcy5iYXNlVG9rZW5zW3RoaXMuYmFzZVRva2VuUG9zICsgMV07XG4gICAgcmV0dXJuIHt0eXBlOiB0eXBlICYmIHR5cGUucmVwbGFjZSgvKCB8XilvdmVybGF5IC4qLywgXCJcIiksXG4gICAgICAgICAgICBzaXplOiB0aGlzLmJhc2VUb2tlbnNbdGhpcy5iYXNlVG9rZW5Qb3NdIC0gbn1cbiAgfTtcblxuICBDb250ZXh0LnByb3RvdHlwZS5uZXh0TGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxpbmUrKztcbiAgICBpZiAodGhpcy5tYXhMb29rQWhlYWQgPiAwKSB7IHRoaXMubWF4TG9va0FoZWFkLS07IH1cbiAgfTtcblxuICBDb250ZXh0LmZyb21TYXZlZCA9IGZ1bmN0aW9uIChkb2MsIHNhdmVkLCBsaW5lKSB7XG4gICAgaWYgKHNhdmVkIGluc3RhbmNlb2YgU2F2ZWRDb250ZXh0KVxuICAgICAgeyByZXR1cm4gbmV3IENvbnRleHQoZG9jLCBjb3B5U3RhdGUoZG9jLm1vZGUsIHNhdmVkLnN0YXRlKSwgbGluZSwgc2F2ZWQubG9va0FoZWFkKSB9XG4gICAgZWxzZVxuICAgICAgeyByZXR1cm4gbmV3IENvbnRleHQoZG9jLCBjb3B5U3RhdGUoZG9jLm1vZGUsIHNhdmVkKSwgbGluZSkgfVxuICB9O1xuXG4gIENvbnRleHQucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoY29weSkge1xuICAgIHZhciBzdGF0ZSA9IGNvcHkgIT09IGZhbHNlID8gY29weVN0YXRlKHRoaXMuZG9jLm1vZGUsIHRoaXMuc3RhdGUpIDogdGhpcy5zdGF0ZTtcbiAgICByZXR1cm4gdGhpcy5tYXhMb29rQWhlYWQgPiAwID8gbmV3IFNhdmVkQ29udGV4dChzdGF0ZSwgdGhpcy5tYXhMb29rQWhlYWQpIDogc3RhdGVcbiAgfTtcblxuXG4gIC8vIENvbXB1dGUgYSBzdHlsZSBhcnJheSAoYW4gYXJyYXkgc3RhcnRpbmcgd2l0aCBhIG1vZGUgZ2VuZXJhdGlvblxuICAvLyAtLSBmb3IgaW52YWxpZGF0aW9uIC0tIGZvbGxvd2VkIGJ5IHBhaXJzIG9mIGVuZCBwb3NpdGlvbnMgYW5kXG4gIC8vIHN0eWxlIHN0cmluZ3MpLCB3aGljaCBpcyB1c2VkIHRvIGhpZ2hsaWdodCB0aGUgdG9rZW5zIG9uIHRoZVxuICAvLyBsaW5lLlxuICBmdW5jdGlvbiBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBjb250ZXh0LCBmb3JjZVRvRW5kKSB7XG4gICAgLy8gQSBzdHlsZXMgYXJyYXkgYWx3YXlzIHN0YXJ0cyB3aXRoIGEgbnVtYmVyIGlkZW50aWZ5aW5nIHRoZVxuICAgIC8vIG1vZGUvb3ZlcmxheXMgdGhhdCBpdCBpcyBiYXNlZCBvbiAoZm9yIGVhc3kgaW52YWxpZGF0aW9uKS5cbiAgICB2YXIgc3QgPSBbY20uc3RhdGUubW9kZUdlbl0sIGxpbmVDbGFzc2VzID0ge307XG4gICAgLy8gQ29tcHV0ZSB0aGUgYmFzZSBhcnJheSBvZiBzdHlsZXNcbiAgICBydW5Nb2RlKGNtLCBsaW5lLnRleHQsIGNtLmRvYy5tb2RlLCBjb250ZXh0LCBmdW5jdGlvbiAoZW5kLCBzdHlsZSkgeyByZXR1cm4gc3QucHVzaChlbmQsIHN0eWxlKTsgfSxcbiAgICAgICAgICAgIGxpbmVDbGFzc2VzLCBmb3JjZVRvRW5kKTtcbiAgICB2YXIgc3RhdGUgPSBjb250ZXh0LnN0YXRlO1xuXG4gICAgLy8gUnVuIG92ZXJsYXlzLCBhZGp1c3Qgc3R5bGUgYXJyYXkuXG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIG8gKSB7XG4gICAgICBjb250ZXh0LmJhc2VUb2tlbnMgPSBzdDtcbiAgICAgIHZhciBvdmVybGF5ID0gY20uc3RhdGUub3ZlcmxheXNbb10sIGkgPSAxLCBhdCA9IDA7XG4gICAgICBjb250ZXh0LnN0YXRlID0gdHJ1ZTtcbiAgICAgIHJ1bk1vZGUoY20sIGxpbmUudGV4dCwgb3ZlcmxheS5tb2RlLCBjb250ZXh0LCBmdW5jdGlvbiAoZW5kLCBzdHlsZSkge1xuICAgICAgICB2YXIgc3RhcnQgPSBpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlcmUncyBhIHRva2VuIGVuZCBhdCB0aGUgY3VycmVudCBwb3NpdGlvbiwgYW5kIHRoYXQgaSBwb2ludHMgYXQgaXRcbiAgICAgICAgd2hpbGUgKGF0IDwgZW5kKSB7XG4gICAgICAgICAgdmFyIGlfZW5kID0gc3RbaV07XG4gICAgICAgICAgaWYgKGlfZW5kID4gZW5kKVxuICAgICAgICAgICAgeyBzdC5zcGxpY2UoaSwgMSwgZW5kLCBzdFtpKzFdLCBpX2VuZCk7IH1cbiAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgYXQgPSBNYXRoLm1pbihlbmQsIGlfZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0eWxlKSB7IHJldHVybiB9XG4gICAgICAgIGlmIChvdmVybGF5Lm9wYXF1ZSkge1xuICAgICAgICAgIHN0LnNwbGljZShzdGFydCwgaSAtIHN0YXJ0LCBlbmQsIFwib3ZlcmxheSBcIiArIHN0eWxlKTtcbiAgICAgICAgICBpID0gc3RhcnQgKyAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoOyBzdGFydCA8IGk7IHN0YXJ0ICs9IDIpIHtcbiAgICAgICAgICAgIHZhciBjdXIgPSBzdFtzdGFydCsxXTtcbiAgICAgICAgICAgIHN0W3N0YXJ0KzFdID0gKGN1ciA/IGN1ciArIFwiIFwiIDogXCJcIikgKyBcIm92ZXJsYXkgXCIgKyBzdHlsZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sIGxpbmVDbGFzc2VzKTtcbiAgICAgIGNvbnRleHQuc3RhdGUgPSBzdGF0ZTtcbiAgICAgIGNvbnRleHQuYmFzZVRva2VucyA9IG51bGw7XG4gICAgICBjb250ZXh0LmJhc2VUb2tlblBvcyA9IDE7XG4gICAgfTtcblxuICAgIGZvciAodmFyIG8gPSAwOyBvIDwgY20uc3RhdGUub3ZlcmxheXMubGVuZ3RoOyArK28pIGxvb3AoIG8gKTtcblxuICAgIHJldHVybiB7c3R5bGVzOiBzdCwgY2xhc3NlczogbGluZUNsYXNzZXMuYmdDbGFzcyB8fCBsaW5lQ2xhc3Nlcy50ZXh0Q2xhc3MgPyBsaW5lQ2xhc3NlcyA6IG51bGx9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMaW5lU3R5bGVzKGNtLCBsaW5lLCB1cGRhdGVGcm9udGllcikge1xuICAgIGlmICghbGluZS5zdHlsZXMgfHwgbGluZS5zdHlsZXNbMF0gIT0gY20uc3RhdGUubW9kZUdlbikge1xuICAgICAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0QmVmb3JlKGNtLCBsaW5lTm8obGluZSkpO1xuICAgICAgdmFyIHJlc2V0U3RhdGUgPSBsaW5lLnRleHQubGVuZ3RoID4gY20ub3B0aW9ucy5tYXhIaWdobGlnaHRMZW5ndGggJiYgY29weVN0YXRlKGNtLmRvYy5tb2RlLCBjb250ZXh0LnN0YXRlKTtcbiAgICAgIHZhciByZXN1bHQgPSBoaWdobGlnaHRMaW5lKGNtLCBsaW5lLCBjb250ZXh0KTtcbiAgICAgIGlmIChyZXNldFN0YXRlKSB7IGNvbnRleHQuc3RhdGUgPSByZXNldFN0YXRlOyB9XG4gICAgICBsaW5lLnN0YXRlQWZ0ZXIgPSBjb250ZXh0LnNhdmUoIXJlc2V0U3RhdGUpO1xuICAgICAgbGluZS5zdHlsZXMgPSByZXN1bHQuc3R5bGVzO1xuICAgICAgaWYgKHJlc3VsdC5jbGFzc2VzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gcmVzdWx0LmNsYXNzZXM7IH1cbiAgICAgIGVsc2UgaWYgKGxpbmUuc3R5bGVDbGFzc2VzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gbnVsbDsgfVxuICAgICAgaWYgKHVwZGF0ZUZyb250aWVyID09PSBjbS5kb2MuaGlnaGxpZ2h0RnJvbnRpZXIpXG4gICAgICAgIHsgY20uZG9jLm1vZGVGcm9udGllciA9IE1hdGgubWF4KGNtLmRvYy5tb2RlRnJvbnRpZXIsICsrY20uZG9jLmhpZ2hsaWdodEZyb250aWVyKTsgfVxuICAgIH1cbiAgICByZXR1cm4gbGluZS5zdHlsZXNcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbnRleHRCZWZvcmUoY20sIG4sIHByZWNpc2UpIHtcbiAgICB2YXIgZG9jID0gY20uZG9jLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoIWRvYy5tb2RlLnN0YXJ0U3RhdGUpIHsgcmV0dXJuIG5ldyBDb250ZXh0KGRvYywgdHJ1ZSwgbikgfVxuICAgIHZhciBzdGFydCA9IGZpbmRTdGFydExpbmUoY20sIG4sIHByZWNpc2UpO1xuICAgIHZhciBzYXZlZCA9IHN0YXJ0ID4gZG9jLmZpcnN0ICYmIGdldExpbmUoZG9jLCBzdGFydCAtIDEpLnN0YXRlQWZ0ZXI7XG4gICAgdmFyIGNvbnRleHQgPSBzYXZlZCA/IENvbnRleHQuZnJvbVNhdmVkKGRvYywgc2F2ZWQsIHN0YXJ0KSA6IG5ldyBDb250ZXh0KGRvYywgc3RhcnRTdGF0ZShkb2MubW9kZSksIHN0YXJ0KTtcblxuICAgIGRvYy5pdGVyKHN0YXJ0LCBuLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgcHJvY2Vzc0xpbmUoY20sIGxpbmUudGV4dCwgY29udGV4dCk7XG4gICAgICB2YXIgcG9zID0gY29udGV4dC5saW5lO1xuICAgICAgbGluZS5zdGF0ZUFmdGVyID0gcG9zID09IG4gLSAxIHx8IHBvcyAlIDUgPT0gMCB8fCBwb3MgPj0gZGlzcGxheS52aWV3RnJvbSAmJiBwb3MgPCBkaXNwbGF5LnZpZXdUbyA/IGNvbnRleHQuc2F2ZSgpIDogbnVsbDtcbiAgICAgIGNvbnRleHQubmV4dExpbmUoKTtcbiAgICB9KTtcbiAgICBpZiAocHJlY2lzZSkgeyBkb2MubW9kZUZyb250aWVyID0gY29udGV4dC5saW5lOyB9XG4gICAgcmV0dXJuIGNvbnRleHRcbiAgfVxuXG4gIC8vIExpZ2h0d2VpZ2h0IGZvcm0gb2YgaGlnaGxpZ2h0IC0tIHByb2NlZWQgb3ZlciB0aGlzIGxpbmUgYW5kXG4gIC8vIHVwZGF0ZSBzdGF0ZSwgYnV0IGRvbid0IHNhdmUgYSBzdHlsZSBhcnJheS4gVXNlZCBmb3IgbGluZXMgdGhhdFxuICAvLyBhcmVuJ3QgY3VycmVudGx5IHZpc2libGUuXG4gIGZ1bmN0aW9uIHByb2Nlc3NMaW5lKGNtLCB0ZXh0LCBjb250ZXh0LCBzdGFydEF0KSB7XG4gICAgdmFyIG1vZGUgPSBjbS5kb2MubW9kZTtcbiAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmluZ1N0cmVhbSh0ZXh0LCBjbS5vcHRpb25zLnRhYlNpemUsIGNvbnRleHQpO1xuICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3MgPSBzdGFydEF0IHx8IDA7XG4gICAgaWYgKHRleHQgPT0gXCJcIikgeyBjYWxsQmxhbmtMaW5lKG1vZGUsIGNvbnRleHQuc3RhdGUpOyB9XG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIGNvbnRleHQuc3RhdGUpO1xuICAgICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQmxhbmtMaW5lKG1vZGUsIHN0YXRlKSB7XG4gICAgaWYgKG1vZGUuYmxhbmtMaW5lKSB7IHJldHVybiBtb2RlLmJsYW5rTGluZShzdGF0ZSkgfVxuICAgIGlmICghbW9kZS5pbm5lck1vZGUpIHsgcmV0dXJuIH1cbiAgICB2YXIgaW5uZXIgPSBpbm5lck1vZGUobW9kZSwgc3RhdGUpO1xuICAgIGlmIChpbm5lci5tb2RlLmJsYW5rTGluZSkgeyByZXR1cm4gaW5uZXIubW9kZS5ibGFua0xpbmUoaW5uZXIuc3RhdGUpIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIHN0YXRlLCBpbm5lcikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgaWYgKGlubmVyKSB7IGlubmVyWzBdID0gaW5uZXJNb2RlKG1vZGUsIHN0YXRlKS5tb2RlOyB9XG4gICAgICB2YXIgc3R5bGUgPSBtb2RlLnRva2VuKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgaWYgKHN0cmVhbS5wb3MgPiBzdHJlYW0uc3RhcnQpIHsgcmV0dXJuIHN0eWxlIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTW9kZSBcIiArIG1vZGUubmFtZSArIFwiIGZhaWxlZCB0byBhZHZhbmNlIHN0cmVhbS5cIilcbiAgfVxuXG4gIHZhciBUb2tlbiA9IGZ1bmN0aW9uKHN0cmVhbSwgdHlwZSwgc3RhdGUpIHtcbiAgICB0aGlzLnN0YXJ0ID0gc3RyZWFtLnN0YXJ0OyB0aGlzLmVuZCA9IHN0cmVhbS5wb3M7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJlYW0uY3VycmVudCgpO1xuICAgIHRoaXMudHlwZSA9IHR5cGUgfHwgbnVsbDtcbiAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBmb3IgZ2V0VG9rZW5BdCBhbmQgZ2V0TGluZVRva2Vuc1xuICBmdW5jdGlvbiB0YWtlVG9rZW4oY20sIHBvcywgcHJlY2lzZSwgYXNBcnJheSkge1xuICAgIHZhciBkb2MgPSBjbS5kb2MsIG1vZGUgPSBkb2MubW9kZSwgc3R5bGU7XG4gICAgcG9zID0gY2xpcFBvcyhkb2MsIHBvcyk7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpLCBjb250ZXh0ID0gZ2V0Q29udGV4dEJlZm9yZShjbSwgcG9zLmxpbmUsIHByZWNpc2UpO1xuICAgIHZhciBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUudGV4dCwgY20ub3B0aW9ucy50YWJTaXplLCBjb250ZXh0KSwgdG9rZW5zO1xuICAgIGlmIChhc0FycmF5KSB7IHRva2VucyA9IFtdOyB9XG4gICAgd2hpbGUgKChhc0FycmF5IHx8IHN0cmVhbS5wb3MgPCBwb3MuY2gpICYmICFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIHN0cmVhbS5zdGFydCA9IHN0cmVhbS5wb3M7XG4gICAgICBzdHlsZSA9IHJlYWRUb2tlbihtb2RlLCBzdHJlYW0sIGNvbnRleHQuc3RhdGUpO1xuICAgICAgaWYgKGFzQXJyYXkpIHsgdG9rZW5zLnB1c2gobmV3IFRva2VuKHN0cmVhbSwgc3R5bGUsIGNvcHlTdGF0ZShkb2MubW9kZSwgY29udGV4dC5zdGF0ZSkpKTsgfVxuICAgIH1cbiAgICByZXR1cm4gYXNBcnJheSA/IHRva2VucyA6IG5ldyBUb2tlbihzdHJlYW0sIHN0eWxlLCBjb250ZXh0LnN0YXRlKVxuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdExpbmVDbGFzc2VzKHR5cGUsIG91dHB1dCkge1xuICAgIGlmICh0eXBlKSB7IGZvciAoOzspIHtcbiAgICAgIHZhciBsaW5lQ2xhc3MgPSB0eXBlLm1hdGNoKC8oPzpefFxccyspbGluZS0oYmFja2dyb3VuZC0pPyhcXFMrKS8pO1xuICAgICAgaWYgKCFsaW5lQ2xhc3MpIHsgYnJlYWsgfVxuICAgICAgdHlwZSA9IHR5cGUuc2xpY2UoMCwgbGluZUNsYXNzLmluZGV4KSArIHR5cGUuc2xpY2UobGluZUNsYXNzLmluZGV4ICsgbGluZUNsYXNzWzBdLmxlbmd0aCk7XG4gICAgICB2YXIgcHJvcCA9IGxpbmVDbGFzc1sxXSA/IFwiYmdDbGFzc1wiIDogXCJ0ZXh0Q2xhc3NcIjtcbiAgICAgIGlmIChvdXRwdXRbcHJvcF0gPT0gbnVsbClcbiAgICAgICAgeyBvdXRwdXRbcHJvcF0gPSBsaW5lQ2xhc3NbMl07IH1cbiAgICAgIGVsc2UgaWYgKCEobmV3IFJlZ0V4cChcIig/Ol58XFxcXHMpXCIgKyBsaW5lQ2xhc3NbMl0gKyBcIig/OiR8XFxcXHMpXCIpKS50ZXN0KG91dHB1dFtwcm9wXSkpXG4gICAgICAgIHsgb3V0cHV0W3Byb3BdICs9IFwiIFwiICsgbGluZUNsYXNzWzJdOyB9XG4gICAgfSB9XG4gICAgcmV0dXJuIHR5cGVcbiAgfVxuXG4gIC8vIFJ1biB0aGUgZ2l2ZW4gbW9kZSdzIHBhcnNlciBvdmVyIGEgbGluZSwgY2FsbGluZyBmIGZvciBlYWNoIHRva2VuLlxuICBmdW5jdGlvbiBydW5Nb2RlKGNtLCB0ZXh0LCBtb2RlLCBjb250ZXh0LCBmLCBsaW5lQ2xhc3NlcywgZm9yY2VUb0VuZCkge1xuICAgIHZhciBmbGF0dGVuU3BhbnMgPSBtb2RlLmZsYXR0ZW5TcGFucztcbiAgICBpZiAoZmxhdHRlblNwYW5zID09IG51bGwpIHsgZmxhdHRlblNwYW5zID0gY20ub3B0aW9ucy5mbGF0dGVuU3BhbnM7IH1cbiAgICB2YXIgY3VyU3RhcnQgPSAwLCBjdXJTdHlsZSA9IG51bGw7XG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0odGV4dCwgY20ub3B0aW9ucy50YWJTaXplLCBjb250ZXh0KSwgc3R5bGU7XG4gICAgdmFyIGlubmVyID0gY20ub3B0aW9ucy5hZGRNb2RlQ2xhc3MgJiYgW251bGxdO1xuICAgIGlmICh0ZXh0ID09IFwiXCIpIHsgZXh0cmFjdExpbmVDbGFzc2VzKGNhbGxCbGFua0xpbmUobW9kZSwgY29udGV4dC5zdGF0ZSksIGxpbmVDbGFzc2VzKTsgfVxuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICBpZiAoc3RyZWFtLnBvcyA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoKSB7XG4gICAgICAgIGZsYXR0ZW5TcGFucyA9IGZhbHNlO1xuICAgICAgICBpZiAoZm9yY2VUb0VuZCkgeyBwcm9jZXNzTGluZShjbSwgdGV4dCwgY29udGV4dCwgc3RyZWFtLnBvcyk7IH1cbiAgICAgICAgc3RyZWFtLnBvcyA9IHRleHQubGVuZ3RoO1xuICAgICAgICBzdHlsZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGV4dHJhY3RMaW5lQ2xhc3NlcyhyZWFkVG9rZW4obW9kZSwgc3RyZWFtLCBjb250ZXh0LnN0YXRlLCBpbm5lciksIGxpbmVDbGFzc2VzKTtcbiAgICAgIH1cbiAgICAgIGlmIChpbm5lcikge1xuICAgICAgICB2YXIgbU5hbWUgPSBpbm5lclswXS5uYW1lO1xuICAgICAgICBpZiAobU5hbWUpIHsgc3R5bGUgPSBcIm0tXCIgKyAoc3R5bGUgPyBtTmFtZSArIFwiIFwiICsgc3R5bGUgOiBtTmFtZSk7IH1cbiAgICAgIH1cbiAgICAgIGlmICghZmxhdHRlblNwYW5zIHx8IGN1clN0eWxlICE9IHN0eWxlKSB7XG4gICAgICAgIHdoaWxlIChjdXJTdGFydCA8IHN0cmVhbS5zdGFydCkge1xuICAgICAgICAgIGN1clN0YXJ0ID0gTWF0aC5taW4oc3RyZWFtLnN0YXJ0LCBjdXJTdGFydCArIDUwMDApO1xuICAgICAgICAgIGYoY3VyU3RhcnQsIGN1clN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJTdHlsZSA9IHN0eWxlO1xuICAgICAgfVxuICAgICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICB9XG4gICAgd2hpbGUgKGN1clN0YXJ0IDwgc3RyZWFtLnBvcykge1xuICAgICAgLy8gV2Via2l0IHNlZW1zIHRvIHJlZnVzZSB0byByZW5kZXIgdGV4dCBub2RlcyBsb25nZXIgdGhhbiA1NzQ0NFxuICAgICAgLy8gY2hhcmFjdGVycywgYW5kIHJldHVybnMgaW5hY2N1cmF0ZSBtZWFzdXJlbWVudHMgaW4gbm9kZXNcbiAgICAgIC8vIHN0YXJ0aW5nIGFyb3VuZCA1MDAwIGNoYXJzLlxuICAgICAgdmFyIHBvcyA9IE1hdGgubWluKHN0cmVhbS5wb3MsIGN1clN0YXJ0ICsgNTAwMCk7XG4gICAgICBmKHBvcywgY3VyU3R5bGUpO1xuICAgICAgY3VyU3RhcnQgPSBwb3M7XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZHMgdGhlIGxpbmUgdG8gc3RhcnQgd2l0aCB3aGVuIHN0YXJ0aW5nIGEgcGFyc2UuIFRyaWVzIHRvXG4gIC8vIGZpbmQgYSBsaW5lIHdpdGggYSBzdGF0ZUFmdGVyLCBzbyB0aGF0IGl0IGNhbiBzdGFydCB3aXRoIGFcbiAgLy8gdmFsaWQgc3RhdGUuIElmIHRoYXQgZmFpbHMsIGl0IHJldHVybnMgdGhlIGxpbmUgd2l0aCB0aGVcbiAgLy8gc21hbGxlc3QgaW5kZW50YXRpb24sIHdoaWNoIHRlbmRzIHRvIG5lZWQgdGhlIGxlYXN0IGNvbnRleHQgdG9cbiAgLy8gcGFyc2UgY29ycmVjdGx5LlxuICBmdW5jdGlvbiBmaW5kU3RhcnRMaW5lKGNtLCBuLCBwcmVjaXNlKSB7XG4gICAgdmFyIG1pbmluZGVudCwgbWlubGluZSwgZG9jID0gY20uZG9jO1xuICAgIHZhciBsaW0gPSBwcmVjaXNlID8gLTEgOiBuIC0gKGNtLmRvYy5tb2RlLmlubmVyTW9kZSA/IDEwMDAgOiAxMDApO1xuICAgIGZvciAodmFyIHNlYXJjaCA9IG47IHNlYXJjaCA+IGxpbTsgLS1zZWFyY2gpIHtcbiAgICAgIGlmIChzZWFyY2ggPD0gZG9jLmZpcnN0KSB7IHJldHVybiBkb2MuZmlyc3QgfVxuICAgICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgc2VhcmNoIC0gMSksIGFmdGVyID0gbGluZS5zdGF0ZUFmdGVyO1xuICAgICAgaWYgKGFmdGVyICYmICghcHJlY2lzZSB8fCBzZWFyY2ggKyAoYWZ0ZXIgaW5zdGFuY2VvZiBTYXZlZENvbnRleHQgPyBhZnRlci5sb29rQWhlYWQgOiAwKSA8PSBkb2MubW9kZUZyb250aWVyKSlcbiAgICAgICAgeyByZXR1cm4gc2VhcmNoIH1cbiAgICAgIHZhciBpbmRlbnRlZCA9IGNvdW50Q29sdW1uKGxpbmUudGV4dCwgbnVsbCwgY20ub3B0aW9ucy50YWJTaXplKTtcbiAgICAgIGlmIChtaW5saW5lID09IG51bGwgfHwgbWluaW5kZW50ID4gaW5kZW50ZWQpIHtcbiAgICAgICAgbWlubGluZSA9IHNlYXJjaCAtIDE7XG4gICAgICAgIG1pbmluZGVudCA9IGluZGVudGVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWlubGluZVxuICB9XG5cbiAgZnVuY3Rpb24gcmV0cmVhdEZyb250aWVyKGRvYywgbikge1xuICAgIGRvYy5tb2RlRnJvbnRpZXIgPSBNYXRoLm1pbihkb2MubW9kZUZyb250aWVyLCBuKTtcbiAgICBpZiAoZG9jLmhpZ2hsaWdodEZyb250aWVyIDwgbiAtIDEwKSB7IHJldHVybiB9XG4gICAgdmFyIHN0YXJ0ID0gZG9jLmZpcnN0O1xuICAgIGZvciAodmFyIGxpbmUgPSBuIC0gMTsgbGluZSA+IHN0YXJ0OyBsaW5lLS0pIHtcbiAgICAgIHZhciBzYXZlZCA9IGdldExpbmUoZG9jLCBsaW5lKS5zdGF0ZUFmdGVyO1xuICAgICAgLy8gY2hhbmdlIGlzIG9uIDNcbiAgICAgIC8vIHN0YXRlIG9uIGxpbmUgMSBsb29rZWQgYWhlYWQgMiAtLSBzbyBzYXcgM1xuICAgICAgLy8gdGVzdCAxICsgMiA8IDMgc2hvdWxkIGNvdmVyIHRoaXNcbiAgICAgIGlmIChzYXZlZCAmJiAoIShzYXZlZCBpbnN0YW5jZW9mIFNhdmVkQ29udGV4dCkgfHwgbGluZSArIHNhdmVkLmxvb2tBaGVhZCA8IG4pKSB7XG4gICAgICAgIHN0YXJ0ID0gbGluZSArIDE7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGRvYy5oaWdobGlnaHRGcm9udGllciA9IE1hdGgubWluKGRvYy5oaWdobGlnaHRGcm9udGllciwgc3RhcnQpO1xuICB9XG5cbiAgLy8gT3B0aW1pemUgc29tZSBjb2RlIHdoZW4gdGhlc2UgZmVhdHVyZXMgYXJlIG5vdCB1c2VkLlxuICB2YXIgc2F3UmVhZE9ubHlTcGFucyA9IGZhbHNlLCBzYXdDb2xsYXBzZWRTcGFucyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHNlZVJlYWRPbmx5U3BhbnMoKSB7XG4gICAgc2F3UmVhZE9ubHlTcGFucyA9IHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBzZWVDb2xsYXBzZWRTcGFucygpIHtcbiAgICBzYXdDb2xsYXBzZWRTcGFucyA9IHRydWU7XG4gIH1cblxuICAvLyBURVhUTUFSS0VSIFNQQU5TXG5cbiAgZnVuY3Rpb24gTWFya2VkU3BhbihtYXJrZXIsIGZyb20sIHRvKSB7XG4gICAgdGhpcy5tYXJrZXIgPSBtYXJrZXI7XG4gICAgdGhpcy5mcm9tID0gZnJvbTsgdGhpcy50byA9IHRvO1xuICB9XG5cbiAgLy8gU2VhcmNoIGFuIGFycmF5IG9mIHNwYW5zIGZvciBhIHNwYW4gbWF0Y2hpbmcgdGhlIGdpdmVuIG1hcmtlci5cbiAgZnVuY3Rpb24gZ2V0TWFya2VkU3BhbkZvcihzcGFucywgbWFya2VyKSB7XG4gICAgaWYgKHNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgICBpZiAoc3Bhbi5tYXJrZXIgPT0gbWFya2VyKSB7IHJldHVybiBzcGFuIH1cbiAgICB9IH1cbiAgfVxuICAvLyBSZW1vdmUgYSBzcGFuIGZyb20gYW4gYXJyYXksIHJldHVybmluZyB1bmRlZmluZWQgaWYgbm8gc3BhbnMgYXJlXG4gIC8vIGxlZnQgKHdlIGRvbid0IHN0b3JlIGFycmF5cyBmb3IgbGluZXMgd2l0aG91dCBzcGFucykuXG4gIGZ1bmN0aW9uIHJlbW92ZU1hcmtlZFNwYW4oc3BhbnMsIHNwYW4pIHtcbiAgICB2YXIgcjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxuICAgICAgeyBpZiAoc3BhbnNbaV0gIT0gc3BhbikgeyAociB8fCAociA9IFtdKSkucHVzaChzcGFuc1tpXSk7IH0gfVxuICAgIHJldHVybiByXG4gIH1cbiAgLy8gQWRkIGEgc3BhbiB0byBhIGxpbmUuXG4gIGZ1bmN0aW9uIGFkZE1hcmtlZFNwYW4obGluZSwgc3Bhbikge1xuICAgIGxpbmUubWFya2VkU3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zID8gbGluZS5tYXJrZWRTcGFucy5jb25jYXQoW3NwYW5dKSA6IFtzcGFuXTtcbiAgICBzcGFuLm1hcmtlci5hdHRhY2hMaW5lKGxpbmUpO1xuICB9XG5cbiAgLy8gVXNlZCBmb3IgdGhlIGFsZ29yaXRobSB0aGF0IGFkanVzdHMgbWFya2VycyBmb3IgYSBjaGFuZ2UgaW4gdGhlXG4gIC8vIGRvY3VtZW50LiBUaGVzZSBmdW5jdGlvbnMgY3V0IGFuIGFycmF5IG9mIHNwYW5zIGF0IGEgZ2l2ZW5cbiAgLy8gY2hhcmFjdGVyIHBvc2l0aW9uLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgcmVtYWluaW5nIGNodW5rcyAob3JcbiAgLy8gdW5kZWZpbmVkIGlmIG5vdGhpbmcgcmVtYWlucykuXG4gIGZ1bmN0aW9uIG1hcmtlZFNwYW5zQmVmb3JlKG9sZCwgc3RhcnRDaCwgaXNJbnNlcnQpIHtcbiAgICB2YXIgbnc7XG4gICAgaWYgKG9sZCkgeyBmb3IgKHZhciBpID0gMDsgaSA8IG9sZC5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwYW4gPSBvbGRbaV0sIG1hcmtlciA9IHNwYW4ubWFya2VyO1xuICAgICAgdmFyIHN0YXJ0c0JlZm9yZSA9IHNwYW4uZnJvbSA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IHNwYW4uZnJvbSA8PSBzdGFydENoIDogc3Bhbi5mcm9tIDwgc3RhcnRDaCk7XG4gICAgICBpZiAoc3RhcnRzQmVmb3JlIHx8IHNwYW4uZnJvbSA9PSBzdGFydENoICYmIG1hcmtlci50eXBlID09IFwiYm9va21hcmtcIiAmJiAoIWlzSW5zZXJ0IHx8ICFzcGFuLm1hcmtlci5pbnNlcnRMZWZ0KSkge1xuICAgICAgICB2YXIgZW5kc0FmdGVyID0gc3Bhbi50byA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyBzcGFuLnRvID49IHN0YXJ0Q2ggOiBzcGFuLnRvID4gc3RhcnRDaClcbiAgICAgICAgOyhudyB8fCAobncgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLCBzcGFuLmZyb20sIGVuZHNBZnRlciA/IG51bGwgOiBzcGFuLnRvKSk7XG4gICAgICB9XG4gICAgfSB9XG4gICAgcmV0dXJuIG53XG4gIH1cbiAgZnVuY3Rpb24gbWFya2VkU3BhbnNBZnRlcihvbGQsIGVuZENoLCBpc0luc2VydCkge1xuICAgIHZhciBudztcbiAgICBpZiAob2xkKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3BhbiA9IG9sZFtpXSwgbWFya2VyID0gc3Bhbi5tYXJrZXI7XG4gICAgICB2YXIgZW5kc0FmdGVyID0gc3Bhbi50byA9PSBudWxsIHx8IChtYXJrZXIuaW5jbHVzaXZlUmlnaHQgPyBzcGFuLnRvID49IGVuZENoIDogc3Bhbi50byA+IGVuZENoKTtcbiAgICAgIGlmIChlbmRzQWZ0ZXIgfHwgc3Bhbi5mcm9tID09IGVuZENoICYmIG1hcmtlci50eXBlID09IFwiYm9va21hcmtcIiAmJiAoIWlzSW5zZXJ0IHx8IHNwYW4ubWFya2VyLmluc2VydExlZnQpKSB7XG4gICAgICAgIHZhciBzdGFydHNCZWZvcmUgPSBzcGFuLmZyb20gPT0gbnVsbCB8fCAobWFya2VyLmluY2x1c2l2ZUxlZnQgPyBzcGFuLmZyb20gPD0gZW5kQ2ggOiBzcGFuLmZyb20gPCBlbmRDaClcbiAgICAgICAgOyhudyB8fCAobncgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4obWFya2VyLCBzdGFydHNCZWZvcmUgPyBudWxsIDogc3Bhbi5mcm9tIC0gZW5kQ2gsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi50byA9PSBudWxsID8gbnVsbCA6IHNwYW4udG8gLSBlbmRDaCkpO1xuICAgICAgfVxuICAgIH0gfVxuICAgIHJldHVybiBud1xuICB9XG5cbiAgLy8gR2l2ZW4gYSBjaGFuZ2Ugb2JqZWN0LCBjb21wdXRlIHRoZSBuZXcgc2V0IG9mIG1hcmtlciBzcGFucyB0aGF0XG4gIC8vIGNvdmVyIHRoZSBsaW5lIGluIHdoaWNoIHRoZSBjaGFuZ2UgdG9vayBwbGFjZS4gUmVtb3ZlcyBzcGFuc1xuICAvLyBlbnRpcmVseSB3aXRoaW4gdGhlIGNoYW5nZSwgcmVjb25uZWN0cyBzcGFucyBiZWxvbmdpbmcgdG8gdGhlXG4gIC8vIHNhbWUgbWFya2VyIHRoYXQgYXBwZWFyIG9uIGJvdGggc2lkZXMgb2YgdGhlIGNoYW5nZSwgYW5kIGN1dHMgb2ZmXG4gIC8vIHNwYW5zIHBhcnRpYWxseSB3aXRoaW4gdGhlIGNoYW5nZS4gUmV0dXJucyBhbiBhcnJheSBvZiBzcGFuXG4gIC8vIGFycmF5cyB3aXRoIG9uZSBlbGVtZW50IGZvciBlYWNoIGxpbmUgaW4gKGFmdGVyKSB0aGUgY2hhbmdlLlxuICBmdW5jdGlvbiBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSB7XG4gICAgaWYgKGNoYW5nZS5mdWxsKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgb2xkRmlyc3QgPSBpc0xpbmUoZG9jLCBjaGFuZ2UuZnJvbS5saW5lKSAmJiBnZXRMaW5lKGRvYywgY2hhbmdlLmZyb20ubGluZSkubWFya2VkU3BhbnM7XG4gICAgdmFyIG9sZExhc3QgPSBpc0xpbmUoZG9jLCBjaGFuZ2UudG8ubGluZSkgJiYgZ2V0TGluZShkb2MsIGNoYW5nZS50by5saW5lKS5tYXJrZWRTcGFucztcbiAgICBpZiAoIW9sZEZpcnN0ICYmICFvbGRMYXN0KSB7IHJldHVybiBudWxsIH1cblxuICAgIHZhciBzdGFydENoID0gY2hhbmdlLmZyb20uY2gsIGVuZENoID0gY2hhbmdlLnRvLmNoLCBpc0luc2VydCA9IGNtcChjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA9PSAwO1xuICAgIC8vIEdldCB0aGUgc3BhbnMgdGhhdCAnc3RpY2sgb3V0JyBvbiBib3RoIHNpZGVzXG4gICAgdmFyIGZpcnN0ID0gbWFya2VkU3BhbnNCZWZvcmUob2xkRmlyc3QsIHN0YXJ0Q2gsIGlzSW5zZXJ0KTtcbiAgICB2YXIgbGFzdCA9IG1hcmtlZFNwYW5zQWZ0ZXIob2xkTGFzdCwgZW5kQ2gsIGlzSW5zZXJ0KTtcblxuICAgIC8vIE5leHQsIG1lcmdlIHRob3NlIHR3byBlbmRzXG4gICAgdmFyIHNhbWVMaW5lID0gY2hhbmdlLnRleHQubGVuZ3RoID09IDEsIG9mZnNldCA9IGxzdChjaGFuZ2UudGV4dCkubGVuZ3RoICsgKHNhbWVMaW5lID8gc3RhcnRDaCA6IDApO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgLy8gRml4IHVwIC50byBwcm9wZXJ0aWVzIG9mIGZpcnN0XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpcnN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzcGFuID0gZmlyc3RbaV07XG4gICAgICAgIGlmIChzcGFuLnRvID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZm91bmQgPSBnZXRNYXJrZWRTcGFuRm9yKGxhc3QsIHNwYW4ubWFya2VyKTtcbiAgICAgICAgICBpZiAoIWZvdW5kKSB7IHNwYW4udG8gPSBzdGFydENoOyB9XG4gICAgICAgICAgZWxzZSBpZiAoc2FtZUxpbmUpIHsgc3Bhbi50byA9IGZvdW5kLnRvID09IG51bGwgPyBudWxsIDogZm91bmQudG8gKyBvZmZzZXQ7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobGFzdCkge1xuICAgICAgLy8gRml4IHVwIC5mcm9tIGluIGxhc3QgKG9yIG1vdmUgdGhlbSBpbnRvIGZpcnN0IGluIGNhc2Ugb2Ygc2FtZUxpbmUpXG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsYXN0Lmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgdmFyIHNwYW4kMSA9IGxhc3RbaSQxXTtcbiAgICAgICAgaWYgKHNwYW4kMS50byAhPSBudWxsKSB7IHNwYW4kMS50byArPSBvZmZzZXQ7IH1cbiAgICAgICAgaWYgKHNwYW4kMS5mcm9tID09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZm91bmQkMSA9IGdldE1hcmtlZFNwYW5Gb3IoZmlyc3QsIHNwYW4kMS5tYXJrZXIpO1xuICAgICAgICAgIGlmICghZm91bmQkMSkge1xuICAgICAgICAgICAgc3BhbiQxLmZyb20gPSBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoc2FtZUxpbmUpIHsgKGZpcnN0IHx8IChmaXJzdCA9IFtdKSkucHVzaChzcGFuJDEpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwYW4kMS5mcm9tICs9IG9mZnNldDtcbiAgICAgICAgICBpZiAoc2FtZUxpbmUpIHsgKGZpcnN0IHx8IChmaXJzdCA9IFtdKSkucHVzaChzcGFuJDEpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTWFrZSBzdXJlIHdlIGRpZG4ndCBjcmVhdGUgYW55IHplcm8tbGVuZ3RoIHNwYW5zXG4gICAgaWYgKGZpcnN0KSB7IGZpcnN0ID0gY2xlYXJFbXB0eVNwYW5zKGZpcnN0KTsgfVxuICAgIGlmIChsYXN0ICYmIGxhc3QgIT0gZmlyc3QpIHsgbGFzdCA9IGNsZWFyRW1wdHlTcGFucyhsYXN0KTsgfVxuXG4gICAgdmFyIG5ld01hcmtlcnMgPSBbZmlyc3RdO1xuICAgIGlmICghc2FtZUxpbmUpIHtcbiAgICAgIC8vIEZpbGwgZ2FwIHdpdGggd2hvbGUtbGluZS1zcGFuc1xuICAgICAgdmFyIGdhcCA9IGNoYW5nZS50ZXh0Lmxlbmd0aCAtIDIsIGdhcE1hcmtlcnM7XG4gICAgICBpZiAoZ2FwID4gMCAmJiBmaXJzdClcbiAgICAgICAgeyBmb3IgKHZhciBpJDIgPSAwOyBpJDIgPCBmaXJzdC5sZW5ndGg7ICsraSQyKVxuICAgICAgICAgIHsgaWYgKGZpcnN0W2kkMl0udG8gPT0gbnVsbClcbiAgICAgICAgICAgIHsgKGdhcE1hcmtlcnMgfHwgKGdhcE1hcmtlcnMgPSBbXSkpLnB1c2gobmV3IE1hcmtlZFNwYW4oZmlyc3RbaSQyXS5tYXJrZXIsIG51bGwsIG51bGwpKTsgfSB9IH1cbiAgICAgIGZvciAodmFyIGkkMyA9IDA7IGkkMyA8IGdhcDsgKytpJDMpXG4gICAgICAgIHsgbmV3TWFya2Vycy5wdXNoKGdhcE1hcmtlcnMpOyB9XG4gICAgICBuZXdNYXJrZXJzLnB1c2gobGFzdCk7XG4gICAgfVxuICAgIHJldHVybiBuZXdNYXJrZXJzXG4gIH1cblxuICAvLyBSZW1vdmUgc3BhbnMgdGhhdCBhcmUgZW1wdHkgYW5kIGRvbid0IGhhdmUgYSBjbGVhcldoZW5FbXB0eVxuICAvLyBvcHRpb24gb2YgZmFsc2UuXG4gIGZ1bmN0aW9uIGNsZWFyRW1wdHlTcGFucyhzcGFucykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgICBpZiAoc3Bhbi5mcm9tICE9IG51bGwgJiYgc3Bhbi5mcm9tID09IHNwYW4udG8gJiYgc3Bhbi5tYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKVxuICAgICAgICB7IHNwYW5zLnNwbGljZShpLS0sIDEpOyB9XG4gICAgfVxuICAgIGlmICghc3BhbnMubGVuZ3RoKSB7IHJldHVybiBudWxsIH1cbiAgICByZXR1cm4gc3BhbnNcbiAgfVxuXG4gIC8vIFVzZWQgdG8gJ2NsaXAnIG91dCByZWFkT25seSByYW5nZXMgd2hlbiBtYWtpbmcgYSBjaGFuZ2UuXG4gIGZ1bmN0aW9uIHJlbW92ZVJlYWRPbmx5UmFuZ2VzKGRvYywgZnJvbSwgdG8pIHtcbiAgICB2YXIgbWFya2VycyA9IG51bGw7XG4gICAgZG9jLml0ZXIoZnJvbS5saW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lLm1hcmtlZFNwYW5zKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS5tYXJrZWRTcGFucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbWFyayA9IGxpbmUubWFya2VkU3BhbnNbaV0ubWFya2VyO1xuICAgICAgICBpZiAobWFyay5yZWFkT25seSAmJiAoIW1hcmtlcnMgfHwgaW5kZXhPZihtYXJrZXJzLCBtYXJrKSA9PSAtMSkpXG4gICAgICAgICAgeyAobWFya2VycyB8fCAobWFya2VycyA9IFtdKSkucHVzaChtYXJrKTsgfVxuICAgICAgfSB9XG4gICAgfSk7XG4gICAgaWYgKCFtYXJrZXJzKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgcGFydHMgPSBbe2Zyb206IGZyb20sIHRvOiB0b31dO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya2Vycy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIG1rID0gbWFya2Vyc1tpXSwgbSA9IG1rLmZpbmQoMCk7XG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcnRzLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIHZhciBwID0gcGFydHNbal07XG4gICAgICAgIGlmIChjbXAocC50bywgbS5mcm9tKSA8IDAgfHwgY21wKHAuZnJvbSwgbS50bykgPiAwKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgdmFyIG5ld1BhcnRzID0gW2osIDFdLCBkZnJvbSA9IGNtcChwLmZyb20sIG0uZnJvbSksIGR0byA9IGNtcChwLnRvLCBtLnRvKTtcbiAgICAgICAgaWYgKGRmcm9tIDwgMCB8fCAhbWsuaW5jbHVzaXZlTGVmdCAmJiAhZGZyb20pXG4gICAgICAgICAgeyBuZXdQYXJ0cy5wdXNoKHtmcm9tOiBwLmZyb20sIHRvOiBtLmZyb219KTsgfVxuICAgICAgICBpZiAoZHRvID4gMCB8fCAhbWsuaW5jbHVzaXZlUmlnaHQgJiYgIWR0bylcbiAgICAgICAgICB7IG5ld1BhcnRzLnB1c2goe2Zyb206IG0udG8sIHRvOiBwLnRvfSk7IH1cbiAgICAgICAgcGFydHMuc3BsaWNlLmFwcGx5KHBhcnRzLCBuZXdQYXJ0cyk7XG4gICAgICAgIGogKz0gbmV3UGFydHMubGVuZ3RoIC0gMztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzXG4gIH1cblxuICAvLyBDb25uZWN0IG9yIGRpc2Nvbm5lY3Qgc3BhbnMgZnJvbSBhIGxpbmUuXG4gIGZ1bmN0aW9uIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpIHtcbiAgICB2YXIgc3BhbnMgPSBsaW5lLm1hcmtlZFNwYW5zO1xuICAgIGlmICghc3BhbnMpIHsgcmV0dXJuIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKVxuICAgICAgeyBzcGFuc1tpXS5tYXJrZXIuZGV0YWNoTGluZShsaW5lKTsgfVxuICAgIGxpbmUubWFya2VkU3BhbnMgPSBudWxsO1xuICB9XG4gIGZ1bmN0aW9uIGF0dGFjaE1hcmtlZFNwYW5zKGxpbmUsIHNwYW5zKSB7XG4gICAgaWYgKCFzcGFucykgeyByZXR1cm4gfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpXG4gICAgICB7IHNwYW5zW2ldLm1hcmtlci5hdHRhY2hMaW5lKGxpbmUpOyB9XG4gICAgbGluZS5tYXJrZWRTcGFucyA9IHNwYW5zO1xuICB9XG5cbiAgLy8gSGVscGVycyB1c2VkIHdoZW4gY29tcHV0aW5nIHdoaWNoIG92ZXJsYXBwaW5nIGNvbGxhcHNlZCBzcGFuXG4gIC8vIGNvdW50cyBhcyB0aGUgbGFyZ2VyIG9uZS5cbiAgZnVuY3Rpb24gZXh0cmFMZWZ0KG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmluY2x1c2l2ZUxlZnQgPyAtMSA6IDAgfVxuICBmdW5jdGlvbiBleHRyYVJpZ2h0KG1hcmtlcikgeyByZXR1cm4gbWFya2VyLmluY2x1c2l2ZVJpZ2h0ID8gMSA6IDAgfVxuXG4gIC8vIFJldHVybnMgYSBudW1iZXIgaW5kaWNhdGluZyB3aGljaCBvZiB0d28gb3ZlcmxhcHBpbmcgY29sbGFwc2VkXG4gIC8vIHNwYW5zIGlzIGxhcmdlciAoYW5kIHRodXMgaW5jbHVkZXMgdGhlIG90aGVyKS4gRmFsbHMgYmFjayB0b1xuICAvLyBjb21wYXJpbmcgaWRzIHdoZW4gdGhlIHNwYW5zIGNvdmVyIGV4YWN0bHkgdGhlIHNhbWUgcmFuZ2UuXG4gIGZ1bmN0aW9uIGNvbXBhcmVDb2xsYXBzZWRNYXJrZXJzKGEsIGIpIHtcbiAgICB2YXIgbGVuRGlmZiA9IGEubGluZXMubGVuZ3RoIC0gYi5saW5lcy5sZW5ndGg7XG4gICAgaWYgKGxlbkRpZmYgIT0gMCkgeyByZXR1cm4gbGVuRGlmZiB9XG4gICAgdmFyIGFQb3MgPSBhLmZpbmQoKSwgYlBvcyA9IGIuZmluZCgpO1xuICAgIHZhciBmcm9tQ21wID0gY21wKGFQb3MuZnJvbSwgYlBvcy5mcm9tKSB8fCBleHRyYUxlZnQoYSkgLSBleHRyYUxlZnQoYik7XG4gICAgaWYgKGZyb21DbXApIHsgcmV0dXJuIC1mcm9tQ21wIH1cbiAgICB2YXIgdG9DbXAgPSBjbXAoYVBvcy50bywgYlBvcy50bykgfHwgZXh0cmFSaWdodChhKSAtIGV4dHJhUmlnaHQoYik7XG4gICAgaWYgKHRvQ21wKSB7IHJldHVybiB0b0NtcCB9XG4gICAgcmV0dXJuIGIuaWQgLSBhLmlkXG4gIH1cblxuICAvLyBGaW5kIG91dCB3aGV0aGVyIGEgbGluZSBlbmRzIG9yIHN0YXJ0cyBpbiBhIGNvbGxhcHNlZCBzcGFuLiBJZlxuICAvLyBzbywgcmV0dXJuIHRoZSBtYXJrZXIgZm9yIHRoYXQgc3Bhbi5cbiAgZnVuY3Rpb24gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCBzdGFydCkge1xuICAgIHZhciBzcHMgPSBzYXdDb2xsYXBzZWRTcGFucyAmJiBsaW5lLm1hcmtlZFNwYW5zLCBmb3VuZDtcbiAgICBpZiAoc3BzKSB7IGZvciAodmFyIHNwID0gKHZvaWQgMCksIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICBzcCA9IHNwc1tpXTtcbiAgICAgIGlmIChzcC5tYXJrZXIuY29sbGFwc2VkICYmIChzdGFydCA/IHNwLmZyb20gOiBzcC50bykgPT0gbnVsbCAmJlxuICAgICAgICAgICghZm91bmQgfHwgY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoZm91bmQsIHNwLm1hcmtlcikgPCAwKSlcbiAgICAgICAgeyBmb3VuZCA9IHNwLm1hcmtlcjsgfVxuICAgIH0gfVxuICAgIHJldHVybiBmb3VuZFxuICB9XG4gIGZ1bmN0aW9uIGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGxpbmUpIHsgcmV0dXJuIGNvbGxhcHNlZFNwYW5BdFNpZGUobGluZSwgdHJ1ZSkgfVxuICBmdW5jdGlvbiBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkgeyByZXR1cm4gY29sbGFwc2VkU3BhbkF0U2lkZShsaW5lLCBmYWxzZSkgfVxuXG4gIGZ1bmN0aW9uIGNvbGxhcHNlZFNwYW5Bcm91bmQobGluZSwgY2gpIHtcbiAgICB2YXIgc3BzID0gc2F3Q29sbGFwc2VkU3BhbnMgJiYgbGluZS5tYXJrZWRTcGFucywgZm91bmQ7XG4gICAgaWYgKHNwcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwID0gc3BzW2ldO1xuICAgICAgaWYgKHNwLm1hcmtlci5jb2xsYXBzZWQgJiYgKHNwLmZyb20gPT0gbnVsbCB8fCBzcC5mcm9tIDwgY2gpICYmIChzcC50byA9PSBudWxsIHx8IHNwLnRvID4gY2gpICYmXG4gICAgICAgICAgKCFmb3VuZCB8fCBjb21wYXJlQ29sbGFwc2VkTWFya2Vycyhmb3VuZCwgc3AubWFya2VyKSA8IDApKSB7IGZvdW5kID0gc3AubWFya2VyOyB9XG4gICAgfSB9XG4gICAgcmV0dXJuIGZvdW5kXG4gIH1cblxuICAvLyBUZXN0IHdoZXRoZXIgdGhlcmUgZXhpc3RzIGEgY29sbGFwc2VkIHNwYW4gdGhhdCBwYXJ0aWFsbHlcbiAgLy8gb3ZlcmxhcHMgKGNvdmVycyB0aGUgc3RhcnQgb3IgZW5kLCBidXQgbm90IGJvdGgpIG9mIGEgbmV3IHNwYW4uXG4gIC8vIFN1Y2ggb3ZlcmxhcCBpcyBub3QgYWxsb3dlZC5cbiAgZnVuY3Rpb24gY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZShkb2MsIGxpbmVObywgZnJvbSwgdG8sIG1hcmtlcikge1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIGxpbmVObyk7XG4gICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnM7XG4gICAgaWYgKHNwcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHNwID0gc3BzW2ldO1xuICAgICAgaWYgKCFzcC5tYXJrZXIuY29sbGFwc2VkKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBmb3VuZCA9IHNwLm1hcmtlci5maW5kKDApO1xuICAgICAgdmFyIGZyb21DbXAgPSBjbXAoZm91bmQuZnJvbSwgZnJvbSkgfHwgZXh0cmFMZWZ0KHNwLm1hcmtlcikgLSBleHRyYUxlZnQobWFya2VyKTtcbiAgICAgIHZhciB0b0NtcCA9IGNtcChmb3VuZC50bywgdG8pIHx8IGV4dHJhUmlnaHQoc3AubWFya2VyKSAtIGV4dHJhUmlnaHQobWFya2VyKTtcbiAgICAgIGlmIChmcm9tQ21wID49IDAgJiYgdG9DbXAgPD0gMCB8fCBmcm9tQ21wIDw9IDAgJiYgdG9DbXAgPj0gMCkgeyBjb250aW51ZSB9XG4gICAgICBpZiAoZnJvbUNtcCA8PSAwICYmIChzcC5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgbWFya2VyLmluY2x1c2l2ZUxlZnQgPyBjbXAoZm91bmQudG8sIGZyb20pID49IDAgOiBjbXAoZm91bmQudG8sIGZyb20pID4gMCkgfHxcbiAgICAgICAgICBmcm9tQ21wID49IDAgJiYgKHNwLm1hcmtlci5pbmNsdXNpdmVSaWdodCAmJiBtYXJrZXIuaW5jbHVzaXZlTGVmdCA/IGNtcChmb3VuZC5mcm9tLCB0bykgPD0gMCA6IGNtcChmb3VuZC5mcm9tLCB0bykgPCAwKSlcbiAgICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfSB9XG4gIH1cblxuICAvLyBBIHZpc3VhbCBsaW5lIGlzIGEgbGluZSBhcyBkcmF3biBvbiB0aGUgc2NyZWVuLiBGb2xkaW5nLCBmb3JcbiAgLy8gZXhhbXBsZSwgY2FuIGNhdXNlIG11bHRpcGxlIGxvZ2ljYWwgbGluZXMgdG8gYXBwZWFyIG9uIHRoZSBzYW1lXG4gIC8vIHZpc3VhbCBsaW5lLiBUaGlzIGZpbmRzIHRoZSBzdGFydCBvZiB0aGUgdmlzdWFsIGxpbmUgdGhhdCB0aGVcbiAgLy8gZ2l2ZW4gbGluZSBpcyBwYXJ0IG9mICh1c3VhbGx5IHRoYXQgaXMgdGhlIGxpbmUgaXRzZWxmKS5cbiAgZnVuY3Rpb24gdmlzdWFsTGluZShsaW5lKSB7XG4gICAgdmFyIG1lcmdlZDtcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0U3RhcnQobGluZSkpXG4gICAgICB7IGxpbmUgPSBtZXJnZWQuZmluZCgtMSwgdHJ1ZSkubGluZTsgfVxuICAgIHJldHVybiBsaW5lXG4gIH1cblxuICBmdW5jdGlvbiB2aXN1YWxMaW5lRW5kKGxpbmUpIHtcbiAgICB2YXIgbWVyZ2VkO1xuICAgIHdoaWxlIChtZXJnZWQgPSBjb2xsYXBzZWRTcGFuQXRFbmQobGluZSkpXG4gICAgICB7IGxpbmUgPSBtZXJnZWQuZmluZCgxLCB0cnVlKS5saW5lOyB9XG4gICAgcmV0dXJuIGxpbmVcbiAgfVxuXG4gIC8vIFJldHVybnMgYW4gYXJyYXkgb2YgbG9naWNhbCBsaW5lcyB0aGF0IGNvbnRpbnVlIHRoZSB2aXN1YWwgbGluZVxuICAvLyBzdGFydGVkIGJ5IHRoZSBhcmd1bWVudCwgb3IgdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBubyBzdWNoIGxpbmVzLlxuICBmdW5jdGlvbiB2aXN1YWxMaW5lQ29udGludWVkKGxpbmUpIHtcbiAgICB2YXIgbWVyZ2VkLCBsaW5lcztcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGxpbmUpKSB7XG4gICAgICBsaW5lID0gbWVyZ2VkLmZpbmQoMSwgdHJ1ZSkubGluZVxuICAgICAgOyhsaW5lcyB8fCAobGluZXMgPSBbXSkpLnB1c2gobGluZSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lc1xuICB9XG5cbiAgLy8gR2V0IHRoZSBsaW5lIG51bWJlciBvZiB0aGUgc3RhcnQgb2YgdGhlIHZpc3VhbCBsaW5lIHRoYXQgdGhlXG4gIC8vIGdpdmVuIGxpbmUgbnVtYmVyIGlzIHBhcnQgb2YuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVObyhkb2MsIGxpbmVOKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGRvYywgbGluZU4pLCB2aXMgPSB2aXN1YWxMaW5lKGxpbmUpO1xuICAgIGlmIChsaW5lID09IHZpcykgeyByZXR1cm4gbGluZU4gfVxuICAgIHJldHVybiBsaW5lTm8odmlzKVxuICB9XG5cbiAgLy8gR2V0IHRoZSBsaW5lIG51bWJlciBvZiB0aGUgc3RhcnQgb2YgdGhlIG5leHQgdmlzdWFsIGxpbmUgYWZ0ZXJcbiAgLy8gdGhlIGdpdmVuIGxpbmUuXG4gIGZ1bmN0aW9uIHZpc3VhbExpbmVFbmRObyhkb2MsIGxpbmVOKSB7XG4gICAgaWYgKGxpbmVOID4gZG9jLmxhc3RMaW5lKCkpIHsgcmV0dXJuIGxpbmVOIH1cbiAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBsaW5lTiksIG1lcmdlZDtcbiAgICBpZiAoIWxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7IHJldHVybiBsaW5lTiB9XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdEVuZChsaW5lKSlcbiAgICAgIHsgbGluZSA9IG1lcmdlZC5maW5kKDEsIHRydWUpLmxpbmU7IH1cbiAgICByZXR1cm4gbGluZU5vKGxpbmUpICsgMVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB3aGV0aGVyIGEgbGluZSBpcyBoaWRkZW4uIExpbmVzIGNvdW50IGFzIGhpZGRlbiB3aGVuIHRoZXlcbiAgLy8gYXJlIHBhcnQgb2YgYSB2aXN1YWwgbGluZSB0aGF0IHN0YXJ0cyB3aXRoIGFub3RoZXIgbGluZSwgb3Igd2hlblxuICAvLyB0aGV5IGFyZSBlbnRpcmVseSBjb3ZlcmVkIGJ5IGNvbGxhcHNlZCwgbm9uLXdpZGdldCBzcGFuLlxuICBmdW5jdGlvbiBsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKSB7XG4gICAgdmFyIHNwcyA9IHNhd0NvbGxhcHNlZFNwYW5zICYmIGxpbmUubWFya2VkU3BhbnM7XG4gICAgaWYgKHNwcykgeyBmb3IgKHZhciBzcCA9ICh2b2lkIDApLCBpID0gMDsgaSA8IHNwcy5sZW5ndGg7ICsraSkge1xuICAgICAgc3AgPSBzcHNbaV07XG4gICAgICBpZiAoIXNwLm1hcmtlci5jb2xsYXBzZWQpIHsgY29udGludWUgfVxuICAgICAgaWYgKHNwLmZyb20gPT0gbnVsbCkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgICBpZiAoc3AubWFya2VyLndpZGdldE5vZGUpIHsgY29udGludWUgfVxuICAgICAgaWYgKHNwLmZyb20gPT0gMCAmJiBzcC5tYXJrZXIuaW5jbHVzaXZlTGVmdCAmJiBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGxpbmUsIHNwKSlcbiAgICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfSB9XG4gIH1cbiAgZnVuY3Rpb24gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBsaW5lLCBzcGFuKSB7XG4gICAgaWYgKHNwYW4udG8gPT0gbnVsbCkge1xuICAgICAgdmFyIGVuZCA9IHNwYW4ubWFya2VyLmZpbmQoMSwgdHJ1ZSk7XG4gICAgICByZXR1cm4gbGluZUlzSGlkZGVuSW5uZXIoZG9jLCBlbmQubGluZSwgZ2V0TWFya2VkU3BhbkZvcihlbmQubGluZS5tYXJrZWRTcGFucywgc3Bhbi5tYXJrZXIpKVxuICAgIH1cbiAgICBpZiAoc3Bhbi5tYXJrZXIuaW5jbHVzaXZlUmlnaHQgJiYgc3Bhbi50byA9PSBsaW5lLnRleHQubGVuZ3RoKVxuICAgICAgeyByZXR1cm4gdHJ1ZSB9XG4gICAgZm9yICh2YXIgc3AgPSAodm9pZCAwKSwgaSA9IDA7IGkgPCBsaW5lLm1hcmtlZFNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICBzcCA9IGxpbmUubWFya2VkU3BhbnNbaV07XG4gICAgICBpZiAoc3AubWFya2VyLmNvbGxhcHNlZCAmJiAhc3AubWFya2VyLndpZGdldE5vZGUgJiYgc3AuZnJvbSA9PSBzcGFuLnRvICYmXG4gICAgICAgICAgKHNwLnRvID09IG51bGwgfHwgc3AudG8gIT0gc3Bhbi5mcm9tKSAmJlxuICAgICAgICAgIChzcC5tYXJrZXIuaW5jbHVzaXZlTGVmdCB8fCBzcGFuLm1hcmtlci5pbmNsdXNpdmVSaWdodCkgJiZcbiAgICAgICAgICBsaW5lSXNIaWRkZW5Jbm5lcihkb2MsIGxpbmUsIHNwKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICB9XG5cbiAgLy8gRmluZCB0aGUgaGVpZ2h0IGFib3ZlIHRoZSBnaXZlbiBsaW5lLlxuICBmdW5jdGlvbiBoZWlnaHRBdExpbmUobGluZU9iaikge1xuICAgIGxpbmVPYmogPSB2aXN1YWxMaW5lKGxpbmVPYmopO1xuXG4gICAgdmFyIGggPSAwLCBjaHVuayA9IGxpbmVPYmoucGFyZW50O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2h1bmsubGluZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsaW5lID0gY2h1bmsubGluZXNbaV07XG4gICAgICBpZiAobGluZSA9PSBsaW5lT2JqKSB7IGJyZWFrIH1cbiAgICAgIGVsc2UgeyBoICs9IGxpbmUuaGVpZ2h0OyB9XG4gICAgfVxuICAgIGZvciAodmFyIHAgPSBjaHVuay5wYXJlbnQ7IHA7IGNodW5rID0gcCwgcCA9IGNodW5rLnBhcmVudCkge1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcC5jaGlsZHJlbi5sZW5ndGg7ICsraSQxKSB7XG4gICAgICAgIHZhciBjdXIgPSBwLmNoaWxkcmVuW2kkMV07XG4gICAgICAgIGlmIChjdXIgPT0gY2h1bmspIHsgYnJlYWsgfVxuICAgICAgICBlbHNlIHsgaCArPSBjdXIuaGVpZ2h0OyB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoXG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBjaGFyYWN0ZXIgbGVuZ3RoIG9mIGEgbGluZSwgdGFraW5nIGludG8gYWNjb3VudFxuICAvLyBjb2xsYXBzZWQgcmFuZ2VzIChzZWUgbWFya1RleHQpIHRoYXQgbWlnaHQgaGlkZSBwYXJ0cywgYW5kIGpvaW5cbiAgLy8gb3RoZXIgbGluZXMgb250byBpdC5cbiAgZnVuY3Rpb24gbGluZUxlbmd0aChsaW5lKSB7XG4gICAgaWYgKGxpbmUuaGVpZ2h0ID09IDApIHsgcmV0dXJuIDAgfVxuICAgIHZhciBsZW4gPSBsaW5lLnRleHQubGVuZ3RoLCBtZXJnZWQsIGN1ciA9IGxpbmU7XG4gICAgd2hpbGUgKG1lcmdlZCA9IGNvbGxhcHNlZFNwYW5BdFN0YXJ0KGN1cikpIHtcbiAgICAgIHZhciBmb3VuZCA9IG1lcmdlZC5maW5kKDAsIHRydWUpO1xuICAgICAgY3VyID0gZm91bmQuZnJvbS5saW5lO1xuICAgICAgbGVuICs9IGZvdW5kLmZyb20uY2ggLSBmb3VuZC50by5jaDtcbiAgICB9XG4gICAgY3VyID0gbGluZTtcbiAgICB3aGlsZSAobWVyZ2VkID0gY29sbGFwc2VkU3BhbkF0RW5kKGN1cikpIHtcbiAgICAgIHZhciBmb3VuZCQxID0gbWVyZ2VkLmZpbmQoMCwgdHJ1ZSk7XG4gICAgICBsZW4gLT0gY3VyLnRleHQubGVuZ3RoIC0gZm91bmQkMS5mcm9tLmNoO1xuICAgICAgY3VyID0gZm91bmQkMS50by5saW5lO1xuICAgICAgbGVuICs9IGN1ci50ZXh0Lmxlbmd0aCAtIGZvdW5kJDEudG8uY2g7XG4gICAgfVxuICAgIHJldHVybiBsZW5cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxvbmdlc3QgbGluZSBpbiB0aGUgZG9jdW1lbnQuXG4gIGZ1bmN0aW9uIGZpbmRNYXhMaW5lKGNtKSB7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5LCBkb2MgPSBjbS5kb2M7XG4gICAgZC5tYXhMaW5lID0gZ2V0TGluZShkb2MsIGRvYy5maXJzdCk7XG4gICAgZC5tYXhMaW5lTGVuZ3RoID0gbGluZUxlbmd0aChkLm1heExpbmUpO1xuICAgIGQubWF4TGluZUNoYW5nZWQgPSB0cnVlO1xuICAgIGRvYy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICB2YXIgbGVuID0gbGluZUxlbmd0aChsaW5lKTtcbiAgICAgIGlmIChsZW4gPiBkLm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgZC5tYXhMaW5lTGVuZ3RoID0gbGVuO1xuICAgICAgICBkLm1heExpbmUgPSBsaW5lO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gTElORSBEQVRBIFNUUlVDVFVSRVxuXG4gIC8vIExpbmUgb2JqZWN0cy4gVGhlc2UgaG9sZCBzdGF0ZSByZWxhdGVkIHRvIGEgbGluZSwgaW5jbHVkaW5nXG4gIC8vIGhpZ2hsaWdodGluZyBpbmZvICh0aGUgc3R5bGVzIGFycmF5KS5cbiAgdmFyIExpbmUgPSBmdW5jdGlvbih0ZXh0LCBtYXJrZWRTcGFucywgZXN0aW1hdGVIZWlnaHQpIHtcbiAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgIGF0dGFjaE1hcmtlZFNwYW5zKHRoaXMsIG1hcmtlZFNwYW5zKTtcbiAgICB0aGlzLmhlaWdodCA9IGVzdGltYXRlSGVpZ2h0ID8gZXN0aW1hdGVIZWlnaHQodGhpcykgOiAxO1xuICB9O1xuXG4gIExpbmUucHJvdG90eXBlLmxpbmVObyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxpbmVObyh0aGlzKSB9O1xuICBldmVudE1peGluKExpbmUpO1xuXG4gIC8vIENoYW5nZSB0aGUgY29udGVudCAodGV4dCwgbWFya2Vycykgb2YgYSBsaW5lLiBBdXRvbWF0aWNhbGx5XG4gIC8vIGludmFsaWRhdGVzIGNhY2hlZCBpbmZvcm1hdGlvbiBhbmQgdHJpZXMgdG8gcmUtZXN0aW1hdGUgdGhlXG4gIC8vIGxpbmUncyBoZWlnaHQuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmUobGluZSwgdGV4dCwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XG4gICAgbGluZS50ZXh0ID0gdGV4dDtcbiAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSB7IGxpbmUuc3RhdGVBZnRlciA9IG51bGw7IH1cbiAgICBpZiAobGluZS5zdHlsZXMpIHsgbGluZS5zdHlsZXMgPSBudWxsOyB9XG4gICAgaWYgKGxpbmUub3JkZXIgIT0gbnVsbCkgeyBsaW5lLm9yZGVyID0gbnVsbDsgfVxuICAgIGRldGFjaE1hcmtlZFNwYW5zKGxpbmUpO1xuICAgIGF0dGFjaE1hcmtlZFNwYW5zKGxpbmUsIG1hcmtlZFNwYW5zKTtcbiAgICB2YXIgZXN0SGVpZ2h0ID0gZXN0aW1hdGVIZWlnaHQgPyBlc3RpbWF0ZUhlaWdodChsaW5lKSA6IDE7XG4gICAgaWYgKGVzdEhlaWdodCAhPSBsaW5lLmhlaWdodCkgeyB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIGVzdEhlaWdodCk7IH1cbiAgfVxuXG4gIC8vIERldGFjaCBhIGxpbmUgZnJvbSB0aGUgZG9jdW1lbnQgdHJlZSBhbmQgaXRzIG1hcmtlcnMuXG4gIGZ1bmN0aW9uIGNsZWFuVXBMaW5lKGxpbmUpIHtcbiAgICBsaW5lLnBhcmVudCA9IG51bGw7XG4gICAgZGV0YWNoTWFya2VkU3BhbnMobGluZSk7XG4gIH1cblxuICAvLyBDb252ZXJ0IGEgc3R5bGUgYXMgcmV0dXJuZWQgYnkgYSBtb2RlIChlaXRoZXIgbnVsbCwgb3IgYSBzdHJpbmdcbiAgLy8gY29udGFpbmluZyBvbmUgb3IgbW9yZSBzdHlsZXMpIHRvIGEgQ1NTIHN0eWxlLiBUaGlzIGlzIGNhY2hlZCxcbiAgLy8gYW5kIGFsc28gbG9va3MgZm9yIGxpbmUtd2lkZSBzdHlsZXMuXG4gIHZhciBzdHlsZVRvQ2xhc3NDYWNoZSA9IHt9LCBzdHlsZVRvQ2xhc3NDYWNoZVdpdGhNb2RlID0ge307XG4gIGZ1bmN0aW9uIGludGVycHJldFRva2VuU3R5bGUoc3R5bGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXN0eWxlIHx8IC9eXFxzKiQvLnRlc3Qoc3R5bGUpKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgY2FjaGUgPSBvcHRpb25zLmFkZE1vZGVDbGFzcyA/IHN0eWxlVG9DbGFzc0NhY2hlV2l0aE1vZGUgOiBzdHlsZVRvQ2xhc3NDYWNoZTtcbiAgICByZXR1cm4gY2FjaGVbc3R5bGVdIHx8XG4gICAgICAoY2FjaGVbc3R5bGVdID0gc3R5bGUucmVwbGFjZSgvXFxTKy9nLCBcImNtLSQmXCIpKVxuICB9XG5cbiAgLy8gUmVuZGVyIHRoZSBET00gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRleHQgb2YgYSBsaW5lLiBBbHNvIGJ1aWxkc1xuICAvLyB1cCBhICdsaW5lIG1hcCcsIHdoaWNoIHBvaW50cyBhdCB0aGUgRE9NIG5vZGVzIHRoYXQgcmVwcmVzZW50XG4gIC8vIHNwZWNpZmljIHN0cmV0Y2hlcyBvZiB0ZXh0LCBhbmQgaXMgdXNlZCBieSB0aGUgbWVhc3VyaW5nIGNvZGUuXG4gIC8vIFRoZSByZXR1cm5lZCBvYmplY3QgY29udGFpbnMgdGhlIERPTSBub2RlLCB0aGlzIG1hcCwgYW5kXG4gIC8vIGluZm9ybWF0aW9uIGFib3V0IGxpbmUtd2lkZSBzdHlsZXMgdGhhdCB3ZXJlIHNldCBieSB0aGUgbW9kZS5cbiAgZnVuY3Rpb24gYnVpbGRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpIHtcbiAgICAvLyBUaGUgcGFkZGluZy1yaWdodCBmb3JjZXMgdGhlIGVsZW1lbnQgdG8gaGF2ZSBhICdib3JkZXInLCB3aGljaFxuICAgIC8vIGlzIG5lZWRlZCBvbiBXZWJraXQgdG8gYmUgYWJsZSB0byBnZXQgbGluZS1sZXZlbCBib3VuZGluZ1xuICAgIC8vIHJlY3RhbmdsZXMgZm9yIGl0IChpbiBtZWFzdXJlQ2hhcikuXG4gICAgdmFyIGNvbnRlbnQgPSBlbHRQKFwic3BhblwiLCBudWxsLCBudWxsLCB3ZWJraXQgPyBcInBhZGRpbmctcmlnaHQ6IC4xcHhcIiA6IG51bGwpO1xuICAgIHZhciBidWlsZGVyID0ge3ByZTogZWx0UChcInByZVwiLCBbY29udGVudF0sIFwiQ29kZU1pcnJvci1saW5lXCIpLCBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgIGNvbDogMCwgcG9zOiAwLCBjbTogY20sXG4gICAgICAgICAgICAgICAgICAgdHJhaWxpbmdTcGFjZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgc3BsaXRTcGFjZXM6IGNtLmdldE9wdGlvbihcImxpbmVXcmFwcGluZ1wiKX07XG4gICAgbGluZVZpZXcubWVhc3VyZSA9IHt9O1xuXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBsb2dpY2FsIGxpbmVzIHRoYXQgbWFrZSB1cCB0aGlzIHZpc3VhbCBsaW5lLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IChsaW5lVmlldy5yZXN0ID8gbGluZVZpZXcucmVzdC5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICB2YXIgbGluZSA9IGkgPyBsaW5lVmlldy5yZXN0W2kgLSAxXSA6IGxpbmVWaWV3LmxpbmUsIG9yZGVyID0gKHZvaWQgMCk7XG4gICAgICBidWlsZGVyLnBvcyA9IDA7XG4gICAgICBidWlsZGVyLmFkZFRva2VuID0gYnVpbGRUb2tlbjtcbiAgICAgIC8vIE9wdGlvbmFsbHkgd2lyZSBpbiBzb21lIGhhY2tzIGludG8gdGhlIHRva2VuLXJlbmRlcmluZ1xuICAgICAgLy8gYWxnb3JpdGhtLCB0byBkZWFsIHdpdGggYnJvd3NlciBxdWlya3MuXG4gICAgICBpZiAoaGFzQmFkQmlkaVJlY3RzKGNtLmRpc3BsYXkubWVhc3VyZSkgJiYgKG9yZGVyID0gZ2V0T3JkZXIobGluZSwgY20uZG9jLmRpcmVjdGlvbikpKVxuICAgICAgICB7IGJ1aWxkZXIuYWRkVG9rZW4gPSBidWlsZFRva2VuQmFkQmlkaShidWlsZGVyLmFkZFRva2VuLCBvcmRlcik7IH1cbiAgICAgIGJ1aWxkZXIubWFwID0gW107XG4gICAgICB2YXIgYWxsb3dGcm9udGllclVwZGF0ZSA9IGxpbmVWaWV3ICE9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCAmJiBsaW5lTm8obGluZSk7XG4gICAgICBpbnNlcnRMaW5lQ29udGVudChsaW5lLCBidWlsZGVyLCBnZXRMaW5lU3R5bGVzKGNtLCBsaW5lLCBhbGxvd0Zyb250aWVyVXBkYXRlKSk7XG4gICAgICBpZiAobGluZS5zdHlsZUNsYXNzZXMpIHtcbiAgICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzLmJnQ2xhc3MpXG4gICAgICAgICAgeyBidWlsZGVyLmJnQ2xhc3MgPSBqb2luQ2xhc3NlcyhsaW5lLnN0eWxlQ2xhc3Nlcy5iZ0NsYXNzLCBidWlsZGVyLmJnQ2xhc3MgfHwgXCJcIik7IH1cbiAgICAgICAgaWYgKGxpbmUuc3R5bGVDbGFzc2VzLnRleHRDbGFzcylcbiAgICAgICAgICB7IGJ1aWxkZXIudGV4dENsYXNzID0gam9pbkNsYXNzZXMobGluZS5zdHlsZUNsYXNzZXMudGV4dENsYXNzLCBidWlsZGVyLnRleHRDbGFzcyB8fCBcIlwiKTsgfVxuICAgICAgfVxuXG4gICAgICAvLyBFbnN1cmUgYXQgbGVhc3QgYSBzaW5nbGUgbm9kZSBpcyBwcmVzZW50LCBmb3IgbWVhc3VyaW5nLlxuICAgICAgaWYgKGJ1aWxkZXIubWFwLmxlbmd0aCA9PSAwKVxuICAgICAgICB7IGJ1aWxkZXIubWFwLnB1c2goMCwgMCwgYnVpbGRlci5jb250ZW50LmFwcGVuZENoaWxkKHplcm9XaWR0aEVsZW1lbnQoY20uZGlzcGxheS5tZWFzdXJlKSkpOyB9XG5cbiAgICAgIC8vIFN0b3JlIHRoZSBtYXAgYW5kIGEgY2FjaGUgb2JqZWN0IGZvciB0aGUgY3VycmVudCBsb2dpY2FsIGxpbmVcbiAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgbGluZVZpZXcubWVhc3VyZS5tYXAgPSBidWlsZGVyLm1hcDtcbiAgICAgICAgbGluZVZpZXcubWVhc3VyZS5jYWNoZSA9IHt9O1xuICAgICAgfSBlbHNlIHtcbiAgKGxpbmVWaWV3Lm1lYXN1cmUubWFwcyB8fCAobGluZVZpZXcubWVhc3VyZS5tYXBzID0gW10pKS5wdXNoKGJ1aWxkZXIubWFwKVxuICAgICAgICA7KGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzIHx8IChsaW5lVmlldy5tZWFzdXJlLmNhY2hlcyA9IFtdKSkucHVzaCh7fSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU2VlIGlzc3VlICMyOTAxXG4gICAgaWYgKHdlYmtpdCkge1xuICAgICAgdmFyIGxhc3QgPSBidWlsZGVyLmNvbnRlbnQubGFzdENoaWxkO1xuICAgICAgaWYgKC9cXGJjbS10YWJcXGIvLnRlc3QobGFzdC5jbGFzc05hbWUpIHx8IChsYXN0LnF1ZXJ5U2VsZWN0b3IgJiYgbGFzdC5xdWVyeVNlbGVjdG9yKFwiLmNtLXRhYlwiKSkpXG4gICAgICAgIHsgYnVpbGRlci5jb250ZW50LmNsYXNzTmFtZSA9IFwiY20tdGFiLXdyYXAtaGFja1wiOyB9XG4gICAgfVxuXG4gICAgc2lnbmFsKGNtLCBcInJlbmRlckxpbmVcIiwgY20sIGxpbmVWaWV3LmxpbmUsIGJ1aWxkZXIucHJlKTtcbiAgICBpZiAoYnVpbGRlci5wcmUuY2xhc3NOYW1lKVxuICAgICAgeyBidWlsZGVyLnRleHRDbGFzcyA9IGpvaW5DbGFzc2VzKGJ1aWxkZXIucHJlLmNsYXNzTmFtZSwgYnVpbGRlci50ZXh0Q2xhc3MgfHwgXCJcIik7IH1cblxuICAgIHJldHVybiBidWlsZGVyXG4gIH1cblxuICBmdW5jdGlvbiBkZWZhdWx0U3BlY2lhbENoYXJQbGFjZWhvbGRlcihjaCkge1xuICAgIHZhciB0b2tlbiA9IGVsdChcInNwYW5cIiwgXCJcXHUyMDIyXCIsIFwiY20taW52YWxpZGNoYXJcIik7XG4gICAgdG9rZW4udGl0bGUgPSBcIlxcXFx1XCIgKyBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KTtcbiAgICB0b2tlbi5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIHRva2VuLnRpdGxlKTtcbiAgICByZXR1cm4gdG9rZW5cbiAgfVxuXG4gIC8vIEJ1aWxkIHVwIHRoZSBET00gcmVwcmVzZW50YXRpb24gZm9yIGEgc2luZ2xlIHRva2VuLCBhbmQgYWRkIGl0IHRvXG4gIC8vIHRoZSBsaW5lIG1hcC4gVGFrZXMgY2FyZSB0byByZW5kZXIgc3BlY2lhbCBjaGFyYWN0ZXJzIHNlcGFyYXRlbHkuXG4gIGZ1bmN0aW9uIGJ1aWxkVG9rZW4oYnVpbGRlciwgdGV4dCwgc3R5bGUsIHN0YXJ0U3R5bGUsIGVuZFN0eWxlLCBjc3MsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoIXRleHQpIHsgcmV0dXJuIH1cbiAgICB2YXIgZGlzcGxheVRleHQgPSBidWlsZGVyLnNwbGl0U3BhY2VzID8gc3BsaXRTcGFjZXModGV4dCwgYnVpbGRlci50cmFpbGluZ1NwYWNlKSA6IHRleHQ7XG4gICAgdmFyIHNwZWNpYWwgPSBidWlsZGVyLmNtLnN0YXRlLnNwZWNpYWxDaGFycywgbXVzdFdyYXAgPSBmYWxzZTtcbiAgICB2YXIgY29udGVudDtcbiAgICBpZiAoIXNwZWNpYWwudGVzdCh0ZXh0KSkge1xuICAgICAgYnVpbGRlci5jb2wgKz0gdGV4dC5sZW5ndGg7XG4gICAgICBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGlzcGxheVRleHQpO1xuICAgICAgYnVpbGRlci5tYXAucHVzaChidWlsZGVyLnBvcywgYnVpbGRlci5wb3MgKyB0ZXh0Lmxlbmd0aCwgY29udGVudCk7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpIHsgbXVzdFdyYXAgPSB0cnVlOyB9XG4gICAgICBidWlsZGVyLnBvcyArPSB0ZXh0Lmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3BlY2lhbC5sYXN0SW5kZXggPSBwb3M7XG4gICAgICAgIHZhciBtID0gc3BlY2lhbC5leGVjKHRleHQpO1xuICAgICAgICB2YXIgc2tpcHBlZCA9IG0gPyBtLmluZGV4IC0gcG9zIDogdGV4dC5sZW5ndGggLSBwb3M7XG4gICAgICAgIGlmIChza2lwcGVkKSB7XG4gICAgICAgICAgdmFyIHR4dCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRpc3BsYXlUZXh0LnNsaWNlKHBvcywgcG9zICsgc2tpcHBlZCkpO1xuICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcInNwYW5cIiwgW3R4dF0pKTsgfVxuICAgICAgICAgIGVsc2UgeyBjb250ZW50LmFwcGVuZENoaWxkKHR4dCk7IH1cbiAgICAgICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHNraXBwZWQsIHR4dCk7XG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gc2tpcHBlZDtcbiAgICAgICAgICBidWlsZGVyLnBvcyArPSBza2lwcGVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbSkgeyBicmVhayB9XG4gICAgICAgIHBvcyArPSBza2lwcGVkICsgMTtcbiAgICAgICAgdmFyIHR4dCQxID0gKHZvaWQgMCk7XG4gICAgICAgIGlmIChtWzBdID09IFwiXFx0XCIpIHtcbiAgICAgICAgICB2YXIgdGFiU2l6ZSA9IGJ1aWxkZXIuY20ub3B0aW9ucy50YWJTaXplLCB0YWJXaWR0aCA9IHRhYlNpemUgLSBidWlsZGVyLmNvbCAlIHRhYlNpemU7XG4gICAgICAgICAgdHh0JDEgPSBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcInNwYW5cIiwgc3BhY2VTdHIodGFiV2lkdGgpLCBcImNtLXRhYlwiKSk7XG4gICAgICAgICAgdHh0JDEuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInByZXNlbnRhdGlvblwiKTtcbiAgICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsIFwiXFx0XCIpO1xuICAgICAgICAgIGJ1aWxkZXIuY29sICs9IHRhYldpZHRoO1xuICAgICAgICB9IGVsc2UgaWYgKG1bMF0gPT0gXCJcXHJcIiB8fCBtWzBdID09IFwiXFxuXCIpIHtcbiAgICAgICAgICB0eHQkMSA9IGNvbnRlbnQuYXBwZW5kQ2hpbGQoZWx0KFwic3BhblwiLCBtWzBdID09IFwiXFxyXCIgPyBcIlxcdTI0MGRcIiA6IFwiXFx1MjQyNFwiLCBcImNtLWludmFsaWRjaGFyXCIpKTtcbiAgICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsIG1bMF0pO1xuICAgICAgICAgIGJ1aWxkZXIuY29sICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHh0JDEgPSBidWlsZGVyLmNtLm9wdGlvbnMuc3BlY2lhbENoYXJQbGFjZWhvbGRlcihtWzBdKTtcbiAgICAgICAgICB0eHQkMS5zZXRBdHRyaWJ1dGUoXCJjbS10ZXh0XCIsIG1bMF0pO1xuICAgICAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSkgeyBjb250ZW50LmFwcGVuZENoaWxkKGVsdChcInNwYW5cIiwgW3R4dCQxXSkpOyB9XG4gICAgICAgICAgZWxzZSB7IGNvbnRlbnQuYXBwZW5kQ2hpbGQodHh0JDEpOyB9XG4gICAgICAgICAgYnVpbGRlci5jb2wgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIDEsIHR4dCQxKTtcbiAgICAgICAgYnVpbGRlci5wb3MrKztcbiAgICAgIH1cbiAgICB9XG4gICAgYnVpbGRlci50cmFpbGluZ1NwYWNlID0gZGlzcGxheVRleHQuY2hhckNvZGVBdCh0ZXh0Lmxlbmd0aCAtIDEpID09IDMyO1xuICAgIGlmIChzdHlsZSB8fCBzdGFydFN0eWxlIHx8IGVuZFN0eWxlIHx8IG11c3RXcmFwIHx8IGNzcyB8fCBhdHRyaWJ1dGVzKSB7XG4gICAgICB2YXIgZnVsbFN0eWxlID0gc3R5bGUgfHwgXCJcIjtcbiAgICAgIGlmIChzdGFydFN0eWxlKSB7IGZ1bGxTdHlsZSArPSBzdGFydFN0eWxlOyB9XG4gICAgICBpZiAoZW5kU3R5bGUpIHsgZnVsbFN0eWxlICs9IGVuZFN0eWxlOyB9XG4gICAgICB2YXIgdG9rZW4gPSBlbHQoXCJzcGFuXCIsIFtjb250ZW50XSwgZnVsbFN0eWxlLCBjc3MpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7IGlmIChhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHIpICYmIGF0dHIgIT0gXCJzdHlsZVwiICYmIGF0dHIgIT0gXCJjbGFzc1wiKVxuICAgICAgICAgIHsgdG9rZW4uc2V0QXR0cmlidXRlKGF0dHIsIGF0dHJpYnV0ZXNbYXR0cl0pOyB9IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQodG9rZW4pXG4gICAgfVxuICAgIGJ1aWxkZXIuY29udGVudC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgfVxuXG4gIC8vIENoYW5nZSBzb21lIHNwYWNlcyB0byBOQlNQIHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBjb2xsYXBzaW5nXG4gIC8vIHRyYWlsaW5nIHNwYWNlcyBhdCB0aGUgZW5kIG9mIGEgbGluZSB3aGVuIHJlbmRlcmluZyB0ZXh0IChpc3N1ZSAjMTM2MikuXG4gIGZ1bmN0aW9uIHNwbGl0U3BhY2VzKHRleHQsIHRyYWlsaW5nQmVmb3JlKSB7XG4gICAgaWYgKHRleHQubGVuZ3RoID4gMSAmJiAhLyAgLy50ZXN0KHRleHQpKSB7IHJldHVybiB0ZXh0IH1cbiAgICB2YXIgc3BhY2VCZWZvcmUgPSB0cmFpbGluZ0JlZm9yZSwgcmVzdWx0ID0gXCJcIjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgaWYgKGNoID09IFwiIFwiICYmIHNwYWNlQmVmb3JlICYmIChpID09IHRleHQubGVuZ3RoIC0gMSB8fCB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpID09IDMyKSlcbiAgICAgICAgeyBjaCA9IFwiXFx1MDBhMFwiOyB9XG4gICAgICByZXN1bHQgKz0gY2g7XG4gICAgICBzcGFjZUJlZm9yZSA9IGNoID09IFwiIFwiO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBXb3JrIGFyb3VuZCBub25zZW5zZSBkaW1lbnNpb25zIGJlaW5nIHJlcG9ydGVkIGZvciBzdHJldGNoZXMgb2ZcbiAgLy8gcmlnaHQtdG8tbGVmdCB0ZXh0LlxuICBmdW5jdGlvbiBidWlsZFRva2VuQmFkQmlkaShpbm5lciwgb3JkZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgY3NzLCBhdHRyaWJ1dGVzKSB7XG4gICAgICBzdHlsZSA9IHN0eWxlID8gc3R5bGUgKyBcIiBjbS1mb3JjZS1ib3JkZXJcIiA6IFwiY20tZm9yY2UtYm9yZGVyXCI7XG4gICAgICB2YXIgc3RhcnQgPSBidWlsZGVyLnBvcywgZW5kID0gc3RhcnQgKyB0ZXh0Lmxlbmd0aDtcbiAgICAgIGZvciAoOzspIHtcbiAgICAgICAgLy8gRmluZCB0aGUgcGFydCB0aGF0IG92ZXJsYXBzIHdpdGggdGhlIHN0YXJ0IG9mIHRoaXMgdGV4dFxuICAgICAgICB2YXIgcGFydCA9ICh2b2lkIDApO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9yZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcGFydCA9IG9yZGVyW2ldO1xuICAgICAgICAgIGlmIChwYXJ0LnRvID4gc3RhcnQgJiYgcGFydC5mcm9tIDw9IHN0YXJ0KSB7IGJyZWFrIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydC50byA+PSBlbmQpIHsgcmV0dXJuIGlubmVyKGJ1aWxkZXIsIHRleHQsIHN0eWxlLCBzdGFydFN0eWxlLCBlbmRTdHlsZSwgY3NzLCBhdHRyaWJ1dGVzKSB9XG4gICAgICAgIGlubmVyKGJ1aWxkZXIsIHRleHQuc2xpY2UoMCwgcGFydC50byAtIHN0YXJ0KSwgc3R5bGUsIHN0YXJ0U3R5bGUsIG51bGwsIGNzcywgYXR0cmlidXRlcyk7XG4gICAgICAgIHN0YXJ0U3R5bGUgPSBudWxsO1xuICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShwYXJ0LnRvIC0gc3RhcnQpO1xuICAgICAgICBzdGFydCA9IHBhcnQudG87XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRDb2xsYXBzZWRTcGFuKGJ1aWxkZXIsIHNpemUsIG1hcmtlciwgaWdub3JlV2lkZ2V0KSB7XG4gICAgdmFyIHdpZGdldCA9ICFpZ25vcmVXaWRnZXQgJiYgbWFya2VyLndpZGdldE5vZGU7XG4gICAgaWYgKHdpZGdldCkgeyBidWlsZGVyLm1hcC5wdXNoKGJ1aWxkZXIucG9zLCBidWlsZGVyLnBvcyArIHNpemUsIHdpZGdldCk7IH1cbiAgICBpZiAoIWlnbm9yZVdpZGdldCAmJiBidWlsZGVyLmNtLmRpc3BsYXkuaW5wdXQubmVlZHNDb250ZW50QXR0cmlidXRlKSB7XG4gICAgICBpZiAoIXdpZGdldClcbiAgICAgICAgeyB3aWRnZXQgPSBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIikpOyB9XG4gICAgICB3aWRnZXQuc2V0QXR0cmlidXRlKFwiY20tbWFya2VyXCIsIG1hcmtlci5pZCk7XG4gICAgfVxuICAgIGlmICh3aWRnZXQpIHtcbiAgICAgIGJ1aWxkZXIuY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKHdpZGdldCk7XG4gICAgICBidWlsZGVyLmNvbnRlbnQuYXBwZW5kQ2hpbGQod2lkZ2V0KTtcbiAgICB9XG4gICAgYnVpbGRlci5wb3MgKz0gc2l6ZTtcbiAgICBidWlsZGVyLnRyYWlsaW5nU3BhY2UgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIE91dHB1dHMgYSBudW1iZXIgb2Ygc3BhbnMgdG8gbWFrZSB1cCBhIGxpbmUsIHRha2luZyBoaWdobGlnaHRpbmdcbiAgLy8gYW5kIG1hcmtlZCB0ZXh0IGludG8gYWNjb3VudC5cbiAgZnVuY3Rpb24gaW5zZXJ0TGluZUNvbnRlbnQobGluZSwgYnVpbGRlciwgc3R5bGVzKSB7XG4gICAgdmFyIHNwYW5zID0gbGluZS5tYXJrZWRTcGFucywgYWxsVGV4dCA9IGxpbmUudGV4dCwgYXQgPSAwO1xuICAgIGlmICghc3BhbnMpIHtcbiAgICAgIGZvciAodmFyIGkkMSA9IDE7IGkkMSA8IHN0eWxlcy5sZW5ndGg7IGkkMSs9MilcbiAgICAgICAgeyBidWlsZGVyLmFkZFRva2VuKGJ1aWxkZXIsIGFsbFRleHQuc2xpY2UoYXQsIGF0ID0gc3R5bGVzW2kkMV0pLCBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlc1tpJDErMV0sIGJ1aWxkZXIuY20ub3B0aW9ucykpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgbGVuID0gYWxsVGV4dC5sZW5ndGgsIHBvcyA9IDAsIGkgPSAxLCB0ZXh0ID0gXCJcIiwgc3R5bGUsIGNzcztcbiAgICB2YXIgbmV4dENoYW5nZSA9IDAsIHNwYW5TdHlsZSwgc3BhbkVuZFN0eWxlLCBzcGFuU3RhcnRTdHlsZSwgY29sbGFwc2VkLCBhdHRyaWJ1dGVzO1xuICAgIGZvciAoOzspIHtcbiAgICAgIGlmIChuZXh0Q2hhbmdlID09IHBvcykgeyAvLyBVcGRhdGUgY3VycmVudCBtYXJrZXIgc2V0XG4gICAgICAgIHNwYW5TdHlsZSA9IHNwYW5FbmRTdHlsZSA9IHNwYW5TdGFydFN0eWxlID0gY3NzID0gXCJcIjtcbiAgICAgICAgYXR0cmlidXRlcyA9IG51bGw7XG4gICAgICAgIGNvbGxhcHNlZCA9IG51bGw7IG5leHRDaGFuZ2UgPSBJbmZpbml0eTtcbiAgICAgICAgdmFyIGZvdW5kQm9va21hcmtzID0gW10sIGVuZFN0eWxlcyA9ICh2b2lkIDApO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHNwYW5zLmxlbmd0aDsgKytqKSB7XG4gICAgICAgICAgdmFyIHNwID0gc3BhbnNbal0sIG0gPSBzcC5tYXJrZXI7XG4gICAgICAgICAgaWYgKG0udHlwZSA9PSBcImJvb2ttYXJrXCIgJiYgc3AuZnJvbSA9PSBwb3MgJiYgbS53aWRnZXROb2RlKSB7XG4gICAgICAgICAgICBmb3VuZEJvb2ttYXJrcy5wdXNoKG0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3AuZnJvbSA8PSBwb3MgJiYgKHNwLnRvID09IG51bGwgfHwgc3AudG8gPiBwb3MgfHwgbS5jb2xsYXBzZWQgJiYgc3AudG8gPT0gcG9zICYmIHNwLmZyb20gPT0gcG9zKSkge1xuICAgICAgICAgICAgaWYgKHNwLnRvICE9IG51bGwgJiYgc3AudG8gIT0gcG9zICYmIG5leHRDaGFuZ2UgPiBzcC50bykge1xuICAgICAgICAgICAgICBuZXh0Q2hhbmdlID0gc3AudG87XG4gICAgICAgICAgICAgIHNwYW5FbmRTdHlsZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobS5jbGFzc05hbWUpIHsgc3BhblN0eWxlICs9IFwiIFwiICsgbS5jbGFzc05hbWU7IH1cbiAgICAgICAgICAgIGlmIChtLmNzcykgeyBjc3MgPSAoY3NzID8gY3NzICsgXCI7XCIgOiBcIlwiKSArIG0uY3NzOyB9XG4gICAgICAgICAgICBpZiAobS5zdGFydFN0eWxlICYmIHNwLmZyb20gPT0gcG9zKSB7IHNwYW5TdGFydFN0eWxlICs9IFwiIFwiICsgbS5zdGFydFN0eWxlOyB9XG4gICAgICAgICAgICBpZiAobS5lbmRTdHlsZSAmJiBzcC50byA9PSBuZXh0Q2hhbmdlKSB7IChlbmRTdHlsZXMgfHwgKGVuZFN0eWxlcyA9IFtdKSkucHVzaChtLmVuZFN0eWxlLCBzcC50byk7IH1cbiAgICAgICAgICAgIC8vIHN1cHBvcnQgZm9yIHRoZSBvbGQgdGl0bGUgcHJvcGVydHlcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2RlbWlycm9yL0NvZGVNaXJyb3IvcHVsbC81NjczXG4gICAgICAgICAgICBpZiAobS50aXRsZSkgeyAoYXR0cmlidXRlcyB8fCAoYXR0cmlidXRlcyA9IHt9KSkudGl0bGUgPSBtLnRpdGxlOyB9XG4gICAgICAgICAgICBpZiAobS5hdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGF0dHIgaW4gbS5hdHRyaWJ1dGVzKVxuICAgICAgICAgICAgICAgIHsgKGF0dHJpYnV0ZXMgfHwgKGF0dHJpYnV0ZXMgPSB7fSkpW2F0dHJdID0gbS5hdHRyaWJ1dGVzW2F0dHJdOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobS5jb2xsYXBzZWQgJiYgKCFjb2xsYXBzZWQgfHwgY29tcGFyZUNvbGxhcHNlZE1hcmtlcnMoY29sbGFwc2VkLm1hcmtlciwgbSkgPCAwKSlcbiAgICAgICAgICAgICAgeyBjb2xsYXBzZWQgPSBzcDsgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoc3AuZnJvbSA+IHBvcyAmJiBuZXh0Q2hhbmdlID4gc3AuZnJvbSkge1xuICAgICAgICAgICAgbmV4dENoYW5nZSA9IHNwLmZyb207XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlbmRTdHlsZXMpIHsgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgZW5kU3R5bGVzLmxlbmd0aDsgaiQxICs9IDIpXG4gICAgICAgICAgeyBpZiAoZW5kU3R5bGVzW2okMSArIDFdID09IG5leHRDaGFuZ2UpIHsgc3BhbkVuZFN0eWxlICs9IFwiIFwiICsgZW5kU3R5bGVzW2okMV07IH0gfSB9XG5cbiAgICAgICAgaWYgKCFjb2xsYXBzZWQgfHwgY29sbGFwc2VkLmZyb20gPT0gcG9zKSB7IGZvciAodmFyIGokMiA9IDA7IGokMiA8IGZvdW5kQm9va21hcmtzLmxlbmd0aDsgKytqJDIpXG4gICAgICAgICAgeyBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgMCwgZm91bmRCb29rbWFya3NbaiQyXSk7IH0gfVxuICAgICAgICBpZiAoY29sbGFwc2VkICYmIChjb2xsYXBzZWQuZnJvbSB8fCAwKSA9PSBwb3MpIHtcbiAgICAgICAgICBidWlsZENvbGxhcHNlZFNwYW4oYnVpbGRlciwgKGNvbGxhcHNlZC50byA9PSBudWxsID8gbGVuICsgMSA6IGNvbGxhcHNlZC50bykgLSBwb3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNlZC5tYXJrZXIsIGNvbGxhcHNlZC5mcm9tID09IG51bGwpO1xuICAgICAgICAgIGlmIChjb2xsYXBzZWQudG8gPT0gbnVsbCkgeyByZXR1cm4gfVxuICAgICAgICAgIGlmIChjb2xsYXBzZWQudG8gPT0gcG9zKSB7IGNvbGxhcHNlZCA9IGZhbHNlOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwb3MgPj0gbGVuKSB7IGJyZWFrIH1cblxuICAgICAgdmFyIHVwdG8gPSBNYXRoLm1pbihsZW4sIG5leHRDaGFuZ2UpO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKHRleHQpIHtcbiAgICAgICAgICB2YXIgZW5kID0gcG9zICsgdGV4dC5sZW5ndGg7XG4gICAgICAgICAgaWYgKCFjb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHZhciB0b2tlblRleHQgPSBlbmQgPiB1cHRvID8gdGV4dC5zbGljZSgwLCB1cHRvIC0gcG9zKSA6IHRleHQ7XG4gICAgICAgICAgICBidWlsZGVyLmFkZFRva2VuKGJ1aWxkZXIsIHRva2VuVGV4dCwgc3R5bGUgPyBzdHlsZSArIHNwYW5TdHlsZSA6IHNwYW5TdHlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhblN0YXJ0U3R5bGUsIHBvcyArIHRva2VuVGV4dC5sZW5ndGggPT0gbmV4dENoYW5nZSA/IHNwYW5FbmRTdHlsZSA6IFwiXCIsIGNzcywgYXR0cmlidXRlcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChlbmQgPj0gdXB0bykge3RleHQgPSB0ZXh0LnNsaWNlKHVwdG8gLSBwb3MpOyBwb3MgPSB1cHRvOyBicmVha31cbiAgICAgICAgICBwb3MgPSBlbmQ7XG4gICAgICAgICAgc3BhblN0YXJ0U3R5bGUgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBhbGxUZXh0LnNsaWNlKGF0LCBhdCA9IHN0eWxlc1tpKytdKTtcbiAgICAgICAgc3R5bGUgPSBpbnRlcnByZXRUb2tlblN0eWxlKHN0eWxlc1tpKytdLCBidWlsZGVyLmNtLm9wdGlvbnMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgLy8gVGhlc2Ugb2JqZWN0cyBhcmUgdXNlZCB0byByZXByZXNlbnQgdGhlIHZpc2libGUgKGN1cnJlbnRseSBkcmF3bilcbiAgLy8gcGFydCBvZiB0aGUgZG9jdW1lbnQuIEEgTGluZVZpZXcgbWF5IGNvcnJlc3BvbmQgdG8gbXVsdGlwbGVcbiAgLy8gbG9naWNhbCBsaW5lcywgaWYgdGhvc2UgYXJlIGNvbm5lY3RlZCBieSBjb2xsYXBzZWQgcmFuZ2VzLlxuICBmdW5jdGlvbiBMaW5lVmlldyhkb2MsIGxpbmUsIGxpbmVOKSB7XG4gICAgLy8gVGhlIHN0YXJ0aW5nIGxpbmVcbiAgICB0aGlzLmxpbmUgPSBsaW5lO1xuICAgIC8vIENvbnRpbnVpbmcgbGluZXMsIGlmIGFueVxuICAgIHRoaXMucmVzdCA9IHZpc3VhbExpbmVDb250aW51ZWQobGluZSk7XG4gICAgLy8gTnVtYmVyIG9mIGxvZ2ljYWwgbGluZXMgaW4gdGhpcyB2aXN1YWwgbGluZVxuICAgIHRoaXMuc2l6ZSA9IHRoaXMucmVzdCA/IGxpbmVObyhsc3QodGhpcy5yZXN0KSkgLSBsaW5lTiArIDEgOiAxO1xuICAgIHRoaXMubm9kZSA9IHRoaXMudGV4dCA9IG51bGw7XG4gICAgdGhpcy5oaWRkZW4gPSBsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIHJhbmdlIG9mIExpbmVWaWV3IG9iamVjdHMgZm9yIHRoZSBnaXZlbiBsaW5lcy5cbiAgZnVuY3Rpb24gYnVpbGRWaWV3QXJyYXkoY20sIGZyb20sIHRvKSB7XG4gICAgdmFyIGFycmF5ID0gW10sIG5leHRQb3M7XG4gICAgZm9yICh2YXIgcG9zID0gZnJvbTsgcG9zIDwgdG87IHBvcyA9IG5leHRQb3MpIHtcbiAgICAgIHZhciB2aWV3ID0gbmV3IExpbmVWaWV3KGNtLmRvYywgZ2V0TGluZShjbS5kb2MsIHBvcyksIHBvcyk7XG4gICAgICBuZXh0UG9zID0gcG9zICsgdmlldy5zaXplO1xuICAgICAgYXJyYXkucHVzaCh2aWV3KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5XG4gIH1cblxuICB2YXIgb3BlcmF0aW9uR3JvdXAgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHB1c2hPcGVyYXRpb24ob3ApIHtcbiAgICBpZiAob3BlcmF0aW9uR3JvdXApIHtcbiAgICAgIG9wZXJhdGlvbkdyb3VwLm9wcy5wdXNoKG9wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3Aub3duc0dyb3VwID0gb3BlcmF0aW9uR3JvdXAgPSB7XG4gICAgICAgIG9wczogW29wXSxcbiAgICAgICAgZGVsYXllZENhbGxiYWNrczogW11cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmlyZUNhbGxiYWNrc0Zvck9wcyhncm91cCkge1xuICAgIC8vIENhbGxzIGRlbGF5ZWQgY2FsbGJhY2tzIGFuZCBjdXJzb3JBY3Rpdml0eSBoYW5kbGVycyB1bnRpbCBub1xuICAgIC8vIG5ldyBvbmVzIGFwcGVhclxuICAgIHZhciBjYWxsYmFja3MgPSBncm91cC5kZWxheWVkQ2FsbGJhY2tzLCBpID0gMDtcbiAgICBkbyB7XG4gICAgICBmb3IgKDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBjYWxsYmFja3NbaV0uY2FsbChudWxsKTsgfVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBncm91cC5vcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIG9wID0gZ3JvdXAub3BzW2pdO1xuICAgICAgICBpZiAob3AuY3Vyc29yQWN0aXZpdHlIYW5kbGVycylcbiAgICAgICAgICB7IHdoaWxlIChvcC5jdXJzb3JBY3Rpdml0eUNhbGxlZCA8IG9wLmN1cnNvckFjdGl2aXR5SGFuZGxlcnMubGVuZ3RoKVxuICAgICAgICAgICAgeyBvcC5jdXJzb3JBY3Rpdml0eUhhbmRsZXJzW29wLmN1cnNvckFjdGl2aXR5Q2FsbGVkKytdLmNhbGwobnVsbCwgb3AuY20pOyB9IH1cbiAgICAgIH1cbiAgICB9IHdoaWxlIChpIDwgY2FsbGJhY2tzLmxlbmd0aClcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaE9wZXJhdGlvbihvcCwgZW5kQ2IpIHtcbiAgICB2YXIgZ3JvdXAgPSBvcC5vd25zR3JvdXA7XG4gICAgaWYgKCFncm91cCkgeyByZXR1cm4gfVxuXG4gICAgdHJ5IHsgZmlyZUNhbGxiYWNrc0Zvck9wcyhncm91cCk7IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgIG9wZXJhdGlvbkdyb3VwID0gbnVsbDtcbiAgICAgIGVuZENiKGdyb3VwKTtcbiAgICB9XG4gIH1cblxuICB2YXIgb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IG51bGw7XG5cbiAgLy8gT2Z0ZW4sIHdlIHdhbnQgdG8gc2lnbmFsIGV2ZW50cyBhdCBhIHBvaW50IHdoZXJlIHdlIGFyZSBpbiB0aGVcbiAgLy8gbWlkZGxlIG9mIHNvbWUgd29yaywgYnV0IGRvbid0IHdhbnQgdGhlIGhhbmRsZXIgdG8gc3RhcnQgY2FsbGluZ1xuICAvLyBvdGhlciBtZXRob2RzIG9uIHRoZSBlZGl0b3IsIHdoaWNoIG1pZ2h0IGJlIGluIGFuIGluY29uc2lzdGVudFxuICAvLyBzdGF0ZSBvciBzaW1wbHkgbm90IGV4cGVjdCBhbnkgb3RoZXIgZXZlbnRzIHRvIGhhcHBlbi5cbiAgLy8gc2lnbmFsTGF0ZXIgbG9va3Mgd2hldGhlciB0aGVyZSBhcmUgYW55IGhhbmRsZXJzLCBhbmQgc2NoZWR1bGVzXG4gIC8vIHRoZW0gdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgbGFzdCBvcGVyYXRpb24gZW5kcywgb3IsIGlmIG5vXG4gIC8vIG9wZXJhdGlvbiBpcyBhY3RpdmUsIHdoZW4gYSB0aW1lb3V0IGZpcmVzLlxuICBmdW5jdGlvbiBzaWduYWxMYXRlcihlbWl0dGVyLCB0eXBlIC8qLCB2YWx1ZXMuLi4qLykge1xuICAgIHZhciBhcnIgPSBnZXRIYW5kbGVycyhlbWl0dGVyLCB0eXBlKTtcbiAgICBpZiAoIWFyci5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksIGxpc3Q7XG4gICAgaWYgKG9wZXJhdGlvbkdyb3VwKSB7XG4gICAgICBsaXN0ID0gb3BlcmF0aW9uR3JvdXAuZGVsYXllZENhbGxiYWNrcztcbiAgICB9IGVsc2UgaWYgKG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MpIHtcbiAgICAgIGxpc3QgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0ID0gb3JwaGFuRGVsYXllZENhbGxiYWNrcyA9IFtdO1xuICAgICAgc2V0VGltZW91dChmaXJlT3JwaGFuRGVsYXllZCwgMCk7XG4gICAgfVxuICAgIHZhciBsb29wID0gZnVuY3Rpb24gKCBpICkge1xuICAgICAgbGlzdC5wdXNoKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFycltpXS5hcHBseShudWxsLCBhcmdzKTsgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKVxuICAgICAgbG9vcCggaSApO1xuICB9XG5cbiAgZnVuY3Rpb24gZmlyZU9ycGhhbkRlbGF5ZWQoKSB7XG4gICAgdmFyIGRlbGF5ZWQgPSBvcnBoYW5EZWxheWVkQ2FsbGJhY2tzO1xuICAgIG9ycGhhbkRlbGF5ZWRDYWxsYmFja3MgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsYXllZC5sZW5ndGg7ICsraSkgeyBkZWxheWVkW2ldKCk7IH1cbiAgfVxuXG4gIC8vIFdoZW4gYW4gYXNwZWN0IG9mIGEgbGluZSBjaGFuZ2VzLCBhIHN0cmluZyBpcyBhZGRlZCB0b1xuICAvLyBsaW5lVmlldy5jaGFuZ2VzLiBUaGlzIHVwZGF0ZXMgdGhlIHJlbGV2YW50IHBhcnQgb2YgdGhlIGxpbmUnc1xuICAvLyBET00gc3RydWN0dXJlLlxuICBmdW5jdGlvbiB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBsaW5lVmlldy5jaGFuZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgdHlwZSA9IGxpbmVWaWV3LmNoYW5nZXNbal07XG4gICAgICBpZiAodHlwZSA9PSBcInRleHRcIikgeyB1cGRhdGVMaW5lVGV4dChjbSwgbGluZVZpZXcpOyB9XG4gICAgICBlbHNlIGlmICh0eXBlID09IFwiZ3V0dGVyXCIpIHsgdXBkYXRlTGluZUd1dHRlcihjbSwgbGluZVZpZXcsIGxpbmVOLCBkaW1zKTsgfVxuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcImNsYXNzXCIpIHsgdXBkYXRlTGluZUNsYXNzZXMoY20sIGxpbmVWaWV3KTsgfVxuICAgICAgZWxzZSBpZiAodHlwZSA9PSBcIndpZGdldFwiKSB7IHVwZGF0ZUxpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcyk7IH1cbiAgICB9XG4gICAgbGluZVZpZXcuY2hhbmdlcyA9IG51bGw7XG4gIH1cblxuICAvLyBMaW5lcyB3aXRoIGd1dHRlciBlbGVtZW50cywgd2lkZ2V0cyBvciBhIGJhY2tncm91bmQgY2xhc3MgbmVlZCB0b1xuICAvLyBiZSB3cmFwcGVkLCBhbmQgaGF2ZSB0aGUgZXh0cmEgZWxlbWVudHMgYWRkZWQgdG8gdGhlIHdyYXBwZXIgZGl2XG4gIGZ1bmN0aW9uIGVuc3VyZUxpbmVXcmFwcGVkKGxpbmVWaWV3KSB7XG4gICAgaWYgKGxpbmVWaWV3Lm5vZGUgPT0gbGluZVZpZXcudGV4dCkge1xuICAgICAgbGluZVZpZXcubm9kZSA9IGVsdChcImRpdlwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZVwiKTtcbiAgICAgIGlmIChsaW5lVmlldy50ZXh0LnBhcmVudE5vZGUpXG4gICAgICAgIHsgbGluZVZpZXcudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChsaW5lVmlldy5ub2RlLCBsaW5lVmlldy50ZXh0KTsgfVxuICAgICAgbGluZVZpZXcubm9kZS5hcHBlbmRDaGlsZChsaW5lVmlldy50ZXh0KTtcbiAgICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOCkgeyBsaW5lVmlldy5ub2RlLnN0eWxlLnpJbmRleCA9IDI7IH1cbiAgICB9XG4gICAgcmV0dXJuIGxpbmVWaWV3Lm5vZGVcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGNtLCBsaW5lVmlldykge1xuICAgIHZhciBjbHMgPSBsaW5lVmlldy5iZ0NsYXNzID8gbGluZVZpZXcuYmdDbGFzcyArIFwiIFwiICsgKGxpbmVWaWV3LmxpbmUuYmdDbGFzcyB8fCBcIlwiKSA6IGxpbmVWaWV3LmxpbmUuYmdDbGFzcztcbiAgICBpZiAoY2xzKSB7IGNscyArPSBcIiBDb2RlTWlycm9yLWxpbmViYWNrZ3JvdW5kXCI7IH1cbiAgICBpZiAobGluZVZpZXcuYmFja2dyb3VuZCkge1xuICAgICAgaWYgKGNscykgeyBsaW5lVmlldy5iYWNrZ3JvdW5kLmNsYXNzTmFtZSA9IGNsczsgfVxuICAgICAgZWxzZSB7IGxpbmVWaWV3LmJhY2tncm91bmQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5lVmlldy5iYWNrZ3JvdW5kKTsgbGluZVZpZXcuYmFja2dyb3VuZCA9IG51bGw7IH1cbiAgICB9IGVsc2UgaWYgKGNscykge1xuICAgICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XG4gICAgICBsaW5lVmlldy5iYWNrZ3JvdW5kID0gd3JhcC5pbnNlcnRCZWZvcmUoZWx0KFwiZGl2XCIsIG51bGwsIGNscyksIHdyYXAuZmlyc3RDaGlsZCk7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobGluZVZpZXcuYmFja2dyb3VuZCk7XG4gICAgfVxuICB9XG5cbiAgLy8gV3JhcHBlciBhcm91bmQgYnVpbGRMaW5lQ29udGVudCB3aGljaCB3aWxsIHJldXNlIHRoZSBzdHJ1Y3R1cmVcbiAgLy8gaW4gZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkIHdoZW4gcG9zc2libGUuXG4gIGZ1bmN0aW9uIGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldykge1xuICAgIHZhciBleHQgPSBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQ7XG4gICAgaWYgKGV4dCAmJiBleHQubGluZSA9PSBsaW5lVmlldy5saW5lKSB7XG4gICAgICBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZWQgPSBudWxsO1xuICAgICAgbGluZVZpZXcubWVhc3VyZSA9IGV4dC5tZWFzdXJlO1xuICAgICAgcmV0dXJuIGV4dC5idWlsdFxuICAgIH1cbiAgICByZXR1cm4gYnVpbGRMaW5lQ29udGVudChjbSwgbGluZVZpZXcpXG4gIH1cblxuICAvLyBSZWRyYXcgdGhlIGxpbmUncyB0ZXh0LiBJbnRlcmFjdHMgd2l0aCB0aGUgYmFja2dyb3VuZCBhbmQgdGV4dFxuICAvLyBjbGFzc2VzIGJlY2F1c2UgdGhlIG1vZGUgbWF5IG91dHB1dCB0b2tlbnMgdGhhdCBpbmZsdWVuY2UgdGhlc2VcbiAgLy8gY2xhc3Nlcy5cbiAgZnVuY3Rpb24gdXBkYXRlTGluZVRleHQoY20sIGxpbmVWaWV3KSB7XG4gICAgdmFyIGNscyA9IGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lO1xuICAgIHZhciBidWlsdCA9IGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldyk7XG4gICAgaWYgKGxpbmVWaWV3LnRleHQgPT0gbGluZVZpZXcubm9kZSkgeyBsaW5lVmlldy5ub2RlID0gYnVpbHQucHJlOyB9XG4gICAgbGluZVZpZXcudGV4dC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChidWlsdC5wcmUsIGxpbmVWaWV3LnRleHQpO1xuICAgIGxpbmVWaWV3LnRleHQgPSBidWlsdC5wcmU7XG4gICAgaWYgKGJ1aWx0LmJnQ2xhc3MgIT0gbGluZVZpZXcuYmdDbGFzcyB8fCBidWlsdC50ZXh0Q2xhc3MgIT0gbGluZVZpZXcudGV4dENsYXNzKSB7XG4gICAgICBsaW5lVmlldy5iZ0NsYXNzID0gYnVpbHQuYmdDbGFzcztcbiAgICAgIGxpbmVWaWV3LnRleHRDbGFzcyA9IGJ1aWx0LnRleHRDbGFzcztcbiAgICAgIHVwZGF0ZUxpbmVDbGFzc2VzKGNtLCBsaW5lVmlldyk7XG4gICAgfSBlbHNlIGlmIChjbHMpIHtcbiAgICAgIGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lID0gY2xzO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVDbGFzc2VzKGNtLCBsaW5lVmlldykge1xuICAgIHVwZGF0ZUxpbmVCYWNrZ3JvdW5kKGNtLCBsaW5lVmlldyk7XG4gICAgaWYgKGxpbmVWaWV3LmxpbmUud3JhcENsYXNzKVxuICAgICAgeyBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldykuY2xhc3NOYW1lID0gbGluZVZpZXcubGluZS53cmFwQ2xhc3M7IH1cbiAgICBlbHNlIGlmIChsaW5lVmlldy5ub2RlICE9IGxpbmVWaWV3LnRleHQpXG4gICAgICB7IGxpbmVWaWV3Lm5vZGUuY2xhc3NOYW1lID0gXCJcIjsgfVxuICAgIHZhciB0ZXh0Q2xhc3MgPSBsaW5lVmlldy50ZXh0Q2xhc3MgPyBsaW5lVmlldy50ZXh0Q2xhc3MgKyBcIiBcIiArIChsaW5lVmlldy5saW5lLnRleHRDbGFzcyB8fCBcIlwiKSA6IGxpbmVWaWV3LmxpbmUudGV4dENsYXNzO1xuICAgIGxpbmVWaWV3LnRleHQuY2xhc3NOYW1lID0gdGV4dENsYXNzIHx8IFwiXCI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpIHtcbiAgICBpZiAobGluZVZpZXcuZ3V0dGVyKSB7XG4gICAgICBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKGxpbmVWaWV3Lmd1dHRlcik7XG4gICAgICBsaW5lVmlldy5ndXR0ZXIgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCkge1xuICAgICAgbGluZVZpZXcubm9kZS5yZW1vdmVDaGlsZChsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kKTtcbiAgICAgIGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAobGluZVZpZXcubGluZS5ndXR0ZXJDbGFzcykge1xuICAgICAgdmFyIHdyYXAgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XG4gICAgICBsaW5lVmlldy5ndXR0ZXJCYWNrZ3JvdW5kID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXItYmFja2dyb3VuZCBcIiArIGxpbmVWaWV3LmxpbmUuZ3V0dGVyQ2xhc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChcImxlZnQ6IFwiICsgKGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBkaW1zLmZpeGVkUG9zIDogLWRpbXMuZ3V0dGVyVG90YWxXaWR0aCkgKyBcInB4OyB3aWR0aDogXCIgKyAoZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFwicHhcIikpO1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGxpbmVWaWV3Lmd1dHRlckJhY2tncm91bmQpO1xuICAgICAgd3JhcC5pbnNlcnRCZWZvcmUobGluZVZpZXcuZ3V0dGVyQmFja2dyb3VuZCwgbGluZVZpZXcudGV4dCk7XG4gICAgfVxuICAgIHZhciBtYXJrZXJzID0gbGluZVZpZXcubGluZS5ndXR0ZXJNYXJrZXJzO1xuICAgIGlmIChjbS5vcHRpb25zLmxpbmVOdW1iZXJzIHx8IG1hcmtlcnMpIHtcbiAgICAgIHZhciB3cmFwJDEgPSBlbnN1cmVMaW5lV3JhcHBlZChsaW5lVmlldyk7XG4gICAgICB2YXIgZ3V0dGVyV3JhcCA9IGxpbmVWaWV3Lmd1dHRlciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyLXdyYXBwZXJcIiwgKFwibGVmdDogXCIgKyAoY20ub3B0aW9ucy5maXhlZEd1dHRlciA/IGRpbXMuZml4ZWRQb3MgOiAtZGltcy5ndXR0ZXJUb3RhbFdpZHRoKSArIFwicHhcIikpO1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKGd1dHRlcldyYXApO1xuICAgICAgd3JhcCQxLmluc2VydEJlZm9yZShndXR0ZXJXcmFwLCBsaW5lVmlldy50ZXh0KTtcbiAgICAgIGlmIChsaW5lVmlldy5saW5lLmd1dHRlckNsYXNzKVxuICAgICAgICB7IGd1dHRlcldyYXAuY2xhc3NOYW1lICs9IFwiIFwiICsgbGluZVZpZXcubGluZS5ndXR0ZXJDbGFzczsgfVxuICAgICAgaWYgKGNtLm9wdGlvbnMubGluZU51bWJlcnMgJiYgKCFtYXJrZXJzIHx8ICFtYXJrZXJzW1wiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiXSkpXG4gICAgICAgIHsgbGluZVZpZXcubGluZU51bWJlciA9IGd1dHRlcldyYXAuYXBwZW5kQ2hpbGQoXG4gICAgICAgICAgZWx0KFwiZGl2XCIsIGxpbmVOdW1iZXJGb3IoY20ub3B0aW9ucywgbGluZU4pLFxuICAgICAgICAgICAgICBcIkNvZGVNaXJyb3ItbGluZW51bWJlciBDb2RlTWlycm9yLWd1dHRlci1lbHRcIixcbiAgICAgICAgICAgICAgKFwibGVmdDogXCIgKyAoZGltcy5ndXR0ZXJMZWZ0W1wiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiXSkgKyBcInB4OyB3aWR0aDogXCIgKyAoY20uZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCkgKyBcInB4XCIpKSk7IH1cbiAgICAgIGlmIChtYXJrZXJzKSB7IGZvciAodmFyIGsgPSAwOyBrIDwgY20uZGlzcGxheS5ndXR0ZXJTcGVjcy5sZW5ndGg7ICsraykge1xuICAgICAgICB2YXIgaWQgPSBjbS5kaXNwbGF5Lmd1dHRlclNwZWNzW2tdLmNsYXNzTmFtZSwgZm91bmQgPSBtYXJrZXJzLmhhc093blByb3BlcnR5KGlkKSAmJiBtYXJrZXJzW2lkXTtcbiAgICAgICAgaWYgKGZvdW5kKVxuICAgICAgICAgIHsgZ3V0dGVyV3JhcC5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgW2ZvdW5kXSwgXCJDb2RlTWlycm9yLWd1dHRlci1lbHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoXCJsZWZ0OiBcIiArIChkaW1zLmd1dHRlckxlZnRbaWRdKSArIFwicHg7IHdpZHRoOiBcIiArIChkaW1zLmd1dHRlcldpZHRoW2lkXSkgKyBcInB4XCIpKSk7IH1cbiAgICAgIH0gfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcykge1xuICAgIGlmIChsaW5lVmlldy5hbGlnbmFibGUpIHsgbGluZVZpZXcuYWxpZ25hYmxlID0gbnVsbDsgfVxuICAgIHZhciBpc1dpZGdldCA9IGNsYXNzVGVzdChcIkNvZGVNaXJyb3ItbGluZXdpZGdldFwiKTtcbiAgICBmb3IgKHZhciBub2RlID0gbGluZVZpZXcubm9kZS5maXJzdENoaWxkLCBuZXh0ID0gKHZvaWQgMCk7IG5vZGU7IG5vZGUgPSBuZXh0KSB7XG4gICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIGlmIChpc1dpZGdldC50ZXN0KG5vZGUuY2xhc3NOYW1lKSkgeyBsaW5lVmlldy5ub2RlLnJlbW92ZUNoaWxkKG5vZGUpOyB9XG4gICAgfVxuICAgIGluc2VydExpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcyk7XG4gIH1cblxuICAvLyBCdWlsZCBhIGxpbmUncyBET00gcmVwcmVzZW50YXRpb24gZnJvbSBzY3JhdGNoXG4gIGZ1bmN0aW9uIGJ1aWxkTGluZUVsZW1lbnQoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcykge1xuICAgIHZhciBidWlsdCA9IGdldExpbmVDb250ZW50KGNtLCBsaW5lVmlldyk7XG4gICAgbGluZVZpZXcudGV4dCA9IGxpbmVWaWV3Lm5vZGUgPSBidWlsdC5wcmU7XG4gICAgaWYgKGJ1aWx0LmJnQ2xhc3MpIHsgbGluZVZpZXcuYmdDbGFzcyA9IGJ1aWx0LmJnQ2xhc3M7IH1cbiAgICBpZiAoYnVpbHQudGV4dENsYXNzKSB7IGxpbmVWaWV3LnRleHRDbGFzcyA9IGJ1aWx0LnRleHRDbGFzczsgfVxuXG4gICAgdXBkYXRlTGluZUNsYXNzZXMoY20sIGxpbmVWaWV3KTtcbiAgICB1cGRhdGVMaW5lR3V0dGVyKGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xuICAgIGluc2VydExpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcyk7XG4gICAgcmV0dXJuIGxpbmVWaWV3Lm5vZGVcbiAgfVxuXG4gIC8vIEEgbGluZVZpZXcgbWF5IGNvbnRhaW4gbXVsdGlwbGUgbG9naWNhbCBsaW5lcyAod2hlbiBtZXJnZWQgYnlcbiAgLy8gY29sbGFwc2VkIHNwYW5zKS4gVGhlIHdpZGdldHMgZm9yIGFsbCBvZiB0aGVtIG5lZWQgdG8gYmUgZHJhd24uXG4gIGZ1bmN0aW9uIGluc2VydExpbmVXaWRnZXRzKGNtLCBsaW5lVmlldywgZGltcykge1xuICAgIGluc2VydExpbmVXaWRnZXRzRm9yKGNtLCBsaW5lVmlldy5saW5lLCBsaW5lVmlldywgZGltcywgdHJ1ZSk7XG4gICAgaWYgKGxpbmVWaWV3LnJlc3QpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgeyBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSwgbGluZVZpZXcucmVzdFtpXSwgbGluZVZpZXcsIGRpbXMsIGZhbHNlKTsgfSB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnRMaW5lV2lkZ2V0c0ZvcihjbSwgbGluZSwgbGluZVZpZXcsIGRpbXMsIGFsbG93QWJvdmUpIHtcbiAgICBpZiAoIWxpbmUud2lkZ2V0cykgeyByZXR1cm4gfVxuICAgIHZhciB3cmFwID0gZW5zdXJlTGluZVdyYXBwZWQobGluZVZpZXcpO1xuICAgIGZvciAodmFyIGkgPSAwLCB3cyA9IGxpbmUud2lkZ2V0czsgaSA8IHdzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgd2lkZ2V0ID0gd3NbaV0sIG5vZGUgPSBlbHQoXCJkaXZcIiwgW3dpZGdldC5ub2RlXSwgXCJDb2RlTWlycm9yLWxpbmV3aWRnZXRcIiArICh3aWRnZXQuY2xhc3NOYW1lID8gXCIgXCIgKyB3aWRnZXQuY2xhc3NOYW1lIDogXCJcIikpO1xuICAgICAgaWYgKCF3aWRnZXQuaGFuZGxlTW91c2VFdmVudHMpIHsgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIsIFwidHJ1ZVwiKTsgfVxuICAgICAgcG9zaXRpb25MaW5lV2lkZ2V0KHdpZGdldCwgbm9kZSwgbGluZVZpZXcsIGRpbXMpO1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5zZXRVbmVkaXRhYmxlKG5vZGUpO1xuICAgICAgaWYgKGFsbG93QWJvdmUgJiYgd2lkZ2V0LmFib3ZlKVxuICAgICAgICB7IHdyYXAuaW5zZXJ0QmVmb3JlKG5vZGUsIGxpbmVWaWV3Lmd1dHRlciB8fCBsaW5lVmlldy50ZXh0KTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHdyYXAuYXBwZW5kQ2hpbGQobm9kZSk7IH1cbiAgICAgIHNpZ25hbExhdGVyKHdpZGdldCwgXCJyZWRyYXdcIik7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcG9zaXRpb25MaW5lV2lkZ2V0KHdpZGdldCwgbm9kZSwgbGluZVZpZXcsIGRpbXMpIHtcbiAgICBpZiAod2lkZ2V0Lm5vSFNjcm9sbCkge1xuICAobGluZVZpZXcuYWxpZ25hYmxlIHx8IChsaW5lVmlldy5hbGlnbmFibGUgPSBbXSkpLnB1c2gobm9kZSk7XG4gICAgICB2YXIgd2lkdGggPSBkaW1zLndyYXBwZXJXaWR0aDtcbiAgICAgIG5vZGUuc3R5bGUubGVmdCA9IGRpbXMuZml4ZWRQb3MgKyBcInB4XCI7XG4gICAgICBpZiAoIXdpZGdldC5jb3Zlckd1dHRlcikge1xuICAgICAgICB3aWR0aCAtPSBkaW1zLmd1dHRlclRvdGFsV2lkdGg7XG4gICAgICAgIG5vZGUuc3R5bGUucGFkZGluZ0xlZnQgPSBkaW1zLmd1dHRlclRvdGFsV2lkdGggKyBcInB4XCI7XG4gICAgICB9XG4gICAgICBub2RlLnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgfVxuICAgIGlmICh3aWRnZXQuY292ZXJHdXR0ZXIpIHtcbiAgICAgIG5vZGUuc3R5bGUuekluZGV4ID0gNTtcbiAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG4gICAgICBpZiAoIXdpZGdldC5ub0hTY3JvbGwpIHsgbm9kZS5zdHlsZS5tYXJnaW5MZWZ0ID0gLWRpbXMuZ3V0dGVyVG90YWxXaWR0aCArIFwicHhcIjsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdpZGdldEhlaWdodCh3aWRnZXQpIHtcbiAgICBpZiAod2lkZ2V0LmhlaWdodCAhPSBudWxsKSB7IHJldHVybiB3aWRnZXQuaGVpZ2h0IH1cbiAgICB2YXIgY20gPSB3aWRnZXQuZG9jLmNtO1xuICAgIGlmICghY20pIHsgcmV0dXJuIDAgfVxuICAgIGlmICghY29udGFpbnMoZG9jdW1lbnQuYm9keSwgd2lkZ2V0Lm5vZGUpKSB7XG4gICAgICB2YXIgcGFyZW50U3R5bGUgPSBcInBvc2l0aW9uOiByZWxhdGl2ZTtcIjtcbiAgICAgIGlmICh3aWRnZXQuY292ZXJHdXR0ZXIpXG4gICAgICAgIHsgcGFyZW50U3R5bGUgKz0gXCJtYXJnaW4tbGVmdDogLVwiICsgY20uZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoICsgXCJweDtcIjsgfVxuICAgICAgaWYgKHdpZGdldC5ub0hTY3JvbGwpXG4gICAgICAgIHsgcGFyZW50U3R5bGUgKz0gXCJ3aWR0aDogXCIgKyBjbS5kaXNwbGF5LndyYXBwZXIuY2xpZW50V2lkdGggKyBcInB4O1wiOyB9XG4gICAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5Lm1lYXN1cmUsIGVsdChcImRpdlwiLCBbd2lkZ2V0Lm5vZGVdLCBudWxsLCBwYXJlbnRTdHlsZSkpO1xuICAgIH1cbiAgICByZXR1cm4gd2lkZ2V0LmhlaWdodCA9IHdpZGdldC5ub2RlLnBhcmVudE5vZGUub2Zmc2V0SGVpZ2h0XG4gIH1cblxuICAvLyBSZXR1cm4gdHJ1ZSB3aGVuIHRoZSBnaXZlbiBtb3VzZSBldmVudCBoYXBwZW5lZCBpbiBhIHdpZGdldFxuICBmdW5jdGlvbiBldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpIHtcbiAgICBmb3IgKHZhciBuID0gZV90YXJnZXQoZSk7IG4gIT0gZGlzcGxheS53cmFwcGVyOyBuID0gbi5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoIW4gfHwgKG4ubm9kZVR5cGUgPT0gMSAmJiBuLmdldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIikgPT0gXCJ0cnVlXCIpIHx8XG4gICAgICAgICAgKG4ucGFyZW50Tm9kZSA9PSBkaXNwbGF5LnNpemVyICYmIG4gIT0gZGlzcGxheS5tb3ZlcikpXG4gICAgICAgIHsgcmV0dXJuIHRydWUgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFBPU0lUSU9OIE1FQVNVUkVNRU5UXG5cbiAgZnVuY3Rpb24gcGFkZGluZ1RvcChkaXNwbGF5KSB7cmV0dXJuIGRpc3BsYXkubGluZVNwYWNlLm9mZnNldFRvcH1cbiAgZnVuY3Rpb24gcGFkZGluZ1ZlcnQoZGlzcGxheSkge3JldHVybiBkaXNwbGF5Lm1vdmVyLm9mZnNldEhlaWdodCAtIGRpc3BsYXkubGluZVNwYWNlLm9mZnNldEhlaWdodH1cbiAgZnVuY3Rpb24gcGFkZGluZ0goZGlzcGxheSkge1xuICAgIGlmIChkaXNwbGF5LmNhY2hlZFBhZGRpbmdIKSB7IHJldHVybiBkaXNwbGF5LmNhY2hlZFBhZGRpbmdIIH1cbiAgICB2YXIgZSA9IHJlbW92ZUNoaWxkcmVuQW5kQWRkKGRpc3BsYXkubWVhc3VyZSwgZWx0KFwicHJlXCIsIFwieFwiLCBcIkNvZGVNaXJyb3ItbGluZS1saWtlXCIpKTtcbiAgICB2YXIgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUpIDogZS5jdXJyZW50U3R5bGU7XG4gICAgdmFyIGRhdGEgPSB7bGVmdDogcGFyc2VJbnQoc3R5bGUucGFkZGluZ0xlZnQpLCByaWdodDogcGFyc2VJbnQoc3R5bGUucGFkZGluZ1JpZ2h0KX07XG4gICAgaWYgKCFpc05hTihkYXRhLmxlZnQpICYmICFpc05hTihkYXRhLnJpZ2h0KSkgeyBkaXNwbGF5LmNhY2hlZFBhZGRpbmdIID0gZGF0YTsgfVxuICAgIHJldHVybiBkYXRhXG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxHYXAoY20pIHsgcmV0dXJuIHNjcm9sbGVyR2FwIC0gY20uZGlzcGxheS5uYXRpdmVCYXJXaWR0aCB9XG4gIGZ1bmN0aW9uIGRpc3BsYXlXaWR0aChjbSkge1xuICAgIHJldHVybiBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoIC0gc2Nyb2xsR2FwKGNtKSAtIGNtLmRpc3BsYXkuYmFyV2lkdGhcbiAgfVxuICBmdW5jdGlvbiBkaXNwbGF5SGVpZ2h0KGNtKSB7XG4gICAgcmV0dXJuIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0IC0gc2Nyb2xsR2FwKGNtKSAtIGNtLmRpc3BsYXkuYmFySGVpZ2h0XG4gIH1cblxuICAvLyBFbnN1cmUgdGhlIGxpbmVWaWV3LndyYXBwaW5nLmhlaWdodHMgYXJyYXkgaXMgcG9wdWxhdGVkLiBUaGlzIGlzXG4gIC8vIGFuIGFycmF5IG9mIGJvdHRvbSBvZmZzZXRzIGZvciB0aGUgbGluZXMgdGhhdCBtYWtlIHVwIGEgZHJhd25cbiAgLy8gbGluZS4gV2hlbiBsaW5lV3JhcHBpbmcgaXMgb24sIHRoZXJlIG1pZ2h0IGJlIG1vcmUgdGhhbiBvbmVcbiAgLy8gaGVpZ2h0LlxuICBmdW5jdGlvbiBlbnN1cmVMaW5lSGVpZ2h0cyhjbSwgbGluZVZpZXcsIHJlY3QpIHtcbiAgICB2YXIgd3JhcHBpbmcgPSBjbS5vcHRpb25zLmxpbmVXcmFwcGluZztcbiAgICB2YXIgY3VyV2lkdGggPSB3cmFwcGluZyAmJiBkaXNwbGF5V2lkdGgoY20pO1xuICAgIGlmICghbGluZVZpZXcubWVhc3VyZS5oZWlnaHRzIHx8IHdyYXBwaW5nICYmIGxpbmVWaWV3Lm1lYXN1cmUud2lkdGggIT0gY3VyV2lkdGgpIHtcbiAgICAgIHZhciBoZWlnaHRzID0gbGluZVZpZXcubWVhc3VyZS5oZWlnaHRzID0gW107XG4gICAgICBpZiAod3JhcHBpbmcpIHtcbiAgICAgICAgbGluZVZpZXcubWVhc3VyZS53aWR0aCA9IGN1cldpZHRoO1xuICAgICAgICB2YXIgcmVjdHMgPSBsaW5lVmlldy50ZXh0LmZpcnN0Q2hpbGQuZ2V0Q2xpZW50UmVjdHMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWN0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICB2YXIgY3VyID0gcmVjdHNbaV0sIG5leHQgPSByZWN0c1tpICsgMV07XG4gICAgICAgICAgaWYgKE1hdGguYWJzKGN1ci5ib3R0b20gLSBuZXh0LmJvdHRvbSkgPiAyKVxuICAgICAgICAgICAgeyBoZWlnaHRzLnB1c2goKGN1ci5ib3R0b20gKyBuZXh0LnRvcCkgLyAyIC0gcmVjdC50b3ApOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhlaWdodHMucHVzaChyZWN0LmJvdHRvbSAtIHJlY3QudG9wKTtcbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIGEgbGluZSBtYXAgKG1hcHBpbmcgY2hhcmFjdGVyIG9mZnNldHMgdG8gdGV4dCBub2RlcykgYW5kIGFcbiAgLy8gbWVhc3VyZW1lbnQgY2FjaGUgZm9yIHRoZSBnaXZlbiBsaW5lIG51bWJlci4gKEEgbGluZSB2aWV3IG1pZ2h0XG4gIC8vIGNvbnRhaW4gbXVsdGlwbGUgbGluZXMgd2hlbiBjb2xsYXBzZWQgcmFuZ2VzIGFyZSBwcmVzZW50LilcbiAgZnVuY3Rpb24gbWFwRnJvbUxpbmVWaWV3KGxpbmVWaWV3LCBsaW5lLCBsaW5lTikge1xuICAgIGlmIChsaW5lVmlldy5saW5lID09IGxpbmUpXG4gICAgICB7IHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcCwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGV9IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVWaWV3LnJlc3QubGVuZ3RoOyBpKyspXG4gICAgICB7IGlmIChsaW5lVmlldy5yZXN0W2ldID09IGxpbmUpXG4gICAgICAgIHsgcmV0dXJuIHttYXA6IGxpbmVWaWV3Lm1lYXN1cmUubWFwc1tpXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldfSB9IH1cbiAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSQxKyspXG4gICAgICB7IGlmIChsaW5lTm8obGluZVZpZXcucmVzdFtpJDFdKSA+IGxpbmVOKVxuICAgICAgICB7IHJldHVybiB7bWFwOiBsaW5lVmlldy5tZWFzdXJlLm1hcHNbaSQxXSwgY2FjaGU6IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2kkMV0sIGJlZm9yZTogdHJ1ZX0gfSB9XG4gIH1cblxuICAvLyBSZW5kZXIgYSBsaW5lIGludG8gdGhlIGhpZGRlbiBub2RlIGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZC4gVXNlZFxuICAvLyB3aGVuIG1lYXN1cmVtZW50IGlzIG5lZWRlZCBmb3IgYSBsaW5lIHRoYXQncyBub3QgaW4gdGhlIHZpZXdwb3J0LlxuICBmdW5jdGlvbiB1cGRhdGVFeHRlcm5hbE1lYXN1cmVtZW50KGNtLCBsaW5lKSB7XG4gICAgbGluZSA9IHZpc3VhbExpbmUobGluZSk7XG4gICAgdmFyIGxpbmVOID0gbGluZU5vKGxpbmUpO1xuICAgIHZhciB2aWV3ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbmV3IExpbmVWaWV3KGNtLmRvYywgbGluZSwgbGluZU4pO1xuICAgIHZpZXcubGluZU4gPSBsaW5lTjtcbiAgICB2YXIgYnVpbHQgPSB2aWV3LmJ1aWx0ID0gYnVpbGRMaW5lQ29udGVudChjbSwgdmlldyk7XG4gICAgdmlldy50ZXh0ID0gYnVpbHQucHJlO1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKGNtLmRpc3BsYXkubGluZU1lYXN1cmUsIGJ1aWx0LnByZSk7XG4gICAgcmV0dXJuIHZpZXdcbiAgfVxuXG4gIC8vIEdldCBhIHt0b3AsIGJvdHRvbSwgbGVmdCwgcmlnaHR9IGJveCAoaW4gbGluZS1sb2NhbCBjb29yZGluYXRlcylcbiAgLy8gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyLlxuICBmdW5jdGlvbiBtZWFzdXJlQ2hhcihjbSwgbGluZSwgY2gsIGJpYXMpIHtcbiAgICByZXR1cm4gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lKSwgY2gsIGJpYXMpXG4gIH1cblxuICAvLyBGaW5kIGEgbGluZSB2aWV3IHRoYXQgY29ycmVzcG9uZHMgdG8gdGhlIGdpdmVuIGxpbmUgbnVtYmVyLlxuICBmdW5jdGlvbiBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKSB7XG4gICAgaWYgKGxpbmVOID49IGNtLmRpc3BsYXkudmlld0Zyb20gJiYgbGluZU4gPCBjbS5kaXNwbGF5LnZpZXdUbylcbiAgICAgIHsgcmV0dXJuIGNtLmRpc3BsYXkudmlld1tmaW5kVmlld0luZGV4KGNtLCBsaW5lTildIH1cbiAgICB2YXIgZXh0ID0gY20uZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xuICAgIGlmIChleHQgJiYgbGluZU4gPj0gZXh0LmxpbmVOICYmIGxpbmVOIDwgZXh0LmxpbmVOICsgZXh0LnNpemUpXG4gICAgICB7IHJldHVybiBleHQgfVxuICB9XG5cbiAgLy8gTWVhc3VyZW1lbnQgY2FuIGJlIHNwbGl0IGluIHR3byBzdGVwcywgdGhlIHNldC11cCB3b3JrIHRoYXRcbiAgLy8gYXBwbGllcyB0byB0aGUgd2hvbGUgbGluZSwgYW5kIHRoZSBtZWFzdXJlbWVudCBvZiB0aGUgYWN0dWFsXG4gIC8vIGNoYXJhY3Rlci4gRnVuY3Rpb25zIGxpa2UgY29vcmRzQ2hhciwgdGhhdCBuZWVkIHRvIGRvIGEgbG90IG9mXG4gIC8vIG1lYXN1cmVtZW50cyBpbiBhIHJvdywgY2FuIHRodXMgZW5zdXJlIHRoYXQgdGhlIHNldC11cCB3b3JrIGlzXG4gIC8vIG9ubHkgZG9uZSBvbmNlLlxuICBmdW5jdGlvbiBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpIHtcbiAgICB2YXIgbGluZU4gPSBsaW5lTm8obGluZSk7XG4gICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKTtcbiAgICBpZiAodmlldyAmJiAhdmlldy50ZXh0KSB7XG4gICAgICB2aWV3ID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHZpZXcgJiYgdmlldy5jaGFuZ2VzKSB7XG4gICAgICB1cGRhdGVMaW5lRm9yQ2hhbmdlcyhjbSwgdmlldywgbGluZU4sIGdldERpbWVuc2lvbnMoY20pKTtcbiAgICAgIGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF2aWV3KVxuICAgICAgeyB2aWV3ID0gdXBkYXRlRXh0ZXJuYWxNZWFzdXJlbWVudChjbSwgbGluZSk7IH1cblxuICAgIHZhciBpbmZvID0gbWFwRnJvbUxpbmVWaWV3KHZpZXcsIGxpbmUsIGxpbmVOKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGluZTogbGluZSwgdmlldzogdmlldywgcmVjdDogbnVsbCxcbiAgICAgIG1hcDogaW5mby5tYXAsIGNhY2hlOiBpbmZvLmNhY2hlLCBiZWZvcmU6IGluZm8uYmVmb3JlLFxuICAgICAgaGFzSGVpZ2h0czogZmFsc2VcbiAgICB9XG4gIH1cblxuICAvLyBHaXZlbiBhIHByZXBhcmVkIG1lYXN1cmVtZW50IG9iamVjdCwgbWVhc3VyZXMgdGhlIHBvc2l0aW9uIG9mIGFuXG4gIC8vIGFjdHVhbCBjaGFyYWN0ZXIgKG9yIGZldGNoZXMgaXQgZnJvbSB0aGUgY2FjaGUpLlxuICBmdW5jdGlvbiBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZCwgY2gsIGJpYXMsIHZhckhlaWdodCkge1xuICAgIGlmIChwcmVwYXJlZC5iZWZvcmUpIHsgY2ggPSAtMTsgfVxuICAgIHZhciBrZXkgPSBjaCArIChiaWFzIHx8IFwiXCIpLCBmb3VuZDtcbiAgICBpZiAocHJlcGFyZWQuY2FjaGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgZm91bmQgPSBwcmVwYXJlZC5jYWNoZVtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXByZXBhcmVkLnJlY3QpXG4gICAgICAgIHsgcHJlcGFyZWQucmVjdCA9IHByZXBhcmVkLnZpZXcudGV4dC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgfVxuICAgICAgaWYgKCFwcmVwYXJlZC5oYXNIZWlnaHRzKSB7XG4gICAgICAgIGVuc3VyZUxpbmVIZWlnaHRzKGNtLCBwcmVwYXJlZC52aWV3LCBwcmVwYXJlZC5yZWN0KTtcbiAgICAgICAgcHJlcGFyZWQuaGFzSGVpZ2h0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICBmb3VuZCA9IG1lYXN1cmVDaGFySW5uZXIoY20sIHByZXBhcmVkLCBjaCwgYmlhcyk7XG4gICAgICBpZiAoIWZvdW5kLmJvZ3VzKSB7IHByZXBhcmVkLmNhY2hlW2tleV0gPSBmb3VuZDsgfVxuICAgIH1cbiAgICByZXR1cm4ge2xlZnQ6IGZvdW5kLmxlZnQsIHJpZ2h0OiBmb3VuZC5yaWdodCxcbiAgICAgICAgICAgIHRvcDogdmFySGVpZ2h0ID8gZm91bmQucnRvcCA6IGZvdW5kLnRvcCxcbiAgICAgICAgICAgIGJvdHRvbTogdmFySGVpZ2h0ID8gZm91bmQucmJvdHRvbSA6IGZvdW5kLmJvdHRvbX1cbiAgfVxuXG4gIHZhciBudWxsUmVjdCA9IHtsZWZ0OiAwLCByaWdodDogMCwgdG9wOiAwLCBib3R0b206IDB9O1xuXG4gIGZ1bmN0aW9uIG5vZGVBbmRPZmZzZXRJbkxpbmVNYXAobWFwLCBjaCwgYmlhcykge1xuICAgIHZhciBub2RlLCBzdGFydCwgZW5kLCBjb2xsYXBzZSwgbVN0YXJ0LCBtRW5kO1xuICAgIC8vIEZpcnN0LCBzZWFyY2ggdGhlIGxpbmUgbWFwIGZvciB0aGUgdGV4dCBub2RlIGNvcnJlc3BvbmRpbmcgdG8sXG4gICAgLy8gb3IgY2xvc2VzdCB0bywgdGhlIHRhcmdldCBjaGFyYWN0ZXIuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXAubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIG1TdGFydCA9IG1hcFtpXTtcbiAgICAgIG1FbmQgPSBtYXBbaSArIDFdO1xuICAgICAgaWYgKGNoIDwgbVN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0ID0gMDsgZW5kID0gMTtcbiAgICAgICAgY29sbGFwc2UgPSBcImxlZnRcIjtcbiAgICAgIH0gZWxzZSBpZiAoY2ggPCBtRW5kKSB7XG4gICAgICAgIHN0YXJ0ID0gY2ggLSBtU3RhcnQ7XG4gICAgICAgIGVuZCA9IHN0YXJ0ICsgMTtcbiAgICAgIH0gZWxzZSBpZiAoaSA9PSBtYXAubGVuZ3RoIC0gMyB8fCBjaCA9PSBtRW5kICYmIG1hcFtpICsgM10gPiBjaCkge1xuICAgICAgICBlbmQgPSBtRW5kIC0gbVN0YXJ0O1xuICAgICAgICBzdGFydCA9IGVuZCAtIDE7XG4gICAgICAgIGlmIChjaCA+PSBtRW5kKSB7IGNvbGxhcHNlID0gXCJyaWdodFwiOyB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICBub2RlID0gbWFwW2kgKyAyXTtcbiAgICAgICAgaWYgKG1TdGFydCA9PSBtRW5kICYmIGJpYXMgPT0gKG5vZGUuaW5zZXJ0TGVmdCA/IFwibGVmdFwiIDogXCJyaWdodFwiKSlcbiAgICAgICAgICB7IGNvbGxhcHNlID0gYmlhczsgfVxuICAgICAgICBpZiAoYmlhcyA9PSBcImxlZnRcIiAmJiBzdGFydCA9PSAwKVxuICAgICAgICAgIHsgd2hpbGUgKGkgJiYgbWFwW2kgLSAyXSA9PSBtYXBbaSAtIDNdICYmIG1hcFtpIC0gMV0uaW5zZXJ0TGVmdCkge1xuICAgICAgICAgICAgbm9kZSA9IG1hcFsoaSAtPSAzKSArIDJdO1xuICAgICAgICAgICAgY29sbGFwc2UgPSBcImxlZnRcIjtcbiAgICAgICAgICB9IH1cbiAgICAgICAgaWYgKGJpYXMgPT0gXCJyaWdodFwiICYmIHN0YXJ0ID09IG1FbmQgLSBtU3RhcnQpXG4gICAgICAgICAgeyB3aGlsZSAoaSA8IG1hcC5sZW5ndGggLSAzICYmIG1hcFtpICsgM10gPT0gbWFwW2kgKyA0XSAmJiAhbWFwW2kgKyA1XS5pbnNlcnRMZWZ0KSB7XG4gICAgICAgICAgICBub2RlID0gbWFwWyhpICs9IDMpICsgMl07XG4gICAgICAgICAgICBjb2xsYXBzZSA9IFwicmlnaHRcIjtcbiAgICAgICAgICB9IH1cbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtub2RlOiBub2RlLCBzdGFydDogc3RhcnQsIGVuZDogZW5kLCBjb2xsYXBzZTogY29sbGFwc2UsIGNvdmVyU3RhcnQ6IG1TdGFydCwgY292ZXJFbmQ6IG1FbmR9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRVc2VmdWxSZWN0KHJlY3RzLCBiaWFzKSB7XG4gICAgdmFyIHJlY3QgPSBudWxsUmVjdDtcbiAgICBpZiAoYmlhcyA9PSBcImxlZnRcIikgeyBmb3IgKHZhciBpID0gMDsgaSA8IHJlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoKHJlY3QgPSByZWN0c1tpXSkubGVmdCAhPSByZWN0LnJpZ2h0KSB7IGJyZWFrIH1cbiAgICB9IH0gZWxzZSB7IGZvciAodmFyIGkkMSA9IHJlY3RzLmxlbmd0aCAtIDE7IGkkMSA+PSAwOyBpJDEtLSkge1xuICAgICAgaWYgKChyZWN0ID0gcmVjdHNbaSQxXSkubGVmdCAhPSByZWN0LnJpZ2h0KSB7IGJyZWFrIH1cbiAgICB9IH1cbiAgICByZXR1cm4gcmVjdFxuICB9XG5cbiAgZnVuY3Rpb24gbWVhc3VyZUNoYXJJbm5lcihjbSwgcHJlcGFyZWQsIGNoLCBiaWFzKSB7XG4gICAgdmFyIHBsYWNlID0gbm9kZUFuZE9mZnNldEluTGluZU1hcChwcmVwYXJlZC5tYXAsIGNoLCBiaWFzKTtcbiAgICB2YXIgbm9kZSA9IHBsYWNlLm5vZGUsIHN0YXJ0ID0gcGxhY2Uuc3RhcnQsIGVuZCA9IHBsYWNlLmVuZCwgY29sbGFwc2UgPSBwbGFjZS5jb2xsYXBzZTtcblxuICAgIHZhciByZWN0O1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09IDMpIHsgLy8gSWYgaXQgaXMgYSB0ZXh0IG5vZGUsIHVzZSBhIHJhbmdlIHRvIHJldHJpZXZlIHRoZSBjb29yZGluYXRlcy5cbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IDQ7IGkkMSsrKSB7IC8vIFJldHJ5IGEgbWF4aW11bSBvZiA0IHRpbWVzIHdoZW4gbm9uc2Vuc2UgcmVjdGFuZ2xlcyBhcmUgcmV0dXJuZWRcbiAgICAgICAgd2hpbGUgKHN0YXJ0ICYmIGlzRXh0ZW5kaW5nQ2hhcihwcmVwYXJlZC5saW5lLnRleHQuY2hhckF0KHBsYWNlLmNvdmVyU3RhcnQgKyBzdGFydCkpKSB7IC0tc3RhcnQ7IH1cbiAgICAgICAgd2hpbGUgKHBsYWNlLmNvdmVyU3RhcnQgKyBlbmQgPCBwbGFjZS5jb3ZlckVuZCAmJiBpc0V4dGVuZGluZ0NoYXIocHJlcGFyZWQubGluZS50ZXh0LmNoYXJBdChwbGFjZS5jb3ZlclN0YXJ0ICsgZW5kKSkpIHsgKytlbmQ7IH1cbiAgICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5ICYmIHN0YXJ0ID09IDAgJiYgZW5kID09IHBsYWNlLmNvdmVyRW5kIC0gcGxhY2UuY292ZXJTdGFydClcbiAgICAgICAgICB7IHJlY3QgPSBub2RlLnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgcmVjdCA9IGdldFVzZWZ1bFJlY3QocmFuZ2Uobm9kZSwgc3RhcnQsIGVuZCkuZ2V0Q2xpZW50UmVjdHMoKSwgYmlhcyk7IH1cbiAgICAgICAgaWYgKHJlY3QubGVmdCB8fCByZWN0LnJpZ2h0IHx8IHN0YXJ0ID09IDApIHsgYnJlYWsgfVxuICAgICAgICBlbmQgPSBzdGFydDtcbiAgICAgICAgc3RhcnQgPSBzdGFydCAtIDE7XG4gICAgICAgIGNvbGxhcHNlID0gXCJyaWdodFwiO1xuICAgICAgfVxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCAxMSkgeyByZWN0ID0gbWF5YmVVcGRhdGVSZWN0Rm9yWm9vbWluZyhjbS5kaXNwbGF5Lm1lYXN1cmUsIHJlY3QpOyB9XG4gICAgfSBlbHNlIHsgLy8gSWYgaXQgaXMgYSB3aWRnZXQsIHNpbXBseSBnZXQgdGhlIGJveCBmb3IgdGhlIHdob2xlIHdpZGdldC5cbiAgICAgIGlmIChzdGFydCA+IDApIHsgY29sbGFwc2UgPSBiaWFzID0gXCJyaWdodFwiOyB9XG4gICAgICB2YXIgcmVjdHM7XG4gICAgICBpZiAoY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgJiYgKHJlY3RzID0gbm9kZS5nZXRDbGllbnRSZWN0cygpKS5sZW5ndGggPiAxKVxuICAgICAgICB7IHJlY3QgPSByZWN0c1tiaWFzID09IFwicmlnaHRcIiA/IHJlY3RzLmxlbmd0aCAtIDEgOiAwXTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHJlY3QgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyB9XG4gICAgfVxuICAgIGlmIChpZSAmJiBpZV92ZXJzaW9uIDwgOSAmJiAhc3RhcnQgJiYgKCFyZWN0IHx8ICFyZWN0LmxlZnQgJiYgIXJlY3QucmlnaHQpKSB7XG4gICAgICB2YXIgclNwYW4gPSBub2RlLnBhcmVudE5vZGUuZ2V0Q2xpZW50UmVjdHMoKVswXTtcbiAgICAgIGlmIChyU3BhbilcbiAgICAgICAgeyByZWN0ID0ge2xlZnQ6IHJTcGFuLmxlZnQsIHJpZ2h0OiByU3Bhbi5sZWZ0ICsgY2hhcldpZHRoKGNtLmRpc3BsYXkpLCB0b3A6IHJTcGFuLnRvcCwgYm90dG9tOiByU3Bhbi5ib3R0b219OyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgcmVjdCA9IG51bGxSZWN0OyB9XG4gICAgfVxuXG4gICAgdmFyIHJ0b3AgPSByZWN0LnRvcCAtIHByZXBhcmVkLnJlY3QudG9wLCByYm90ID0gcmVjdC5ib3R0b20gLSBwcmVwYXJlZC5yZWN0LnRvcDtcbiAgICB2YXIgbWlkID0gKHJ0b3AgKyByYm90KSAvIDI7XG4gICAgdmFyIGhlaWdodHMgPSBwcmVwYXJlZC52aWV3Lm1lYXN1cmUuaGVpZ2h0cztcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBoZWlnaHRzLmxlbmd0aCAtIDE7IGkrKylcbiAgICAgIHsgaWYgKG1pZCA8IGhlaWdodHNbaV0pIHsgYnJlYWsgfSB9XG4gICAgdmFyIHRvcCA9IGkgPyBoZWlnaHRzW2kgLSAxXSA6IDAsIGJvdCA9IGhlaWdodHNbaV07XG4gICAgdmFyIHJlc3VsdCA9IHtsZWZ0OiAoY29sbGFwc2UgPT0gXCJyaWdodFwiID8gcmVjdC5yaWdodCA6IHJlY3QubGVmdCkgLSBwcmVwYXJlZC5yZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICByaWdodDogKGNvbGxhcHNlID09IFwibGVmdFwiID8gcmVjdC5sZWZ0IDogcmVjdC5yaWdodCkgLSBwcmVwYXJlZC5yZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICB0b3A6IHRvcCwgYm90dG9tOiBib3R9O1xuICAgIGlmICghcmVjdC5sZWZ0ICYmICFyZWN0LnJpZ2h0KSB7IHJlc3VsdC5ib2d1cyA9IHRydWU7IH1cbiAgICBpZiAoIWNtLm9wdGlvbnMuc2luZ2xlQ3Vyc29ySGVpZ2h0UGVyTGluZSkgeyByZXN1bHQucnRvcCA9IHJ0b3A7IHJlc3VsdC5yYm90dG9tID0gcmJvdDsgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gV29yayBhcm91bmQgcHJvYmxlbSB3aXRoIGJvdW5kaW5nIGNsaWVudCByZWN0cyBvbiByYW5nZXMgYmVpbmdcbiAgLy8gcmV0dXJuZWQgaW5jb3JyZWN0bHkgd2hlbiB6b29tZWQgb24gSUUxMCBhbmQgYmVsb3cuXG4gIGZ1bmN0aW9uIG1heWJlVXBkYXRlUmVjdEZvclpvb21pbmcobWVhc3VyZSwgcmVjdCkge1xuICAgIGlmICghd2luZG93LnNjcmVlbiB8fCBzY3JlZW4ubG9naWNhbFhEUEkgPT0gbnVsbCB8fFxuICAgICAgICBzY3JlZW4ubG9naWNhbFhEUEkgPT0gc2NyZWVuLmRldmljZVhEUEkgfHwgIWhhc0JhZFpvb21lZFJlY3RzKG1lYXN1cmUpKVxuICAgICAgeyByZXR1cm4gcmVjdCB9XG4gICAgdmFyIHNjYWxlWCA9IHNjcmVlbi5sb2dpY2FsWERQSSAvIHNjcmVlbi5kZXZpY2VYRFBJO1xuICAgIHZhciBzY2FsZVkgPSBzY3JlZW4ubG9naWNhbFlEUEkgLyBzY3JlZW4uZGV2aWNlWURQSTtcbiAgICByZXR1cm4ge2xlZnQ6IHJlY3QubGVmdCAqIHNjYWxlWCwgcmlnaHQ6IHJlY3QucmlnaHQgKiBzY2FsZVgsXG4gICAgICAgICAgICB0b3A6IHJlY3QudG9wICogc2NhbGVZLCBib3R0b206IHJlY3QuYm90dG9tICogc2NhbGVZfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJMaW5lTWVhc3VyZW1lbnRDYWNoZUZvcihsaW5lVmlldykge1xuICAgIGlmIChsaW5lVmlldy5tZWFzdXJlKSB7XG4gICAgICBsaW5lVmlldy5tZWFzdXJlLmNhY2hlID0ge307XG4gICAgICBsaW5lVmlldy5tZWFzdXJlLmhlaWdodHMgPSBudWxsO1xuICAgICAgaWYgKGxpbmVWaWV3LnJlc3QpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lVmlldy5yZXN0Lmxlbmd0aDsgaSsrKVxuICAgICAgICB7IGxpbmVWaWV3Lm1lYXN1cmUuY2FjaGVzW2ldID0ge307IH0gfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUoY20pIHtcbiAgICBjbS5kaXNwbGF5LmV4dGVybmFsTWVhc3VyZSA9IG51bGw7XG4gICAgcmVtb3ZlQ2hpbGRyZW4oY20uZGlzcGxheS5saW5lTWVhc3VyZSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjbS5kaXNwbGF5LnZpZXcubGVuZ3RoOyBpKyspXG4gICAgICB7IGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3IoY20uZGlzcGxheS52aWV3W2ldKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJDYWNoZXMoY20pIHtcbiAgICBjbGVhckxpbmVNZWFzdXJlbWVudENhY2hlKGNtKTtcbiAgICBjbS5kaXNwbGF5LmNhY2hlZENoYXJXaWR0aCA9IGNtLmRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCA9IGNtLmRpc3BsYXkuY2FjaGVkUGFkZGluZ0ggPSBudWxsO1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgY20uZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9IHRydWU7IH1cbiAgICBjbS5kaXNwbGF5LmxpbmVOdW1DaGFycyA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBwYWdlU2Nyb2xsWCgpIHtcbiAgICAvLyBXb3JrIGFyb3VuZCBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00ODkyMDZcbiAgICAvLyB3aGljaCBjYXVzZXMgcGFnZV9PZmZzZXQgYW5kIGJvdW5kaW5nIGNsaWVudCByZWN0cyB0byB1c2VcbiAgICAvLyBkaWZmZXJlbnQgcmVmZXJlbmNlIHZpZXdwb3J0cyBhbmQgaW52YWxpZGF0ZSBvdXIgY2FsY3VsYXRpb25zLlxuICAgIGlmIChjaHJvbWUgJiYgYW5kcm9pZCkgeyByZXR1cm4gLShkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLm1hcmdpbkxlZnQpKSB9XG4gICAgcmV0dXJuIHdpbmRvdy5wYWdlWE9mZnNldCB8fCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IGRvY3VtZW50LmJvZHkpLnNjcm9sbExlZnRcbiAgfVxuICBmdW5jdGlvbiBwYWdlU2Nyb2xsWSgpIHtcbiAgICBpZiAoY2hyb21lICYmIGFuZHJvaWQpIHsgcmV0dXJuIC0oZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSBwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHkpLm1hcmdpblRvcCkpIH1cbiAgICByZXR1cm4gd2luZG93LnBhZ2VZT2Zmc2V0IHx8IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keSkuc2Nyb2xsVG9wXG4gIH1cblxuICBmdW5jdGlvbiB3aWRnZXRUb3BIZWlnaHQobGluZU9iaikge1xuICAgIHZhciBoZWlnaHQgPSAwO1xuICAgIGlmIChsaW5lT2JqLndpZGdldHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lT2JqLndpZGdldHMubGVuZ3RoOyArK2kpIHsgaWYgKGxpbmVPYmoud2lkZ2V0c1tpXS5hYm92ZSlcbiAgICAgIHsgaGVpZ2h0ICs9IHdpZGdldEhlaWdodChsaW5lT2JqLndpZGdldHNbaV0pOyB9IH0gfVxuICAgIHJldHVybiBoZWlnaHRcbiAgfVxuXG4gIC8vIENvbnZlcnRzIGEge3RvcCwgYm90dG9tLCBsZWZ0LCByaWdodH0gYm94IGZyb20gbGluZS1sb2NhbFxuICAvLyBjb29yZGluYXRlcyBpbnRvIGFub3RoZXIgY29vcmRpbmF0ZSBzeXN0ZW0uIENvbnRleHQgbWF5IGJlIG9uZSBvZlxuICAvLyBcImxpbmVcIiwgXCJkaXZcIiAoZGlzcGxheS5saW5lRGl2KSwgXCJsb2NhbFwiLi9udWxsIChlZGl0b3IpLCBcIndpbmRvd1wiLFxuICAvLyBvciBcInBhZ2VcIi5cbiAgZnVuY3Rpb24gaW50b0Nvb3JkU3lzdGVtKGNtLCBsaW5lT2JqLCByZWN0LCBjb250ZXh0LCBpbmNsdWRlV2lkZ2V0cykge1xuICAgIGlmICghaW5jbHVkZVdpZGdldHMpIHtcbiAgICAgIHZhciBoZWlnaHQgPSB3aWRnZXRUb3BIZWlnaHQobGluZU9iaik7XG4gICAgICByZWN0LnRvcCArPSBoZWlnaHQ7IHJlY3QuYm90dG9tICs9IGhlaWdodDtcbiAgICB9XG4gICAgaWYgKGNvbnRleHQgPT0gXCJsaW5lXCIpIHsgcmV0dXJuIHJlY3QgfVxuICAgIGlmICghY29udGV4dCkgeyBjb250ZXh0ID0gXCJsb2NhbFwiOyB9XG4gICAgdmFyIHlPZmYgPSBoZWlnaHRBdExpbmUobGluZU9iaik7XG4gICAgaWYgKGNvbnRleHQgPT0gXCJsb2NhbFwiKSB7IHlPZmYgKz0gcGFkZGluZ1RvcChjbS5kaXNwbGF5KTsgfVxuICAgIGVsc2UgeyB5T2ZmIC09IGNtLmRpc3BsYXkudmlld09mZnNldDsgfVxuICAgIGlmIChjb250ZXh0ID09IFwicGFnZVwiIHx8IGNvbnRleHQgPT0gXCJ3aW5kb3dcIikge1xuICAgICAgdmFyIGxPZmYgPSBjbS5kaXNwbGF5LmxpbmVTcGFjZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHlPZmYgKz0gbE9mZi50b3AgKyAoY29udGV4dCA9PSBcIndpbmRvd1wiID8gMCA6IHBhZ2VTY3JvbGxZKCkpO1xuICAgICAgdmFyIHhPZmYgPSBsT2ZmLmxlZnQgKyAoY29udGV4dCA9PSBcIndpbmRvd1wiID8gMCA6IHBhZ2VTY3JvbGxYKCkpO1xuICAgICAgcmVjdC5sZWZ0ICs9IHhPZmY7IHJlY3QucmlnaHQgKz0geE9mZjtcbiAgICB9XG4gICAgcmVjdC50b3AgKz0geU9mZjsgcmVjdC5ib3R0b20gKz0geU9mZjtcbiAgICByZXR1cm4gcmVjdFxuICB9XG5cbiAgLy8gQ292ZXJ0cyBhIGJveCBmcm9tIFwiZGl2XCIgY29vcmRzIHRvIGFub3RoZXIgY29vcmRpbmF0ZSBzeXN0ZW0uXG4gIC8vIENvbnRleHQgbWF5IGJlIFwid2luZG93XCIsIFwicGFnZVwiLCBcImRpdlwiLCBvciBcImxvY2FsXCIuL251bGwuXG4gIGZ1bmN0aW9uIGZyb21Db29yZFN5c3RlbShjbSwgY29vcmRzLCBjb250ZXh0KSB7XG4gICAgaWYgKGNvbnRleHQgPT0gXCJkaXZcIikgeyByZXR1cm4gY29vcmRzIH1cbiAgICB2YXIgbGVmdCA9IGNvb3Jkcy5sZWZ0LCB0b3AgPSBjb29yZHMudG9wO1xuICAgIC8vIEZpcnN0IG1vdmUgaW50byBcInBhZ2VcIiBjb29yZGluYXRlIHN5c3RlbVxuICAgIGlmIChjb250ZXh0ID09IFwicGFnZVwiKSB7XG4gICAgICBsZWZ0IC09IHBhZ2VTY3JvbGxYKCk7XG4gICAgICB0b3AgLT0gcGFnZVNjcm9sbFkoKTtcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQgPT0gXCJsb2NhbFwiIHx8ICFjb250ZXh0KSB7XG4gICAgICB2YXIgbG9jYWxCb3ggPSBjbS5kaXNwbGF5LnNpemVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgbGVmdCArPSBsb2NhbEJveC5sZWZ0O1xuICAgICAgdG9wICs9IGxvY2FsQm94LnRvcDtcbiAgICB9XG5cbiAgICB2YXIgbGluZVNwYWNlQm94ID0gY20uZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgcmV0dXJuIHtsZWZ0OiBsZWZ0IC0gbGluZVNwYWNlQm94LmxlZnQsIHRvcDogdG9wIC0gbGluZVNwYWNlQm94LnRvcH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNoYXJDb29yZHMoY20sIHBvcywgY29udGV4dCwgbGluZU9iaiwgYmlhcykge1xuICAgIGlmICghbGluZU9iaikgeyBsaW5lT2JqID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTsgfVxuICAgIHJldHVybiBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIG1lYXN1cmVDaGFyKGNtLCBsaW5lT2JqLCBwb3MuY2gsIGJpYXMpLCBjb250ZXh0KVxuICB9XG5cbiAgLy8gUmV0dXJucyBhIGJveCBmb3IgYSBnaXZlbiBjdXJzb3IgcG9zaXRpb24sIHdoaWNoIG1heSBoYXZlIGFuXG4gIC8vICdvdGhlcicgcHJvcGVydHkgY29udGFpbmluZyB0aGUgcG9zaXRpb24gb2YgdGhlIHNlY29uZGFyeSBjdXJzb3JcbiAgLy8gb24gYSBiaWRpIGJvdW5kYXJ5LlxuICAvLyBBIGN1cnNvciBQb3MobGluZSwgY2hhciwgXCJiZWZvcmVcIikgaXMgb24gdGhlIHNhbWUgdmlzdWFsIGxpbmUgYXMgYGNoYXIgLSAxYFxuICAvLyBhbmQgYWZ0ZXIgYGNoYXIgLSAxYCBpbiB3cml0aW5nIG9yZGVyIG9mIGBjaGFyIC0gMWBcbiAgLy8gQSBjdXJzb3IgUG9zKGxpbmUsIGNoYXIsIFwiYWZ0ZXJcIikgaXMgb24gdGhlIHNhbWUgdmlzdWFsIGxpbmUgYXMgYGNoYXJgXG4gIC8vIGFuZCBiZWZvcmUgYGNoYXJgIGluIHdyaXRpbmcgb3JkZXIgb2YgYGNoYXJgXG4gIC8vIEV4YW1wbGVzICh1cHBlci1jYXNlIGxldHRlcnMgYXJlIFJUTCwgbG93ZXItY2FzZSBhcmUgTFRSKTpcbiAgLy8gICAgIFBvcygwLCAxLCAuLi4pXG4gIC8vICAgICBiZWZvcmUgICBhZnRlclxuICAvLyBhYiAgICAgYXxiICAgICBhfGJcbiAgLy8gYUIgICAgIGF8QiAgICAgYUJ8XG4gIC8vIEFiICAgICB8QWIgICAgIEF8YlxuICAvLyBBQiAgICAgQnxBICAgICBCfEFcbiAgLy8gRXZlcnkgcG9zaXRpb24gYWZ0ZXIgdGhlIGxhc3QgY2hhcmFjdGVyIG9uIGEgbGluZSBpcyBjb25zaWRlcmVkIHRvIHN0aWNrXG4gIC8vIHRvIHRoZSBsYXN0IGNoYXJhY3RlciBvbiB0aGUgbGluZS5cbiAgZnVuY3Rpb24gY3Vyc29yQ29vcmRzKGNtLCBwb3MsIGNvbnRleHQsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSwgdmFySGVpZ2h0KSB7XG4gICAgbGluZU9iaiA9IGxpbmVPYmogfHwgZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcbiAgICBpZiAoIXByZXBhcmVkTWVhc3VyZSkgeyBwcmVwYXJlZE1lYXN1cmUgPSBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmVPYmopOyB9XG4gICAgZnVuY3Rpb24gZ2V0KGNoLCByaWdodCkge1xuICAgICAgdmFyIG0gPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwYXJlZE1lYXN1cmUsIGNoLCByaWdodCA/IFwicmlnaHRcIiA6IFwibGVmdFwiLCB2YXJIZWlnaHQpO1xuICAgICAgaWYgKHJpZ2h0KSB7IG0ubGVmdCA9IG0ucmlnaHQ7IH0gZWxzZSB7IG0ucmlnaHQgPSBtLmxlZnQ7IH1cbiAgICAgIHJldHVybiBpbnRvQ29vcmRTeXN0ZW0oY20sIGxpbmVPYmosIG0sIGNvbnRleHQpXG4gICAgfVxuICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmosIGNtLmRvYy5kaXJlY3Rpb24pLCBjaCA9IHBvcy5jaCwgc3RpY2t5ID0gcG9zLnN0aWNreTtcbiAgICBpZiAoY2ggPj0gbGluZU9iai50ZXh0Lmxlbmd0aCkge1xuICAgICAgY2ggPSBsaW5lT2JqLnRleHQubGVuZ3RoO1xuICAgICAgc3RpY2t5ID0gXCJiZWZvcmVcIjtcbiAgICB9IGVsc2UgaWYgKGNoIDw9IDApIHtcbiAgICAgIGNoID0gMDtcbiAgICAgIHN0aWNreSA9IFwiYWZ0ZXJcIjtcbiAgICB9XG4gICAgaWYgKCFvcmRlcikgeyByZXR1cm4gZ2V0KHN0aWNreSA9PSBcImJlZm9yZVwiID8gY2ggLSAxIDogY2gsIHN0aWNreSA9PSBcImJlZm9yZVwiKSB9XG5cbiAgICBmdW5jdGlvbiBnZXRCaWRpKGNoLCBwYXJ0UG9zLCBpbnZlcnQpIHtcbiAgICAgIHZhciBwYXJ0ID0gb3JkZXJbcGFydFBvc10sIHJpZ2h0ID0gcGFydC5sZXZlbCA9PSAxO1xuICAgICAgcmV0dXJuIGdldChpbnZlcnQgPyBjaCAtIDEgOiBjaCwgcmlnaHQgIT0gaW52ZXJ0KVxuICAgIH1cbiAgICB2YXIgcGFydFBvcyA9IGdldEJpZGlQYXJ0QXQob3JkZXIsIGNoLCBzdGlja3kpO1xuICAgIHZhciBvdGhlciA9IGJpZGlPdGhlcjtcbiAgICB2YXIgdmFsID0gZ2V0QmlkaShjaCwgcGFydFBvcywgc3RpY2t5ID09IFwiYmVmb3JlXCIpO1xuICAgIGlmIChvdGhlciAhPSBudWxsKSB7IHZhbC5vdGhlciA9IGdldEJpZGkoY2gsIG90aGVyLCBzdGlja3kgIT0gXCJiZWZvcmVcIik7IH1cbiAgICByZXR1cm4gdmFsXG4gIH1cblxuICAvLyBVc2VkIHRvIGNoZWFwbHkgZXN0aW1hdGUgdGhlIGNvb3JkaW5hdGVzIGZvciBhIHBvc2l0aW9uLiBVc2VkIGZvclxuICAvLyBpbnRlcm1lZGlhdGUgc2Nyb2xsIHVwZGF0ZXMuXG4gIGZ1bmN0aW9uIGVzdGltYXRlQ29vcmRzKGNtLCBwb3MpIHtcbiAgICB2YXIgbGVmdCA9IDA7XG4gICAgcG9zID0gY2xpcFBvcyhjbS5kb2MsIHBvcyk7XG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykgeyBsZWZ0ID0gY2hhcldpZHRoKGNtLmRpc3BsYXkpICogcG9zLmNoOyB9XG4gICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGNtLmRvYywgcG9zLmxpbmUpO1xuICAgIHZhciB0b3AgPSBoZWlnaHRBdExpbmUobGluZU9iaikgKyBwYWRkaW5nVG9wKGNtLmRpc3BsYXkpO1xuICAgIHJldHVybiB7bGVmdDogbGVmdCwgcmlnaHQ6IGxlZnQsIHRvcDogdG9wLCBib3R0b206IHRvcCArIGxpbmVPYmouaGVpZ2h0fVxuICB9XG5cbiAgLy8gUG9zaXRpb25zIHJldHVybmVkIGJ5IGNvb3Jkc0NoYXIgY29udGFpbiBzb21lIGV4dHJhIGluZm9ybWF0aW9uLlxuICAvLyB4UmVsIGlzIHRoZSByZWxhdGl2ZSB4IHBvc2l0aW9uIG9mIHRoZSBpbnB1dCBjb29yZGluYXRlcyBjb21wYXJlZFxuICAvLyB0byB0aGUgZm91bmQgcG9zaXRpb24gKHNvIHhSZWwgPiAwIG1lYW5zIHRoZSBjb29yZGluYXRlcyBhcmUgdG9cbiAgLy8gdGhlIHJpZ2h0IG9mIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24sIGZvciBleGFtcGxlKS4gV2hlbiBvdXRzaWRlXG4gIC8vIGlzIHRydWUsIHRoYXQgbWVhbnMgdGhlIGNvb3JkaW5hdGVzIGxpZSBvdXRzaWRlIHRoZSBsaW5lJ3NcbiAgLy8gdmVydGljYWwgcmFuZ2UuXG4gIGZ1bmN0aW9uIFBvc1dpdGhJbmZvKGxpbmUsIGNoLCBzdGlja3ksIG91dHNpZGUsIHhSZWwpIHtcbiAgICB2YXIgcG9zID0gUG9zKGxpbmUsIGNoLCBzdGlja3kpO1xuICAgIHBvcy54UmVsID0geFJlbDtcbiAgICBpZiAob3V0c2lkZSkgeyBwb3Mub3V0c2lkZSA9IG91dHNpZGU7IH1cbiAgICByZXR1cm4gcG9zXG4gIH1cblxuICAvLyBDb21wdXRlIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gY2xvc2VzdCB0byB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gIC8vIElucHV0IG11c3QgYmUgbGluZVNwYWNlLWxvY2FsIChcImRpdlwiIGNvb3JkaW5hdGUgc3lzdGVtKS5cbiAgZnVuY3Rpb24gY29vcmRzQ2hhcihjbSwgeCwgeSkge1xuICAgIHZhciBkb2MgPSBjbS5kb2M7XG4gICAgeSArPSBjbS5kaXNwbGF5LnZpZXdPZmZzZXQ7XG4gICAgaWYgKHkgPCAwKSB7IHJldHVybiBQb3NXaXRoSW5mbyhkb2MuZmlyc3QsIDAsIG51bGwsIC0xLCAtMSkgfVxuICAgIHZhciBsaW5lTiA9IGxpbmVBdEhlaWdodChkb2MsIHkpLCBsYXN0ID0gZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxO1xuICAgIGlmIChsaW5lTiA+IGxhc3QpXG4gICAgICB7IHJldHVybiBQb3NXaXRoSW5mbyhkb2MuZmlyc3QgKyBkb2Muc2l6ZSAtIDEsIGdldExpbmUoZG9jLCBsYXN0KS50ZXh0Lmxlbmd0aCwgbnVsbCwgMSwgMSkgfVxuICAgIGlmICh4IDwgMCkgeyB4ID0gMDsgfVxuXG4gICAgdmFyIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbGluZU4pO1xuICAgIGZvciAoOzspIHtcbiAgICAgIHZhciBmb3VuZCA9IGNvb3Jkc0NoYXJJbm5lcihjbSwgbGluZU9iaiwgbGluZU4sIHgsIHkpO1xuICAgICAgdmFyIGNvbGxhcHNlZCA9IGNvbGxhcHNlZFNwYW5Bcm91bmQobGluZU9iaiwgZm91bmQuY2ggKyAoZm91bmQueFJlbCA+IDAgfHwgZm91bmQub3V0c2lkZSA+IDAgPyAxIDogMCkpO1xuICAgICAgaWYgKCFjb2xsYXBzZWQpIHsgcmV0dXJuIGZvdW5kIH1cbiAgICAgIHZhciByYW5nZUVuZCA9IGNvbGxhcHNlZC5maW5kKDEpO1xuICAgICAgaWYgKHJhbmdlRW5kLmxpbmUgPT0gbGluZU4pIHsgcmV0dXJuIHJhbmdlRW5kIH1cbiAgICAgIGxpbmVPYmogPSBnZXRMaW5lKGRvYywgbGluZU4gPSByYW5nZUVuZC5saW5lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwcGVkTGluZUV4dGVudChjbSwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB5KSB7XG4gICAgeSAtPSB3aWRnZXRUb3BIZWlnaHQobGluZU9iaik7XG4gICAgdmFyIGVuZCA9IGxpbmVPYmoudGV4dC5sZW5ndGg7XG4gICAgdmFyIGJlZ2luID0gZmluZEZpcnN0KGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCAtIDEpLmJvdHRvbSA8PSB5OyB9LCBlbmQsIDApO1xuICAgIGVuZCA9IGZpbmRGaXJzdChmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2gpLnRvcCA+IHk7IH0sIGJlZ2luLCBlbmQpO1xuICAgIHJldHVybiB7YmVnaW46IGJlZ2luLCBlbmQ6IGVuZH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBwZWRMaW5lRXh0ZW50Q2hhcihjbSwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB0YXJnZXQpIHtcbiAgICBpZiAoIXByZXBhcmVkTWVhc3VyZSkgeyBwcmVwYXJlZE1lYXN1cmUgPSBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmVPYmopOyB9XG4gICAgdmFyIHRhcmdldFRvcCA9IGludG9Db29yZFN5c3RlbShjbSwgbGluZU9iaiwgbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCB0YXJnZXQpLCBcImxpbmVcIikudG9wO1xuICAgIHJldHVybiB3cmFwcGVkTGluZUV4dGVudChjbSwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlLCB0YXJnZXRUb3ApXG4gIH1cblxuICAvLyBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHNpZGUgb2YgYSBib3ggaXMgYWZ0ZXIgdGhlIGdpdmVuXG4gIC8vIGNvb3JkaW5hdGVzLCBpbiB0b3AtdG8tYm90dG9tLCBsZWZ0LXRvLXJpZ2h0IG9yZGVyLlxuICBmdW5jdGlvbiBib3hJc0FmdGVyKGJveCwgeCwgeSwgbGVmdCkge1xuICAgIHJldHVybiBib3guYm90dG9tIDw9IHkgPyBmYWxzZSA6IGJveC50b3AgPiB5ID8gdHJ1ZSA6IChsZWZ0ID8gYm94LmxlZnQgOiBib3gucmlnaHQpID4geFxuICB9XG5cbiAgZnVuY3Rpb24gY29vcmRzQ2hhcklubmVyKGNtLCBsaW5lT2JqLCBsaW5lTm8sIHgsIHkpIHtcbiAgICAvLyBNb3ZlIHkgaW50byBsaW5lLWxvY2FsIGNvb3JkaW5hdGUgc3BhY2VcbiAgICB5IC09IGhlaWdodEF0TGluZShsaW5lT2JqKTtcbiAgICB2YXIgcHJlcGFyZWRNZWFzdXJlID0gcHJlcGFyZU1lYXN1cmVGb3JMaW5lKGNtLCBsaW5lT2JqKTtcbiAgICAvLyBXaGVuIGRpcmVjdGx5IGNhbGxpbmcgYG1lYXN1cmVDaGFyUHJlcGFyZWRgLCB3ZSBoYXZlIHRvIGFkanVzdFxuICAgIC8vIGZvciB0aGUgd2lkZ2V0cyBhdCB0aGlzIGxpbmUuXG4gICAgdmFyIHdpZGdldEhlaWdodCA9IHdpZGdldFRvcEhlaWdodChsaW5lT2JqKTtcbiAgICB2YXIgYmVnaW4gPSAwLCBlbmQgPSBsaW5lT2JqLnRleHQubGVuZ3RoLCBsdHIgPSB0cnVlO1xuXG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZU9iaiwgY20uZG9jLmRpcmVjdGlvbik7XG4gICAgLy8gSWYgdGhlIGxpbmUgaXNuJ3QgcGxhaW4gbGVmdC10by1yaWdodCB0ZXh0LCBmaXJzdCBmaWd1cmUgb3V0XG4gICAgLy8gd2hpY2ggYmlkaSBzZWN0aW9uIHRoZSBjb29yZGluYXRlcyBmYWxsIGludG8uXG4gICAgaWYgKG9yZGVyKSB7XG4gICAgICB2YXIgcGFydCA9IChjbS5vcHRpb25zLmxpbmVXcmFwcGluZyA/IGNvb3Jkc0JpZGlQYXJ0V3JhcHBlZCA6IGNvb3Jkc0JpZGlQYXJ0KVxuICAgICAgICAgICAgICAgICAgIChjbSwgbGluZU9iaiwgbGluZU5vLCBwcmVwYXJlZE1lYXN1cmUsIG9yZGVyLCB4LCB5KTtcbiAgICAgIGx0ciA9IHBhcnQubGV2ZWwgIT0gMTtcbiAgICAgIC8vIFRoZSBhd2t3YXJkIC0xIG9mZnNldHMgYXJlIG5lZWRlZCBiZWNhdXNlIGZpbmRGaXJzdCAoY2FsbGVkXG4gICAgICAvLyBvbiB0aGVzZSBiZWxvdykgd2lsbCB0cmVhdCBpdHMgZmlyc3QgYm91bmQgYXMgaW5jbHVzaXZlLFxuICAgICAgLy8gc2Vjb25kIGFzIGV4Y2x1c2l2ZSwgYnV0IHdlIHdhbnQgdG8gYWN0dWFsbHkgYWRkcmVzcyB0aGVcbiAgICAgIC8vIGNoYXJhY3RlcnMgaW4gdGhlIHBhcnQncyByYW5nZVxuICAgICAgYmVnaW4gPSBsdHIgPyBwYXJ0LmZyb20gOiBwYXJ0LnRvIC0gMTtcbiAgICAgIGVuZCA9IGx0ciA/IHBhcnQudG8gOiBwYXJ0LmZyb20gLSAxO1xuICAgIH1cblxuICAgIC8vIEEgYmluYXJ5IHNlYXJjaCB0byBmaW5kIHRoZSBmaXJzdCBjaGFyYWN0ZXIgd2hvc2UgYm91bmRpbmcgYm94XG4gICAgLy8gc3RhcnRzIGFmdGVyIHRoZSBjb29yZGluYXRlcy4gSWYgd2UgcnVuIGFjcm9zcyBhbnkgd2hvc2UgYm94IHdyYXBcbiAgICAvLyB0aGUgY29vcmRpbmF0ZXMsIHN0b3JlIHRoYXQuXG4gICAgdmFyIGNoQXJvdW5kID0gbnVsbCwgYm94QXJvdW5kID0gbnVsbDtcbiAgICB2YXIgY2ggPSBmaW5kRmlyc3QoZnVuY3Rpb24gKGNoKSB7XG4gICAgICB2YXIgYm94ID0gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcGFyZWRNZWFzdXJlLCBjaCk7XG4gICAgICBib3gudG9wICs9IHdpZGdldEhlaWdodDsgYm94LmJvdHRvbSArPSB3aWRnZXRIZWlnaHQ7XG4gICAgICBpZiAoIWJveElzQWZ0ZXIoYm94LCB4LCB5LCBmYWxzZSkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgIGlmIChib3gudG9wIDw9IHkgJiYgYm94LmxlZnQgPD0geCkge1xuICAgICAgICBjaEFyb3VuZCA9IGNoO1xuICAgICAgICBib3hBcm91bmQgPSBib3g7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0sIGJlZ2luLCBlbmQpO1xuXG4gICAgdmFyIGJhc2VYLCBzdGlja3ksIG91dHNpZGUgPSBmYWxzZTtcbiAgICAvLyBJZiBhIGJveCBhcm91bmQgdGhlIGNvb3JkaW5hdGVzIHdhcyBmb3VuZCwgdXNlIHRoYXRcbiAgICBpZiAoYm94QXJvdW5kKSB7XG4gICAgICAvLyBEaXN0aW5ndWlzaCBjb29yZGluYXRlcyBuZWFyZXIgdG8gdGhlIGxlZnQgb3IgcmlnaHQgc2lkZSBvZiB0aGUgYm94XG4gICAgICB2YXIgYXRMZWZ0ID0geCAtIGJveEFyb3VuZC5sZWZ0IDwgYm94QXJvdW5kLnJpZ2h0IC0geCwgYXRTdGFydCA9IGF0TGVmdCA9PSBsdHI7XG4gICAgICBjaCA9IGNoQXJvdW5kICsgKGF0U3RhcnQgPyAwIDogMSk7XG4gICAgICBzdGlja3kgPSBhdFN0YXJ0ID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIjtcbiAgICAgIGJhc2VYID0gYXRMZWZ0ID8gYm94QXJvdW5kLmxlZnQgOiBib3hBcm91bmQucmlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIChBZGp1c3QgZm9yIGV4dGVuZGVkIGJvdW5kLCBpZiBuZWNlc3NhcnkuKVxuICAgICAgaWYgKCFsdHIgJiYgKGNoID09IGVuZCB8fCBjaCA9PSBiZWdpbikpIHsgY2grKzsgfVxuICAgICAgLy8gVG8gZGV0ZXJtaW5lIHdoaWNoIHNpZGUgdG8gYXNzb2NpYXRlIHdpdGgsIGdldCB0aGUgYm94IHRvIHRoZVxuICAgICAgLy8gbGVmdCBvZiB0aGUgY2hhcmFjdGVyIGFuZCBjb21wYXJlIGl0J3MgdmVydGljYWwgcG9zaXRpb24gdG8gdGhlXG4gICAgICAvLyBjb29yZGluYXRlc1xuICAgICAgc3RpY2t5ID0gY2ggPT0gMCA/IFwiYWZ0ZXJcIiA6IGNoID09IGxpbmVPYmoudGV4dC5sZW5ndGggPyBcImJlZm9yZVwiIDpcbiAgICAgICAgKG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgY2ggLSAobHRyID8gMSA6IDApKS5ib3R0b20gKyB3aWRnZXRIZWlnaHQgPD0geSkgPT0gbHRyID9cbiAgICAgICAgXCJhZnRlclwiIDogXCJiZWZvcmVcIjtcbiAgICAgIC8vIE5vdyBnZXQgYWNjdXJhdGUgY29vcmRpbmF0ZXMgZm9yIHRoaXMgcGxhY2UsIGluIG9yZGVyIHRvIGdldCBhXG4gICAgICAvLyBiYXNlIFggcG9zaXRpb25cbiAgICAgIHZhciBjb29yZHMgPSBjdXJzb3JDb29yZHMoY20sIFBvcyhsaW5lTm8sIGNoLCBzdGlja3kpLCBcImxpbmVcIiwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlKTtcbiAgICAgIGJhc2VYID0gY29vcmRzLmxlZnQ7XG4gICAgICBvdXRzaWRlID0geSA8IGNvb3Jkcy50b3AgPyAtMSA6IHkgPj0gY29vcmRzLmJvdHRvbSA/IDEgOiAwO1xuICAgIH1cblxuICAgIGNoID0gc2tpcEV4dGVuZGluZ0NoYXJzKGxpbmVPYmoudGV4dCwgY2gsIDEpO1xuICAgIHJldHVybiBQb3NXaXRoSW5mbyhsaW5lTm8sIGNoLCBzdGlja3ksIG91dHNpZGUsIHggLSBiYXNlWClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvb3Jkc0JpZGlQYXJ0KGNtLCBsaW5lT2JqLCBsaW5lTm8sIHByZXBhcmVkTWVhc3VyZSwgb3JkZXIsIHgsIHkpIHtcbiAgICAvLyBCaWRpIHBhcnRzIGFyZSBzb3J0ZWQgbGVmdC10by1yaWdodCwgYW5kIGluIGEgbm9uLWxpbmUtd3JhcHBpbmdcbiAgICAvLyBzaXR1YXRpb24sIHdlIGNhbiB0YWtlIHRoaXMgb3JkZXJpbmcgdG8gY29ycmVzcG9uZCB0byB0aGUgdmlzdWFsXG4gICAgLy8gb3JkZXJpbmcuIFRoaXMgZmluZHMgdGhlIGZpcnN0IHBhcnQgd2hvc2UgZW5kIGlzIGFmdGVyIHRoZSBnaXZlblxuICAgIC8vIGNvb3JkaW5hdGVzLlxuICAgIHZhciBpbmRleCA9IGZpbmRGaXJzdChmdW5jdGlvbiAoaSkge1xuICAgICAgdmFyIHBhcnQgPSBvcmRlcltpXSwgbHRyID0gcGFydC5sZXZlbCAhPSAxO1xuICAgICAgcmV0dXJuIGJveElzQWZ0ZXIoY3Vyc29yQ29vcmRzKGNtLCBQb3MobGluZU5vLCBsdHIgPyBwYXJ0LnRvIDogcGFydC5mcm9tLCBsdHIgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImxpbmVcIiwgbGluZU9iaiwgcHJlcGFyZWRNZWFzdXJlKSwgeCwgeSwgdHJ1ZSlcbiAgICB9LCAwLCBvcmRlci5sZW5ndGggLSAxKTtcbiAgICB2YXIgcGFydCA9IG9yZGVyW2luZGV4XTtcbiAgICAvLyBJZiB0aGlzIGlzbid0IHRoZSBmaXJzdCBwYXJ0LCB0aGUgcGFydCdzIHN0YXJ0IGlzIGFsc28gYWZ0ZXJcbiAgICAvLyB0aGUgY29vcmRpbmF0ZXMsIGFuZCB0aGUgY29vcmRpbmF0ZXMgYXJlbid0IG9uIHRoZSBzYW1lIGxpbmUgYXNcbiAgICAvLyB0aGF0IHN0YXJ0LCBtb3ZlIG9uZSBwYXJ0IGJhY2suXG4gICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgdmFyIGx0ciA9IHBhcnQubGV2ZWwgIT0gMTtcbiAgICAgIHZhciBzdGFydCA9IGN1cnNvckNvb3JkcyhjbSwgUG9zKGxpbmVObywgbHRyID8gcGFydC5mcm9tIDogcGFydC50bywgbHRyID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW5lXCIsIGxpbmVPYmosIHByZXBhcmVkTWVhc3VyZSk7XG4gICAgICBpZiAoYm94SXNBZnRlcihzdGFydCwgeCwgeSwgdHJ1ZSkgJiYgc3RhcnQudG9wID4geSlcbiAgICAgICAgeyBwYXJ0ID0gb3JkZXJbaW5kZXggLSAxXTsgfVxuICAgIH1cbiAgICByZXR1cm4gcGFydFxuICB9XG5cbiAgZnVuY3Rpb24gY29vcmRzQmlkaVBhcnRXcmFwcGVkKGNtLCBsaW5lT2JqLCBfbGluZU5vLCBwcmVwYXJlZE1lYXN1cmUsIG9yZGVyLCB4LCB5KSB7XG4gICAgLy8gSW4gYSB3cmFwcGVkIGxpbmUsIHJ0bCB0ZXh0IG9uIHdyYXBwaW5nIGJvdW5kYXJpZXMgY2FuIGRvIHRoaW5nc1xuICAgIC8vIHRoYXQgZG9uJ3QgY29ycmVzcG9uZCB0byB0aGUgb3JkZXJpbmcgaW4gb3VyIGBvcmRlcmAgYXJyYXkgYXRcbiAgICAvLyBhbGwsIHNvIGEgYmluYXJ5IHNlYXJjaCBkb2Vzbid0IHdvcmssIGFuZCB3ZSB3YW50IHRvIHJldHVybiBhXG4gICAgLy8gcGFydCB0aGF0IG9ubHkgc3BhbnMgb25lIGxpbmUgc28gdGhhdCB0aGUgYmluYXJ5IHNlYXJjaCBpblxuICAgIC8vIGNvb3Jkc0NoYXJJbm5lciBpcyBzYWZlLiBBcyBzdWNoLCB3ZSBmaXJzdCBmaW5kIHRoZSBleHRlbnQgb2YgdGhlXG4gICAgLy8gd3JhcHBlZCBsaW5lLCBhbmQgdGhlbiBkbyBhIGZsYXQgc2VhcmNoIGluIHdoaWNoIHdlIGRpc2NhcmQgYW55XG4gICAgLy8gc3BhbnMgdGhhdCBhcmVuJ3Qgb24gdGhlIGxpbmUuXG4gICAgdmFyIHJlZiA9IHdyYXBwZWRMaW5lRXh0ZW50KGNtLCBsaW5lT2JqLCBwcmVwYXJlZE1lYXN1cmUsIHkpO1xuICAgIHZhciBiZWdpbiA9IHJlZi5iZWdpbjtcbiAgICB2YXIgZW5kID0gcmVmLmVuZDtcbiAgICBpZiAoL1xccy8udGVzdChsaW5lT2JqLnRleHQuY2hhckF0KGVuZCAtIDEpKSkgeyBlbmQtLTsgfVxuICAgIHZhciBwYXJ0ID0gbnVsbCwgY2xvc2VzdERpc3QgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gb3JkZXJbaV07XG4gICAgICBpZiAocC5mcm9tID49IGVuZCB8fCBwLnRvIDw9IGJlZ2luKSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciBsdHIgPSBwLmxldmVsICE9IDE7XG4gICAgICB2YXIgZW5kWCA9IG1lYXN1cmVDaGFyUHJlcGFyZWQoY20sIHByZXBhcmVkTWVhc3VyZSwgbHRyID8gTWF0aC5taW4oZW5kLCBwLnRvKSAtIDEgOiBNYXRoLm1heChiZWdpbiwgcC5mcm9tKSkucmlnaHQ7XG4gICAgICAvLyBXZWlnaCBhZ2FpbnN0IHNwYW5zIGVuZGluZyBiZWZvcmUgdGhpcywgc28gdGhhdCB0aGV5IGFyZSBvbmx5XG4gICAgICAvLyBwaWNrZWQgaWYgbm90aGluZyBlbmRzIGFmdGVyXG4gICAgICB2YXIgZGlzdCA9IGVuZFggPCB4ID8geCAtIGVuZFggKyAxZTkgOiBlbmRYIC0geDtcbiAgICAgIGlmICghcGFydCB8fCBjbG9zZXN0RGlzdCA+IGRpc3QpIHtcbiAgICAgICAgcGFydCA9IHA7XG4gICAgICAgIGNsb3Nlc3REaXN0ID0gZGlzdDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFwYXJ0KSB7IHBhcnQgPSBvcmRlcltvcmRlci5sZW5ndGggLSAxXTsgfVxuICAgIC8vIENsaXAgdGhlIHBhcnQgdG8gdGhlIHdyYXBwZWQgbGluZS5cbiAgICBpZiAocGFydC5mcm9tIDwgYmVnaW4pIHsgcGFydCA9IHtmcm9tOiBiZWdpbiwgdG86IHBhcnQudG8sIGxldmVsOiBwYXJ0LmxldmVsfTsgfVxuICAgIGlmIChwYXJ0LnRvID4gZW5kKSB7IHBhcnQgPSB7ZnJvbTogcGFydC5mcm9tLCB0bzogZW5kLCBsZXZlbDogcGFydC5sZXZlbH07IH1cbiAgICByZXR1cm4gcGFydFxuICB9XG5cbiAgdmFyIG1lYXN1cmVUZXh0O1xuICAvLyBDb21wdXRlIHRoZSBkZWZhdWx0IHRleHQgaGVpZ2h0LlxuICBmdW5jdGlvbiB0ZXh0SGVpZ2h0KGRpc3BsYXkpIHtcbiAgICBpZiAoZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0ICE9IG51bGwpIHsgcmV0dXJuIGRpc3BsYXkuY2FjaGVkVGV4dEhlaWdodCB9XG4gICAgaWYgKG1lYXN1cmVUZXh0ID09IG51bGwpIHtcbiAgICAgIG1lYXN1cmVUZXh0ID0gZWx0KFwicHJlXCIsIG51bGwsIFwiQ29kZU1pcnJvci1saW5lLWxpa2VcIik7XG4gICAgICAvLyBNZWFzdXJlIGEgYnVuY2ggb2YgbGluZXMsIGZvciBicm93c2VycyB0aGF0IGNvbXB1dGVcbiAgICAgIC8vIGZyYWN0aW9uYWwgaGVpZ2h0cy5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDk7ICsraSkge1xuICAgICAgICBtZWFzdXJlVGV4dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcInhcIikpO1xuICAgICAgICBtZWFzdXJlVGV4dC5hcHBlbmRDaGlsZChlbHQoXCJiclwiKSk7XG4gICAgICB9XG4gICAgICBtZWFzdXJlVGV4dC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcInhcIikpO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5Lm1lYXN1cmUsIG1lYXN1cmVUZXh0KTtcbiAgICB2YXIgaGVpZ2h0ID0gbWVhc3VyZVRleHQub2Zmc2V0SGVpZ2h0IC8gNTA7XG4gICAgaWYgKGhlaWdodCA+IDMpIHsgZGlzcGxheS5jYWNoZWRUZXh0SGVpZ2h0ID0gaGVpZ2h0OyB9XG4gICAgcmVtb3ZlQ2hpbGRyZW4oZGlzcGxheS5tZWFzdXJlKTtcbiAgICByZXR1cm4gaGVpZ2h0IHx8IDFcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIGRlZmF1bHQgY2hhcmFjdGVyIHdpZHRoLlxuICBmdW5jdGlvbiBjaGFyV2lkdGgoZGlzcGxheSkge1xuICAgIGlmIChkaXNwbGF5LmNhY2hlZENoYXJXaWR0aCAhPSBudWxsKSB7IHJldHVybiBkaXNwbGF5LmNhY2hlZENoYXJXaWR0aCB9XG4gICAgdmFyIGFuY2hvciA9IGVsdChcInNwYW5cIiwgXCJ4eHh4eHh4eHh4XCIpO1xuICAgIHZhciBwcmUgPSBlbHQoXCJwcmVcIiwgW2FuY2hvcl0sIFwiQ29kZU1pcnJvci1saW5lLWxpa2VcIik7XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5tZWFzdXJlLCBwcmUpO1xuICAgIHZhciByZWN0ID0gYW5jaG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB3aWR0aCA9IChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSAvIDEwO1xuICAgIGlmICh3aWR0aCA+IDIpIHsgZGlzcGxheS5jYWNoZWRDaGFyV2lkdGggPSB3aWR0aDsgfVxuICAgIHJldHVybiB3aWR0aCB8fCAxMFxuICB9XG5cbiAgLy8gRG8gYSBidWxrLXJlYWQgb2YgdGhlIERPTSBwb3NpdGlvbnMgYW5kIHNpemVzIG5lZWRlZCB0byBkcmF3IHRoZVxuICAvLyB2aWV3LCBzbyB0aGF0IHdlIGRvbid0IGludGVybGVhdmUgcmVhZGluZyBhbmQgd3JpdGluZyB0byB0aGUgRE9NLlxuICBmdW5jdGlvbiBnZXREaW1lbnNpb25zKGNtKSB7XG4gICAgdmFyIGQgPSBjbS5kaXNwbGF5LCBsZWZ0ID0ge30sIHdpZHRoID0ge307XG4gICAgdmFyIGd1dHRlckxlZnQgPSBkLmd1dHRlcnMuY2xpZW50TGVmdDtcbiAgICBmb3IgKHZhciBuID0gZC5ndXR0ZXJzLmZpcnN0Q2hpbGQsIGkgPSAwOyBuOyBuID0gbi5uZXh0U2libGluZywgKytpKSB7XG4gICAgICB2YXIgaWQgPSBjbS5kaXNwbGF5Lmd1dHRlclNwZWNzW2ldLmNsYXNzTmFtZTtcbiAgICAgIGxlZnRbaWRdID0gbi5vZmZzZXRMZWZ0ICsgbi5jbGllbnRMZWZ0ICsgZ3V0dGVyTGVmdDtcbiAgICAgIHdpZHRoW2lkXSA9IG4uY2xpZW50V2lkdGg7XG4gICAgfVxuICAgIHJldHVybiB7Zml4ZWRQb3M6IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGQpLFxuICAgICAgICAgICAgZ3V0dGVyVG90YWxXaWR0aDogZC5ndXR0ZXJzLm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgZ3V0dGVyTGVmdDogbGVmdCxcbiAgICAgICAgICAgIGd1dHRlcldpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIHdyYXBwZXJXaWR0aDogZC53cmFwcGVyLmNsaWVudFdpZHRofVxuICB9XG5cbiAgLy8gQ29tcHV0ZXMgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICsgZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoLFxuICAvLyBidXQgdXNpbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHRvIGdldCBhIHN1Yi1waXhlbC1hY2N1cmF0ZVxuICAvLyByZXN1bHQuXG4gIGZ1bmN0aW9uIGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGRpc3BsYXkpIHtcbiAgICByZXR1cm4gZGlzcGxheS5zY3JvbGxlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC0gZGlzcGxheS5zaXplci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBlc3RpbWF0ZXMgdGhlIGhlaWdodCBvZiBhIGxpbmUsIHRvIHVzZSBhc1xuICAvLyBmaXJzdCBhcHByb3hpbWF0aW9uIHVudGlsIHRoZSBsaW5lIGJlY29tZXMgdmlzaWJsZSAoYW5kIGlzIHRodXNcbiAgLy8gcHJvcGVybHkgbWVhc3VyYWJsZSkuXG4gIGZ1bmN0aW9uIGVzdGltYXRlSGVpZ2h0KGNtKSB7XG4gICAgdmFyIHRoID0gdGV4dEhlaWdodChjbS5kaXNwbGF5KSwgd3JhcHBpbmcgPSBjbS5vcHRpb25zLmxpbmVXcmFwcGluZztcbiAgICB2YXIgcGVyTGluZSA9IHdyYXBwaW5nICYmIE1hdGgubWF4KDUsIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGggLyBjaGFyV2lkdGgoY20uZGlzcGxheSkgLSAzKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChsaW5lSXNIaWRkZW4oY20uZG9jLCBsaW5lKSkgeyByZXR1cm4gMCB9XG5cbiAgICAgIHZhciB3aWRnZXRzSGVpZ2h0ID0gMDtcbiAgICAgIGlmIChsaW5lLndpZGdldHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLndpZGdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxpbmUud2lkZ2V0c1tpXS5oZWlnaHQpIHsgd2lkZ2V0c0hlaWdodCArPSBsaW5lLndpZGdldHNbaV0uaGVpZ2h0OyB9XG4gICAgICB9IH1cblxuICAgICAgaWYgKHdyYXBwaW5nKVxuICAgICAgICB7IHJldHVybiB3aWRnZXRzSGVpZ2h0ICsgKE1hdGguY2VpbChsaW5lLnRleHQubGVuZ3RoIC8gcGVyTGluZSkgfHwgMSkgKiB0aCB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgcmV0dXJuIHdpZGdldHNIZWlnaHQgKyB0aCB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZXN0aW1hdGVMaW5lSGVpZ2h0cyhjbSkge1xuICAgIHZhciBkb2MgPSBjbS5kb2MsIGVzdCA9IGVzdGltYXRlSGVpZ2h0KGNtKTtcbiAgICBkb2MuaXRlcihmdW5jdGlvbiAobGluZSkge1xuICAgICAgdmFyIGVzdEhlaWdodCA9IGVzdChsaW5lKTtcbiAgICAgIGlmIChlc3RIZWlnaHQgIT0gbGluZS5oZWlnaHQpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBlc3RIZWlnaHQpOyB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBHaXZlbiBhIG1vdXNlIGV2ZW50LCBmaW5kIHRoZSBjb3JyZXNwb25kaW5nIHBvc2l0aW9uLiBJZiBsaWJlcmFsXG4gIC8vIGlzIGZhbHNlLCBpdCBjaGVja3Mgd2hldGhlciBhIGd1dHRlciBvciBzY3JvbGxiYXIgd2FzIGNsaWNrZWQsXG4gIC8vIGFuZCByZXR1cm5zIG51bGwgaWYgaXQgd2FzLiBmb3JSZWN0IGlzIHVzZWQgYnkgcmVjdGFuZ3VsYXJcbiAgLy8gc2VsZWN0aW9ucywgYW5kIHRyaWVzIHRvIGVzdGltYXRlIGEgY2hhcmFjdGVyIHBvc2l0aW9uIGV2ZW4gZm9yXG4gIC8vIGNvb3JkaW5hdGVzIGJleW9uZCB0aGUgcmlnaHQgb2YgdGhlIHRleHQuXG4gIGZ1bmN0aW9uIHBvc0Zyb21Nb3VzZShjbSwgZSwgbGliZXJhbCwgZm9yUmVjdCkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoIWxpYmVyYWwgJiYgZV90YXJnZXQoZSkuZ2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIikgPT0gXCJ0cnVlXCIpIHsgcmV0dXJuIG51bGwgfVxuXG4gICAgdmFyIHgsIHksIHNwYWNlID0gZGlzcGxheS5saW5lU3BhY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gRmFpbHMgdW5wcmVkaWN0YWJseSBvbiBJRVs2N10gd2hlbiBtb3VzZSBpcyBkcmFnZ2VkIGFyb3VuZCBxdWlja2x5LlxuICAgIHRyeSB7IHggPSBlLmNsaWVudFggLSBzcGFjZS5sZWZ0OyB5ID0gZS5jbGllbnRZIC0gc3BhY2UudG9wOyB9XG4gICAgY2F0Y2ggKGUkMSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIGNvb3JkcyA9IGNvb3Jkc0NoYXIoY20sIHgsIHkpLCBsaW5lO1xuICAgIGlmIChmb3JSZWN0ICYmIGNvb3Jkcy54UmVsID4gMCAmJiAobGluZSA9IGdldExpbmUoY20uZG9jLCBjb29yZHMubGluZSkudGV4dCkubGVuZ3RoID09IGNvb3Jkcy5jaCkge1xuICAgICAgdmFyIGNvbERpZmYgPSBjb3VudENvbHVtbihsaW5lLCBsaW5lLmxlbmd0aCwgY20ub3B0aW9ucy50YWJTaXplKSAtIGxpbmUubGVuZ3RoO1xuICAgICAgY29vcmRzID0gUG9zKGNvb3Jkcy5saW5lLCBNYXRoLm1heCgwLCBNYXRoLnJvdW5kKCh4IC0gcGFkZGluZ0goY20uZGlzcGxheSkubGVmdCkgLyBjaGFyV2lkdGgoY20uZGlzcGxheSkpIC0gY29sRGlmZikpO1xuICAgIH1cbiAgICByZXR1cm4gY29vcmRzXG4gIH1cblxuICAvLyBGaW5kIHRoZSB2aWV3IGVsZW1lbnQgY29ycmVzcG9uZGluZyB0byBhIGdpdmVuIGxpbmUuIFJldHVybiBudWxsXG4gIC8vIHdoZW4gdGhlIGxpbmUgaXNuJ3QgdmlzaWJsZS5cbiAgZnVuY3Rpb24gZmluZFZpZXdJbmRleChjbSwgbikge1xuICAgIGlmIChuID49IGNtLmRpc3BsYXkudmlld1RvKSB7IHJldHVybiBudWxsIH1cbiAgICBuIC09IGNtLmRpc3BsYXkudmlld0Zyb207XG4gICAgaWYgKG4gPCAwKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgdmlldyA9IGNtLmRpc3BsYXkudmlldztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gLT0gdmlld1tpXS5zaXplO1xuICAgICAgaWYgKG4gPCAwKSB7IHJldHVybiBpIH1cbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGVzIHRoZSBkaXNwbGF5LnZpZXcgZGF0YSBzdHJ1Y3R1cmUgZm9yIGEgZ2l2ZW4gY2hhbmdlIHRvIHRoZVxuICAvLyBkb2N1bWVudC4gRnJvbSBhbmQgdG8gYXJlIGluIHByZS1jaGFuZ2UgY29vcmRpbmF0ZXMuIExlbmRpZmYgaXNcbiAgLy8gdGhlIGFtb3VudCBvZiBsaW5lcyBhZGRlZCBvciBzdWJ0cmFjdGVkIGJ5IHRoZSBjaGFuZ2UuIFRoaXMgaXNcbiAgLy8gdXNlZCBmb3IgY2hhbmdlcyB0aGF0IHNwYW4gbXVsdGlwbGUgbGluZXMsIG9yIGNoYW5nZSB0aGUgd2F5XG4gIC8vIGxpbmVzIGFyZSBkaXZpZGVkIGludG8gdmlzdWFsIGxpbmVzLiByZWdMaW5lQ2hhbmdlIChiZWxvdylcbiAgLy8gcmVnaXN0ZXJzIHNpbmdsZS1saW5lIGNoYW5nZXMuXG4gIGZ1bmN0aW9uIHJlZ0NoYW5nZShjbSwgZnJvbSwgdG8sIGxlbmRpZmYpIHtcbiAgICBpZiAoZnJvbSA9PSBudWxsKSB7IGZyb20gPSBjbS5kb2MuZmlyc3Q7IH1cbiAgICBpZiAodG8gPT0gbnVsbCkgeyB0byA9IGNtLmRvYy5maXJzdCArIGNtLmRvYy5zaXplOyB9XG4gICAgaWYgKCFsZW5kaWZmKSB7IGxlbmRpZmYgPSAwOyB9XG5cbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKGxlbmRpZmYgJiYgdG8gPCBkaXNwbGF5LnZpZXdUbyAmJlxuICAgICAgICAoZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9PSBudWxsIHx8IGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPiBmcm9tKSlcbiAgICAgIHsgZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9IGZyb207IH1cblxuICAgIGNtLmN1ck9wLnZpZXdDaGFuZ2VkID0gdHJ1ZTtcblxuICAgIGlmIChmcm9tID49IGRpc3BsYXkudmlld1RvKSB7IC8vIENoYW5nZSBhZnRlclxuICAgICAgaWYgKHNhd0NvbGxhcHNlZFNwYW5zICYmIHZpc3VhbExpbmVObyhjbS5kb2MsIGZyb20pIDwgZGlzcGxheS52aWV3VG8pXG4gICAgICAgIHsgcmVzZXRWaWV3KGNtKTsgfVxuICAgIH0gZWxzZSBpZiAodG8gPD0gZGlzcGxheS52aWV3RnJvbSkgeyAvLyBDaGFuZ2UgYmVmb3JlXG4gICAgICBpZiAoc2F3Q29sbGFwc2VkU3BhbnMgJiYgdmlzdWFsTGluZUVuZE5vKGNtLmRvYywgdG8gKyBsZW5kaWZmKSA+IGRpc3BsYXkudmlld0Zyb20pIHtcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BsYXkudmlld0Zyb20gKz0gbGVuZGlmZjtcbiAgICAgICAgZGlzcGxheS52aWV3VG8gKz0gbGVuZGlmZjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZyb20gPD0gZGlzcGxheS52aWV3RnJvbSAmJiB0byA+PSBkaXNwbGF5LnZpZXdUbykgeyAvLyBGdWxsIG92ZXJsYXBcbiAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgfSBlbHNlIGlmIChmcm9tIDw9IGRpc3BsYXkudmlld0Zyb20pIHsgLy8gVG9wIG92ZXJsYXBcbiAgICAgIHZhciBjdXQgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCB0bywgdG8gKyBsZW5kaWZmLCAxKTtcbiAgICAgIGlmIChjdXQpIHtcbiAgICAgICAgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKGN1dC5pbmRleCk7XG4gICAgICAgIGRpc3BsYXkudmlld0Zyb20gPSBjdXQubGluZU47XG4gICAgICAgIGRpc3BsYXkudmlld1RvICs9IGxlbmRpZmY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNldFZpZXcoY20pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodG8gPj0gZGlzcGxheS52aWV3VG8pIHsgLy8gQm90dG9tIG92ZXJsYXBcbiAgICAgIHZhciBjdXQkMSA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIGZyb20sIGZyb20sIC0xKTtcbiAgICAgIGlmIChjdXQkMSkge1xuICAgICAgICBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgY3V0JDEuaW5kZXgpO1xuICAgICAgICBkaXNwbGF5LnZpZXdUbyA9IGN1dCQxLmxpbmVOO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgeyAvLyBHYXAgaW4gdGhlIG1pZGRsZVxuICAgICAgdmFyIGN1dFRvcCA9IHZpZXdDdXR0aW5nUG9pbnQoY20sIGZyb20sIGZyb20sIC0xKTtcbiAgICAgIHZhciBjdXRCb3QgPSB2aWV3Q3V0dGluZ1BvaW50KGNtLCB0bywgdG8gKyBsZW5kaWZmLCAxKTtcbiAgICAgIGlmIChjdXRUb3AgJiYgY3V0Qm90KSB7XG4gICAgICAgIGRpc3BsYXkudmlldyA9IGRpc3BsYXkudmlldy5zbGljZSgwLCBjdXRUb3AuaW5kZXgpXG4gICAgICAgICAgLmNvbmNhdChidWlsZFZpZXdBcnJheShjbSwgY3V0VG9wLmxpbmVOLCBjdXRCb3QubGluZU4pKVxuICAgICAgICAgIC5jb25jYXQoZGlzcGxheS52aWV3LnNsaWNlKGN1dEJvdC5pbmRleCkpO1xuICAgICAgICBkaXNwbGF5LnZpZXdUbyArPSBsZW5kaWZmO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZXh0ID0gZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkO1xuICAgIGlmIChleHQpIHtcbiAgICAgIGlmICh0byA8IGV4dC5saW5lTilcbiAgICAgICAgeyBleHQubGluZU4gKz0gbGVuZGlmZjsgfVxuICAgICAgZWxzZSBpZiAoZnJvbSA8IGV4dC5saW5lTiArIGV4dC5zaXplKVxuICAgICAgICB7IGRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZCA9IG51bGw7IH1cbiAgICB9XG4gIH1cblxuICAvLyBSZWdpc3RlciBhIGNoYW5nZSB0byBhIHNpbmdsZSBsaW5lLiBUeXBlIG11c3QgYmUgb25lIG9mIFwidGV4dFwiLFxuICAvLyBcImd1dHRlclwiLCBcImNsYXNzXCIsIFwid2lkZ2V0XCJcbiAgZnVuY3Rpb24gcmVnTGluZUNoYW5nZShjbSwgbGluZSwgdHlwZSkge1xuICAgIGNtLmN1ck9wLnZpZXdDaGFuZ2VkID0gdHJ1ZTtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGV4dCA9IGNtLmRpc3BsYXkuZXh0ZXJuYWxNZWFzdXJlZDtcbiAgICBpZiAoZXh0ICYmIGxpbmUgPj0gZXh0LmxpbmVOICYmIGxpbmUgPCBleHQubGluZU4gKyBleHQuc2l6ZSlcbiAgICAgIHsgZGlzcGxheS5leHRlcm5hbE1lYXN1cmVkID0gbnVsbDsgfVxuXG4gICAgaWYgKGxpbmUgPCBkaXNwbGF5LnZpZXdGcm9tIHx8IGxpbmUgPj0gZGlzcGxheS52aWV3VG8pIHsgcmV0dXJuIH1cbiAgICB2YXIgbGluZVZpZXcgPSBkaXNwbGF5LnZpZXdbZmluZFZpZXdJbmRleChjbSwgbGluZSldO1xuICAgIGlmIChsaW5lVmlldy5ub2RlID09IG51bGwpIHsgcmV0dXJuIH1cbiAgICB2YXIgYXJyID0gbGluZVZpZXcuY2hhbmdlcyB8fCAobGluZVZpZXcuY2hhbmdlcyA9IFtdKTtcbiAgICBpZiAoaW5kZXhPZihhcnIsIHR5cGUpID09IC0xKSB7IGFyci5wdXNoKHR5cGUpOyB9XG4gIH1cblxuICAvLyBDbGVhciB0aGUgdmlldy5cbiAgZnVuY3Rpb24gcmVzZXRWaWV3KGNtKSB7XG4gICAgY20uZGlzcGxheS52aWV3RnJvbSA9IGNtLmRpc3BsYXkudmlld1RvID0gY20uZG9jLmZpcnN0O1xuICAgIGNtLmRpc3BsYXkudmlldyA9IFtdO1xuICAgIGNtLmRpc3BsYXkudmlld09mZnNldCA9IDA7XG4gIH1cblxuICBmdW5jdGlvbiB2aWV3Q3V0dGluZ1BvaW50KGNtLCBvbGROLCBuZXdOLCBkaXIpIHtcbiAgICB2YXIgaW5kZXggPSBmaW5kVmlld0luZGV4KGNtLCBvbGROKSwgZGlmZiwgdmlldyA9IGNtLmRpc3BsYXkudmlldztcbiAgICBpZiAoIXNhd0NvbGxhcHNlZFNwYW5zIHx8IG5ld04gPT0gY20uZG9jLmZpcnN0ICsgY20uZG9jLnNpemUpXG4gICAgICB7IHJldHVybiB7aW5kZXg6IGluZGV4LCBsaW5lTjogbmV3Tn0gfVxuICAgIHZhciBuID0gY20uZGlzcGxheS52aWV3RnJvbTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4OyBpKyspXG4gICAgICB7IG4gKz0gdmlld1tpXS5zaXplOyB9XG4gICAgaWYgKG4gIT0gb2xkTikge1xuICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgaWYgKGluZGV4ID09IHZpZXcubGVuZ3RoIC0gMSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgIGRpZmYgPSAobiArIHZpZXdbaW5kZXhdLnNpemUpIC0gb2xkTjtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpZmYgPSBuIC0gb2xkTjtcbiAgICAgIH1cbiAgICAgIG9sZE4gKz0gZGlmZjsgbmV3TiArPSBkaWZmO1xuICAgIH1cbiAgICB3aGlsZSAodmlzdWFsTGluZU5vKGNtLmRvYywgbmV3TikgIT0gbmV3Tikge1xuICAgICAgaWYgKGluZGV4ID09IChkaXIgPCAwID8gMCA6IHZpZXcubGVuZ3RoIC0gMSkpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgbmV3TiArPSBkaXIgKiB2aWV3W2luZGV4IC0gKGRpciA8IDAgPyAxIDogMCldLnNpemU7XG4gICAgICBpbmRleCArPSBkaXI7XG4gICAgfVxuICAgIHJldHVybiB7aW5kZXg6IGluZGV4LCBsaW5lTjogbmV3Tn1cbiAgfVxuXG4gIC8vIEZvcmNlIHRoZSB2aWV3IHRvIGNvdmVyIGEgZ2l2ZW4gcmFuZ2UsIGFkZGluZyBlbXB0eSB2aWV3IGVsZW1lbnRcbiAgLy8gb3IgY2xpcHBpbmcgb2ZmIGV4aXN0aW5nIG9uZXMgYXMgbmVlZGVkLlxuICBmdW5jdGlvbiBhZGp1c3RWaWV3KGNtLCBmcm9tLCB0bykge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgdmlldyA9IGRpc3BsYXkudmlldztcbiAgICBpZiAodmlldy5sZW5ndGggPT0gMCB8fCBmcm9tID49IGRpc3BsYXkudmlld1RvIHx8IHRvIDw9IGRpc3BsYXkudmlld0Zyb20pIHtcbiAgICAgIGRpc3BsYXkudmlldyA9IGJ1aWxkVmlld0FycmF5KGNtLCBmcm9tLCB0byk7XG4gICAgICBkaXNwbGF5LnZpZXdGcm9tID0gZnJvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRpc3BsYXkudmlld0Zyb20gPiBmcm9tKVxuICAgICAgICB7IGRpc3BsYXkudmlldyA9IGJ1aWxkVmlld0FycmF5KGNtLCBmcm9tLCBkaXNwbGF5LnZpZXdGcm9tKS5jb25jYXQoZGlzcGxheS52aWV3KTsgfVxuICAgICAgZWxzZSBpZiAoZGlzcGxheS52aWV3RnJvbSA8IGZyb20pXG4gICAgICAgIHsgZGlzcGxheS52aWV3ID0gZGlzcGxheS52aWV3LnNsaWNlKGZpbmRWaWV3SW5kZXgoY20sIGZyb20pKTsgfVxuICAgICAgZGlzcGxheS52aWV3RnJvbSA9IGZyb207XG4gICAgICBpZiAoZGlzcGxheS52aWV3VG8gPCB0bylcbiAgICAgICAgeyBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuY29uY2F0KGJ1aWxkVmlld0FycmF5KGNtLCBkaXNwbGF5LnZpZXdUbywgdG8pKTsgfVxuICAgICAgZWxzZSBpZiAoZGlzcGxheS52aWV3VG8gPiB0bylcbiAgICAgICAgeyBkaXNwbGF5LnZpZXcgPSBkaXNwbGF5LnZpZXcuc2xpY2UoMCwgZmluZFZpZXdJbmRleChjbSwgdG8pKTsgfVxuICAgIH1cbiAgICBkaXNwbGF5LnZpZXdUbyA9IHRvO1xuICB9XG5cbiAgLy8gQ291bnQgdGhlIG51bWJlciBvZiBsaW5lcyBpbiB0aGUgdmlldyB3aG9zZSBET00gcmVwcmVzZW50YXRpb24gaXNcbiAgLy8gb3V0IG9mIGRhdGUgKG9yIG5vbmV4aXN0ZW50KS5cbiAgZnVuY3Rpb24gY291bnREaXJ0eVZpZXcoY20pIHtcbiAgICB2YXIgdmlldyA9IGNtLmRpc3BsYXkudmlldywgZGlydHkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpbmVWaWV3ID0gdmlld1tpXTtcbiAgICAgIGlmICghbGluZVZpZXcuaGlkZGVuICYmICghbGluZVZpZXcubm9kZSB8fCBsaW5lVmlldy5jaGFuZ2VzKSkgeyArK2RpcnR5OyB9XG4gICAgfVxuICAgIHJldHVybiBkaXJ0eVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2VsZWN0aW9uKGNtKSB7XG4gICAgY20uZGlzcGxheS5pbnB1dC5zaG93U2VsZWN0aW9uKGNtLmRpc3BsYXkuaW5wdXQucHJlcGFyZVNlbGVjdGlvbigpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVTZWxlY3Rpb24oY20sIHByaW1hcnkpIHtcbiAgICBpZiAoIHByaW1hcnkgPT09IHZvaWQgMCApIHByaW1hcnkgPSB0cnVlO1xuXG4gICAgdmFyIGRvYyA9IGNtLmRvYywgcmVzdWx0ID0ge307XG4gICAgdmFyIGN1ckZyYWdtZW50ID0gcmVzdWx0LmN1cnNvcnMgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgdmFyIHNlbEZyYWdtZW50ID0gcmVzdWx0LnNlbGVjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghcHJpbWFyeSAmJiBpID09IGRvYy5zZWwucHJpbUluZGV4KSB7IGNvbnRpbnVlIH1cbiAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2ldO1xuICAgICAgaWYgKHJhbmdlLmZyb20oKS5saW5lID49IGNtLmRpc3BsYXkudmlld1RvIHx8IHJhbmdlLnRvKCkubGluZSA8IGNtLmRpc3BsYXkudmlld0Zyb20pIHsgY29udGludWUgfVxuICAgICAgdmFyIGNvbGxhcHNlZCA9IHJhbmdlLmVtcHR5KCk7XG4gICAgICBpZiAoY29sbGFwc2VkIHx8IGNtLm9wdGlvbnMuc2hvd0N1cnNvcldoZW5TZWxlY3RpbmcpXG4gICAgICAgIHsgZHJhd1NlbGVjdGlvbkN1cnNvcihjbSwgcmFuZ2UuaGVhZCwgY3VyRnJhZ21lbnQpOyB9XG4gICAgICBpZiAoIWNvbGxhcHNlZClcbiAgICAgICAgeyBkcmF3U2VsZWN0aW9uUmFuZ2UoY20sIHJhbmdlLCBzZWxGcmFnbWVudCk7IH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gRHJhd3MgYSBjdXJzb3IgZm9yIHRoZSBnaXZlbiByYW5nZVxuICBmdW5jdGlvbiBkcmF3U2VsZWN0aW9uQ3Vyc29yKGNtLCBoZWFkLCBvdXRwdXQpIHtcbiAgICB2YXIgcG9zID0gY3Vyc29yQ29vcmRzKGNtLCBoZWFkLCBcImRpdlwiLCBudWxsLCBudWxsLCAhY20ub3B0aW9ucy5zaW5nbGVDdXJzb3JIZWlnaHRQZXJMaW5lKTtcblxuICAgIHZhciBjdXJzb3IgPSBvdXRwdXQuYXBwZW5kQ2hpbGQoZWx0KFwiZGl2XCIsIFwiXFx1MDBhMFwiLCBcIkNvZGVNaXJyb3ItY3Vyc29yXCIpKTtcbiAgICBjdXJzb3Iuc3R5bGUubGVmdCA9IHBvcy5sZWZ0ICsgXCJweFwiO1xuICAgIGN1cnNvci5zdHlsZS50b3AgPSBwb3MudG9wICsgXCJweFwiO1xuICAgIGN1cnNvci5zdHlsZS5oZWlnaHQgPSBNYXRoLm1heCgwLCBwb3MuYm90dG9tIC0gcG9zLnRvcCkgKiBjbS5vcHRpb25zLmN1cnNvckhlaWdodCArIFwicHhcIjtcblxuICAgIGlmIChwb3Mub3RoZXIpIHtcbiAgICAgIC8vIFNlY29uZGFyeSBjdXJzb3IsIHNob3duIHdoZW4gb24gYSAnanVtcCcgaW4gYmktZGlyZWN0aW9uYWwgdGV4dFxuICAgICAgdmFyIG90aGVyQ3Vyc29yID0gb3V0cHV0LmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBcIlxcdTAwYTBcIiwgXCJDb2RlTWlycm9yLWN1cnNvciBDb2RlTWlycm9yLXNlY29uZGFyeWN1cnNvclwiKSk7XG4gICAgICBvdGhlckN1cnNvci5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLmxlZnQgPSBwb3Mub3RoZXIubGVmdCArIFwicHhcIjtcbiAgICAgIG90aGVyQ3Vyc29yLnN0eWxlLnRvcCA9IHBvcy5vdGhlci50b3AgKyBcInB4XCI7XG4gICAgICBvdGhlckN1cnNvci5zdHlsZS5oZWlnaHQgPSAocG9zLm90aGVyLmJvdHRvbSAtIHBvcy5vdGhlci50b3ApICogLjg1ICsgXCJweFwiO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNtcENvb3JkcyhhLCBiKSB7IHJldHVybiBhLnRvcCAtIGIudG9wIHx8IGEubGVmdCAtIGIubGVmdCB9XG5cbiAgLy8gRHJhd3MgdGhlIGdpdmVuIHJhbmdlIGFzIGEgaGlnaGxpZ2h0ZWQgc2VsZWN0aW9uXG4gIGZ1bmN0aW9uIGRyYXdTZWxlY3Rpb25SYW5nZShjbSwgcmFuZ2UsIG91dHB1dCkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICB2YXIgcGFkZGluZyA9IHBhZGRpbmdIKGNtLmRpc3BsYXkpLCBsZWZ0U2lkZSA9IHBhZGRpbmcubGVmdDtcbiAgICB2YXIgcmlnaHRTaWRlID0gTWF0aC5tYXgoZGlzcGxheS5zaXplcldpZHRoLCBkaXNwbGF5V2lkdGgoY20pIC0gZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0KSAtIHBhZGRpbmcucmlnaHQ7XG4gICAgdmFyIGRvY0xUUiA9IGRvYy5kaXJlY3Rpb24gPT0gXCJsdHJcIjtcblxuICAgIGZ1bmN0aW9uIGFkZChsZWZ0LCB0b3AsIHdpZHRoLCBib3R0b20pIHtcbiAgICAgIGlmICh0b3AgPCAwKSB7IHRvcCA9IDA7IH1cbiAgICAgIHRvcCA9IE1hdGgucm91bmQodG9wKTtcbiAgICAgIGJvdHRvbSA9IE1hdGgucm91bmQoYm90dG9tKTtcbiAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3Itc2VsZWN0ZWRcIiwgKFwicG9zaXRpb246IGFic29sdXRlOyBsZWZ0OiBcIiArIGxlZnQgKyBcInB4O1xcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBcIiArIHRvcCArIFwicHg7IHdpZHRoOiBcIiArICh3aWR0aCA9PSBudWxsID8gcmlnaHRTaWRlIC0gbGVmdCA6IHdpZHRoKSArIFwicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IFwiICsgKGJvdHRvbSAtIHRvcCkgKyBcInB4XCIpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZHJhd0ZvckxpbmUobGluZSwgZnJvbUFyZywgdG9BcmcpIHtcbiAgICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIGxpbmUpO1xuICAgICAgdmFyIGxpbmVMZW4gPSBsaW5lT2JqLnRleHQubGVuZ3RoO1xuICAgICAgdmFyIHN0YXJ0LCBlbmQ7XG4gICAgICBmdW5jdGlvbiBjb29yZHMoY2gsIGJpYXMpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJDb29yZHMoY20sIFBvcyhsaW5lLCBjaCksIFwiZGl2XCIsIGxpbmVPYmosIGJpYXMpXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBYKHBvcywgZGlyLCBzaWRlKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSB3cmFwcGVkTGluZUV4dGVudENoYXIoY20sIGxpbmVPYmosIG51bGwsIHBvcyk7XG4gICAgICAgIHZhciBwcm9wID0gKGRpciA9PSBcImx0clwiKSA9PSAoc2lkZSA9PSBcImFmdGVyXCIpID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCI7XG4gICAgICAgIHZhciBjaCA9IHNpZGUgPT0gXCJhZnRlclwiID8gZXh0ZW50LmJlZ2luIDogZXh0ZW50LmVuZCAtICgvXFxzLy50ZXN0KGxpbmVPYmoudGV4dC5jaGFyQXQoZXh0ZW50LmVuZCAtIDEpKSA/IDIgOiAxKTtcbiAgICAgICAgcmV0dXJuIGNvb3JkcyhjaCwgcHJvcClbcHJvcF1cbiAgICAgIH1cblxuICAgICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIobGluZU9iaiwgZG9jLmRpcmVjdGlvbik7XG4gICAgICBpdGVyYXRlQmlkaVNlY3Rpb25zKG9yZGVyLCBmcm9tQXJnIHx8IDAsIHRvQXJnID09IG51bGwgPyBsaW5lTGVuIDogdG9BcmcsIGZ1bmN0aW9uIChmcm9tLCB0bywgZGlyLCBpKSB7XG4gICAgICAgIHZhciBsdHIgPSBkaXIgPT0gXCJsdHJcIjtcbiAgICAgICAgdmFyIGZyb21Qb3MgPSBjb29yZHMoZnJvbSwgbHRyID8gXCJsZWZ0XCIgOiBcInJpZ2h0XCIpO1xuICAgICAgICB2YXIgdG9Qb3MgPSBjb29yZHModG8gLSAxLCBsdHIgPyBcInJpZ2h0XCIgOiBcImxlZnRcIik7XG5cbiAgICAgICAgdmFyIG9wZW5TdGFydCA9IGZyb21BcmcgPT0gbnVsbCAmJiBmcm9tID09IDAsIG9wZW5FbmQgPSB0b0FyZyA9PSBudWxsICYmIHRvID09IGxpbmVMZW47XG4gICAgICAgIHZhciBmaXJzdCA9IGkgPT0gMCwgbGFzdCA9ICFvcmRlciB8fCBpID09IG9yZGVyLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmICh0b1Bvcy50b3AgLSBmcm9tUG9zLnRvcCA8PSAzKSB7IC8vIFNpbmdsZSBsaW5lXG4gICAgICAgICAgdmFyIG9wZW5MZWZ0ID0gKGRvY0xUUiA/IG9wZW5TdGFydCA6IG9wZW5FbmQpICYmIGZpcnN0O1xuICAgICAgICAgIHZhciBvcGVuUmlnaHQgPSAoZG9jTFRSID8gb3BlbkVuZCA6IG9wZW5TdGFydCkgJiYgbGFzdDtcbiAgICAgICAgICB2YXIgbGVmdCA9IG9wZW5MZWZ0ID8gbGVmdFNpZGUgOiAobHRyID8gZnJvbVBvcyA6IHRvUG9zKS5sZWZ0O1xuICAgICAgICAgIHZhciByaWdodCA9IG9wZW5SaWdodCA/IHJpZ2h0U2lkZSA6IChsdHIgPyB0b1BvcyA6IGZyb21Qb3MpLnJpZ2h0O1xuICAgICAgICAgIGFkZChsZWZ0LCBmcm9tUG9zLnRvcCwgcmlnaHQgLSBsZWZ0LCBmcm9tUG9zLmJvdHRvbSk7XG4gICAgICAgIH0gZWxzZSB7IC8vIE11bHRpcGxlIGxpbmVzXG4gICAgICAgICAgdmFyIHRvcExlZnQsIHRvcFJpZ2h0LCBib3RMZWZ0LCBib3RSaWdodDtcbiAgICAgICAgICBpZiAobHRyKSB7XG4gICAgICAgICAgICB0b3BMZWZ0ID0gZG9jTFRSICYmIG9wZW5TdGFydCAmJiBmaXJzdCA/IGxlZnRTaWRlIDogZnJvbVBvcy5sZWZ0O1xuICAgICAgICAgICAgdG9wUmlnaHQgPSBkb2NMVFIgPyByaWdodFNpZGUgOiB3cmFwWChmcm9tLCBkaXIsIFwiYmVmb3JlXCIpO1xuICAgICAgICAgICAgYm90TGVmdCA9IGRvY0xUUiA/IGxlZnRTaWRlIDogd3JhcFgodG8sIGRpciwgXCJhZnRlclwiKTtcbiAgICAgICAgICAgIGJvdFJpZ2h0ID0gZG9jTFRSICYmIG9wZW5FbmQgJiYgbGFzdCA/IHJpZ2h0U2lkZSA6IHRvUG9zLnJpZ2h0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3BMZWZ0ID0gIWRvY0xUUiA/IGxlZnRTaWRlIDogd3JhcFgoZnJvbSwgZGlyLCBcImJlZm9yZVwiKTtcbiAgICAgICAgICAgIHRvcFJpZ2h0ID0gIWRvY0xUUiAmJiBvcGVuU3RhcnQgJiYgZmlyc3QgPyByaWdodFNpZGUgOiBmcm9tUG9zLnJpZ2h0O1xuICAgICAgICAgICAgYm90TGVmdCA9ICFkb2NMVFIgJiYgb3BlbkVuZCAmJiBsYXN0ID8gbGVmdFNpZGUgOiB0b1Bvcy5sZWZ0O1xuICAgICAgICAgICAgYm90UmlnaHQgPSAhZG9jTFRSID8gcmlnaHRTaWRlIDogd3JhcFgodG8sIGRpciwgXCJhZnRlclwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYWRkKHRvcExlZnQsIGZyb21Qb3MudG9wLCB0b3BSaWdodCAtIHRvcExlZnQsIGZyb21Qb3MuYm90dG9tKTtcbiAgICAgICAgICBpZiAoZnJvbVBvcy5ib3R0b20gPCB0b1Bvcy50b3ApIHsgYWRkKGxlZnRTaWRlLCBmcm9tUG9zLmJvdHRvbSwgbnVsbCwgdG9Qb3MudG9wKTsgfVxuICAgICAgICAgIGFkZChib3RMZWZ0LCB0b1Bvcy50b3AsIGJvdFJpZ2h0IC0gYm90TGVmdCwgdG9Qb3MuYm90dG9tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghc3RhcnQgfHwgY21wQ29vcmRzKGZyb21Qb3MsIHN0YXJ0KSA8IDApIHsgc3RhcnQgPSBmcm9tUG9zOyB9XG4gICAgICAgIGlmIChjbXBDb29yZHModG9Qb3MsIHN0YXJ0KSA8IDApIHsgc3RhcnQgPSB0b1BvczsgfVxuICAgICAgICBpZiAoIWVuZCB8fCBjbXBDb29yZHMoZnJvbVBvcywgZW5kKSA8IDApIHsgZW5kID0gZnJvbVBvczsgfVxuICAgICAgICBpZiAoY21wQ29vcmRzKHRvUG9zLCBlbmQpIDwgMCkgeyBlbmQgPSB0b1BvczsgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge3N0YXJ0OiBzdGFydCwgZW5kOiBlbmR9XG4gICAgfVxuXG4gICAgdmFyIHNGcm9tID0gcmFuZ2UuZnJvbSgpLCBzVG8gPSByYW5nZS50bygpO1xuICAgIGlmIChzRnJvbS5saW5lID09IHNUby5saW5lKSB7XG4gICAgICBkcmF3Rm9yTGluZShzRnJvbS5saW5lLCBzRnJvbS5jaCwgc1RvLmNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGZyb21MaW5lID0gZ2V0TGluZShkb2MsIHNGcm9tLmxpbmUpLCB0b0xpbmUgPSBnZXRMaW5lKGRvYywgc1RvLmxpbmUpO1xuICAgICAgdmFyIHNpbmdsZVZMaW5lID0gdmlzdWFsTGluZShmcm9tTGluZSkgPT0gdmlzdWFsTGluZSh0b0xpbmUpO1xuICAgICAgdmFyIGxlZnRFbmQgPSBkcmF3Rm9yTGluZShzRnJvbS5saW5lLCBzRnJvbS5jaCwgc2luZ2xlVkxpbmUgPyBmcm9tTGluZS50ZXh0Lmxlbmd0aCArIDEgOiBudWxsKS5lbmQ7XG4gICAgICB2YXIgcmlnaHRTdGFydCA9IGRyYXdGb3JMaW5lKHNUby5saW5lLCBzaW5nbGVWTGluZSA/IDAgOiBudWxsLCBzVG8uY2gpLnN0YXJ0O1xuICAgICAgaWYgKHNpbmdsZVZMaW5lKSB7XG4gICAgICAgIGlmIChsZWZ0RW5kLnRvcCA8IHJpZ2h0U3RhcnQudG9wIC0gMikge1xuICAgICAgICAgIGFkZChsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLnRvcCwgbnVsbCwgbGVmdEVuZC5ib3R0b20pO1xuICAgICAgICAgIGFkZChsZWZ0U2lkZSwgcmlnaHRTdGFydC50b3AsIHJpZ2h0U3RhcnQubGVmdCwgcmlnaHRTdGFydC5ib3R0b20pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZChsZWZ0RW5kLnJpZ2h0LCBsZWZ0RW5kLnRvcCwgcmlnaHRTdGFydC5sZWZ0IC0gbGVmdEVuZC5yaWdodCwgbGVmdEVuZC5ib3R0b20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGVmdEVuZC5ib3R0b20gPCByaWdodFN0YXJ0LnRvcClcbiAgICAgICAgeyBhZGQobGVmdFNpZGUsIGxlZnRFbmQuYm90dG9tLCBudWxsLCByaWdodFN0YXJ0LnRvcCk7IH1cbiAgICB9XG5cbiAgICBvdXRwdXQuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICB9XG5cbiAgLy8gQ3Vyc29yLWJsaW5raW5nXG4gIGZ1bmN0aW9uIHJlc3RhcnRCbGluayhjbSkge1xuICAgIGlmICghY20uc3RhdGUuZm9jdXNlZCkgeyByZXR1cm4gfVxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBjbGVhckludGVydmFsKGRpc3BsYXkuYmxpbmtlcik7XG4gICAgdmFyIG9uID0gdHJ1ZTtcbiAgICBkaXNwbGF5LmN1cnNvckRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJcIjtcbiAgICBpZiAoY20ub3B0aW9ucy5jdXJzb3JCbGlua1JhdGUgPiAwKVxuICAgICAgeyBkaXNwbGF5LmJsaW5rZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghY20uaGFzRm9jdXMoKSkgeyBvbkJsdXIoY20pOyB9XG4gICAgICAgIGRpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSAob24gPSAhb24pID8gXCJcIiA6IFwiaGlkZGVuXCI7XG4gICAgICB9LCBjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSk7IH1cbiAgICBlbHNlIGlmIChjbS5vcHRpb25zLmN1cnNvckJsaW5rUmF0ZSA8IDApXG4gICAgICB7IGRpc3BsYXkuY3Vyc29yRGl2LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiOyB9XG4gIH1cblxuICBmdW5jdGlvbiBlbnN1cmVGb2N1cyhjbSkge1xuICAgIGlmICghY20uaGFzRm9jdXMoKSkge1xuICAgICAgY20uZGlzcGxheS5pbnB1dC5mb2N1cygpO1xuICAgICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7IG9uRm9jdXMoY20pOyB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGVsYXlCbHVyRXZlbnQoY20pIHtcbiAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IHRydWU7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCkge1xuICAgICAgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZTtcbiAgICAgIGlmIChjbS5zdGF0ZS5mb2N1c2VkKSB7IG9uQmx1cihjbSk7IH1cbiAgICB9IH0sIDEwMCk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkZvY3VzKGNtLCBlKSB7XG4gICAgaWYgKGNtLnN0YXRlLmRlbGF5aW5nQmx1ckV2ZW50ICYmICFjbS5zdGF0ZS5kcmFnZ2luZ1RleHQpIHsgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZTsgfVxuXG4gICAgaWYgKGNtLm9wdGlvbnMucmVhZE9ubHkgPT0gXCJub2N1cnNvclwiKSB7IHJldHVybiB9XG4gICAgaWYgKCFjbS5zdGF0ZS5mb2N1c2VkKSB7XG4gICAgICBzaWduYWwoY20sIFwiZm9jdXNcIiwgY20sIGUpO1xuICAgICAgY20uc3RhdGUuZm9jdXNlZCA9IHRydWU7XG4gICAgICBhZGRDbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci1mb2N1c2VkXCIpO1xuICAgICAgLy8gVGhpcyB0ZXN0IHByZXZlbnRzIHRoaXMgZnJvbSBmaXJpbmcgd2hlbiBhIGNvbnRleHRcbiAgICAgIC8vIG1lbnUgaXMgY2xvc2VkIChzaW5jZSB0aGUgaW5wdXQgcmVzZXQgd291bGQga2lsbCB0aGVcbiAgICAgIC8vIHNlbGVjdC1hbGwgZGV0ZWN0aW9uIGhhY2spXG4gICAgICBpZiAoIWNtLmN1ck9wICYmIGNtLmRpc3BsYXkuc2VsRm9yQ29udGV4dE1lbnUgIT0gY20uZG9jLnNlbCkge1xuICAgICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICAgIGlmICh3ZWJraXQpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KHRydWUpOyB9LCAyMCk7IH0gLy8gSXNzdWUgIzE3MzBcbiAgICAgIH1cbiAgICAgIGNtLmRpc3BsYXkuaW5wdXQucmVjZWl2ZWRGb2N1cygpO1xuICAgIH1cbiAgICByZXN0YXJ0QmxpbmsoY20pO1xuICB9XG4gIGZ1bmN0aW9uIG9uQmx1cihjbSwgZSkge1xuICAgIGlmIChjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCkgeyByZXR1cm4gfVxuXG4gICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgIHNpZ25hbChjbSwgXCJibHVyXCIsIGNtLCBlKTtcbiAgICAgIGNtLnN0YXRlLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgIHJtQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3ItZm9jdXNlZFwiKTtcbiAgICB9XG4gICAgY2xlYXJJbnRlcnZhbChjbS5kaXNwbGF5LmJsaW5rZXIpO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBpZiAoIWNtLnN0YXRlLmZvY3VzZWQpIHsgY20uZGlzcGxheS5zaGlmdCA9IGZhbHNlOyB9IH0sIDE1MCk7XG4gIH1cblxuICAvLyBSZWFkIHRoZSBhY3R1YWwgaGVpZ2h0cyBvZiB0aGUgcmVuZGVyZWQgbGluZXMsIGFuZCB1cGRhdGUgdGhlaXJcbiAgLy8gc3RvcmVkIGhlaWdodHMgdG8gbWF0Y2guXG4gIGZ1bmN0aW9uIHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIHZhciBwcmV2Qm90dG9tID0gZGlzcGxheS5saW5lRGl2Lm9mZnNldFRvcDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BsYXkudmlldy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1ciA9IGRpc3BsYXkudmlld1tpXSwgd3JhcHBpbmcgPSBjbS5vcHRpb25zLmxpbmVXcmFwcGluZztcbiAgICAgIHZhciBoZWlnaHQgPSAodm9pZCAwKSwgd2lkdGggPSAwO1xuICAgICAgaWYgKGN1ci5oaWRkZW4pIHsgY29udGludWUgfVxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA4KSB7XG4gICAgICAgIHZhciBib3QgPSBjdXIubm9kZS5vZmZzZXRUb3AgKyBjdXIubm9kZS5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGhlaWdodCA9IGJvdCAtIHByZXZCb3R0b207XG4gICAgICAgIHByZXZCb3R0b20gPSBib3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYm94ID0gY3VyLm5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGhlaWdodCA9IGJveC5ib3R0b20gLSBib3gudG9wO1xuICAgICAgICAvLyBDaGVjayB0aGF0IGxpbmVzIGRvbid0IGV4dGVuZCBwYXN0IHRoZSByaWdodCBvZiB0aGUgY3VycmVudFxuICAgICAgICAvLyBlZGl0b3Igd2lkdGhcbiAgICAgICAgaWYgKCF3cmFwcGluZyAmJiBjdXIudGV4dC5maXJzdENoaWxkKVxuICAgICAgICAgIHsgd2lkdGggPSBjdXIudGV4dC5maXJzdENoaWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0IC0gYm94LmxlZnQgLSAxOyB9XG4gICAgICB9XG4gICAgICB2YXIgZGlmZiA9IGN1ci5saW5lLmhlaWdodCAtIGhlaWdodDtcbiAgICAgIGlmIChkaWZmID4gLjAwNSB8fCBkaWZmIDwgLS4wMDUpIHtcbiAgICAgICAgdXBkYXRlTGluZUhlaWdodChjdXIubGluZSwgaGVpZ2h0KTtcbiAgICAgICAgdXBkYXRlV2lkZ2V0SGVpZ2h0KGN1ci5saW5lKTtcbiAgICAgICAgaWYgKGN1ci5yZXN0KSB7IGZvciAodmFyIGogPSAwOyBqIDwgY3VyLnJlc3QubGVuZ3RoOyBqKyspXG4gICAgICAgICAgeyB1cGRhdGVXaWRnZXRIZWlnaHQoY3VyLnJlc3Rbal0pOyB9IH1cbiAgICAgIH1cbiAgICAgIGlmICh3aWR0aCA+IGNtLmRpc3BsYXkuc2l6ZXJXaWR0aCkge1xuICAgICAgICB2YXIgY2hXaWR0aCA9IE1hdGguY2VpbCh3aWR0aCAvIGNoYXJXaWR0aChjbS5kaXNwbGF5KSk7XG4gICAgICAgIGlmIChjaFdpZHRoID4gY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoKSB7XG4gICAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lTGVuZ3RoID0gY2hXaWR0aDtcbiAgICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmUgPSBjdXIubGluZTtcbiAgICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJlYWQgYW5kIHN0b3JlIHRoZSBoZWlnaHQgb2YgbGluZSB3aWRnZXRzIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgLy8gZ2l2ZW4gbGluZS5cbiAgZnVuY3Rpb24gdXBkYXRlV2lkZ2V0SGVpZ2h0KGxpbmUpIHtcbiAgICBpZiAobGluZS53aWRnZXRzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgbGluZS53aWRnZXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgdyA9IGxpbmUud2lkZ2V0c1tpXSwgcGFyZW50ID0gdy5ub2RlLnBhcmVudE5vZGU7XG4gICAgICBpZiAocGFyZW50KSB7IHcuaGVpZ2h0ID0gcGFyZW50Lm9mZnNldEhlaWdodDsgfVxuICAgIH0gfVxuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgbGluZXMgdGhhdCBhcmUgdmlzaWJsZSBpbiBhIGdpdmVuIHZpZXdwb3J0IChkZWZhdWx0c1xuICAvLyB0aGUgdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uKS4gdmlld3BvcnQgbWF5IGNvbnRhaW4gdG9wLFxuICAvLyBoZWlnaHQsIGFuZCBlbnN1cmUgKHNlZSBvcC5zY3JvbGxUb1BvcykgcHJvcGVydGllcy5cbiAgZnVuY3Rpb24gdmlzaWJsZUxpbmVzKGRpc3BsYXksIGRvYywgdmlld3BvcnQpIHtcbiAgICB2YXIgdG9wID0gdmlld3BvcnQgJiYgdmlld3BvcnQudG9wICE9IG51bGwgPyBNYXRoLm1heCgwLCB2aWV3cG9ydC50b3ApIDogZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7XG4gICAgdG9wID0gTWF0aC5mbG9vcih0b3AgLSBwYWRkaW5nVG9wKGRpc3BsYXkpKTtcbiAgICB2YXIgYm90dG9tID0gdmlld3BvcnQgJiYgdmlld3BvcnQuYm90dG9tICE9IG51bGwgPyB2aWV3cG9ydC5ib3R0b20gOiB0b3AgKyBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuXG4gICAgdmFyIGZyb20gPSBsaW5lQXRIZWlnaHQoZG9jLCB0b3ApLCB0byA9IGxpbmVBdEhlaWdodChkb2MsIGJvdHRvbSk7XG4gICAgLy8gRW5zdXJlIGlzIGEge2Zyb206IHtsaW5lLCBjaH0sIHRvOiB7bGluZSwgY2h9fSBvYmplY3QsIGFuZFxuICAgIC8vIGZvcmNlcyB0aG9zZSBsaW5lcyBpbnRvIHRoZSB2aWV3cG9ydCAoaWYgcG9zc2libGUpLlxuICAgIGlmICh2aWV3cG9ydCAmJiB2aWV3cG9ydC5lbnN1cmUpIHtcbiAgICAgIHZhciBlbnN1cmVGcm9tID0gdmlld3BvcnQuZW5zdXJlLmZyb20ubGluZSwgZW5zdXJlVG8gPSB2aWV3cG9ydC5lbnN1cmUudG8ubGluZTtcbiAgICAgIGlmIChlbnN1cmVGcm9tIDwgZnJvbSkge1xuICAgICAgICBmcm9tID0gZW5zdXJlRnJvbTtcbiAgICAgICAgdG8gPSBsaW5lQXRIZWlnaHQoZG9jLCBoZWlnaHRBdExpbmUoZ2V0TGluZShkb2MsIGVuc3VyZUZyb20pKSArIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQpO1xuICAgICAgfSBlbHNlIGlmIChNYXRoLm1pbihlbnN1cmVUbywgZG9jLmxhc3RMaW5lKCkpID49IHRvKSB7XG4gICAgICAgIGZyb20gPSBsaW5lQXRIZWlnaHQoZG9jLCBoZWlnaHRBdExpbmUoZ2V0TGluZShkb2MsIGVuc3VyZVRvKSkgLSBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0KTtcbiAgICAgICAgdG8gPSBlbnN1cmVUbztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtmcm9tOiBmcm9tLCB0bzogTWF0aC5tYXgodG8sIGZyb20gKyAxKX1cbiAgfVxuXG4gIC8vIFNDUk9MTElORyBUSElOR1MgSU5UTyBWSUVXXG5cbiAgLy8gSWYgYW4gZWRpdG9yIHNpdHMgb24gdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIHdpbmRvdywgcGFydGlhbGx5XG4gIC8vIHNjcm9sbGVkIG91dCBvZiB2aWV3LCB0aGlzIGVuc3VyZXMgdGhhdCB0aGUgY3Vyc29yIGlzIHZpc2libGUuXG4gIGZ1bmN0aW9uIG1heWJlU2Nyb2xsV2luZG93KGNtLCByZWN0KSB7XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBcInNjcm9sbEN1cnNvckludG9WaWV3XCIpKSB7IHJldHVybiB9XG5cbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIGJveCA9IGRpc3BsYXkuc2l6ZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGRvU2Nyb2xsID0gbnVsbDtcbiAgICBpZiAocmVjdC50b3AgKyBib3gudG9wIDwgMCkgeyBkb1Njcm9sbCA9IHRydWU7IH1cbiAgICBlbHNlIGlmIChyZWN0LmJvdHRvbSArIGJveC50b3AgPiAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpKSB7IGRvU2Nyb2xsID0gZmFsc2U7IH1cbiAgICBpZiAoZG9TY3JvbGwgIT0gbnVsbCAmJiAhcGhhbnRvbSkge1xuICAgICAgdmFyIHNjcm9sbE5vZGUgPSBlbHQoXCJkaXZcIiwgXCJcXHUyMDBiXCIsIG51bGwsIChcInBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBcIiArIChyZWN0LnRvcCAtIGRpc3BsYXkudmlld09mZnNldCAtIHBhZGRpbmdUb3AoY20uZGlzcGxheSkpICsgXCJweDtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBcIiArIChyZWN0LmJvdHRvbSAtIHJlY3QudG9wICsgc2Nyb2xsR2FwKGNtKSArIGRpc3BsYXkuYmFySGVpZ2h0KSArIFwicHg7XFxuICAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IFwiICsgKHJlY3QubGVmdCkgKyBcInB4OyB3aWR0aDogXCIgKyAoTWF0aC5tYXgoMiwgcmVjdC5yaWdodCAtIHJlY3QubGVmdCkpICsgXCJweDtcIikpO1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UuYXBwZW5kQ2hpbGQoc2Nyb2xsTm9kZSk7XG4gICAgICBzY3JvbGxOb2RlLnNjcm9sbEludG9WaWV3KGRvU2Nyb2xsKTtcbiAgICAgIGNtLmRpc3BsYXkubGluZVNwYWNlLnJlbW92ZUNoaWxkKHNjcm9sbE5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNjcm9sbCBhIGdpdmVuIHBvc2l0aW9uIGludG8gdmlldyAoaW1tZWRpYXRlbHkpLCB2ZXJpZnlpbmcgdGhhdFxuICAvLyBpdCBhY3R1YWxseSBiZWNhbWUgdmlzaWJsZSAoYXMgbGluZSBoZWlnaHRzIGFyZSBhY2N1cmF0ZWx5XG4gIC8vIG1lYXN1cmVkLCB0aGUgcG9zaXRpb24gb2Ygc29tZXRoaW5nIG1heSAnZHJpZnQnIGR1cmluZyBkcmF3aW5nKS5cbiAgZnVuY3Rpb24gc2Nyb2xsUG9zSW50b1ZpZXcoY20sIHBvcywgZW5kLCBtYXJnaW4pIHtcbiAgICBpZiAobWFyZ2luID09IG51bGwpIHsgbWFyZ2luID0gMDsgfVxuICAgIHZhciByZWN0O1xuICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgJiYgcG9zID09IGVuZCkge1xuICAgICAgLy8gU2V0IHBvcyBhbmQgZW5kIHRvIHRoZSBjdXJzb3IgcG9zaXRpb25zIGFyb3VuZCB0aGUgY2hhcmFjdGVyIHBvcyBzdGlja3MgdG9cbiAgICAgIC8vIElmIHBvcy5zdGlja3kgPT0gXCJiZWZvcmVcIiwgdGhhdCBpcyBhcm91bmQgcG9zLmNoIC0gMSwgb3RoZXJ3aXNlIGFyb3VuZCBwb3MuY2hcbiAgICAgIC8vIElmIHBvcyA9PSBQb3MoXywgMCwgXCJiZWZvcmVcIiksIHBvcyBhbmQgZW5kIGFyZSB1bmNoYW5nZWRcbiAgICAgIHBvcyA9IHBvcy5jaCA/IFBvcyhwb3MubGluZSwgcG9zLnN0aWNreSA9PSBcImJlZm9yZVwiID8gcG9zLmNoIC0gMSA6IHBvcy5jaCwgXCJhZnRlclwiKSA6IHBvcztcbiAgICAgIGVuZCA9IHBvcy5zdGlja3kgPT0gXCJiZWZvcmVcIiA/IFBvcyhwb3MubGluZSwgcG9zLmNoICsgMSwgXCJiZWZvcmVcIikgOiBwb3M7XG4gICAgfVxuICAgIGZvciAodmFyIGxpbWl0ID0gMDsgbGltaXQgPCA1OyBsaW1pdCsrKSB7XG4gICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgdmFyIGNvb3JkcyA9IGN1cnNvckNvb3JkcyhjbSwgcG9zKTtcbiAgICAgIHZhciBlbmRDb29yZHMgPSAhZW5kIHx8IGVuZCA9PSBwb3MgPyBjb29yZHMgOiBjdXJzb3JDb29yZHMoY20sIGVuZCk7XG4gICAgICByZWN0ID0ge2xlZnQ6IE1hdGgubWluKGNvb3Jkcy5sZWZ0LCBlbmRDb29yZHMubGVmdCksXG4gICAgICAgICAgICAgIHRvcDogTWF0aC5taW4oY29vcmRzLnRvcCwgZW5kQ29vcmRzLnRvcCkgLSBtYXJnaW4sXG4gICAgICAgICAgICAgIHJpZ2h0OiBNYXRoLm1heChjb29yZHMubGVmdCwgZW5kQ29vcmRzLmxlZnQpLFxuICAgICAgICAgICAgICBib3R0b206IE1hdGgubWF4KGNvb3Jkcy5ib3R0b20sIGVuZENvb3Jkcy5ib3R0b20pICsgbWFyZ2lufTtcbiAgICAgIHZhciBzY3JvbGxQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHJlY3QpO1xuICAgICAgdmFyIHN0YXJ0VG9wID0gY20uZG9jLnNjcm9sbFRvcCwgc3RhcnRMZWZ0ID0gY20uZG9jLnNjcm9sbExlZnQ7XG4gICAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbFRvcCAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZVNjcm9sbFRvcChjbSwgc2Nyb2xsUG9zLnNjcm9sbFRvcCk7XG4gICAgICAgIGlmIChNYXRoLmFicyhjbS5kb2Muc2Nyb2xsVG9wIC0gc3RhcnRUb3ApID4gMSkgeyBjaGFuZ2VkID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgICAgaWYgKHNjcm9sbFBvcy5zY3JvbGxMZWZ0ICE9IG51bGwpIHtcbiAgICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgc2Nyb2xsUG9zLnNjcm9sbExlZnQpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoY20uZG9jLnNjcm9sbExlZnQgLSBzdGFydExlZnQpID4gMSkgeyBjaGFuZ2VkID0gdHJ1ZTsgfVxuICAgICAgfVxuICAgICAgaWYgKCFjaGFuZ2VkKSB7IGJyZWFrIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlY3RcbiAgfVxuXG4gIC8vIFNjcm9sbCBhIGdpdmVuIHNldCBvZiBjb29yZGluYXRlcyBpbnRvIHZpZXcgKGltbWVkaWF0ZWx5KS5cbiAgZnVuY3Rpb24gc2Nyb2xsSW50b1ZpZXcoY20sIHJlY3QpIHtcbiAgICB2YXIgc2Nyb2xsUG9zID0gY2FsY3VsYXRlU2Nyb2xsUG9zKGNtLCByZWN0KTtcbiAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbFRvcCAhPSBudWxsKSB7IHVwZGF0ZVNjcm9sbFRvcChjbSwgc2Nyb2xsUG9zLnNjcm9sbFRvcCk7IH1cbiAgICBpZiAoc2Nyb2xsUG9zLnNjcm9sbExlZnQgIT0gbnVsbCkgeyBzZXRTY3JvbGxMZWZ0KGNtLCBzY3JvbGxQb3Muc2Nyb2xsTGVmdCk7IH1cbiAgfVxuXG4gIC8vIENhbGN1bGF0ZSBhIG5ldyBzY3JvbGwgcG9zaXRpb24gbmVlZGVkIHRvIHNjcm9sbCB0aGUgZ2l2ZW5cbiAgLy8gcmVjdGFuZ2xlIGludG8gdmlldy4gUmV0dXJucyBhbiBvYmplY3Qgd2l0aCBzY3JvbGxUb3AgYW5kXG4gIC8vIHNjcm9sbExlZnQgcHJvcGVydGllcy4gV2hlbiB0aGVzZSBhcmUgdW5kZWZpbmVkLCB0aGVcbiAgLy8gdmVydGljYWwvaG9yaXpvbnRhbCBwb3NpdGlvbiBkb2VzIG5vdCBuZWVkIHRvIGJlIGFkanVzdGVkLlxuICBmdW5jdGlvbiBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHJlY3QpIHtcbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNuYXBNYXJnaW4gPSB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpO1xuICAgIGlmIChyZWN0LnRvcCA8IDApIHsgcmVjdC50b3AgPSAwOyB9XG4gICAgdmFyIHNjcmVlbnRvcCA9IGNtLmN1ck9wICYmIGNtLmN1ck9wLnNjcm9sbFRvcCAhPSBudWxsID8gY20uY3VyT3Auc2Nyb2xsVG9wIDogZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3A7XG4gICAgdmFyIHNjcmVlbiA9IGRpc3BsYXlIZWlnaHQoY20pLCByZXN1bHQgPSB7fTtcbiAgICBpZiAocmVjdC5ib3R0b20gLSByZWN0LnRvcCA+IHNjcmVlbikgeyByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgc2NyZWVuOyB9XG4gICAgdmFyIGRvY0JvdHRvbSA9IGNtLmRvYy5oZWlnaHQgKyBwYWRkaW5nVmVydChkaXNwbGF5KTtcbiAgICB2YXIgYXRUb3AgPSByZWN0LnRvcCA8IHNuYXBNYXJnaW4sIGF0Qm90dG9tID0gcmVjdC5ib3R0b20gPiBkb2NCb3R0b20gLSBzbmFwTWFyZ2luO1xuICAgIGlmIChyZWN0LnRvcCA8IHNjcmVlbnRvcCkge1xuICAgICAgcmVzdWx0LnNjcm9sbFRvcCA9IGF0VG9wID8gMCA6IHJlY3QudG9wO1xuICAgIH0gZWxzZSBpZiAocmVjdC5ib3R0b20gPiBzY3JlZW50b3AgKyBzY3JlZW4pIHtcbiAgICAgIHZhciBuZXdUb3AgPSBNYXRoLm1pbihyZWN0LnRvcCwgKGF0Qm90dG9tID8gZG9jQm90dG9tIDogcmVjdC5ib3R0b20pIC0gc2NyZWVuKTtcbiAgICAgIGlmIChuZXdUb3AgIT0gc2NyZWVudG9wKSB7IHJlc3VsdC5zY3JvbGxUb3AgPSBuZXdUb3A7IH1cbiAgICB9XG5cbiAgICB2YXIgZ3V0dGVyU3BhY2UgPSBjbS5vcHRpb25zLmZpeGVkR3V0dGVyID8gMCA6IGRpc3BsYXkuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICB2YXIgc2NyZWVubGVmdCA9IGNtLmN1ck9wICYmIGNtLmN1ck9wLnNjcm9sbExlZnQgIT0gbnVsbCA/IGNtLmN1ck9wLnNjcm9sbExlZnQgOiBkaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgLSBndXR0ZXJTcGFjZTtcbiAgICB2YXIgc2NyZWVudyA9IGRpc3BsYXlXaWR0aChjbSkgLSBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGg7XG4gICAgdmFyIHRvb1dpZGUgPSByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0ID4gc2NyZWVudztcbiAgICBpZiAodG9vV2lkZSkgeyByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgc2NyZWVudzsgfVxuICAgIGlmIChyZWN0LmxlZnQgPCAxMClcbiAgICAgIHsgcmVzdWx0LnNjcm9sbExlZnQgPSAwOyB9XG4gICAgZWxzZSBpZiAocmVjdC5sZWZ0IDwgc2NyZWVubGVmdClcbiAgICAgIHsgcmVzdWx0LnNjcm9sbExlZnQgPSBNYXRoLm1heCgwLCByZWN0LmxlZnQgKyBndXR0ZXJTcGFjZSAtICh0b29XaWRlID8gMCA6IDEwKSk7IH1cbiAgICBlbHNlIGlmIChyZWN0LnJpZ2h0ID4gc2NyZWVudyArIHNjcmVlbmxlZnQgLSAzKVxuICAgICAgeyByZXN1bHQuc2Nyb2xsTGVmdCA9IHJlY3QucmlnaHQgKyAodG9vV2lkZSA/IDAgOiAxMCkgLSBzY3JlZW53OyB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy8gU3RvcmUgYSByZWxhdGl2ZSBhZGp1c3RtZW50IHRvIHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdGhlIGN1cnJlbnRcbiAgLy8gb3BlcmF0aW9uICh0byBiZSBhcHBsaWVkIHdoZW4gdGhlIG9wZXJhdGlvbiBmaW5pc2hlcykuXG4gIGZ1bmN0aW9uIGFkZFRvU2Nyb2xsVG9wKGNtLCB0b3ApIHtcbiAgICBpZiAodG9wID09IG51bGwpIHsgcmV0dXJuIH1cbiAgICByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pO1xuICAgIGNtLmN1ck9wLnNjcm9sbFRvcCA9IChjbS5jdXJPcC5zY3JvbGxUb3AgPT0gbnVsbCA/IGNtLmRvYy5zY3JvbGxUb3AgOiBjbS5jdXJPcC5zY3JvbGxUb3ApICsgdG9wO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIHRoYXQgYXQgdGhlIGVuZCBvZiB0aGUgb3BlcmF0aW9uIHRoZSBjdXJyZW50IGN1cnNvciBpc1xuICAvLyBzaG93bi5cbiAgZnVuY3Rpb24gZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSkge1xuICAgIHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7XG4gICAgdmFyIGN1ciA9IGNtLmdldEN1cnNvcigpO1xuICAgIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0ge2Zyb206IGN1ciwgdG86IGN1ciwgbWFyZ2luOiBjbS5vcHRpb25zLmN1cnNvclNjcm9sbE1hcmdpbn07XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxUb0Nvb3JkcyhjbSwgeCwgeSkge1xuICAgIGlmICh4ICE9IG51bGwgfHwgeSAhPSBudWxsKSB7IHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7IH1cbiAgICBpZiAoeCAhPSBudWxsKSB7IGNtLmN1ck9wLnNjcm9sbExlZnQgPSB4OyB9XG4gICAgaWYgKHkgIT0gbnVsbCkgeyBjbS5jdXJPcC5zY3JvbGxUb3AgPSB5OyB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxUb1JhbmdlKGNtLCByYW5nZSkge1xuICAgIHJlc29sdmVTY3JvbGxUb1BvcyhjbSk7XG4gICAgY20uY3VyT3Auc2Nyb2xsVG9Qb3MgPSByYW5nZTtcbiAgfVxuXG4gIC8vIFdoZW4gYW4gb3BlcmF0aW9uIGhhcyBpdHMgc2Nyb2xsVG9Qb3MgcHJvcGVydHkgc2V0LCBhbmQgYW5vdGhlclxuICAvLyBzY3JvbGwgYWN0aW9uIGlzIGFwcGxpZWQgYmVmb3JlIHRoZSBlbmQgb2YgdGhlIG9wZXJhdGlvbiwgdGhpc1xuICAvLyAnc2ltdWxhdGVzJyBzY3JvbGxpbmcgdGhhdCBwb3NpdGlvbiBpbnRvIHZpZXcgaW4gYSBjaGVhcCB3YXksIHNvXG4gIC8vIHRoYXQgdGhlIGVmZmVjdCBvZiBpbnRlcm1lZGlhdGUgc2Nyb2xsIGNvbW1hbmRzIGlzIG5vdCBpZ25vcmVkLlxuICBmdW5jdGlvbiByZXNvbHZlU2Nyb2xsVG9Qb3MoY20pIHtcbiAgICB2YXIgcmFuZ2UgPSBjbS5jdXJPcC5zY3JvbGxUb1BvcztcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIGNtLmN1ck9wLnNjcm9sbFRvUG9zID0gbnVsbDtcbiAgICAgIHZhciBmcm9tID0gZXN0aW1hdGVDb29yZHMoY20sIHJhbmdlLmZyb20pLCB0byA9IGVzdGltYXRlQ29vcmRzKGNtLCByYW5nZS50byk7XG4gICAgICBzY3JvbGxUb0Nvb3Jkc1JhbmdlKGNtLCBmcm9tLCB0bywgcmFuZ2UubWFyZ2luKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY3JvbGxUb0Nvb3Jkc1JhbmdlKGNtLCBmcm9tLCB0bywgbWFyZ2luKSB7XG4gICAgdmFyIHNQb3MgPSBjYWxjdWxhdGVTY3JvbGxQb3MoY20sIHtcbiAgICAgIGxlZnQ6IE1hdGgubWluKGZyb20ubGVmdCwgdG8ubGVmdCksXG4gICAgICB0b3A6IE1hdGgubWluKGZyb20udG9wLCB0by50b3ApIC0gbWFyZ2luLFxuICAgICAgcmlnaHQ6IE1hdGgubWF4KGZyb20ucmlnaHQsIHRvLnJpZ2h0KSxcbiAgICAgIGJvdHRvbTogTWF0aC5tYXgoZnJvbS5ib3R0b20sIHRvLmJvdHRvbSkgKyBtYXJnaW5cbiAgICB9KTtcbiAgICBzY3JvbGxUb0Nvb3JkcyhjbSwgc1Bvcy5zY3JvbGxMZWZ0LCBzUG9zLnNjcm9sbFRvcCk7XG4gIH1cblxuICAvLyBTeW5jIHRoZSBzY3JvbGxhYmxlIGFyZWEgYW5kIHNjcm9sbGJhcnMsIGVuc3VyZSB0aGUgdmlld3BvcnRcbiAgLy8gY292ZXJzIHRoZSB2aXNpYmxlIGFyZWEuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNjcm9sbFRvcChjbSwgdmFsKSB7XG4gICAgaWYgKE1hdGguYWJzKGNtLmRvYy5zY3JvbGxUb3AgLSB2YWwpIDwgMikgeyByZXR1cm4gfVxuICAgIGlmICghZ2Vja28pIHsgdXBkYXRlRGlzcGxheVNpbXBsZShjbSwge3RvcDogdmFsfSk7IH1cbiAgICBzZXRTY3JvbGxUb3AoY20sIHZhbCwgdHJ1ZSk7XG4gICAgaWYgKGdlY2tvKSB7IHVwZGF0ZURpc3BsYXlTaW1wbGUoY20pOyB9XG4gICAgc3RhcnRXb3JrZXIoY20sIDEwMCk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTY3JvbGxUb3AoY20sIHZhbCwgZm9yY2VTY3JvbGwpIHtcbiAgICB2YWwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbEhlaWdodCAtIGNtLmRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50SGVpZ2h0LCB2YWwpKTtcbiAgICBpZiAoY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPT0gdmFsICYmICFmb3JjZVNjcm9sbCkgeyByZXR1cm4gfVxuICAgIGNtLmRvYy5zY3JvbGxUb3AgPSB2YWw7XG4gICAgY20uZGlzcGxheS5zY3JvbGxiYXJzLnNldFNjcm9sbFRvcCh2YWwpO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbFRvcCAhPSB2YWwpIHsgY20uZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPSB2YWw7IH1cbiAgfVxuXG4gIC8vIFN5bmMgc2Nyb2xsZXIgYW5kIHNjcm9sbGJhciwgZW5zdXJlIHRoZSBndXR0ZXIgZWxlbWVudHMgYXJlXG4gIC8vIGFsaWduZWQuXG4gIGZ1bmN0aW9uIHNldFNjcm9sbExlZnQoY20sIHZhbCwgaXNTY3JvbGxlciwgZm9yY2VTY3JvbGwpIHtcbiAgICB2YWwgPSBNYXRoLm1heCgwLCBNYXRoLm1pbih2YWwsIGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsV2lkdGggLSBjbS5kaXNwbGF5LnNjcm9sbGVyLmNsaWVudFdpZHRoKSk7XG4gICAgaWYgKChpc1Njcm9sbGVyID8gdmFsID09IGNtLmRvYy5zY3JvbGxMZWZ0IDogTWF0aC5hYnMoY20uZG9jLnNjcm9sbExlZnQgLSB2YWwpIDwgMikgJiYgIWZvcmNlU2Nyb2xsKSB7IHJldHVybiB9XG4gICAgY20uZG9jLnNjcm9sbExlZnQgPSB2YWw7XG4gICAgYWxpZ25Ib3Jpem9udGFsbHkoY20pO1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQgIT0gdmFsKSB7IGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsTGVmdCA9IHZhbDsgfVxuICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxMZWZ0KHZhbCk7XG4gIH1cblxuICAvLyBTQ1JPTExCQVJTXG5cbiAgLy8gUHJlcGFyZSBET00gcmVhZHMgbmVlZGVkIHRvIHVwZGF0ZSB0aGUgc2Nyb2xsYmFycy4gRG9uZSBpbiBvbmVcbiAgLy8gc2hvdCB0byBtaW5pbWl6ZSB1cGRhdGUvbWVhc3VyZSByb3VuZHRyaXBzLlxuICBmdW5jdGlvbiBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSkge1xuICAgIHZhciBkID0gY20uZGlzcGxheSwgZ3V0dGVyVyA9IGQuZ3V0dGVycy5vZmZzZXRXaWR0aDtcbiAgICB2YXIgZG9jSCA9IE1hdGgucm91bmQoY20uZG9jLmhlaWdodCArIHBhZGRpbmdWZXJ0KGNtLmRpc3BsYXkpKTtcbiAgICByZXR1cm4ge1xuICAgICAgY2xpZW50SGVpZ2h0OiBkLnNjcm9sbGVyLmNsaWVudEhlaWdodCxcbiAgICAgIHZpZXdIZWlnaHQ6IGQud3JhcHBlci5jbGllbnRIZWlnaHQsXG4gICAgICBzY3JvbGxXaWR0aDogZC5zY3JvbGxlci5zY3JvbGxXaWR0aCwgY2xpZW50V2lkdGg6IGQuc2Nyb2xsZXIuY2xpZW50V2lkdGgsXG4gICAgICB2aWV3V2lkdGg6IGQud3JhcHBlci5jbGllbnRXaWR0aCxcbiAgICAgIGJhckxlZnQ6IGNtLm9wdGlvbnMuZml4ZWRHdXR0ZXIgPyBndXR0ZXJXIDogMCxcbiAgICAgIGRvY0hlaWdodDogZG9jSCxcbiAgICAgIHNjcm9sbEhlaWdodDogZG9jSCArIHNjcm9sbEdhcChjbSkgKyBkLmJhckhlaWdodCxcbiAgICAgIG5hdGl2ZUJhcldpZHRoOiBkLm5hdGl2ZUJhcldpZHRoLFxuICAgICAgZ3V0dGVyV2lkdGg6IGd1dHRlcldcbiAgICB9XG4gIH1cblxuICB2YXIgTmF0aXZlU2Nyb2xsYmFycyA9IGZ1bmN0aW9uKHBsYWNlLCBzY3JvbGwsIGNtKSB7XG4gICAgdGhpcy5jbSA9IGNtO1xuICAgIHZhciB2ZXJ0ID0gdGhpcy52ZXJ0ID0gZWx0KFwiZGl2XCIsIFtlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJtaW4td2lkdGg6IDFweFwiKV0sIFwiQ29kZU1pcnJvci12c2Nyb2xsYmFyXCIpO1xuICAgIHZhciBob3JpeiA9IHRoaXMuaG9yaXogPSBlbHQoXCJkaXZcIiwgW2VsdChcImRpdlwiLCBudWxsLCBudWxsLCBcImhlaWdodDogMTAwJTsgbWluLWhlaWdodDogMXB4XCIpXSwgXCJDb2RlTWlycm9yLWhzY3JvbGxiYXJcIik7XG4gICAgdmVydC50YWJJbmRleCA9IGhvcml6LnRhYkluZGV4ID0gLTE7XG4gICAgcGxhY2UodmVydCk7IHBsYWNlKGhvcml6KTtcblxuICAgIG9uKHZlcnQsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh2ZXJ0LmNsaWVudEhlaWdodCkgeyBzY3JvbGwodmVydC5zY3JvbGxUb3AsIFwidmVydGljYWxcIik7IH1cbiAgICB9KTtcbiAgICBvbihob3JpeiwgXCJzY3JvbGxcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGhvcml6LmNsaWVudFdpZHRoKSB7IHNjcm9sbChob3Jpei5zY3JvbGxMZWZ0LCBcImhvcml6b250YWxcIik7IH1cbiAgICB9KTtcblxuICAgIHRoaXMuY2hlY2tlZFplcm9XaWR0aCA9IGZhbHNlO1xuICAgIC8vIE5lZWQgdG8gc2V0IGEgbWluaW11bSB3aWR0aCB0byBzZWUgdGhlIHNjcm9sbGJhciBvbiBJRTcgKGJ1dCBtdXN0IG5vdCBzZXQgaXQgb24gSUU4KS5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHsgdGhpcy5ob3Jpei5zdHlsZS5taW5IZWlnaHQgPSB0aGlzLnZlcnQuc3R5bGUubWluV2lkdGggPSBcIjE4cHhcIjsgfVxuICB9O1xuXG4gIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZWFzdXJlKSB7XG4gICAgdmFyIG5lZWRzSCA9IG1lYXN1cmUuc2Nyb2xsV2lkdGggPiBtZWFzdXJlLmNsaWVudFdpZHRoICsgMTtcbiAgICB2YXIgbmVlZHNWID0gbWVhc3VyZS5zY3JvbGxIZWlnaHQgPiBtZWFzdXJlLmNsaWVudEhlaWdodCArIDE7XG4gICAgdmFyIHNXaWR0aCA9IG1lYXN1cmUubmF0aXZlQmFyV2lkdGg7XG5cbiAgICBpZiAobmVlZHNWKSB7XG4gICAgICB0aGlzLnZlcnQuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgIHRoaXMudmVydC5zdHlsZS5ib3R0b20gPSBuZWVkc0ggPyBzV2lkdGggKyBcInB4XCIgOiBcIjBcIjtcbiAgICAgIHZhciB0b3RhbEhlaWdodCA9IG1lYXN1cmUudmlld0hlaWdodCAtIChuZWVkc0ggPyBzV2lkdGggOiAwKTtcbiAgICAgIC8vIEEgYnVnIGluIElFOCBjYW4gY2F1c2UgdGhpcyB2YWx1ZSB0byBiZSBuZWdhdGl2ZSwgc28gZ3VhcmQgaXQuXG4gICAgICB0aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPVxuICAgICAgICBNYXRoLm1heCgwLCBtZWFzdXJlLnNjcm9sbEhlaWdodCAtIG1lYXN1cmUuY2xpZW50SGVpZ2h0ICsgdG90YWxIZWlnaHQpICsgXCJweFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZlcnQuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICB0aGlzLnZlcnQuZmlyc3RDaGlsZC5zdHlsZS5oZWlnaHQgPSBcIjBcIjtcbiAgICB9XG5cbiAgICBpZiAobmVlZHNIKSB7XG4gICAgICB0aGlzLmhvcml6LnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgICB0aGlzLmhvcml6LnN0eWxlLnJpZ2h0ID0gbmVlZHNWID8gc1dpZHRoICsgXCJweFwiIDogXCIwXCI7XG4gICAgICB0aGlzLmhvcml6LnN0eWxlLmxlZnQgPSBtZWFzdXJlLmJhckxlZnQgKyBcInB4XCI7XG4gICAgICB2YXIgdG90YWxXaWR0aCA9IG1lYXN1cmUudmlld1dpZHRoIC0gbWVhc3VyZS5iYXJMZWZ0IC0gKG5lZWRzViA/IHNXaWR0aCA6IDApO1xuICAgICAgdGhpcy5ob3Jpei5maXJzdENoaWxkLnN0eWxlLndpZHRoID1cbiAgICAgICAgTWF0aC5tYXgoMCwgbWVhc3VyZS5zY3JvbGxXaWR0aCAtIG1lYXN1cmUuY2xpZW50V2lkdGggKyB0b3RhbFdpZHRoKSArIFwicHhcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5ob3Jpei5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgIHRoaXMuaG9yaXouZmlyc3RDaGlsZC5zdHlsZS53aWR0aCA9IFwiMFwiO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5jaGVja2VkWmVyb1dpZHRoICYmIG1lYXN1cmUuY2xpZW50SGVpZ2h0ID4gMCkge1xuICAgICAgaWYgKHNXaWR0aCA9PSAwKSB7IHRoaXMuemVyb1dpZHRoSGFjaygpOyB9XG4gICAgICB0aGlzLmNoZWNrZWRaZXJvV2lkdGggPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiB7cmlnaHQ6IG5lZWRzViA/IHNXaWR0aCA6IDAsIGJvdHRvbTogbmVlZHNIID8gc1dpZHRoIDogMH1cbiAgfTtcblxuICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKHBvcykge1xuICAgIGlmICh0aGlzLmhvcml6LnNjcm9sbExlZnQgIT0gcG9zKSB7IHRoaXMuaG9yaXouc2Nyb2xsTGVmdCA9IHBvczsgfVxuICAgIGlmICh0aGlzLmRpc2FibGVIb3JpeikgeyB0aGlzLmVuYWJsZVplcm9XaWR0aEJhcih0aGlzLmhvcml6LCB0aGlzLmRpc2FibGVIb3JpeiwgXCJob3JpelwiKTsgfVxuICB9O1xuXG4gIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICBpZiAodGhpcy52ZXJ0LnNjcm9sbFRvcCAhPSBwb3MpIHsgdGhpcy52ZXJ0LnNjcm9sbFRvcCA9IHBvczsgfVxuICAgIGlmICh0aGlzLmRpc2FibGVWZXJ0KSB7IHRoaXMuZW5hYmxlWmVyb1dpZHRoQmFyKHRoaXMudmVydCwgdGhpcy5kaXNhYmxlVmVydCwgXCJ2ZXJ0XCIpOyB9XG4gIH07XG5cbiAgTmF0aXZlU2Nyb2xsYmFycy5wcm90b3R5cGUuemVyb1dpZHRoSGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdyA9IG1hYyAmJiAhbWFjX2dlTW91bnRhaW5MaW9uID8gXCIxMnB4XCIgOiBcIjE4cHhcIjtcbiAgICB0aGlzLmhvcml6LnN0eWxlLmhlaWdodCA9IHRoaXMudmVydC5zdHlsZS53aWR0aCA9IHc7XG4gICAgdGhpcy5ob3Jpei5zdHlsZS5wb2ludGVyRXZlbnRzID0gdGhpcy52ZXJ0LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjtcbiAgICB0aGlzLmRpc2FibGVIb3JpeiA9IG5ldyBEZWxheWVkO1xuICAgIHRoaXMuZGlzYWJsZVZlcnQgPSBuZXcgRGVsYXllZDtcbiAgfTtcblxuICBOYXRpdmVTY3JvbGxiYXJzLnByb3RvdHlwZS5lbmFibGVaZXJvV2lkdGhCYXIgPSBmdW5jdGlvbiAoYmFyLCBkZWxheSwgdHlwZSkge1xuICAgIGJhci5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgZnVuY3Rpb24gbWF5YmVEaXNhYmxlKCkge1xuICAgICAgLy8gVG8gZmluZCBvdXQgd2hldGhlciB0aGUgc2Nyb2xsYmFyIGlzIHN0aWxsIHZpc2libGUsIHdlXG4gICAgICAvLyBjaGVjayB3aGV0aGVyIHRoZSBlbGVtZW50IHVuZGVyIHRoZSBwaXhlbCBpbiB0aGUgYm90dG9tXG4gICAgICAvLyByaWdodCBjb3JuZXIgb2YgdGhlIHNjcm9sbGJhciBib3ggaXMgdGhlIHNjcm9sbGJhciBib3hcbiAgICAgIC8vIGl0c2VsZiAod2hlbiB0aGUgYmFyIGlzIHN0aWxsIHZpc2libGUpIG9yIGl0cyBmaWxsZXIgY2hpbGRcbiAgICAgIC8vICh3aGVuIHRoZSBiYXIgaXMgaGlkZGVuKS4gSWYgaXQgaXMgc3RpbGwgdmlzaWJsZSwgd2Uga2VlcFxuICAgICAgLy8gaXQgZW5hYmxlZCwgaWYgaXQncyBoaWRkZW4sIHdlIGRpc2FibGUgcG9pbnRlciBldmVudHMuXG4gICAgICB2YXIgYm94ID0gYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgdmFyIGVsdCA9IHR5cGUgPT0gXCJ2ZXJ0XCIgPyBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGJveC5yaWdodCAtIDEsIChib3gudG9wICsgYm94LmJvdHRvbSkgLyAyKVxuICAgICAgICAgIDogZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCgoYm94LnJpZ2h0ICsgYm94LmxlZnQpIC8gMiwgYm94LmJvdHRvbSAtIDEpO1xuICAgICAgaWYgKGVsdCAhPSBiYXIpIHsgYmFyLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcIm5vbmVcIjsgfVxuICAgICAgZWxzZSB7IGRlbGF5LnNldCgxMDAwLCBtYXliZURpc2FibGUpOyB9XG4gICAgfVxuICAgIGRlbGF5LnNldCgxMDAwLCBtYXliZURpc2FibGUpO1xuICB9O1xuXG4gIE5hdGl2ZVNjcm9sbGJhcnMucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLmhvcml6LnBhcmVudE5vZGU7XG4gICAgcGFyZW50LnJlbW92ZUNoaWxkKHRoaXMuaG9yaXopO1xuICAgIHBhcmVudC5yZW1vdmVDaGlsZCh0aGlzLnZlcnQpO1xuICB9O1xuXG4gIHZhciBOdWxsU2Nyb2xsYmFycyA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIE51bGxTY3JvbGxiYXJzLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB7Ym90dG9tOiAwLCByaWdodDogMH0gfTtcbiAgTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgTnVsbFNjcm9sbGJhcnMucHJvdG90eXBlLnNldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHt9O1xuICBOdWxsU2Nyb2xsYmFycy5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBmdW5jdGlvbiB1cGRhdGVTY3JvbGxiYXJzKGNtLCBtZWFzdXJlKSB7XG4gICAgaWYgKCFtZWFzdXJlKSB7IG1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7IH1cbiAgICB2YXIgc3RhcnRXaWR0aCA9IGNtLmRpc3BsYXkuYmFyV2lkdGgsIHN0YXJ0SGVpZ2h0ID0gY20uZGlzcGxheS5iYXJIZWlnaHQ7XG4gICAgdXBkYXRlU2Nyb2xsYmFyc0lubmVyKGNtLCBtZWFzdXJlKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQgJiYgc3RhcnRXaWR0aCAhPSBjbS5kaXNwbGF5LmJhcldpZHRoIHx8IHN0YXJ0SGVpZ2h0ICE9IGNtLmRpc3BsYXkuYmFySGVpZ2h0OyBpKyspIHtcbiAgICAgIGlmIChzdGFydFdpZHRoICE9IGNtLmRpc3BsYXkuYmFyV2lkdGggJiYgY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpXG4gICAgICAgIHsgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pOyB9XG4gICAgICB1cGRhdGVTY3JvbGxiYXJzSW5uZXIoY20sIG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKSk7XG4gICAgICBzdGFydFdpZHRoID0gY20uZGlzcGxheS5iYXJXaWR0aDsgc3RhcnRIZWlnaHQgPSBjbS5kaXNwbGF5LmJhckhlaWdodDtcbiAgICB9XG4gIH1cblxuICAvLyBSZS1zeW5jaHJvbml6ZSB0aGUgZmFrZSBzY3JvbGxiYXJzIHdpdGggdGhlIGFjdHVhbCBzaXplIG9mIHRoZVxuICAvLyBjb250ZW50LlxuICBmdW5jdGlvbiB1cGRhdGVTY3JvbGxiYXJzSW5uZXIoY20sIG1lYXN1cmUpIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XG4gICAgdmFyIHNpemVzID0gZC5zY3JvbGxiYXJzLnVwZGF0ZShtZWFzdXJlKTtcblxuICAgIGQuc2l6ZXIuc3R5bGUucGFkZGluZ1JpZ2h0ID0gKGQuYmFyV2lkdGggPSBzaXplcy5yaWdodCkgKyBcInB4XCI7XG4gICAgZC5zaXplci5zdHlsZS5wYWRkaW5nQm90dG9tID0gKGQuYmFySGVpZ2h0ID0gc2l6ZXMuYm90dG9tKSArIFwicHhcIjtcbiAgICBkLmhlaWdodEZvcmNlci5zdHlsZS5ib3JkZXJCb3R0b20gPSBzaXplcy5ib3R0b20gKyBcInB4IHNvbGlkIHRyYW5zcGFyZW50XCI7XG5cbiAgICBpZiAoc2l6ZXMucmlnaHQgJiYgc2l6ZXMuYm90dG9tKSB7XG4gICAgICBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZXMuYm90dG9tICsgXCJweFwiO1xuICAgICAgZC5zY3JvbGxiYXJGaWxsZXIuc3R5bGUud2lkdGggPSBzaXplcy5yaWdodCArIFwicHhcIjtcbiAgICB9IGVsc2UgeyBkLnNjcm9sbGJhckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXCJcIjsgfVxuICAgIGlmIChzaXplcy5ib3R0b20gJiYgY20ub3B0aW9ucy5jb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhciAmJiBjbS5vcHRpb25zLmZpeGVkR3V0dGVyKSB7XG4gICAgICBkLmd1dHRlckZpbGxlci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUuaGVpZ2h0ID0gc2l6ZXMuYm90dG9tICsgXCJweFwiO1xuICAgICAgZC5ndXR0ZXJGaWxsZXIuc3R5bGUud2lkdGggPSBtZWFzdXJlLmd1dHRlcldpZHRoICsgXCJweFwiO1xuICAgIH0gZWxzZSB7IGQuZ3V0dGVyRmlsbGVyLnN0eWxlLmRpc3BsYXkgPSBcIlwiOyB9XG4gIH1cblxuICB2YXIgc2Nyb2xsYmFyTW9kZWwgPSB7XCJuYXRpdmVcIjogTmF0aXZlU2Nyb2xsYmFycywgXCJudWxsXCI6IE51bGxTY3JvbGxiYXJzfTtcblxuICBmdW5jdGlvbiBpbml0U2Nyb2xsYmFycyhjbSkge1xuICAgIGlmIChjbS5kaXNwbGF5LnNjcm9sbGJhcnMpIHtcbiAgICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5jbGVhcigpO1xuICAgICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcylcbiAgICAgICAgeyBybUNsYXNzKGNtLmRpc3BsYXkud3JhcHBlciwgY20uZGlzcGxheS5zY3JvbGxiYXJzLmFkZENsYXNzKTsgfVxuICAgIH1cblxuICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycyA9IG5ldyBzY3JvbGxiYXJNb2RlbFtjbS5vcHRpb25zLnNjcm9sbGJhclN0eWxlXShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgY20uZGlzcGxheS53cmFwcGVyLmluc2VydEJlZm9yZShub2RlLCBjbS5kaXNwbGF5LnNjcm9sbGJhckZpbGxlcik7XG4gICAgICAvLyBQcmV2ZW50IGNsaWNrcyBpbiB0aGUgc2Nyb2xsYmFycyBmcm9tIGtpbGxpbmcgZm9jdXNcbiAgICAgIG9uKG5vZGUsIFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNtLnN0YXRlLmZvY3VzZWQpIHsgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7IH0sIDApOyB9XG4gICAgICB9KTtcbiAgICAgIG5vZGUuc2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIiwgXCJ0cnVlXCIpO1xuICAgIH0sIGZ1bmN0aW9uIChwb3MsIGF4aXMpIHtcbiAgICAgIGlmIChheGlzID09IFwiaG9yaXpvbnRhbFwiKSB7IHNldFNjcm9sbExlZnQoY20sIHBvcyk7IH1cbiAgICAgIGVsc2UgeyB1cGRhdGVTY3JvbGxUb3AoY20sIHBvcyk7IH1cbiAgICB9LCBjbSk7XG4gICAgaWYgKGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5hZGRDbGFzcylcbiAgICAgIHsgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuYWRkQ2xhc3MpOyB9XG4gIH1cblxuICAvLyBPcGVyYXRpb25zIGFyZSB1c2VkIHRvIHdyYXAgYSBzZXJpZXMgb2YgY2hhbmdlcyB0byB0aGUgZWRpdG9yXG4gIC8vIHN0YXRlIGluIHN1Y2ggYSB3YXkgdGhhdCBlYWNoIGNoYW5nZSB3b24ndCBoYXZlIHRvIHVwZGF0ZSB0aGVcbiAgLy8gY3Vyc29yIGFuZCBkaXNwbGF5ICh3aGljaCB3b3VsZCBiZSBhd2t3YXJkLCBzbG93LCBhbmRcbiAgLy8gZXJyb3ItcHJvbmUpLiBJbnN0ZWFkLCBkaXNwbGF5IHVwZGF0ZXMgYXJlIGJhdGNoZWQgYW5kIHRoZW4gYWxsXG4gIC8vIGNvbWJpbmVkIGFuZCBleGVjdXRlZCBhdCBvbmNlLlxuXG4gIHZhciBuZXh0T3BJZCA9IDA7XG4gIC8vIFN0YXJ0IGEgbmV3IG9wZXJhdGlvbi5cbiAgZnVuY3Rpb24gc3RhcnRPcGVyYXRpb24oY20pIHtcbiAgICBjbS5jdXJPcCA9IHtcbiAgICAgIGNtOiBjbSxcbiAgICAgIHZpZXdDaGFuZ2VkOiBmYWxzZSwgICAgICAvLyBGbGFnIHRoYXQgaW5kaWNhdGVzIHRoYXQgbGluZXMgbWlnaHQgbmVlZCB0byBiZSByZWRyYXduXG4gICAgICBzdGFydEhlaWdodDogY20uZG9jLmhlaWdodCwgLy8gVXNlZCB0byBkZXRlY3QgbmVlZCB0byB1cGRhdGUgc2Nyb2xsYmFyXG4gICAgICBmb3JjZVVwZGF0ZTogZmFsc2UsICAgICAgLy8gVXNlZCB0byBmb3JjZSBhIHJlZHJhd1xuICAgICAgdXBkYXRlSW5wdXQ6IDAsICAgICAgIC8vIFdoZXRoZXIgdG8gcmVzZXQgdGhlIGlucHV0IHRleHRhcmVhXG4gICAgICB0eXBpbmc6IGZhbHNlLCAgICAgICAgICAgLy8gV2hldGhlciB0aGlzIHJlc2V0IHNob3VsZCBiZSBjYXJlZnVsIHRvIGxlYXZlIGV4aXN0aW5nIHRleHQgKGZvciBjb21wb3NpdGluZylcbiAgICAgIGNoYW5nZU9ianM6IG51bGwsICAgICAgICAvLyBBY2N1bXVsYXRlZCBjaGFuZ2VzLCBmb3IgZmlyaW5nIGNoYW5nZSBldmVudHNcbiAgICAgIGN1cnNvckFjdGl2aXR5SGFuZGxlcnM6IG51bGwsIC8vIFNldCBvZiBoYW5kbGVycyB0byBmaXJlIGN1cnNvckFjdGl2aXR5IG9uXG4gICAgICBjdXJzb3JBY3Rpdml0eUNhbGxlZDogMCwgLy8gVHJhY2tzIHdoaWNoIGN1cnNvckFjdGl2aXR5IGhhbmRsZXJzIGhhdmUgYmVlbiBjYWxsZWQgYWxyZWFkeVxuICAgICAgc2VsZWN0aW9uQ2hhbmdlZDogZmFsc2UsIC8vIFdoZXRoZXIgdGhlIHNlbGVjdGlvbiBuZWVkcyB0byBiZSByZWRyYXduXG4gICAgICB1cGRhdGVNYXhMaW5lOiBmYWxzZSwgICAgLy8gU2V0IHdoZW4gdGhlIHdpZGVzdCBsaW5lIG5lZWRzIHRvIGJlIGRldGVybWluZWQgYW5ld1xuICAgICAgc2Nyb2xsTGVmdDogbnVsbCwgc2Nyb2xsVG9wOiBudWxsLCAvLyBJbnRlcm1lZGlhdGUgc2Nyb2xsIHBvc2l0aW9uLCBub3QgcHVzaGVkIHRvIERPTSB5ZXRcbiAgICAgIHNjcm9sbFRvUG9zOiBudWxsLCAgICAgICAvLyBVc2VkIHRvIHNjcm9sbCB0byBhIHNwZWNpZmljIHBvc2l0aW9uXG4gICAgICBmb2N1czogZmFsc2UsXG4gICAgICBpZDogKytuZXh0T3BJZCAgICAgICAgICAgLy8gVW5pcXVlIElEXG4gICAgfTtcbiAgICBwdXNoT3BlcmF0aW9uKGNtLmN1ck9wKTtcbiAgfVxuXG4gIC8vIEZpbmlzaCBhbiBvcGVyYXRpb24sIHVwZGF0aW5nIHRoZSBkaXNwbGF5IGFuZCBzaWduYWxsaW5nIGRlbGF5ZWQgZXZlbnRzXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbihjbSkge1xuICAgIHZhciBvcCA9IGNtLmN1ck9wO1xuICAgIGlmIChvcCkgeyBmaW5pc2hPcGVyYXRpb24ob3AsIGZ1bmN0aW9uIChncm91cCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5vcHMubGVuZ3RoOyBpKyspXG4gICAgICAgIHsgZ3JvdXAub3BzW2ldLmNtLmN1ck9wID0gbnVsbDsgfVxuICAgICAgZW5kT3BlcmF0aW9ucyhncm91cCk7XG4gICAgfSk7IH1cbiAgfVxuXG4gIC8vIFRoZSBET00gdXBkYXRlcyBkb25lIHdoZW4gYW4gb3BlcmF0aW9uIGZpbmlzaGVzIGFyZSBiYXRjaGVkIHNvXG4gIC8vIHRoYXQgdGhlIG1pbmltdW0gbnVtYmVyIG9mIHJlbGF5b3V0cyBhcmUgcmVxdWlyZWQuXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbnMoZ3JvdXApIHtcbiAgICB2YXIgb3BzID0gZ3JvdXAub3BzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSAvLyBSZWFkIERPTVxuICAgICAgeyBlbmRPcGVyYXRpb25fUjEob3BzW2ldKTsgfVxuICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IG9wcy5sZW5ndGg7IGkkMSsrKSAvLyBXcml0ZSBET00gKG1heWJlKVxuICAgICAgeyBlbmRPcGVyYXRpb25fVzEob3BzW2kkMV0pOyB9XG4gICAgZm9yICh2YXIgaSQyID0gMDsgaSQyIDwgb3BzLmxlbmd0aDsgaSQyKyspIC8vIFJlYWQgRE9NXG4gICAgICB7IGVuZE9wZXJhdGlvbl9SMihvcHNbaSQyXSk7IH1cbiAgICBmb3IgKHZhciBpJDMgPSAwOyBpJDMgPCBvcHMubGVuZ3RoOyBpJDMrKykgLy8gV3JpdGUgRE9NIChtYXliZSlcbiAgICAgIHsgZW5kT3BlcmF0aW9uX1cyKG9wc1tpJDNdKTsgfVxuICAgIGZvciAodmFyIGkkNCA9IDA7IGkkNCA8IG9wcy5sZW5ndGg7IGkkNCsrKSAvLyBSZWFkIERPTVxuICAgICAgeyBlbmRPcGVyYXRpb25fZmluaXNoKG9wc1tpJDRdKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gZW5kT3BlcmF0aW9uX1IxKG9wKSB7XG4gICAgdmFyIGNtID0gb3AuY20sIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIG1heWJlQ2xpcFNjcm9sbGJhcnMoY20pO1xuICAgIGlmIChvcC51cGRhdGVNYXhMaW5lKSB7IGZpbmRNYXhMaW5lKGNtKTsgfVxuXG4gICAgb3AubXVzdFVwZGF0ZSA9IG9wLnZpZXdDaGFuZ2VkIHx8IG9wLmZvcmNlVXBkYXRlIHx8IG9wLnNjcm9sbFRvcCAhPSBudWxsIHx8XG4gICAgICBvcC5zY3JvbGxUb1BvcyAmJiAob3Auc2Nyb2xsVG9Qb3MuZnJvbS5saW5lIDwgZGlzcGxheS52aWV3RnJvbSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIG9wLnNjcm9sbFRvUG9zLnRvLmxpbmUgPj0gZGlzcGxheS52aWV3VG8pIHx8XG4gICAgICBkaXNwbGF5Lm1heExpbmVDaGFuZ2VkICYmIGNtLm9wdGlvbnMubGluZVdyYXBwaW5nO1xuICAgIG9wLnVwZGF0ZSA9IG9wLm11c3RVcGRhdGUgJiZcbiAgICAgIG5ldyBEaXNwbGF5VXBkYXRlKGNtLCBvcC5tdXN0VXBkYXRlICYmIHt0b3A6IG9wLnNjcm9sbFRvcCwgZW5zdXJlOiBvcC5zY3JvbGxUb1Bvc30sIG9wLmZvcmNlVXBkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9XMShvcCkge1xuICAgIG9wLnVwZGF0ZWREaXNwbGF5ID0gb3AubXVzdFVwZGF0ZSAmJiB1cGRhdGVEaXNwbGF5SWZOZWVkZWQob3AuY20sIG9wLnVwZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fUjIob3ApIHtcbiAgICB2YXIgY20gPSBvcC5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKG9wLnVwZGF0ZWREaXNwbGF5KSB7IHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTsgfVxuXG4gICAgb3AuYmFyTWVhc3VyZSA9IG1lYXN1cmVGb3JTY3JvbGxiYXJzKGNtKTtcblxuICAgIC8vIElmIHRoZSBtYXggbGluZSBjaGFuZ2VkIHNpbmNlIGl0IHdhcyBsYXN0IG1lYXN1cmVkLCBtZWFzdXJlIGl0LFxuICAgIC8vIGFuZCBlbnN1cmUgdGhlIGRvY3VtZW50J3Mgd2lkdGggbWF0Y2hlcyBpdC5cbiAgICAvLyB1cGRhdGVEaXNwbGF5X1cyIHdpbGwgdXNlIHRoZXNlIHByb3BlcnRpZXMgdG8gZG8gdGhlIGFjdHVhbCByZXNpemluZ1xuICAgIGlmIChkaXNwbGF5Lm1heExpbmVDaGFuZ2VkICYmICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xuICAgICAgb3AuYWRqdXN0V2lkdGhUbyA9IG1lYXN1cmVDaGFyKGNtLCBkaXNwbGF5Lm1heExpbmUsIGRpc3BsYXkubWF4TGluZS50ZXh0Lmxlbmd0aCkubGVmdCArIDM7XG4gICAgICBjbS5kaXNwbGF5LnNpemVyV2lkdGggPSBvcC5hZGp1c3RXaWR0aFRvO1xuICAgICAgb3AuYmFyTWVhc3VyZS5zY3JvbGxXaWR0aCA9XG4gICAgICAgIE1hdGgubWF4KGRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGgsIGRpc3BsYXkuc2l6ZXIub2Zmc2V0TGVmdCArIG9wLmFkanVzdFdpZHRoVG8gKyBzY3JvbGxHYXAoY20pICsgY20uZGlzcGxheS5iYXJXaWR0aCk7XG4gICAgICBvcC5tYXhTY3JvbGxMZWZ0ID0gTWF0aC5tYXgoMCwgZGlzcGxheS5zaXplci5vZmZzZXRMZWZ0ICsgb3AuYWRqdXN0V2lkdGhUbyAtIGRpc3BsYXlXaWR0aChjbSkpO1xuICAgIH1cblxuICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSB8fCBvcC5zZWxlY3Rpb25DaGFuZ2VkKVxuICAgICAgeyBvcC5wcmVwYXJlZFNlbGVjdGlvbiA9IGRpc3BsYXkuaW5wdXQucHJlcGFyZVNlbGVjdGlvbigpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBlbmRPcGVyYXRpb25fVzIob3ApIHtcbiAgICB2YXIgY20gPSBvcC5jbTtcblxuICAgIGlmIChvcC5hZGp1c3RXaWR0aFRvICE9IG51bGwpIHtcbiAgICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluV2lkdGggPSBvcC5hZGp1c3RXaWR0aFRvICsgXCJweFwiO1xuICAgICAgaWYgKG9wLm1heFNjcm9sbExlZnQgPCBjbS5kb2Muc2Nyb2xsTGVmdClcbiAgICAgICAgeyBzZXRTY3JvbGxMZWZ0KGNtLCBNYXRoLm1pbihjbS5kaXNwbGF5LnNjcm9sbGVyLnNjcm9sbExlZnQsIG9wLm1heFNjcm9sbExlZnQpLCB0cnVlKTsgfVxuICAgICAgY20uZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0YWtlRm9jdXMgPSBvcC5mb2N1cyAmJiBvcC5mb2N1cyA9PSBhY3RpdmVFbHQoKTtcbiAgICBpZiAob3AucHJlcGFyZWRTZWxlY3Rpb24pXG4gICAgICB7IGNtLmRpc3BsYXkuaW5wdXQuc2hvd1NlbGVjdGlvbihvcC5wcmVwYXJlZFNlbGVjdGlvbiwgdGFrZUZvY3VzKTsgfVxuICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSB8fCBvcC5zdGFydEhlaWdodCAhPSBjbS5kb2MuaGVpZ2h0KVxuICAgICAgeyB1cGRhdGVTY3JvbGxiYXJzKGNtLCBvcC5iYXJNZWFzdXJlKTsgfVxuICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSlcbiAgICAgIHsgc2V0RG9jdW1lbnRIZWlnaHQoY20sIG9wLmJhck1lYXN1cmUpOyB9XG5cbiAgICBpZiAob3Auc2VsZWN0aW9uQ2hhbmdlZCkgeyByZXN0YXJ0QmxpbmsoY20pOyB9XG5cbiAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCAmJiBvcC51cGRhdGVJbnB1dClcbiAgICAgIHsgY20uZGlzcGxheS5pbnB1dC5yZXNldChvcC50eXBpbmcpOyB9XG4gICAgaWYgKHRha2VGb2N1cykgeyBlbnN1cmVGb2N1cyhvcC5jbSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9wZXJhdGlvbl9maW5pc2gob3ApIHtcbiAgICB2YXIgY20gPSBvcC5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcblxuICAgIGlmIChvcC51cGRhdGVkRGlzcGxheSkgeyBwb3N0VXBkYXRlRGlzcGxheShjbSwgb3AudXBkYXRlKTsgfVxuXG4gICAgLy8gQWJvcnQgbW91c2Ugd2hlZWwgZGVsdGEgbWVhc3VyZW1lbnQsIHdoZW4gc2Nyb2xsaW5nIGV4cGxpY2l0bHlcbiAgICBpZiAoZGlzcGxheS53aGVlbFN0YXJ0WCAhPSBudWxsICYmIChvcC5zY3JvbGxUb3AgIT0gbnVsbCB8fCBvcC5zY3JvbGxMZWZ0ICE9IG51bGwgfHwgb3Auc2Nyb2xsVG9Qb3MpKVxuICAgICAgeyBkaXNwbGF5LndoZWVsU3RhcnRYID0gZGlzcGxheS53aGVlbFN0YXJ0WSA9IG51bGw7IH1cblxuICAgIC8vIFByb3BhZ2F0ZSB0aGUgc2Nyb2xsIHBvc2l0aW9uIHRvIHRoZSBhY3R1YWwgRE9NIHNjcm9sbGVyXG4gICAgaWYgKG9wLnNjcm9sbFRvcCAhPSBudWxsKSB7IHNldFNjcm9sbFRvcChjbSwgb3Auc2Nyb2xsVG9wLCBvcC5mb3JjZVNjcm9sbCk7IH1cblxuICAgIGlmIChvcC5zY3JvbGxMZWZ0ICE9IG51bGwpIHsgc2V0U2Nyb2xsTGVmdChjbSwgb3Auc2Nyb2xsTGVmdCwgdHJ1ZSwgdHJ1ZSk7IH1cbiAgICAvLyBJZiB3ZSBuZWVkIHRvIHNjcm9sbCBhIHNwZWNpZmljIHBvc2l0aW9uIGludG8gdmlldywgZG8gc28uXG4gICAgaWYgKG9wLnNjcm9sbFRvUG9zKSB7XG4gICAgICB2YXIgcmVjdCA9IHNjcm9sbFBvc0ludG9WaWV3KGNtLCBjbGlwUG9zKGRvYywgb3Auc2Nyb2xsVG9Qb3MuZnJvbSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBQb3MoZG9jLCBvcC5zY3JvbGxUb1Bvcy50byksIG9wLnNjcm9sbFRvUG9zLm1hcmdpbik7XG4gICAgICBtYXliZVNjcm9sbFdpbmRvdyhjbSwgcmVjdCk7XG4gICAgfVxuXG4gICAgLy8gRmlyZSBldmVudHMgZm9yIG1hcmtlcnMgdGhhdCBhcmUgaGlkZGVuL3VuaWRkZW4gYnkgZWRpdGluZyBvclxuICAgIC8vIHVuZG9pbmdcbiAgICB2YXIgaGlkZGVuID0gb3AubWF5YmVIaWRkZW5NYXJrZXJzLCB1bmhpZGRlbiA9IG9wLm1heWJlVW5oaWRkZW5NYXJrZXJzO1xuICAgIGlmIChoaWRkZW4pIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW4ubGVuZ3RoOyArK2kpXG4gICAgICB7IGlmICghaGlkZGVuW2ldLmxpbmVzLmxlbmd0aCkgeyBzaWduYWwoaGlkZGVuW2ldLCBcImhpZGVcIik7IH0gfSB9XG4gICAgaWYgKHVuaGlkZGVuKSB7IGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHVuaGlkZGVuLmxlbmd0aDsgKytpJDEpXG4gICAgICB7IGlmICh1bmhpZGRlbltpJDFdLmxpbmVzLmxlbmd0aCkgeyBzaWduYWwodW5oaWRkZW5baSQxXSwgXCJ1bmhpZGVcIik7IH0gfSB9XG5cbiAgICBpZiAoZGlzcGxheS53cmFwcGVyLm9mZnNldEhlaWdodClcbiAgICAgIHsgZG9jLnNjcm9sbFRvcCA9IGNtLmRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wOyB9XG5cbiAgICAvLyBGaXJlIGNoYW5nZSBldmVudHMsIGFuZCBkZWxheWVkIGV2ZW50IGhhbmRsZXJzXG4gICAgaWYgKG9wLmNoYW5nZU9ianMpXG4gICAgICB7IHNpZ25hbChjbSwgXCJjaGFuZ2VzXCIsIGNtLCBvcC5jaGFuZ2VPYmpzKTsgfVxuICAgIGlmIChvcC51cGRhdGUpXG4gICAgICB7IG9wLnVwZGF0ZS5maW5pc2goKTsgfVxuICB9XG5cbiAgLy8gUnVuIHRoZSBnaXZlbiBmdW5jdGlvbiBpbiBhbiBvcGVyYXRpb25cbiAgZnVuY3Rpb24gcnVuSW5PcChjbSwgZikge1xuICAgIGlmIChjbS5jdXJPcCkgeyByZXR1cm4gZigpIH1cbiAgICBzdGFydE9wZXJhdGlvbihjbSk7XG4gICAgdHJ5IHsgcmV0dXJuIGYoKSB9XG4gICAgZmluYWxseSB7IGVuZE9wZXJhdGlvbihjbSk7IH1cbiAgfVxuICAvLyBXcmFwcyBhIGZ1bmN0aW9uIGluIGFuIG9wZXJhdGlvbi4gUmV0dXJucyB0aGUgd3JhcHBlZCBmdW5jdGlvbi5cbiAgZnVuY3Rpb24gb3BlcmF0aW9uKGNtLCBmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGNtLmN1ck9wKSB7IHJldHVybiBmLmFwcGx5KGNtLCBhcmd1bWVudHMpIH1cbiAgICAgIHN0YXJ0T3BlcmF0aW9uKGNtKTtcbiAgICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KGNtLCBhcmd1bWVudHMpIH1cbiAgICAgIGZpbmFsbHkgeyBlbmRPcGVyYXRpb24oY20pOyB9XG4gICAgfVxuICB9XG4gIC8vIFVzZWQgdG8gYWRkIG1ldGhvZHMgdG8gZWRpdG9yIGFuZCBkb2MgaW5zdGFuY2VzLCB3cmFwcGluZyB0aGVtIGluXG4gIC8vIG9wZXJhdGlvbnMuXG4gIGZ1bmN0aW9uIG1ldGhvZE9wKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jdXJPcCkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgICAgIHN0YXJ0T3BlcmF0aW9uKHRoaXMpO1xuICAgICAgdHJ5IHsgcmV0dXJuIGYuYXBwbHkodGhpcywgYXJndW1lbnRzKSB9XG4gICAgICBmaW5hbGx5IHsgZW5kT3BlcmF0aW9uKHRoaXMpOyB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRvY01ldGhvZE9wKGYpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY20gPSB0aGlzLmNtO1xuICAgICAgaWYgKCFjbSB8fCBjbS5jdXJPcCkgeyByZXR1cm4gZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpIH1cbiAgICAgIHN0YXJ0T3BlcmF0aW9uKGNtKTtcbiAgICAgIHRyeSB7IHJldHVybiBmLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfVxuICAgICAgZmluYWxseSB7IGVuZE9wZXJhdGlvbihjbSk7IH1cbiAgICB9XG4gIH1cblxuICAvLyBISUdITElHSFQgV09SS0VSXG5cbiAgZnVuY3Rpb24gc3RhcnRXb3JrZXIoY20sIHRpbWUpIHtcbiAgICBpZiAoY20uZG9jLmhpZ2hsaWdodEZyb250aWVyIDwgY20uZGlzcGxheS52aWV3VG8pXG4gICAgICB7IGNtLnN0YXRlLmhpZ2hsaWdodC5zZXQodGltZSwgYmluZChoaWdobGlnaHRXb3JrZXIsIGNtKSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodFdvcmtlcihjbSkge1xuICAgIHZhciBkb2MgPSBjbS5kb2M7XG4gICAgaWYgKGRvYy5oaWdobGlnaHRGcm9udGllciA+PSBjbS5kaXNwbGF5LnZpZXdUbykgeyByZXR1cm4gfVxuICAgIHZhciBlbmQgPSArbmV3IERhdGUgKyBjbS5vcHRpb25zLndvcmtUaW1lO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0Q29udGV4dEJlZm9yZShjbSwgZG9jLmhpZ2hsaWdodEZyb250aWVyKTtcbiAgICB2YXIgY2hhbmdlZExpbmVzID0gW107XG5cbiAgICBkb2MuaXRlcihjb250ZXh0LmxpbmUsIE1hdGgubWluKGRvYy5maXJzdCArIGRvYy5zaXplLCBjbS5kaXNwbGF5LnZpZXdUbyArIDUwMCksIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAoY29udGV4dC5saW5lID49IGNtLmRpc3BsYXkudmlld0Zyb20pIHsgLy8gVmlzaWJsZVxuICAgICAgICB2YXIgb2xkU3R5bGVzID0gbGluZS5zdHlsZXM7XG4gICAgICAgIHZhciByZXNldFN0YXRlID0gbGluZS50ZXh0Lmxlbmd0aCA+IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoID8gY29weVN0YXRlKGRvYy5tb2RlLCBjb250ZXh0LnN0YXRlKSA6IG51bGw7XG4gICAgICAgIHZhciBoaWdobGlnaHRlZCA9IGhpZ2hsaWdodExpbmUoY20sIGxpbmUsIGNvbnRleHQsIHRydWUpO1xuICAgICAgICBpZiAocmVzZXRTdGF0ZSkgeyBjb250ZXh0LnN0YXRlID0gcmVzZXRTdGF0ZTsgfVxuICAgICAgICBsaW5lLnN0eWxlcyA9IGhpZ2hsaWdodGVkLnN0eWxlcztcbiAgICAgICAgdmFyIG9sZENscyA9IGxpbmUuc3R5bGVDbGFzc2VzLCBuZXdDbHMgPSBoaWdobGlnaHRlZC5jbGFzc2VzO1xuICAgICAgICBpZiAobmV3Q2xzKSB7IGxpbmUuc3R5bGVDbGFzc2VzID0gbmV3Q2xzOyB9XG4gICAgICAgIGVsc2UgaWYgKG9sZENscykgeyBsaW5lLnN0eWxlQ2xhc3NlcyA9IG51bGw7IH1cbiAgICAgICAgdmFyIGlzY2hhbmdlID0gIW9sZFN0eWxlcyB8fCBvbGRTdHlsZXMubGVuZ3RoICE9IGxpbmUuc3R5bGVzLmxlbmd0aCB8fFxuICAgICAgICAgIG9sZENscyAhPSBuZXdDbHMgJiYgKCFvbGRDbHMgfHwgIW5ld0NscyB8fCBvbGRDbHMuYmdDbGFzcyAhPSBuZXdDbHMuYmdDbGFzcyB8fCBvbGRDbHMudGV4dENsYXNzICE9IG5ld0Nscy50ZXh0Q2xhc3MpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgIWlzY2hhbmdlICYmIGkgPCBvbGRTdHlsZXMubGVuZ3RoOyArK2kpIHsgaXNjaGFuZ2UgPSBvbGRTdHlsZXNbaV0gIT0gbGluZS5zdHlsZXNbaV07IH1cbiAgICAgICAgaWYgKGlzY2hhbmdlKSB7IGNoYW5nZWRMaW5lcy5wdXNoKGNvbnRleHQubGluZSk7IH1cbiAgICAgICAgbGluZS5zdGF0ZUFmdGVyID0gY29udGV4dC5zYXZlKCk7XG4gICAgICAgIGNvbnRleHQubmV4dExpbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsaW5lLnRleHQubGVuZ3RoIDw9IGNtLm9wdGlvbnMubWF4SGlnaGxpZ2h0TGVuZ3RoKVxuICAgICAgICAgIHsgcHJvY2Vzc0xpbmUoY20sIGxpbmUudGV4dCwgY29udGV4dCk7IH1cbiAgICAgICAgbGluZS5zdGF0ZUFmdGVyID0gY29udGV4dC5saW5lICUgNSA9PSAwID8gY29udGV4dC5zYXZlKCkgOiBudWxsO1xuICAgICAgICBjb250ZXh0Lm5leHRMaW5lKCk7XG4gICAgICB9XG4gICAgICBpZiAoK25ldyBEYXRlID4gZW5kKSB7XG4gICAgICAgIHN0YXJ0V29ya2VyKGNtLCBjbS5vcHRpb25zLndvcmtEZWxheSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgZG9jLmhpZ2hsaWdodEZyb250aWVyID0gY29udGV4dC5saW5lO1xuICAgIGRvYy5tb2RlRnJvbnRpZXIgPSBNYXRoLm1heChkb2MubW9kZUZyb250aWVyLCBjb250ZXh0LmxpbmUpO1xuICAgIGlmIChjaGFuZ2VkTGluZXMubGVuZ3RoKSB7IHJ1bkluT3AoY20sIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlZExpbmVzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7IHJlZ0xpbmVDaGFuZ2UoY20sIGNoYW5nZWRMaW5lc1tpXSwgXCJ0ZXh0XCIpOyB9XG4gICAgfSk7IH1cbiAgfVxuXG4gIC8vIERJU1BMQVkgRFJBV0lOR1xuXG4gIHZhciBEaXNwbGF5VXBkYXRlID0gZnVuY3Rpb24oY20sIHZpZXdwb3J0LCBmb3JjZSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheTtcblxuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAvLyBTdG9yZSBzb21lIHZhbHVlcyB0aGF0IHdlJ2xsIG5lZWQgbGF0ZXIgKGJ1dCBkb24ndCB3YW50IHRvIGZvcmNlIGEgcmVsYXlvdXQgZm9yKVxuICAgIHRoaXMudmlzaWJsZSA9IHZpc2libGVMaW5lcyhkaXNwbGF5LCBjbS5kb2MsIHZpZXdwb3J0KTtcbiAgICB0aGlzLmVkaXRvcklzSGlkZGVuID0gIWRpc3BsYXkud3JhcHBlci5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLndyYXBwZXJIZWlnaHQgPSBkaXNwbGF5LndyYXBwZXIuY2xpZW50SGVpZ2h0O1xuICAgIHRoaXMud3JhcHBlcldpZHRoID0gZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoO1xuICAgIHRoaXMub2xkRGlzcGxheVdpZHRoID0gZGlzcGxheVdpZHRoKGNtKTtcbiAgICB0aGlzLmZvcmNlID0gZm9yY2U7XG4gICAgdGhpcy5kaW1zID0gZ2V0RGltZW5zaW9ucyhjbSk7XG4gICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgfTtcblxuICBEaXNwbGF5VXBkYXRlLnByb3RvdHlwZS5zaWduYWwgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICAgIGlmIChoYXNIYW5kbGVyKGVtaXR0ZXIsIHR5cGUpKVxuICAgICAgeyB0aGlzLmV2ZW50cy5wdXNoKGFyZ3VtZW50cyk7IH1cbiAgfTtcbiAgRGlzcGxheVVwZGF0ZS5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ldmVudHMubGVuZ3RoOyBpKyspXG4gICAgICB7IHNpZ25hbC5hcHBseShudWxsLCB0aGlzLmV2ZW50c1tpXSk7IH1cbiAgfTtcblxuICBmdW5jdGlvbiBtYXliZUNsaXBTY3JvbGxiYXJzKGNtKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5O1xuICAgIGlmICghZGlzcGxheS5zY3JvbGxiYXJzQ2xpcHBlZCAmJiBkaXNwbGF5LnNjcm9sbGVyLm9mZnNldFdpZHRoKSB7XG4gICAgICBkaXNwbGF5Lm5hdGl2ZUJhcldpZHRoID0gZGlzcGxheS5zY3JvbGxlci5vZmZzZXRXaWR0aCAtIGRpc3BsYXkuc2Nyb2xsZXIuY2xpZW50V2lkdGg7XG4gICAgICBkaXNwbGF5LmhlaWdodEZvcmNlci5zdHlsZS5oZWlnaHQgPSBzY3JvbGxHYXAoY20pICsgXCJweFwiO1xuICAgICAgZGlzcGxheS5zaXplci5zdHlsZS5tYXJnaW5Cb3R0b20gPSAtZGlzcGxheS5uYXRpdmVCYXJXaWR0aCArIFwicHhcIjtcbiAgICAgIGRpc3BsYXkuc2l6ZXIuc3R5bGUuYm9yZGVyUmlnaHRXaWR0aCA9IHNjcm9sbEdhcChjbSkgKyBcInB4XCI7XG4gICAgICBkaXNwbGF5LnNjcm9sbGJhcnNDbGlwcGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZWxlY3Rpb25TbmFwc2hvdChjbSkge1xuICAgIGlmIChjbS5oYXNGb2N1cygpKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgYWN0aXZlID0gYWN0aXZlRWx0KCk7XG4gICAgaWYgKCFhY3RpdmUgfHwgIWNvbnRhaW5zKGNtLmRpc3BsYXkubGluZURpdiwgYWN0aXZlKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgdmFyIHJlc3VsdCA9IHthY3RpdmVFbHQ6IGFjdGl2ZX07XG4gICAgaWYgKHdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICBpZiAoc2VsLmFuY2hvck5vZGUgJiYgc2VsLmV4dGVuZCAmJiBjb250YWlucyhjbS5kaXNwbGF5LmxpbmVEaXYsIHNlbC5hbmNob3JOb2RlKSkge1xuICAgICAgICByZXN1bHQuYW5jaG9yTm9kZSA9IHNlbC5hbmNob3JOb2RlO1xuICAgICAgICByZXN1bHQuYW5jaG9yT2Zmc2V0ID0gc2VsLmFuY2hvck9mZnNldDtcbiAgICAgICAgcmVzdWx0LmZvY3VzTm9kZSA9IHNlbC5mb2N1c05vZGU7XG4gICAgICAgIHJlc3VsdC5mb2N1c09mZnNldCA9IHNlbC5mb2N1c09mZnNldDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgZnVuY3Rpb24gcmVzdG9yZVNlbGVjdGlvbihzbmFwc2hvdCkge1xuICAgIGlmICghc25hcHNob3QgfHwgIXNuYXBzaG90LmFjdGl2ZUVsdCB8fCBzbmFwc2hvdC5hY3RpdmVFbHQgPT0gYWN0aXZlRWx0KCkpIHsgcmV0dXJuIH1cbiAgICBzbmFwc2hvdC5hY3RpdmVFbHQuZm9jdXMoKTtcbiAgICBpZiAoIS9eKElOUFVUfFRFWFRBUkVBKSQvLnRlc3Qoc25hcHNob3QuYWN0aXZlRWx0Lm5vZGVOYW1lKSAmJlxuICAgICAgICBzbmFwc2hvdC5hbmNob3JOb2RlICYmIGNvbnRhaW5zKGRvY3VtZW50LmJvZHksIHNuYXBzaG90LmFuY2hvck5vZGUpICYmIGNvbnRhaW5zKGRvY3VtZW50LmJvZHksIHNuYXBzaG90LmZvY3VzTm9kZSkpIHtcbiAgICAgIHZhciBzZWwgPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCksIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgIHJhbmdlLnNldEVuZChzbmFwc2hvdC5hbmNob3JOb2RlLCBzbmFwc2hvdC5hbmNob3JPZmZzZXQpO1xuICAgICAgcmFuZ2UuY29sbGFwc2UoZmFsc2UpO1xuICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgc2VsLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbC5leHRlbmQoc25hcHNob3QuZm9jdXNOb2RlLCBzbmFwc2hvdC5mb2N1c09mZnNldCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRG9lcyB0aGUgYWN0dWFsIHVwZGF0aW5nIG9mIHRoZSBsaW5lIGRpc3BsYXkuIEJhaWxzIG91dFxuICAvLyAocmV0dXJuaW5nIGZhbHNlKSB3aGVuIHRoZXJlIGlzIG5vdGhpbmcgdG8gYmUgZG9uZSBhbmQgZm9yY2VkIGlzXG4gIC8vIGZhbHNlLlxuICBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuXG4gICAgaWYgKHVwZGF0ZS5lZGl0b3JJc0hpZGRlbikge1xuICAgICAgcmVzZXRWaWV3KGNtKTtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8vIEJhaWwgb3V0IGlmIHRoZSB2aXNpYmxlIGFyZWEgaXMgYWxyZWFkeSByZW5kZXJlZCBhbmQgbm90aGluZyBjaGFuZ2VkLlxuICAgIGlmICghdXBkYXRlLmZvcmNlICYmXG4gICAgICAgIHVwZGF0ZS52aXNpYmxlLmZyb20gPj0gZGlzcGxheS52aWV3RnJvbSAmJiB1cGRhdGUudmlzaWJsZS50byA8PSBkaXNwbGF5LnZpZXdUbyAmJlxuICAgICAgICAoZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9PSBudWxsIHx8IGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPj0gZGlzcGxheS52aWV3VG8pICYmXG4gICAgICAgIGRpc3BsYXkucmVuZGVyZWRWaWV3ID09IGRpc3BsYXkudmlldyAmJiBjb3VudERpcnR5VmlldyhjbSkgPT0gMClcbiAgICAgIHsgcmV0dXJuIGZhbHNlIH1cblxuICAgIGlmIChtYXliZVVwZGF0ZUxpbmVOdW1iZXJXaWR0aChjbSkpIHtcbiAgICAgIHJlc2V0VmlldyhjbSk7XG4gICAgICB1cGRhdGUuZGltcyA9IGdldERpbWVuc2lvbnMoY20pO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgYSBzdWl0YWJsZSBuZXcgdmlld3BvcnQgKGZyb20gJiB0bylcbiAgICB2YXIgZW5kID0gZG9jLmZpcnN0ICsgZG9jLnNpemU7XG4gICAgdmFyIGZyb20gPSBNYXRoLm1heCh1cGRhdGUudmlzaWJsZS5mcm9tIC0gY20ub3B0aW9ucy52aWV3cG9ydE1hcmdpbiwgZG9jLmZpcnN0KTtcbiAgICB2YXIgdG8gPSBNYXRoLm1pbihlbmQsIHVwZGF0ZS52aXNpYmxlLnRvICsgY20ub3B0aW9ucy52aWV3cG9ydE1hcmdpbik7XG4gICAgaWYgKGRpc3BsYXkudmlld0Zyb20gPCBmcm9tICYmIGZyb20gLSBkaXNwbGF5LnZpZXdGcm9tIDwgMjApIHsgZnJvbSA9IE1hdGgubWF4KGRvYy5maXJzdCwgZGlzcGxheS52aWV3RnJvbSk7IH1cbiAgICBpZiAoZGlzcGxheS52aWV3VG8gPiB0byAmJiBkaXNwbGF5LnZpZXdUbyAtIHRvIDwgMjApIHsgdG8gPSBNYXRoLm1pbihlbmQsIGRpc3BsYXkudmlld1RvKTsgfVxuICAgIGlmIChzYXdDb2xsYXBzZWRTcGFucykge1xuICAgICAgZnJvbSA9IHZpc3VhbExpbmVObyhjbS5kb2MsIGZyb20pO1xuICAgICAgdG8gPSB2aXN1YWxMaW5lRW5kTm8oY20uZG9jLCB0byk7XG4gICAgfVxuXG4gICAgdmFyIGRpZmZlcmVudCA9IGZyb20gIT0gZGlzcGxheS52aWV3RnJvbSB8fCB0byAhPSBkaXNwbGF5LnZpZXdUbyB8fFxuICAgICAgZGlzcGxheS5sYXN0V3JhcEhlaWdodCAhPSB1cGRhdGUud3JhcHBlckhlaWdodCB8fCBkaXNwbGF5Lmxhc3RXcmFwV2lkdGggIT0gdXBkYXRlLndyYXBwZXJXaWR0aDtcbiAgICBhZGp1c3RWaWV3KGNtLCBmcm9tLCB0byk7XG5cbiAgICBkaXNwbGF5LnZpZXdPZmZzZXQgPSBoZWlnaHRBdExpbmUoZ2V0TGluZShjbS5kb2MsIGRpc3BsYXkudmlld0Zyb20pKTtcbiAgICAvLyBQb3NpdGlvbiB0aGUgbW92ZXIgZGl2IHRvIGFsaWduIHdpdGggdGhlIGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uXG4gICAgY20uZGlzcGxheS5tb3Zlci5zdHlsZS50b3AgPSBkaXNwbGF5LnZpZXdPZmZzZXQgKyBcInB4XCI7XG5cbiAgICB2YXIgdG9VcGRhdGUgPSBjb3VudERpcnR5VmlldyhjbSk7XG4gICAgaWYgKCFkaWZmZXJlbnQgJiYgdG9VcGRhdGUgPT0gMCAmJiAhdXBkYXRlLmZvcmNlICYmIGRpc3BsYXkucmVuZGVyZWRWaWV3ID09IGRpc3BsYXkudmlldyAmJlxuICAgICAgICAoZGlzcGxheS51cGRhdGVMaW5lTnVtYmVycyA9PSBudWxsIHx8IGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMgPj0gZGlzcGxheS52aWV3VG8pKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgLy8gRm9yIGJpZyBjaGFuZ2VzLCB3ZSBoaWRlIHRoZSBlbmNsb3NpbmcgZWxlbWVudCBkdXJpbmcgdGhlXG4gICAgLy8gdXBkYXRlLCBzaW5jZSB0aGF0IHNwZWVkcyB1cCB0aGUgb3BlcmF0aW9ucyBvbiBtb3N0IGJyb3dzZXJzLlxuICAgIHZhciBzZWxTbmFwc2hvdCA9IHNlbGVjdGlvblNuYXBzaG90KGNtKTtcbiAgICBpZiAodG9VcGRhdGUgPiA0KSB7IGRpc3BsYXkubGluZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7IH1cbiAgICBwYXRjaERpc3BsYXkoY20sIGRpc3BsYXkudXBkYXRlTGluZU51bWJlcnMsIHVwZGF0ZS5kaW1zKTtcbiAgICBpZiAodG9VcGRhdGUgPiA0KSB7IGRpc3BsYXkubGluZURpdi5zdHlsZS5kaXNwbGF5ID0gXCJcIjsgfVxuICAgIGRpc3BsYXkucmVuZGVyZWRWaWV3ID0gZGlzcGxheS52aWV3O1xuICAgIC8vIFRoZXJlIG1pZ2h0IGhhdmUgYmVlbiBhIHdpZGdldCB3aXRoIGEgZm9jdXNlZCBlbGVtZW50IHRoYXQgZ290XG4gICAgLy8gaGlkZGVuIG9yIHVwZGF0ZWQsIGlmIHNvIHJlLWZvY3VzIGl0LlxuICAgIHJlc3RvcmVTZWxlY3Rpb24oc2VsU25hcHNob3QpO1xuXG4gICAgLy8gUHJldmVudCBzZWxlY3Rpb24gYW5kIGN1cnNvcnMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIHRoZSBzY3JvbGxcbiAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgIHJlbW92ZUNoaWxkcmVuKGRpc3BsYXkuY3Vyc29yRGl2KTtcbiAgICByZW1vdmVDaGlsZHJlbihkaXNwbGF5LnNlbGVjdGlvbkRpdik7XG4gICAgZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmhlaWdodCA9IGRpc3BsYXkuc2l6ZXIuc3R5bGUubWluSGVpZ2h0ID0gMDtcblxuICAgIGlmIChkaWZmZXJlbnQpIHtcbiAgICAgIGRpc3BsYXkubGFzdFdyYXBIZWlnaHQgPSB1cGRhdGUud3JhcHBlckhlaWdodDtcbiAgICAgIGRpc3BsYXkubGFzdFdyYXBXaWR0aCA9IHVwZGF0ZS53cmFwcGVyV2lkdGg7XG4gICAgICBzdGFydFdvcmtlcihjbSwgNDAwKTtcbiAgICB9XG5cbiAgICBkaXNwbGF5LnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbDtcblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBmdW5jdGlvbiBwb3N0VXBkYXRlRGlzcGxheShjbSwgdXBkYXRlKSB7XG4gICAgdmFyIHZpZXdwb3J0ID0gdXBkYXRlLnZpZXdwb3J0O1xuXG4gICAgZm9yICh2YXIgZmlyc3QgPSB0cnVlOzsgZmlyc3QgPSBmYWxzZSkge1xuICAgICAgaWYgKCFmaXJzdCB8fCAhY20ub3B0aW9ucy5saW5lV3JhcHBpbmcgfHwgdXBkYXRlLm9sZERpc3BsYXlXaWR0aCA9PSBkaXNwbGF5V2lkdGgoY20pKSB7XG4gICAgICAgIC8vIENsaXAgZm9yY2VkIHZpZXdwb3J0IHRvIGFjdHVhbCBzY3JvbGxhYmxlIGFyZWEuXG4gICAgICAgIGlmICh2aWV3cG9ydCAmJiB2aWV3cG9ydC50b3AgIT0gbnVsbClcbiAgICAgICAgICB7IHZpZXdwb3J0ID0ge3RvcDogTWF0aC5taW4oY20uZG9jLmhlaWdodCArIHBhZGRpbmdWZXJ0KGNtLmRpc3BsYXkpIC0gZGlzcGxheUhlaWdodChjbSksIHZpZXdwb3J0LnRvcCl9OyB9XG4gICAgICAgIC8vIFVwZGF0ZWQgbGluZSBoZWlnaHRzIG1pZ2h0IHJlc3VsdCBpbiB0aGUgZHJhd24gYXJlYSBub3RcbiAgICAgICAgLy8gYWN0dWFsbHkgY292ZXJpbmcgdGhlIHZpZXdwb3J0LiBLZWVwIGxvb3BpbmcgdW50aWwgaXQgZG9lcy5cbiAgICAgICAgdXBkYXRlLnZpc2libGUgPSB2aXNpYmxlTGluZXMoY20uZGlzcGxheSwgY20uZG9jLCB2aWV3cG9ydCk7XG4gICAgICAgIGlmICh1cGRhdGUudmlzaWJsZS5mcm9tID49IGNtLmRpc3BsYXkudmlld0Zyb20gJiYgdXBkYXRlLnZpc2libGUudG8gPD0gY20uZGlzcGxheS52aWV3VG8pXG4gICAgICAgICAgeyBicmVhayB9XG4gICAgICB9IGVsc2UgaWYgKGZpcnN0KSB7XG4gICAgICAgIHVwZGF0ZS52aXNpYmxlID0gdmlzaWJsZUxpbmVzKGNtLmRpc3BsYXksIGNtLmRvYywgdmlld3BvcnQpO1xuICAgICAgfVxuICAgICAgaWYgKCF1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkpIHsgYnJlYWsgfVxuICAgICAgdXBkYXRlSGVpZ2h0c0luVmlld3BvcnQoY20pO1xuICAgICAgdmFyIGJhck1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XG4gICAgICB1cGRhdGVTZWxlY3Rpb24oY20pO1xuICAgICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgYmFyTWVhc3VyZSk7XG4gICAgICBzZXREb2N1bWVudEhlaWdodChjbSwgYmFyTWVhc3VyZSk7XG4gICAgICB1cGRhdGUuZm9yY2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB1cGRhdGUuc2lnbmFsKGNtLCBcInVwZGF0ZVwiLCBjbSk7XG4gICAgaWYgKGNtLmRpc3BsYXkudmlld0Zyb20gIT0gY20uZGlzcGxheS5yZXBvcnRlZFZpZXdGcm9tIHx8IGNtLmRpc3BsYXkudmlld1RvICE9IGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3VG8pIHtcbiAgICAgIHVwZGF0ZS5zaWduYWwoY20sIFwidmlld3BvcnRDaGFuZ2VcIiwgY20sIGNtLmRpc3BsYXkudmlld0Zyb20sIGNtLmRpc3BsYXkudmlld1RvKTtcbiAgICAgIGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3RnJvbSA9IGNtLmRpc3BsYXkudmlld0Zyb207IGNtLmRpc3BsYXkucmVwb3J0ZWRWaWV3VG8gPSBjbS5kaXNwbGF5LnZpZXdUbztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVEaXNwbGF5U2ltcGxlKGNtLCB2aWV3cG9ydCkge1xuICAgIHZhciB1cGRhdGUgPSBuZXcgRGlzcGxheVVwZGF0ZShjbSwgdmlld3BvcnQpO1xuICAgIGlmICh1cGRhdGVEaXNwbGF5SWZOZWVkZWQoY20sIHVwZGF0ZSkpIHtcbiAgICAgIHVwZGF0ZUhlaWdodHNJblZpZXdwb3J0KGNtKTtcbiAgICAgIHBvc3RVcGRhdGVEaXNwbGF5KGNtLCB1cGRhdGUpO1xuICAgICAgdmFyIGJhck1lYXN1cmUgPSBtZWFzdXJlRm9yU2Nyb2xsYmFycyhjbSk7XG4gICAgICB1cGRhdGVTZWxlY3Rpb24oY20pO1xuICAgICAgdXBkYXRlU2Nyb2xsYmFycyhjbSwgYmFyTWVhc3VyZSk7XG4gICAgICBzZXREb2N1bWVudEhlaWdodChjbSwgYmFyTWVhc3VyZSk7XG4gICAgICB1cGRhdGUuZmluaXNoKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gU3luYyB0aGUgYWN0dWFsIGRpc3BsYXkgRE9NIHN0cnVjdHVyZSB3aXRoIGRpc3BsYXkudmlldywgcmVtb3ZpbmdcbiAgLy8gbm9kZXMgZm9yIGxpbmVzIHRoYXQgYXJlIG5vIGxvbmdlciBpbiB2aWV3LCBhbmQgY3JlYXRpbmcgdGhlIG9uZXNcbiAgLy8gdGhhdCBhcmUgbm90IHRoZXJlIHlldCwgYW5kIHVwZGF0aW5nIHRoZSBvbmVzIHRoYXQgYXJlIG91dCBvZlxuICAvLyBkYXRlLlxuICBmdW5jdGlvbiBwYXRjaERpc3BsYXkoY20sIHVwZGF0ZU51bWJlcnNGcm9tLCBkaW1zKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCBsaW5lTnVtYmVycyA9IGNtLm9wdGlvbnMubGluZU51bWJlcnM7XG4gICAgdmFyIGNvbnRhaW5lciA9IGRpc3BsYXkubGluZURpdiwgY3VyID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG5cbiAgICBmdW5jdGlvbiBybShub2RlKSB7XG4gICAgICB2YXIgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAvLyBXb3JrcyBhcm91bmQgYSB0aHJvdy1zY3JvbGwgYnVnIGluIE9TIFggV2Via2l0XG4gICAgICBpZiAod2Via2l0ICYmIG1hYyAmJiBjbS5kaXNwbGF5LmN1cnJlbnRXaGVlbFRhcmdldCA9PSBub2RlKVxuICAgICAgICB7IG5vZGUuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpOyB9XG4gICAgICByZXR1cm4gbmV4dFxuICAgIH1cblxuICAgIHZhciB2aWV3ID0gZGlzcGxheS52aWV3LCBsaW5lTiA9IGRpc3BsYXkudmlld0Zyb207XG4gICAgLy8gTG9vcCBvdmVyIHRoZSBlbGVtZW50cyBpbiB0aGUgdmlldywgc3luY2luZyBjdXIgKHRoZSBET00gbm9kZXNcbiAgICAvLyBpbiBkaXNwbGF5LmxpbmVEaXYpIHdpdGggdGhlIHZpZXcgYXMgd2UgZ28uXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZVZpZXcgPSB2aWV3W2ldO1xuICAgICAgaWYgKGxpbmVWaWV3LmhpZGRlbikgOyBlbHNlIGlmICghbGluZVZpZXcubm9kZSB8fCBsaW5lVmlldy5ub2RlLnBhcmVudE5vZGUgIT0gY29udGFpbmVyKSB7IC8vIE5vdCBkcmF3biB5ZXRcbiAgICAgICAgdmFyIG5vZGUgPSBidWlsZExpbmVFbGVtZW50KGNtLCBsaW5lVmlldywgbGluZU4sIGRpbXMpO1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKG5vZGUsIGN1cik7XG4gICAgICB9IGVsc2UgeyAvLyBBbHJlYWR5IGRyYXduXG4gICAgICAgIHdoaWxlIChjdXIgIT0gbGluZVZpZXcubm9kZSkgeyBjdXIgPSBybShjdXIpOyB9XG4gICAgICAgIHZhciB1cGRhdGVOdW1iZXIgPSBsaW5lTnVtYmVycyAmJiB1cGRhdGVOdW1iZXJzRnJvbSAhPSBudWxsICYmXG4gICAgICAgICAgdXBkYXRlTnVtYmVyc0Zyb20gPD0gbGluZU4gJiYgbGluZVZpZXcubGluZU51bWJlcjtcbiAgICAgICAgaWYgKGxpbmVWaWV3LmNoYW5nZXMpIHtcbiAgICAgICAgICBpZiAoaW5kZXhPZihsaW5lVmlldy5jaGFuZ2VzLCBcImd1dHRlclwiKSA+IC0xKSB7IHVwZGF0ZU51bWJlciA9IGZhbHNlOyB9XG4gICAgICAgICAgdXBkYXRlTGluZUZvckNoYW5nZXMoY20sIGxpbmVWaWV3LCBsaW5lTiwgZGltcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVwZGF0ZU51bWJlcikge1xuICAgICAgICAgIHJlbW92ZUNoaWxkcmVuKGxpbmVWaWV3LmxpbmVOdW1iZXIpO1xuICAgICAgICAgIGxpbmVWaWV3LmxpbmVOdW1iZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobGluZU51bWJlckZvcihjbS5vcHRpb25zLCBsaW5lTikpKTtcbiAgICAgICAgfVxuICAgICAgICBjdXIgPSBsaW5lVmlldy5ub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgbGluZU4gKz0gbGluZVZpZXcuc2l6ZTtcbiAgICB9XG4gICAgd2hpbGUgKGN1cikgeyBjdXIgPSBybShjdXIpOyB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVHdXR0ZXJTcGFjZShkaXNwbGF5KSB7XG4gICAgdmFyIHdpZHRoID0gZGlzcGxheS5ndXR0ZXJzLm9mZnNldFdpZHRoO1xuICAgIGRpc3BsYXkuc2l6ZXIuc3R5bGUubWFyZ2luTGVmdCA9IHdpZHRoICsgXCJweFwiO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0RG9jdW1lbnRIZWlnaHQoY20sIG1lYXN1cmUpIHtcbiAgICBjbS5kaXNwbGF5LnNpemVyLnN0eWxlLm1pbkhlaWdodCA9IG1lYXN1cmUuZG9jSGVpZ2h0ICsgXCJweFwiO1xuICAgIGNtLmRpc3BsYXkuaGVpZ2h0Rm9yY2VyLnN0eWxlLnRvcCA9IG1lYXN1cmUuZG9jSGVpZ2h0ICsgXCJweFwiO1xuICAgIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5oZWlnaHQgPSAobWVhc3VyZS5kb2NIZWlnaHQgKyBjbS5kaXNwbGF5LmJhckhlaWdodCArIHNjcm9sbEdhcChjbSkpICsgXCJweFwiO1xuICB9XG5cbiAgLy8gUmUtYWxpZ24gbGluZSBudW1iZXJzIGFuZCBndXR0ZXIgbWFya3MgdG8gY29tcGVuc2F0ZSBmb3JcbiAgLy8gaG9yaXpvbnRhbCBzY3JvbGxpbmcuXG4gIGZ1bmN0aW9uIGFsaWduSG9yaXpvbnRhbGx5KGNtKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBjbS5kaXNwbGF5LCB2aWV3ID0gZGlzcGxheS52aWV3O1xuICAgIGlmICghZGlzcGxheS5hbGlnbldpZGdldHMgJiYgKCFkaXNwbGF5Lmd1dHRlcnMuZmlyc3RDaGlsZCB8fCAhY20ub3B0aW9ucy5maXhlZEd1dHRlcikpIHsgcmV0dXJuIH1cbiAgICB2YXIgY29tcCA9IGNvbXBlbnNhdGVGb3JIU2Nyb2xsKGRpc3BsYXkpIC0gZGlzcGxheS5zY3JvbGxlci5zY3JvbGxMZWZ0ICsgY20uZG9jLnNjcm9sbExlZnQ7XG4gICAgdmFyIGd1dHRlclcgPSBkaXNwbGF5Lmd1dHRlcnMub2Zmc2V0V2lkdGgsIGxlZnQgPSBjb21wICsgXCJweFwiO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmlldy5sZW5ndGg7IGkrKykgeyBpZiAoIXZpZXdbaV0uaGlkZGVuKSB7XG4gICAgICBpZiAoY20ub3B0aW9ucy5maXhlZEd1dHRlcikge1xuICAgICAgICBpZiAodmlld1tpXS5ndXR0ZXIpXG4gICAgICAgICAgeyB2aWV3W2ldLmd1dHRlci5zdHlsZS5sZWZ0ID0gbGVmdDsgfVxuICAgICAgICBpZiAodmlld1tpXS5ndXR0ZXJCYWNrZ3JvdW5kKVxuICAgICAgICAgIHsgdmlld1tpXS5ndXR0ZXJCYWNrZ3JvdW5kLnN0eWxlLmxlZnQgPSBsZWZ0OyB9XG4gICAgICB9XG4gICAgICB2YXIgYWxpZ24gPSB2aWV3W2ldLmFsaWduYWJsZTtcbiAgICAgIGlmIChhbGlnbikgeyBmb3IgKHZhciBqID0gMDsgaiA8IGFsaWduLmxlbmd0aDsgaisrKVxuICAgICAgICB7IGFsaWduW2pdLnN0eWxlLmxlZnQgPSBsZWZ0OyB9IH1cbiAgICB9IH1cbiAgICBpZiAoY20ub3B0aW9ucy5maXhlZEd1dHRlcilcbiAgICAgIHsgZGlzcGxheS5ndXR0ZXJzLnN0eWxlLmxlZnQgPSAoY29tcCArIGd1dHRlclcpICsgXCJweFwiOyB9XG4gIH1cblxuICAvLyBVc2VkIHRvIGVuc3VyZSB0aGF0IHRoZSBsaW5lIG51bWJlciBndXR0ZXIgaXMgc3RpbGwgdGhlIHJpZ2h0XG4gIC8vIHNpemUgZm9yIHRoZSBjdXJyZW50IGRvY3VtZW50IHNpemUuIFJldHVybnMgdHJ1ZSB3aGVuIGFuIHVwZGF0ZVxuICAvLyBpcyBuZWVkZWQuXG4gIGZ1bmN0aW9uIG1heWJlVXBkYXRlTGluZU51bWJlcldpZHRoKGNtKSB7XG4gICAgaWYgKCFjbS5vcHRpb25zLmxpbmVOdW1iZXJzKSB7IHJldHVybiBmYWxzZSB9XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgbGFzdCA9IGxpbmVOdW1iZXJGb3IoY20ub3B0aW9ucywgZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxKSwgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgaWYgKGxhc3QubGVuZ3RoICE9IGRpc3BsYXkubGluZU51bUNoYXJzKSB7XG4gICAgICB2YXIgdGVzdCA9IGRpc3BsYXkubWVhc3VyZS5hcHBlbmRDaGlsZChlbHQoXCJkaXZcIiwgW2VsdChcImRpdlwiLCBsYXN0KV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJDb2RlTWlycm9yLWxpbmVudW1iZXIgQ29kZU1pcnJvci1ndXR0ZXItZWx0XCIpKTtcbiAgICAgIHZhciBpbm5lclcgPSB0ZXN0LmZpcnN0Q2hpbGQub2Zmc2V0V2lkdGgsIHBhZGRpbmcgPSB0ZXN0Lm9mZnNldFdpZHRoIC0gaW5uZXJXO1xuICAgICAgZGlzcGxheS5saW5lR3V0dGVyLnN0eWxlLndpZHRoID0gXCJcIjtcbiAgICAgIGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggPSBNYXRoLm1heChpbm5lclcsIGRpc3BsYXkubGluZUd1dHRlci5vZmZzZXRXaWR0aCAtIHBhZGRpbmcpICsgMTtcbiAgICAgIGRpc3BsYXkubGluZU51bVdpZHRoID0gZGlzcGxheS5saW5lTnVtSW5uZXJXaWR0aCArIHBhZGRpbmc7XG4gICAgICBkaXNwbGF5LmxpbmVOdW1DaGFycyA9IGRpc3BsYXkubGluZU51bUlubmVyV2lkdGggPyBsYXN0Lmxlbmd0aCA6IC0xO1xuICAgICAgZGlzcGxheS5saW5lR3V0dGVyLnN0eWxlLndpZHRoID0gZGlzcGxheS5saW5lTnVtV2lkdGggKyBcInB4XCI7XG4gICAgICB1cGRhdGVHdXR0ZXJTcGFjZShjbS5kaXNwbGF5KTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZnVuY3Rpb24gZ2V0R3V0dGVycyhndXR0ZXJzLCBsaW5lTnVtYmVycykge1xuICAgIHZhciByZXN1bHQgPSBbXSwgc2F3TGluZU51bWJlcnMgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGd1dHRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gZ3V0dGVyc1tpXSwgc3R5bGUgPSBudWxsO1xuICAgICAgaWYgKHR5cGVvZiBuYW1lICE9IFwic3RyaW5nXCIpIHsgc3R5bGUgPSBuYW1lLnN0eWxlOyBuYW1lID0gbmFtZS5jbGFzc05hbWU7IH1cbiAgICAgIGlmIChuYW1lID09IFwiQ29kZU1pcnJvci1saW5lbnVtYmVyc1wiKSB7XG4gICAgICAgIGlmICghbGluZU51bWJlcnMpIHsgY29udGludWUgfVxuICAgICAgICBlbHNlIHsgc2F3TGluZU51bWJlcnMgPSB0cnVlOyB9XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh7Y2xhc3NOYW1lOiBuYW1lLCBzdHlsZTogc3R5bGV9KTtcbiAgICB9XG4gICAgaWYgKGxpbmVOdW1iZXJzICYmICFzYXdMaW5lTnVtYmVycykgeyByZXN1bHQucHVzaCh7Y2xhc3NOYW1lOiBcIkNvZGVNaXJyb3ItbGluZW51bWJlcnNcIiwgc3R5bGU6IG51bGx9KTsgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vIFJlYnVpbGQgdGhlIGd1dHRlciBlbGVtZW50cywgZW5zdXJlIHRoZSBtYXJnaW4gdG8gdGhlIGxlZnQgb2YgdGhlXG4gIC8vIGNvZGUgbWF0Y2hlcyB0aGVpciB3aWR0aC5cbiAgZnVuY3Rpb24gcmVuZGVyR3V0dGVycyhkaXNwbGF5KSB7XG4gICAgdmFyIGd1dHRlcnMgPSBkaXNwbGF5Lmd1dHRlcnMsIHNwZWNzID0gZGlzcGxheS5ndXR0ZXJTcGVjcztcbiAgICByZW1vdmVDaGlsZHJlbihndXR0ZXJzKTtcbiAgICBkaXNwbGF5LmxpbmVHdXR0ZXIgPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BlY3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciByZWYgPSBzcGVjc1tpXTtcbiAgICAgIHZhciBjbGFzc05hbWUgPSByZWYuY2xhc3NOYW1lO1xuICAgICAgdmFyIHN0eWxlID0gcmVmLnN0eWxlO1xuICAgICAgdmFyIGdFbHQgPSBndXR0ZXJzLmFwcGVuZENoaWxkKGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItZ3V0dGVyIFwiICsgY2xhc3NOYW1lKSk7XG4gICAgICBpZiAoc3R5bGUpIHsgZ0VsdC5zdHlsZS5jc3NUZXh0ID0gc3R5bGU7IH1cbiAgICAgIGlmIChjbGFzc05hbWUgPT0gXCJDb2RlTWlycm9yLWxpbmVudW1iZXJzXCIpIHtcbiAgICAgICAgZGlzcGxheS5saW5lR3V0dGVyID0gZ0VsdDtcbiAgICAgICAgZ0VsdC5zdHlsZS53aWR0aCA9IChkaXNwbGF5LmxpbmVOdW1XaWR0aCB8fCAxKSArIFwicHhcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgZ3V0dGVycy5zdHlsZS5kaXNwbGF5ID0gc3BlY3MubGVuZ3RoID8gXCJcIiA6IFwibm9uZVwiO1xuICAgIHVwZGF0ZUd1dHRlclNwYWNlKGRpc3BsYXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlR3V0dGVycyhjbSkge1xuICAgIHJlbmRlckd1dHRlcnMoY20uZGlzcGxheSk7XG4gICAgcmVnQ2hhbmdlKGNtKTtcbiAgICBhbGlnbkhvcml6b250YWxseShjbSk7XG4gIH1cblxuICAvLyBUaGUgZGlzcGxheSBoYW5kbGVzIHRoZSBET00gaW50ZWdyYXRpb24sIGJvdGggZm9yIGlucHV0IHJlYWRpbmdcbiAgLy8gYW5kIGNvbnRlbnQgZHJhd2luZy4gSXQgaG9sZHMgcmVmZXJlbmNlcyB0byBET00gbm9kZXMgYW5kXG4gIC8vIGRpc3BsYXktcmVsYXRlZCBzdGF0ZS5cblxuICBmdW5jdGlvbiBEaXNwbGF5KHBsYWNlLCBkb2MsIGlucHV0LCBvcHRpb25zKSB7XG4gICAgdmFyIGQgPSB0aGlzO1xuICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcblxuICAgIC8vIENvdmVycyBib3R0b20tcmlnaHQgc3F1YXJlIHdoZW4gYm90aCBzY3JvbGxiYXJzIGFyZSBwcmVzZW50LlxuICAgIGQuc2Nyb2xsYmFyRmlsbGVyID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1zY3JvbGxiYXItZmlsbGVyXCIpO1xuICAgIGQuc2Nyb2xsYmFyRmlsbGVyLnNldEF0dHJpYnV0ZShcImNtLW5vdC1jb250ZW50XCIsIFwidHJ1ZVwiKTtcbiAgICAvLyBDb3ZlcnMgYm90dG9tIG9mIGd1dHRlciB3aGVuIGNvdmVyR3V0dGVyTmV4dFRvU2Nyb2xsYmFyIGlzIG9uXG4gICAgLy8gYW5kIGggc2Nyb2xsYmFyIGlzIHByZXNlbnQuXG4gICAgZC5ndXR0ZXJGaWxsZXIgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWd1dHRlci1maWxsZXJcIik7XG4gICAgZC5ndXR0ZXJGaWxsZXIuc2V0QXR0cmlidXRlKFwiY20tbm90LWNvbnRlbnRcIiwgXCJ0cnVlXCIpO1xuICAgIC8vIFdpbGwgY29udGFpbiB0aGUgYWN0dWFsIGNvZGUsIHBvc2l0aW9uZWQgdG8gY292ZXIgdGhlIHZpZXdwb3J0LlxuICAgIGQubGluZURpdiA9IGVsdFAoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWNvZGVcIik7XG4gICAgLy8gRWxlbWVudHMgYXJlIGFkZGVkIHRvIHRoZXNlIHRvIHJlcHJlc2VudCBzZWxlY3Rpb24gYW5kIGN1cnNvcnMuXG4gICAgZC5zZWxlY3Rpb25EaXYgPSBlbHQoXCJkaXZcIiwgbnVsbCwgbnVsbCwgXCJwb3NpdGlvbjogcmVsYXRpdmU7IHotaW5kZXg6IDFcIik7XG4gICAgZC5jdXJzb3JEaXYgPSBlbHQoXCJkaXZcIiwgbnVsbCwgXCJDb2RlTWlycm9yLWN1cnNvcnNcIik7XG4gICAgLy8gQSB2aXNpYmlsaXR5OiBoaWRkZW4gZWxlbWVudCB1c2VkIHRvIGZpbmQgdGhlIHNpemUgb2YgdGhpbmdzLlxuICAgIGQubWVhc3VyZSA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItbWVhc3VyZVwiKTtcbiAgICAvLyBXaGVuIGxpbmVzIG91dHNpZGUgb2YgdGhlIHZpZXdwb3J0IGFyZSBtZWFzdXJlZCwgdGhleSBhcmUgZHJhd24gaW4gdGhpcy5cbiAgICBkLmxpbmVNZWFzdXJlID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1tZWFzdXJlXCIpO1xuICAgIC8vIFdyYXBzIGV2ZXJ5dGhpbmcgdGhhdCBuZWVkcyB0byBleGlzdCBpbnNpZGUgdGhlIHZlcnRpY2FsbHktcGFkZGVkIGNvb3JkaW5hdGUgc3lzdGVtXG4gICAgZC5saW5lU3BhY2UgPSBlbHRQKFwiZGl2XCIsIFtkLm1lYXN1cmUsIGQubGluZU1lYXN1cmUsIGQuc2VsZWN0aW9uRGl2LCBkLmN1cnNvckRpdiwgZC5saW5lRGl2XSxcbiAgICAgICAgICAgICAgICAgICAgICBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZTsgb3V0bGluZTogbm9uZVwiKTtcbiAgICB2YXIgbGluZXMgPSBlbHRQKFwiZGl2XCIsIFtkLmxpbmVTcGFjZV0sIFwiQ29kZU1pcnJvci1saW5lc1wiKTtcbiAgICAvLyBNb3ZlZCBhcm91bmQgaXRzIHBhcmVudCB0byBjb3ZlciB2aXNpYmxlIHZpZXcuXG4gICAgZC5tb3ZlciA9IGVsdChcImRpdlwiLCBbbGluZXNdLCBudWxsLCBcInBvc2l0aW9uOiByZWxhdGl2ZVwiKTtcbiAgICAvLyBTZXQgdG8gdGhlIGhlaWdodCBvZiB0aGUgZG9jdW1lbnQsIGFsbG93aW5nIHNjcm9sbGluZy5cbiAgICBkLnNpemVyID0gZWx0KFwiZGl2XCIsIFtkLm1vdmVyXSwgXCJDb2RlTWlycm9yLXNpemVyXCIpO1xuICAgIGQuc2l6ZXJXaWR0aCA9IG51bGw7XG4gICAgLy8gQmVoYXZpb3Igb2YgZWx0cyB3aXRoIG92ZXJmbG93OiBhdXRvIGFuZCBwYWRkaW5nIGlzXG4gICAgLy8gaW5jb25zaXN0ZW50IGFjcm9zcyBicm93c2Vycy4gVGhpcyBpcyB1c2VkIHRvIGVuc3VyZSB0aGVcbiAgICAvLyBzY3JvbGxhYmxlIGFyZWEgaXMgYmlnIGVub3VnaC5cbiAgICBkLmhlaWdodEZvcmNlciA9IGVsdChcImRpdlwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgaGVpZ2h0OiBcIiArIHNjcm9sbGVyR2FwICsgXCJweDsgd2lkdGg6IDFweDtcIik7XG4gICAgLy8gV2lsbCBjb250YWluIHRoZSBndXR0ZXJzLCBpZiBhbnkuXG4gICAgZC5ndXR0ZXJzID0gZWx0KFwiZGl2XCIsIG51bGwsIFwiQ29kZU1pcnJvci1ndXR0ZXJzXCIpO1xuICAgIGQubGluZUd1dHRlciA9IG51bGw7XG4gICAgLy8gQWN0dWFsIHNjcm9sbGFibGUgZWxlbWVudC5cbiAgICBkLnNjcm9sbGVyID0gZWx0KFwiZGl2XCIsIFtkLnNpemVyLCBkLmhlaWdodEZvcmNlciwgZC5ndXR0ZXJzXSwgXCJDb2RlTWlycm9yLXNjcm9sbFwiKTtcbiAgICBkLnNjcm9sbGVyLnNldEF0dHJpYnV0ZShcInRhYkluZGV4XCIsIFwiLTFcIik7XG4gICAgLy8gVGhlIGVsZW1lbnQgaW4gd2hpY2ggdGhlIGVkaXRvciBsaXZlcy5cbiAgICBkLndyYXBwZXIgPSBlbHQoXCJkaXZcIiwgW2Quc2Nyb2xsYmFyRmlsbGVyLCBkLmd1dHRlckZpbGxlciwgZC5zY3JvbGxlcl0sIFwiQ29kZU1pcnJvclwiKTtcblxuICAgIC8vIFdvcmsgYXJvdW5kIElFNyB6LWluZGV4IGJ1ZyAobm90IHBlcmZlY3QsIGhlbmNlIElFNyBub3QgcmVhbGx5IGJlaW5nIHN1cHBvcnRlZClcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDgpIHsgZC5ndXR0ZXJzLnN0eWxlLnpJbmRleCA9IC0xOyBkLnNjcm9sbGVyLnN0eWxlLnBhZGRpbmdSaWdodCA9IDA7IH1cbiAgICBpZiAoIXdlYmtpdCAmJiAhKGdlY2tvICYmIG1vYmlsZSkpIHsgZC5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlOyB9XG5cbiAgICBpZiAocGxhY2UpIHtcbiAgICAgIGlmIChwbGFjZS5hcHBlbmRDaGlsZCkgeyBwbGFjZS5hcHBlbmRDaGlsZChkLndyYXBwZXIpOyB9XG4gICAgICBlbHNlIHsgcGxhY2UoZC53cmFwcGVyKTsgfVxuICAgIH1cblxuICAgIC8vIEN1cnJlbnQgcmVuZGVyZWQgcmFuZ2UgKG1heSBiZSBiaWdnZXIgdGhhbiB0aGUgdmlldyB3aW5kb3cpLlxuICAgIGQudmlld0Zyb20gPSBkLnZpZXdUbyA9IGRvYy5maXJzdDtcbiAgICBkLnJlcG9ydGVkVmlld0Zyb20gPSBkLnJlcG9ydGVkVmlld1RvID0gZG9jLmZpcnN0O1xuICAgIC8vIEluZm9ybWF0aW9uIGFib3V0IHRoZSByZW5kZXJlZCBsaW5lcy5cbiAgICBkLnZpZXcgPSBbXTtcbiAgICBkLnJlbmRlcmVkVmlldyA9IG51bGw7XG4gICAgLy8gSG9sZHMgaW5mbyBhYm91dCBhIHNpbmdsZSByZW5kZXJlZCBsaW5lIHdoZW4gaXQgd2FzIHJlbmRlcmVkXG4gICAgLy8gZm9yIG1lYXN1cmVtZW50LCB3aGlsZSBub3QgaW4gdmlldy5cbiAgICBkLmV4dGVybmFsTWVhc3VyZWQgPSBudWxsO1xuICAgIC8vIEVtcHR5IHNwYWNlIChpbiBwaXhlbHMpIGFib3ZlIHRoZSB2aWV3XG4gICAgZC52aWV3T2Zmc2V0ID0gMDtcbiAgICBkLmxhc3RXcmFwSGVpZ2h0ID0gZC5sYXN0V3JhcFdpZHRoID0gMDtcbiAgICBkLnVwZGF0ZUxpbmVOdW1iZXJzID0gbnVsbDtcblxuICAgIGQubmF0aXZlQmFyV2lkdGggPSBkLmJhckhlaWdodCA9IGQuYmFyV2lkdGggPSAwO1xuICAgIGQuc2Nyb2xsYmFyc0NsaXBwZWQgPSBmYWxzZTtcblxuICAgIC8vIFVzZWQgdG8gb25seSByZXNpemUgdGhlIGxpbmUgbnVtYmVyIGd1dHRlciB3aGVuIG5lY2Vzc2FyeSAod2hlblxuICAgIC8vIHRoZSBhbW91bnQgb2YgbGluZXMgY3Jvc3NlcyBhIGJvdW5kYXJ5IHRoYXQgbWFrZXMgaXRzIHdpZHRoIGNoYW5nZSlcbiAgICBkLmxpbmVOdW1XaWR0aCA9IGQubGluZU51bUlubmVyV2lkdGggPSBkLmxpbmVOdW1DaGFycyA9IG51bGw7XG4gICAgLy8gU2V0IHRvIHRydWUgd2hlbiBhIG5vbi1ob3Jpem9udGFsLXNjcm9sbGluZyBsaW5lIHdpZGdldCBpc1xuICAgIC8vIGFkZGVkLiBBcyBhbiBvcHRpbWl6YXRpb24sIGxpbmUgd2lkZ2V0IGFsaWduaW5nIGlzIHNraXBwZWQgd2hlblxuICAgIC8vIHRoaXMgaXMgZmFsc2UuXG4gICAgZC5hbGlnbldpZGdldHMgPSBmYWxzZTtcblxuICAgIGQuY2FjaGVkQ2hhcldpZHRoID0gZC5jYWNoZWRUZXh0SGVpZ2h0ID0gZC5jYWNoZWRQYWRkaW5nSCA9IG51bGw7XG5cbiAgICAvLyBUcmFja3MgdGhlIG1heGltdW0gbGluZSBsZW5ndGggc28gdGhhdCB0aGUgaG9yaXpvbnRhbCBzY3JvbGxiYXJcbiAgICAvLyBjYW4gYmUga2VwdCBzdGF0aWMgd2hlbiBzY3JvbGxpbmcuXG4gICAgZC5tYXhMaW5lID0gbnVsbDtcbiAgICBkLm1heExpbmVMZW5ndGggPSAwO1xuICAgIGQubWF4TGluZUNoYW5nZWQgPSBmYWxzZTtcblxuICAgIC8vIFVzZWQgZm9yIG1lYXN1cmluZyB3aGVlbCBzY3JvbGxpbmcgZ3JhbnVsYXJpdHlcbiAgICBkLndoZWVsRFggPSBkLndoZWVsRFkgPSBkLndoZWVsU3RhcnRYID0gZC53aGVlbFN0YXJ0WSA9IG51bGw7XG5cbiAgICAvLyBUcnVlIHdoZW4gc2hpZnQgaXMgaGVsZCBkb3duLlxuICAgIGQuc2hpZnQgPSBmYWxzZTtcblxuICAgIC8vIFVzZWQgdG8gdHJhY2sgd2hldGhlciBhbnl0aGluZyBoYXBwZW5lZCBzaW5jZSB0aGUgY29udGV4dCBtZW51XG4gICAgLy8gd2FzIG9wZW5lZC5cbiAgICBkLnNlbEZvckNvbnRleHRNZW51ID0gbnVsbDtcblxuICAgIGQuYWN0aXZlVG91Y2ggPSBudWxsO1xuXG4gICAgZC5ndXR0ZXJTcGVjcyA9IGdldEd1dHRlcnMob3B0aW9ucy5ndXR0ZXJzLCBvcHRpb25zLmxpbmVOdW1iZXJzKTtcbiAgICByZW5kZXJHdXR0ZXJzKGQpO1xuXG4gICAgaW5wdXQuaW5pdChkKTtcbiAgfVxuXG4gIC8vIFNpbmNlIHRoZSBkZWx0YSB2YWx1ZXMgcmVwb3J0ZWQgb24gbW91c2Ugd2hlZWwgZXZlbnRzIGFyZVxuICAvLyB1bnN0YW5kYXJkaXplZCBiZXR3ZWVuIGJyb3dzZXJzIGFuZCBldmVuIGJyb3dzZXIgdmVyc2lvbnMsIGFuZFxuICAvLyBnZW5lcmFsbHkgaG9ycmlibHkgdW5wcmVkaWN0YWJsZSwgdGhpcyBjb2RlIHN0YXJ0cyBieSBtZWFzdXJpbmdcbiAgLy8gdGhlIHNjcm9sbCBlZmZlY3QgdGhhdCB0aGUgZmlyc3QgZmV3IG1vdXNlIHdoZWVsIGV2ZW50cyBoYXZlLFxuICAvLyBhbmQsIGZyb20gdGhhdCwgZGV0ZWN0cyB0aGUgd2F5IGl0IGNhbiBjb252ZXJ0IGRlbHRhcyB0byBwaXhlbFxuICAvLyBvZmZzZXRzIGFmdGVyd2FyZHMuXG4gIC8vXG4gIC8vIFRoZSByZWFzb24gd2Ugd2FudCB0byBrbm93IHRoZSBhbW91bnQgYSB3aGVlbCBldmVudCB3aWxsIHNjcm9sbFxuICAvLyBpcyB0aGF0IGl0IGdpdmVzIHVzIGEgY2hhbmNlIHRvIHVwZGF0ZSB0aGUgZGlzcGxheSBiZWZvcmUgdGhlXG4gIC8vIGFjdHVhbCBzY3JvbGxpbmcgaGFwcGVucywgcmVkdWNpbmcgZmxpY2tlcmluZy5cblxuICB2YXIgd2hlZWxTYW1wbGVzID0gMCwgd2hlZWxQaXhlbHNQZXJVbml0ID0gbnVsbDtcbiAgLy8gRmlsbCBpbiBhIGJyb3dzZXItZGV0ZWN0ZWQgc3RhcnRpbmcgdmFsdWUgb24gYnJvd3NlcnMgd2hlcmUgd2VcbiAgLy8ga25vdyBvbmUuIFRoZXNlIGRvbid0IGhhdmUgdG8gYmUgYWNjdXJhdGUgLS0gdGhlIHJlc3VsdCBvZiB0aGVtXG4gIC8vIGJlaW5nIHdyb25nIHdvdWxkIGp1c3QgYmUgYSBzbGlnaHQgZmxpY2tlciBvbiB0aGUgZmlyc3Qgd2hlZWxcbiAgLy8gc2Nyb2xsIChpZiBpdCBpcyBsYXJnZSBlbm91Z2gpLlxuICBpZiAoaWUpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLS41MzsgfVxuICBlbHNlIGlmIChnZWNrbykgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAxNTsgfVxuICBlbHNlIGlmIChjaHJvbWUpIHsgd2hlZWxQaXhlbHNQZXJVbml0ID0gLS43OyB9XG4gIGVsc2UgaWYgKHNhZmFyaSkgeyB3aGVlbFBpeGVsc1BlclVuaXQgPSAtMS8zOyB9XG5cbiAgZnVuY3Rpb24gd2hlZWxFdmVudERlbHRhKGUpIHtcbiAgICB2YXIgZHggPSBlLndoZWVsRGVsdGFYLCBkeSA9IGUud2hlZWxEZWx0YVk7XG4gICAgaWYgKGR4ID09IG51bGwgJiYgZS5kZXRhaWwgJiYgZS5heGlzID09IGUuSE9SSVpPTlRBTF9BWElTKSB7IGR4ID0gZS5kZXRhaWw7IH1cbiAgICBpZiAoZHkgPT0gbnVsbCAmJiBlLmRldGFpbCAmJiBlLmF4aXMgPT0gZS5WRVJUSUNBTF9BWElTKSB7IGR5ID0gZS5kZXRhaWw7IH1cbiAgICBlbHNlIGlmIChkeSA9PSBudWxsKSB7IGR5ID0gZS53aGVlbERlbHRhOyB9XG4gICAgcmV0dXJuIHt4OiBkeCwgeTogZHl9XG4gIH1cbiAgZnVuY3Rpb24gd2hlZWxFdmVudFBpeGVscyhlKSB7XG4gICAgdmFyIGRlbHRhID0gd2hlZWxFdmVudERlbHRhKGUpO1xuICAgIGRlbHRhLnggKj0gd2hlZWxQaXhlbHNQZXJVbml0O1xuICAgIGRlbHRhLnkgKj0gd2hlZWxQaXhlbHNQZXJVbml0O1xuICAgIHJldHVybiBkZWx0YVxuICB9XG5cbiAgZnVuY3Rpb24gb25TY3JvbGxXaGVlbChjbSwgZSkge1xuICAgIHZhciBkZWx0YSA9IHdoZWVsRXZlbnREZWx0YShlKSwgZHggPSBkZWx0YS54LCBkeSA9IGRlbHRhLnk7XG5cbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXksIHNjcm9sbCA9IGRpc3BsYXkuc2Nyb2xsZXI7XG4gICAgLy8gUXVpdCBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gc2Nyb2xsIGhlcmVcbiAgICB2YXIgY2FuU2Nyb2xsWCA9IHNjcm9sbC5zY3JvbGxXaWR0aCA+IHNjcm9sbC5jbGllbnRXaWR0aDtcbiAgICB2YXIgY2FuU2Nyb2xsWSA9IHNjcm9sbC5zY3JvbGxIZWlnaHQgPiBzY3JvbGwuY2xpZW50SGVpZ2h0O1xuICAgIGlmICghKGR4ICYmIGNhblNjcm9sbFggfHwgZHkgJiYgY2FuU2Nyb2xsWSkpIHsgcmV0dXJuIH1cblxuICAgIC8vIFdlYmtpdCBicm93c2VycyBvbiBPUyBYIGFib3J0IG1vbWVudHVtIHNjcm9sbHMgd2hlbiB0aGUgdGFyZ2V0XG4gICAgLy8gb2YgdGhlIHNjcm9sbCBldmVudCBpcyByZW1vdmVkIGZyb20gdGhlIHNjcm9sbGFibGUgZWxlbWVudC5cbiAgICAvLyBUaGlzIGhhY2sgKHNlZSByZWxhdGVkIGNvZGUgaW4gcGF0Y2hEaXNwbGF5KSBtYWtlcyBzdXJlIHRoZVxuICAgIC8vIGVsZW1lbnQgaXMga2VwdCBhcm91bmQuXG4gICAgaWYgKGR5ICYmIG1hYyAmJiB3ZWJraXQpIHtcbiAgICAgIG91dGVyOiBmb3IgKHZhciBjdXIgPSBlLnRhcmdldCwgdmlldyA9IGRpc3BsYXkudmlldzsgY3VyICE9IHNjcm9sbDsgY3VyID0gY3VyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHZpZXdbaV0ubm9kZSA9PSBjdXIpIHtcbiAgICAgICAgICAgIGNtLmRpc3BsYXkuY3VycmVudFdoZWVsVGFyZ2V0ID0gY3VyO1xuICAgICAgICAgICAgYnJlYWsgb3V0ZXJcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPbiBzb21lIGJyb3dzZXJzLCBob3Jpem9udGFsIHNjcm9sbGluZyB3aWxsIGNhdXNlIHJlZHJhd3MgdG9cbiAgICAvLyBoYXBwZW4gYmVmb3JlIHRoZSBndXR0ZXIgaGFzIGJlZW4gcmVhbGlnbmVkLCBjYXVzaW5nIGl0IHRvXG4gICAgLy8gd3JpZ2dsZSBhcm91bmQgaW4gYSBtb3N0IHVuc2VlbWx5IHdheS4gV2hlbiB3ZSBoYXZlIGFuXG4gICAgLy8gZXN0aW1hdGVkIHBpeGVscy9kZWx0YSB2YWx1ZSwgd2UganVzdCBoYW5kbGUgaG9yaXpvbnRhbFxuICAgIC8vIHNjcm9sbGluZyBlbnRpcmVseSBoZXJlLiBJdCdsbCBiZSBzbGlnaHRseSBvZmYgZnJvbSBuYXRpdmUsIGJ1dFxuICAgIC8vIGJldHRlciB0aGFuIGdsaXRjaGluZyBvdXQuXG4gICAgaWYgKGR4ICYmICFnZWNrbyAmJiAhcHJlc3RvICYmIHdoZWVsUGl4ZWxzUGVyVW5pdCAhPSBudWxsKSB7XG4gICAgICBpZiAoZHkgJiYgY2FuU2Nyb2xsWSlcbiAgICAgICAgeyB1cGRhdGVTY3JvbGxUb3AoY20sIE1hdGgubWF4KDAsIHNjcm9sbC5zY3JvbGxUb3AgKyBkeSAqIHdoZWVsUGl4ZWxzUGVyVW5pdCkpOyB9XG4gICAgICBzZXRTY3JvbGxMZWZ0KGNtLCBNYXRoLm1heCgwLCBzY3JvbGwuc2Nyb2xsTGVmdCArIGR4ICogd2hlZWxQaXhlbHNQZXJVbml0KSk7XG4gICAgICAvLyBPbmx5IHByZXZlbnQgZGVmYXVsdCBzY3JvbGxpbmcgaWYgdmVydGljYWwgc2Nyb2xsaW5nIGlzXG4gICAgICAvLyBhY3R1YWxseSBwb3NzaWJsZS4gT3RoZXJ3aXNlLCBpdCBjYXVzZXMgdmVydGljYWwgc2Nyb2xsXG4gICAgICAvLyBqaXR0ZXIgb24gT1NYIHRyYWNrcGFkcyB3aGVuIGRlbHRhWCBpcyBzbWFsbCBhbmQgZGVsdGFZXG4gICAgICAvLyBpcyBsYXJnZSAoaXNzdWUgIzM1NzkpXG4gICAgICBpZiAoIWR5IHx8IChkeSAmJiBjYW5TY3JvbGxZKSlcbiAgICAgICAgeyBlX3ByZXZlbnREZWZhdWx0KGUpOyB9XG4gICAgICBkaXNwbGF5LndoZWVsU3RhcnRYID0gbnVsbDsgLy8gQWJvcnQgbWVhc3VyZW1lbnQsIGlmIGluIHByb2dyZXNzXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyAnUHJvamVjdCcgdGhlIHZpc2libGUgdmlld3BvcnQgdG8gY292ZXIgdGhlIGFyZWEgdGhhdCBpcyBiZWluZ1xuICAgIC8vIHNjcm9sbGVkIGludG8gdmlldyAoaWYgd2Uga25vdyBlbm91Z2ggdG8gZXN0aW1hdGUgaXQpLlxuICAgIGlmIChkeSAmJiB3aGVlbFBpeGVsc1BlclVuaXQgIT0gbnVsbCkge1xuICAgICAgdmFyIHBpeGVscyA9IGR5ICogd2hlZWxQaXhlbHNQZXJVbml0O1xuICAgICAgdmFyIHRvcCA9IGNtLmRvYy5zY3JvbGxUb3AsIGJvdCA9IHRvcCArIGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQ7XG4gICAgICBpZiAocGl4ZWxzIDwgMCkgeyB0b3AgPSBNYXRoLm1heCgwLCB0b3AgKyBwaXhlbHMgLSA1MCk7IH1cbiAgICAgIGVsc2UgeyBib3QgPSBNYXRoLm1pbihjbS5kb2MuaGVpZ2h0LCBib3QgKyBwaXhlbHMgKyA1MCk7IH1cbiAgICAgIHVwZGF0ZURpc3BsYXlTaW1wbGUoY20sIHt0b3A6IHRvcCwgYm90dG9tOiBib3R9KTtcbiAgICB9XG5cbiAgICBpZiAod2hlZWxTYW1wbGVzIDwgMjApIHtcbiAgICAgIGlmIChkaXNwbGF5LndoZWVsU3RhcnRYID09IG51bGwpIHtcbiAgICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IHNjcm9sbC5zY3JvbGxMZWZ0OyBkaXNwbGF5LndoZWVsU3RhcnRZID0gc2Nyb2xsLnNjcm9sbFRvcDtcbiAgICAgICAgZGlzcGxheS53aGVlbERYID0gZHg7IGRpc3BsYXkud2hlZWxEWSA9IGR5O1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBpZiAoZGlzcGxheS53aGVlbFN0YXJ0WCA9PSBudWxsKSB7IHJldHVybiB9XG4gICAgICAgICAgdmFyIG1vdmVkWCA9IHNjcm9sbC5zY3JvbGxMZWZ0IC0gZGlzcGxheS53aGVlbFN0YXJ0WDtcbiAgICAgICAgICB2YXIgbW92ZWRZID0gc2Nyb2xsLnNjcm9sbFRvcCAtIGRpc3BsYXkud2hlZWxTdGFydFk7XG4gICAgICAgICAgdmFyIHNhbXBsZSA9IChtb3ZlZFkgJiYgZGlzcGxheS53aGVlbERZICYmIG1vdmVkWSAvIGRpc3BsYXkud2hlZWxEWSkgfHxcbiAgICAgICAgICAgIChtb3ZlZFggJiYgZGlzcGxheS53aGVlbERYICYmIG1vdmVkWCAvIGRpc3BsYXkud2hlZWxEWCk7XG4gICAgICAgICAgZGlzcGxheS53aGVlbFN0YXJ0WCA9IGRpc3BsYXkud2hlZWxTdGFydFkgPSBudWxsO1xuICAgICAgICAgIGlmICghc2FtcGxlKSB7IHJldHVybiB9XG4gICAgICAgICAgd2hlZWxQaXhlbHNQZXJVbml0ID0gKHdoZWVsUGl4ZWxzUGVyVW5pdCAqIHdoZWVsU2FtcGxlcyArIHNhbXBsZSkgLyAod2hlZWxTYW1wbGVzICsgMSk7XG4gICAgICAgICAgKyt3aGVlbFNhbXBsZXM7XG4gICAgICAgIH0sIDIwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwbGF5LndoZWVsRFggKz0gZHg7IGRpc3BsYXkud2hlZWxEWSArPSBkeTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBTZWxlY3Rpb24gb2JqZWN0cyBhcmUgaW1tdXRhYmxlLiBBIG5ldyBvbmUgaXMgY3JlYXRlZCBldmVyeSB0aW1lXG4gIC8vIHRoZSBzZWxlY3Rpb24gY2hhbmdlcy4gQSBzZWxlY3Rpb24gaXMgb25lIG9yIG1vcmUgbm9uLW92ZXJsYXBwaW5nXG4gIC8vIChhbmQgbm9uLXRvdWNoaW5nKSByYW5nZXMsIHNvcnRlZCwgYW5kIGFuIGludGVnZXIgdGhhdCBpbmRpY2F0ZXNcbiAgLy8gd2hpY2ggb25lIGlzIHRoZSBwcmltYXJ5IHNlbGVjdGlvbiAodGhlIG9uZSB0aGF0J3Mgc2Nyb2xsZWQgaW50b1xuICAvLyB2aWV3LCB0aGF0IGdldEN1cnNvciByZXR1cm5zLCBldGMpLlxuICB2YXIgU2VsZWN0aW9uID0gZnVuY3Rpb24ocmFuZ2VzLCBwcmltSW5kZXgpIHtcbiAgICB0aGlzLnJhbmdlcyA9IHJhbmdlcztcbiAgICB0aGlzLnByaW1JbmRleCA9IHByaW1JbmRleDtcbiAgfTtcblxuICBTZWxlY3Rpb24ucHJvdG90eXBlLnByaW1hcnkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLnJhbmdlc1t0aGlzLnByaW1JbmRleF0gfTtcblxuICBTZWxlY3Rpb24ucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChvdGhlcikge1xuICAgIGlmIChvdGhlciA9PSB0aGlzKSB7IHJldHVybiB0cnVlIH1cbiAgICBpZiAob3RoZXIucHJpbUluZGV4ICE9IHRoaXMucHJpbUluZGV4IHx8IG90aGVyLnJhbmdlcy5sZW5ndGggIT0gdGhpcy5yYW5nZXMubGVuZ3RoKSB7IHJldHVybiBmYWxzZSB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlcmUgPSB0aGlzLnJhbmdlc1tpXSwgdGhlcmUgPSBvdGhlci5yYW5nZXNbaV07XG4gICAgICBpZiAoIWVxdWFsQ3Vyc29yUG9zKGhlcmUuYW5jaG9yLCB0aGVyZS5hbmNob3IpIHx8ICFlcXVhbEN1cnNvclBvcyhoZXJlLmhlYWQsIHRoZXJlLmhlYWQpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlXG4gIH07XG5cbiAgU2VsZWN0aW9uLnByb3RvdHlwZS5kZWVwQ29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgIHsgb3V0W2ldID0gbmV3IFJhbmdlKGNvcHlQb3ModGhpcy5yYW5nZXNbaV0uYW5jaG9yKSwgY29weVBvcyh0aGlzLnJhbmdlc1tpXS5oZWFkKSk7IH1cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihvdXQsIHRoaXMucHJpbUluZGV4KVxuICB9O1xuXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUuc29tZXRoaW5nU2VsZWN0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgIHsgaWYgKCF0aGlzLnJhbmdlc1tpXS5lbXB0eSgpKSB7IHJldHVybiB0cnVlIH0gfVxuICAgIHJldHVybiBmYWxzZVxuICB9O1xuXG4gIFNlbGVjdGlvbi5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAocG9zLCBlbmQpIHtcbiAgICBpZiAoIWVuZCkgeyBlbmQgPSBwb3M7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnJhbmdlc1tpXTtcbiAgICAgIGlmIChjbXAoZW5kLCByYW5nZS5mcm9tKCkpID49IDAgJiYgY21wKHBvcywgcmFuZ2UudG8oKSkgPD0gMClcbiAgICAgICAgeyByZXR1cm4gaSB9XG4gICAgfVxuICAgIHJldHVybiAtMVxuICB9O1xuXG4gIHZhciBSYW5nZSA9IGZ1bmN0aW9uKGFuY2hvciwgaGVhZCkge1xuICAgIHRoaXMuYW5jaG9yID0gYW5jaG9yOyB0aGlzLmhlYWQgPSBoZWFkO1xuICB9O1xuXG4gIFJhbmdlLnByb3RvdHlwZS5mcm9tID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWluUG9zKHRoaXMuYW5jaG9yLCB0aGlzLmhlYWQpIH07XG4gIFJhbmdlLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1heFBvcyh0aGlzLmFuY2hvciwgdGhpcy5oZWFkKSB9O1xuICBSYW5nZS5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmhlYWQubGluZSA9PSB0aGlzLmFuY2hvci5saW5lICYmIHRoaXMuaGVhZC5jaCA9PSB0aGlzLmFuY2hvci5jaCB9O1xuXG4gIC8vIFRha2UgYW4gdW5zb3J0ZWQsIHBvdGVudGlhbGx5IG92ZXJsYXBwaW5nIHNldCBvZiByYW5nZXMsIGFuZFxuICAvLyBidWlsZCBhIHNlbGVjdGlvbiBvdXQgb2YgaXQuICdDb25zdW1lcycgcmFuZ2VzIGFycmF5IChtb2RpZnlpbmdcbiAgLy8gaXQpLlxuICBmdW5jdGlvbiBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcywgcHJpbUluZGV4KSB7XG4gICAgdmFyIG1heVRvdWNoID0gY20gJiYgY20ub3B0aW9ucy5zZWxlY3Rpb25zTWF5VG91Y2g7XG4gICAgdmFyIHByaW0gPSByYW5nZXNbcHJpbUluZGV4XTtcbiAgICByYW5nZXMuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gY21wKGEuZnJvbSgpLCBiLmZyb20oKSk7IH0pO1xuICAgIHByaW1JbmRleCA9IGluZGV4T2YocmFuZ2VzLCBwcmltKTtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGN1ciA9IHJhbmdlc1tpXSwgcHJldiA9IHJhbmdlc1tpIC0gMV07XG4gICAgICB2YXIgZGlmZiA9IGNtcChwcmV2LnRvKCksIGN1ci5mcm9tKCkpO1xuICAgICAgaWYgKG1heVRvdWNoICYmICFjdXIuZW1wdHkoKSA/IGRpZmYgPiAwIDogZGlmZiA+PSAwKSB7XG4gICAgICAgIHZhciBmcm9tID0gbWluUG9zKHByZXYuZnJvbSgpLCBjdXIuZnJvbSgpKSwgdG8gPSBtYXhQb3MocHJldi50bygpLCBjdXIudG8oKSk7XG4gICAgICAgIHZhciBpbnYgPSBwcmV2LmVtcHR5KCkgPyBjdXIuZnJvbSgpID09IGN1ci5oZWFkIDogcHJldi5mcm9tKCkgPT0gcHJldi5oZWFkO1xuICAgICAgICBpZiAoaSA8PSBwcmltSW5kZXgpIHsgLS1wcmltSW5kZXg7IH1cbiAgICAgICAgcmFuZ2VzLnNwbGljZSgtLWksIDIsIG5ldyBSYW5nZShpbnYgPyB0byA6IGZyb20sIGludiA/IGZyb20gOiB0bykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihyYW5nZXMsIHByaW1JbmRleClcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpbXBsZVNlbGVjdGlvbihhbmNob3IsIGhlYWQpIHtcbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihbbmV3IFJhbmdlKGFuY2hvciwgaGVhZCB8fCBhbmNob3IpXSwgMClcbiAgfVxuXG4gIC8vIENvbXB1dGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgYSBjaGFuZ2UgKGl0cyAndG8nIHByb3BlcnR5XG4gIC8vIHJlZmVycyB0byB0aGUgcHJlLWNoYW5nZSBlbmQpLlxuICBmdW5jdGlvbiBjaGFuZ2VFbmQoY2hhbmdlKSB7XG4gICAgaWYgKCFjaGFuZ2UudGV4dCkgeyByZXR1cm4gY2hhbmdlLnRvIH1cbiAgICByZXR1cm4gUG9zKGNoYW5nZS5mcm9tLmxpbmUgKyBjaGFuZ2UudGV4dC5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgbHN0KGNoYW5nZS50ZXh0KS5sZW5ndGggKyAoY2hhbmdlLnRleHQubGVuZ3RoID09IDEgPyBjaGFuZ2UuZnJvbS5jaCA6IDApKVxuICB9XG5cbiAgLy8gQWRqdXN0IGEgcG9zaXRpb24gdG8gcmVmZXIgdG8gdGhlIHBvc3QtY2hhbmdlIHBvc2l0aW9uIG9mIHRoZVxuICAvLyBzYW1lIHRleHQsIG9yIHRoZSBlbmQgb2YgdGhlIGNoYW5nZSBpZiB0aGUgY2hhbmdlIGNvdmVycyBpdC5cbiAgZnVuY3Rpb24gYWRqdXN0Rm9yQ2hhbmdlKHBvcywgY2hhbmdlKSB7XG4gICAgaWYgKGNtcChwb3MsIGNoYW5nZS5mcm9tKSA8IDApIHsgcmV0dXJuIHBvcyB9XG4gICAgaWYgKGNtcChwb3MsIGNoYW5nZS50bykgPD0gMCkgeyByZXR1cm4gY2hhbmdlRW5kKGNoYW5nZSkgfVxuXG4gICAgdmFyIGxpbmUgPSBwb3MubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCAtIChjaGFuZ2UudG8ubGluZSAtIGNoYW5nZS5mcm9tLmxpbmUpIC0gMSwgY2ggPSBwb3MuY2g7XG4gICAgaWYgKHBvcy5saW5lID09IGNoYW5nZS50by5saW5lKSB7IGNoICs9IGNoYW5nZUVuZChjaGFuZ2UpLmNoIC0gY2hhbmdlLnRvLmNoOyB9XG4gICAgcmV0dXJuIFBvcyhsaW5lLCBjaClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSkge1xuICAgIHZhciBvdXQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXTtcbiAgICAgIG91dC5wdXNoKG5ldyBSYW5nZShhZGp1c3RGb3JDaGFuZ2UocmFuZ2UuYW5jaG9yLCBjaGFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGFkanVzdEZvckNoYW5nZShyYW5nZS5oZWFkLCBjaGFuZ2UpKSk7XG4gICAgfVxuICAgIHJldHVybiBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCBvdXQsIGRvYy5zZWwucHJpbUluZGV4KVxuICB9XG5cbiAgZnVuY3Rpb24gb2Zmc2V0UG9zKHBvcywgb2xkLCBudykge1xuICAgIGlmIChwb3MubGluZSA9PSBvbGQubGluZSlcbiAgICAgIHsgcmV0dXJuIFBvcyhudy5saW5lLCBwb3MuY2ggLSBvbGQuY2ggKyBudy5jaCkgfVxuICAgIGVsc2VcbiAgICAgIHsgcmV0dXJuIFBvcyhudy5saW5lICsgKHBvcy5saW5lIC0gb2xkLmxpbmUpLCBwb3MuY2gpIH1cbiAgfVxuXG4gIC8vIFVzZWQgYnkgcmVwbGFjZVNlbGVjdGlvbnMgdG8gYWxsb3cgbW92aW5nIHRoZSBzZWxlY3Rpb24gdG8gdGhlXG4gIC8vIHN0YXJ0IG9yIGFyb3VuZCB0aGUgcmVwbGFjZWQgdGVzdC4gSGludCBtYXkgYmUgXCJzdGFydFwiIG9yIFwiYXJvdW5kXCIuXG4gIGZ1bmN0aW9uIGNvbXB1dGVSZXBsYWNlZFNlbChkb2MsIGNoYW5nZXMsIGhpbnQpIHtcbiAgICB2YXIgb3V0ID0gW107XG4gICAgdmFyIG9sZFByZXYgPSBQb3MoZG9jLmZpcnN0LCAwKSwgbmV3UHJldiA9IG9sZFByZXY7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpXTtcbiAgICAgIHZhciBmcm9tID0gb2Zmc2V0UG9zKGNoYW5nZS5mcm9tLCBvbGRQcmV2LCBuZXdQcmV2KTtcbiAgICAgIHZhciB0byA9IG9mZnNldFBvcyhjaGFuZ2VFbmQoY2hhbmdlKSwgb2xkUHJldiwgbmV3UHJldik7XG4gICAgICBvbGRQcmV2ID0gY2hhbmdlLnRvO1xuICAgICAgbmV3UHJldiA9IHRvO1xuICAgICAgaWYgKGhpbnQgPT0gXCJhcm91bmRcIikge1xuICAgICAgICB2YXIgcmFuZ2UgPSBkb2Muc2VsLnJhbmdlc1tpXSwgaW52ID0gY21wKHJhbmdlLmhlYWQsIHJhbmdlLmFuY2hvcikgPCAwO1xuICAgICAgICBvdXRbaV0gPSBuZXcgUmFuZ2UoaW52ID8gdG8gOiBmcm9tLCBpbnYgPyBmcm9tIDogdG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKGZyb20sIGZyb20pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFNlbGVjdGlvbihvdXQsIGRvYy5zZWwucHJpbUluZGV4KVxuICB9XG5cbiAgLy8gVXNlZCB0byBnZXQgdGhlIGVkaXRvciBpbnRvIGEgY29uc2lzdGVudCBzdGF0ZSBhZ2FpbiB3aGVuIG9wdGlvbnMgY2hhbmdlLlxuXG4gIGZ1bmN0aW9uIGxvYWRNb2RlKGNtKSB7XG4gICAgY20uZG9jLm1vZGUgPSBnZXRNb2RlKGNtLm9wdGlvbnMsIGNtLmRvYy5tb2RlT3B0aW9uKTtcbiAgICByZXNldE1vZGVTdGF0ZShjbSk7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldE1vZGVTdGF0ZShjbSkge1xuICAgIGNtLmRvYy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBpZiAobGluZS5zdGF0ZUFmdGVyKSB7IGxpbmUuc3RhdGVBZnRlciA9IG51bGw7IH1cbiAgICAgIGlmIChsaW5lLnN0eWxlcykgeyBsaW5lLnN0eWxlcyA9IG51bGw7IH1cbiAgICB9KTtcbiAgICBjbS5kb2MubW9kZUZyb250aWVyID0gY20uZG9jLmhpZ2hsaWdodEZyb250aWVyID0gY20uZG9jLmZpcnN0O1xuICAgIHN0YXJ0V29ya2VyKGNtLCAxMDApO1xuICAgIGNtLnN0YXRlLm1vZGVHZW4rKztcbiAgICBpZiAoY20uY3VyT3ApIHsgcmVnQ2hhbmdlKGNtKTsgfVxuICB9XG5cbiAgLy8gRE9DVU1FTlQgREFUQSBTVFJVQ1RVUkVcblxuICAvLyBCeSBkZWZhdWx0LCB1cGRhdGVzIHRoYXQgc3RhcnQgYW5kIGVuZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgbGluZVxuICAvLyBhcmUgdHJlYXRlZCBzcGVjaWFsbHksIGluIG9yZGVyIHRvIG1ha2UgdGhlIGFzc29jaWF0aW9uIG9mIGxpbmVcbiAgLy8gd2lkZ2V0cyBhbmQgbWFya2VyIGVsZW1lbnRzIHdpdGggdGhlIHRleHQgYmVoYXZlIG1vcmUgaW50dWl0aXZlLlxuICBmdW5jdGlvbiBpc1dob2xlTGluZVVwZGF0ZShkb2MsIGNoYW5nZSkge1xuICAgIHJldHVybiBjaGFuZ2UuZnJvbS5jaCA9PSAwICYmIGNoYW5nZS50by5jaCA9PSAwICYmIGxzdChjaGFuZ2UudGV4dCkgPT0gXCJcIiAmJlxuICAgICAgKCFkb2MuY20gfHwgZG9jLmNtLm9wdGlvbnMud2hvbGVMaW5lVXBkYXRlQmVmb3JlKVxuICB9XG5cbiAgLy8gUGVyZm9ybSBhIGNoYW5nZSBvbiB0aGUgZG9jdW1lbnQgZGF0YSBzdHJ1Y3R1cmUuXG4gIGZ1bmN0aW9uIHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgbWFya2VkU3BhbnMsIGVzdGltYXRlSGVpZ2h0KSB7XG4gICAgZnVuY3Rpb24gc3BhbnNGb3Iobikge3JldHVybiBtYXJrZWRTcGFucyA/IG1hcmtlZFNwYW5zW25dIDogbnVsbH1cbiAgICBmdW5jdGlvbiB1cGRhdGUobGluZSwgdGV4dCwgc3BhbnMpIHtcbiAgICAgIHVwZGF0ZUxpbmUobGluZSwgdGV4dCwgc3BhbnMsIGVzdGltYXRlSGVpZ2h0KTtcbiAgICAgIHNpZ25hbExhdGVyKGxpbmUsIFwiY2hhbmdlXCIsIGxpbmUsIGNoYW5nZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVzRm9yKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKVxuICAgICAgICB7IHJlc3VsdC5wdXNoKG5ldyBMaW5lKHRleHRbaV0sIHNwYW5zRm9yKGkpLCBlc3RpbWF0ZUhlaWdodCkpOyB9XG4gICAgICByZXR1cm4gcmVzdWx0XG4gICAgfVxuXG4gICAgdmFyIGZyb20gPSBjaGFuZ2UuZnJvbSwgdG8gPSBjaGFuZ2UudG8sIHRleHQgPSBjaGFuZ2UudGV4dDtcbiAgICB2YXIgZmlyc3RMaW5lID0gZ2V0TGluZShkb2MsIGZyb20ubGluZSksIGxhc3RMaW5lID0gZ2V0TGluZShkb2MsIHRvLmxpbmUpO1xuICAgIHZhciBsYXN0VGV4dCA9IGxzdCh0ZXh0KSwgbGFzdFNwYW5zID0gc3BhbnNGb3IodGV4dC5sZW5ndGggLSAxKSwgbmxpbmVzID0gdG8ubGluZSAtIGZyb20ubGluZTtcblxuICAgIC8vIEFkanVzdCB0aGUgbGluZSBzdHJ1Y3R1cmVcbiAgICBpZiAoY2hhbmdlLmZ1bGwpIHtcbiAgICAgIGRvYy5pbnNlcnQoMCwgbGluZXNGb3IoMCwgdGV4dC5sZW5ndGgpKTtcbiAgICAgIGRvYy5yZW1vdmUodGV4dC5sZW5ndGgsIGRvYy5zaXplIC0gdGV4dC5sZW5ndGgpO1xuICAgIH0gZWxzZSBpZiAoaXNXaG9sZUxpbmVVcGRhdGUoZG9jLCBjaGFuZ2UpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgd2hvbGUtbGluZSByZXBsYWNlLiBUcmVhdGVkIHNwZWNpYWxseSB0byBtYWtlXG4gICAgICAvLyBzdXJlIGxpbmUgb2JqZWN0cyBtb3ZlIHRoZSB3YXkgdGhleSBhcmUgc3VwcG9zZWQgdG8uXG4gICAgICB2YXIgYWRkZWQgPSBsaW5lc0ZvcigwLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgdXBkYXRlKGxhc3RMaW5lLCBsYXN0TGluZS50ZXh0LCBsYXN0U3BhbnMpO1xuICAgICAgaWYgKG5saW5lcykgeyBkb2MucmVtb3ZlKGZyb20ubGluZSwgbmxpbmVzKTsgfVxuICAgICAgaWYgKGFkZGVkLmxlbmd0aCkgeyBkb2MuaW5zZXJ0KGZyb20ubGluZSwgYWRkZWQpOyB9XG4gICAgfSBlbHNlIGlmIChmaXJzdExpbmUgPT0gbGFzdExpbmUpIHtcbiAgICAgIGlmICh0ZXh0Lmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgbGFzdFRleHQgKyBmaXJzdExpbmUudGV4dC5zbGljZSh0by5jaCksIGxhc3RTcGFucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYWRkZWQkMSA9IGxpbmVzRm9yKDEsIHRleHQubGVuZ3RoIC0gMSk7XG4gICAgICAgIGFkZGVkJDEucHVzaChuZXcgTGluZShsYXN0VGV4dCArIGZpcnN0TGluZS50ZXh0LnNsaWNlKHRvLmNoKSwgbGFzdFNwYW5zLCBlc3RpbWF0ZUhlaWdodCkpO1xuICAgICAgICB1cGRhdGUoZmlyc3RMaW5lLCBmaXJzdExpbmUudGV4dC5zbGljZSgwLCBmcm9tLmNoKSArIHRleHRbMF0sIHNwYW5zRm9yKDApKTtcbiAgICAgICAgZG9jLmluc2VydChmcm9tLmxpbmUgKyAxLCBhZGRlZCQxKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRleHQubGVuZ3RoID09IDEpIHtcbiAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSArIGxhc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBzcGFuc0ZvcigwKSk7XG4gICAgICBkb2MucmVtb3ZlKGZyb20ubGluZSArIDEsIG5saW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZShmaXJzdExpbmUsIGZpcnN0TGluZS50ZXh0LnNsaWNlKDAsIGZyb20uY2gpICsgdGV4dFswXSwgc3BhbnNGb3IoMCkpO1xuICAgICAgdXBkYXRlKGxhc3RMaW5lLCBsYXN0VGV4dCArIGxhc3RMaW5lLnRleHQuc2xpY2UodG8uY2gpLCBsYXN0U3BhbnMpO1xuICAgICAgdmFyIGFkZGVkJDIgPSBsaW5lc0ZvcigxLCB0ZXh0Lmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKG5saW5lcyA+IDEpIHsgZG9jLnJlbW92ZShmcm9tLmxpbmUgKyAxLCBubGluZXMgLSAxKTsgfVxuICAgICAgZG9jLmluc2VydChmcm9tLmxpbmUgKyAxLCBhZGRlZCQyKTtcbiAgICB9XG5cbiAgICBzaWduYWxMYXRlcihkb2MsIFwiY2hhbmdlXCIsIGRvYywgY2hhbmdlKTtcbiAgfVxuXG4gIC8vIENhbGwgZiBmb3IgYWxsIGxpbmtlZCBkb2N1bWVudHMuXG4gIGZ1bmN0aW9uIGxpbmtlZERvY3MoZG9jLCBmLCBzaGFyZWRIaXN0T25seSkge1xuICAgIGZ1bmN0aW9uIHByb3BhZ2F0ZShkb2MsIHNraXAsIHNoYXJlZEhpc3QpIHtcbiAgICAgIGlmIChkb2MubGlua2VkKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLmxpbmtlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcmVsID0gZG9jLmxpbmtlZFtpXTtcbiAgICAgICAgaWYgKHJlbC5kb2MgPT0gc2tpcCkgeyBjb250aW51ZSB9XG4gICAgICAgIHZhciBzaGFyZWQgPSBzaGFyZWRIaXN0ICYmIHJlbC5zaGFyZWRIaXN0O1xuICAgICAgICBpZiAoc2hhcmVkSGlzdE9ubHkgJiYgIXNoYXJlZCkgeyBjb250aW51ZSB9XG4gICAgICAgIGYocmVsLmRvYywgc2hhcmVkKTtcbiAgICAgICAgcHJvcGFnYXRlKHJlbC5kb2MsIGRvYywgc2hhcmVkKTtcbiAgICAgIH0gfVxuICAgIH1cbiAgICBwcm9wYWdhdGUoZG9jLCBudWxsLCB0cnVlKTtcbiAgfVxuXG4gIC8vIEF0dGFjaCBhIGRvY3VtZW50IHRvIGFuIGVkaXRvci5cbiAgZnVuY3Rpb24gYXR0YWNoRG9jKGNtLCBkb2MpIHtcbiAgICBpZiAoZG9jLmNtKSB7IHRocm93IG5ldyBFcnJvcihcIlRoaXMgZG9jdW1lbnQgaXMgYWxyZWFkeSBpbiB1c2UuXCIpIH1cbiAgICBjbS5kb2MgPSBkb2M7XG4gICAgZG9jLmNtID0gY207XG4gICAgZXN0aW1hdGVMaW5lSGVpZ2h0cyhjbSk7XG4gICAgbG9hZE1vZGUoY20pO1xuICAgIHNldERpcmVjdGlvbkNsYXNzKGNtKTtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGZpbmRNYXhMaW5lKGNtKTsgfVxuICAgIGNtLm9wdGlvbnMubW9kZSA9IGRvYy5tb2RlT3B0aW9uO1xuICAgIHJlZ0NoYW5nZShjbSk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXREaXJlY3Rpb25DbGFzcyhjbSkge1xuICAoY20uZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiID8gYWRkQ2xhc3MgOiBybUNsYXNzKShjbS5kaXNwbGF5LmxpbmVEaXYsIFwiQ29kZU1pcnJvci1ydGxcIik7XG4gIH1cblxuICBmdW5jdGlvbiBkaXJlY3Rpb25DaGFuZ2VkKGNtKSB7XG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgc2V0RGlyZWN0aW9uQ2xhc3MoY20pO1xuICAgICAgcmVnQ2hhbmdlKGNtKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIEhpc3Rvcnkoc3RhcnRHZW4pIHtcbiAgICAvLyBBcnJheXMgb2YgY2hhbmdlIGV2ZW50cyBhbmQgc2VsZWN0aW9ucy4gRG9pbmcgc29tZXRoaW5nIGFkZHMgYW5cbiAgICAvLyBldmVudCB0byBkb25lIGFuZCBjbGVhcnMgdW5kby4gVW5kb2luZyBtb3ZlcyBldmVudHMgZnJvbSBkb25lXG4gICAgLy8gdG8gdW5kb25lLCByZWRvaW5nIG1vdmVzIHRoZW0gaW4gdGhlIG90aGVyIGRpcmVjdGlvbi5cbiAgICB0aGlzLmRvbmUgPSBbXTsgdGhpcy51bmRvbmUgPSBbXTtcbiAgICB0aGlzLnVuZG9EZXB0aCA9IEluZmluaXR5O1xuICAgIC8vIFVzZWQgdG8gdHJhY2sgd2hlbiBjaGFuZ2VzIGNhbiBiZSBtZXJnZWQgaW50byBhIHNpbmdsZSB1bmRvXG4gICAgLy8gZXZlbnRcbiAgICB0aGlzLmxhc3RNb2RUaW1lID0gdGhpcy5sYXN0U2VsVGltZSA9IDA7XG4gICAgdGhpcy5sYXN0T3AgPSB0aGlzLmxhc3RTZWxPcCA9IG51bGw7XG4gICAgdGhpcy5sYXN0T3JpZ2luID0gdGhpcy5sYXN0U2VsT3JpZ2luID0gbnVsbDtcbiAgICAvLyBVc2VkIGJ5IHRoZSBpc0NsZWFuKCkgbWV0aG9kXG4gICAgdGhpcy5nZW5lcmF0aW9uID0gdGhpcy5tYXhHZW5lcmF0aW9uID0gc3RhcnRHZW4gfHwgMTtcbiAgfVxuXG4gIC8vIENyZWF0ZSBhIGhpc3RvcnkgY2hhbmdlIGV2ZW50IGZyb20gYW4gdXBkYXRlRG9jLXN0eWxlIGNoYW5nZVxuICAvLyBvYmplY3QuXG4gIGZ1bmN0aW9uIGhpc3RvcnlDaGFuZ2VGcm9tQ2hhbmdlKGRvYywgY2hhbmdlKSB7XG4gICAgdmFyIGhpc3RDaGFuZ2UgPSB7ZnJvbTogY29weVBvcyhjaGFuZ2UuZnJvbSksIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKSwgdGV4dDogZ2V0QmV0d2Vlbihkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pfTtcbiAgICBhdHRhY2hMb2NhbFNwYW5zKGRvYywgaGlzdENoYW5nZSwgY2hhbmdlLmZyb20ubGluZSwgY2hhbmdlLnRvLmxpbmUgKyAxKTtcbiAgICBsaW5rZWREb2NzKGRvYywgZnVuY3Rpb24gKGRvYykgeyByZXR1cm4gYXR0YWNoTG9jYWxTcGFucyhkb2MsIGhpc3RDaGFuZ2UsIGNoYW5nZS5mcm9tLmxpbmUsIGNoYW5nZS50by5saW5lICsgMSk7IH0sIHRydWUpO1xuICAgIHJldHVybiBoaXN0Q2hhbmdlXG4gIH1cblxuICAvLyBQb3AgYWxsIHNlbGVjdGlvbiBldmVudHMgb2ZmIHRoZSBlbmQgb2YgYSBoaXN0b3J5IGFycmF5LiBTdG9wIGF0XG4gIC8vIGEgY2hhbmdlIGV2ZW50LlxuICBmdW5jdGlvbiBjbGVhclNlbGVjdGlvbkV2ZW50cyhhcnJheSkge1xuICAgIHdoaWxlIChhcnJheS5sZW5ndGgpIHtcbiAgICAgIHZhciBsYXN0ID0gbHN0KGFycmF5KTtcbiAgICAgIGlmIChsYXN0LnJhbmdlcykgeyBhcnJheS5wb3AoKTsgfVxuICAgICAgZWxzZSB7IGJyZWFrIH1cbiAgICB9XG4gIH1cblxuICAvLyBGaW5kIHRoZSB0b3AgY2hhbmdlIGV2ZW50IGluIHRoZSBoaXN0b3J5LiBQb3Agb2ZmIHNlbGVjdGlvblxuICAvLyBldmVudHMgdGhhdCBhcmUgaW4gdGhlIHdheS5cbiAgZnVuY3Rpb24gbGFzdENoYW5nZUV2ZW50KGhpc3QsIGZvcmNlKSB7XG4gICAgaWYgKGZvcmNlKSB7XG4gICAgICBjbGVhclNlbGVjdGlvbkV2ZW50cyhoaXN0LmRvbmUpO1xuICAgICAgcmV0dXJuIGxzdChoaXN0LmRvbmUpXG4gICAgfSBlbHNlIGlmIChoaXN0LmRvbmUubGVuZ3RoICYmICFsc3QoaGlzdC5kb25lKS5yYW5nZXMpIHtcbiAgICAgIHJldHVybiBsc3QoaGlzdC5kb25lKVxuICAgIH0gZWxzZSBpZiAoaGlzdC5kb25lLmxlbmd0aCA+IDEgJiYgIWhpc3QuZG9uZVtoaXN0LmRvbmUubGVuZ3RoIC0gMl0ucmFuZ2VzKSB7XG4gICAgICBoaXN0LmRvbmUucG9wKCk7XG4gICAgICByZXR1cm4gbHN0KGhpc3QuZG9uZSlcbiAgICB9XG4gIH1cblxuICAvLyBSZWdpc3RlciBhIGNoYW5nZSBpbiB0aGUgaGlzdG9yeS4gTWVyZ2VzIGNoYW5nZXMgdGhhdCBhcmUgd2l0aGluXG4gIC8vIGEgc2luZ2xlIG9wZXJhdGlvbiwgb3IgYXJlIGNsb3NlIHRvZ2V0aGVyIHdpdGggYW4gb3JpZ2luIHRoYXRcbiAgLy8gYWxsb3dzIG1lcmdpbmcgKHN0YXJ0aW5nIHdpdGggXCIrXCIpIGludG8gYSBzaW5nbGUgZXZlbnQuXG4gIGZ1bmN0aW9uIGFkZENoYW5nZVRvSGlzdG9yeShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIG9wSWQpIHtcbiAgICB2YXIgaGlzdCA9IGRvYy5oaXN0b3J5O1xuICAgIGhpc3QudW5kb25lLmxlbmd0aCA9IDA7XG4gICAgdmFyIHRpbWUgPSArbmV3IERhdGUsIGN1cjtcbiAgICB2YXIgbGFzdDtcblxuICAgIGlmICgoaGlzdC5sYXN0T3AgPT0gb3BJZCB8fFxuICAgICAgICAgaGlzdC5sYXN0T3JpZ2luID09IGNoYW5nZS5vcmlnaW4gJiYgY2hhbmdlLm9yaWdpbiAmJlxuICAgICAgICAgKChjaGFuZ2Uub3JpZ2luLmNoYXJBdCgwKSA9PSBcIitcIiAmJiBoaXN0Lmxhc3RNb2RUaW1lID4gdGltZSAtIChkb2MuY20gPyBkb2MuY20ub3B0aW9ucy5oaXN0b3J5RXZlbnREZWxheSA6IDUwMCkpIHx8XG4gICAgICAgICAgY2hhbmdlLm9yaWdpbi5jaGFyQXQoMCkgPT0gXCIqXCIpKSAmJlxuICAgICAgICAoY3VyID0gbGFzdENoYW5nZUV2ZW50KGhpc3QsIGhpc3QubGFzdE9wID09IG9wSWQpKSkge1xuICAgICAgLy8gTWVyZ2UgdGhpcyBjaGFuZ2UgaW50byB0aGUgbGFzdCBldmVudFxuICAgICAgbGFzdCA9IGxzdChjdXIuY2hhbmdlcyk7XG4gICAgICBpZiAoY21wKGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pID09IDAgJiYgY21wKGNoYW5nZS5mcm9tLCBsYXN0LnRvKSA9PSAwKSB7XG4gICAgICAgIC8vIE9wdGltaXplZCBjYXNlIGZvciBzaW1wbGUgaW5zZXJ0aW9uIC0tIGRvbid0IHdhbnQgdG8gYWRkXG4gICAgICAgIC8vIG5ldyBjaGFuZ2VzZXRzIGZvciBldmVyeSBjaGFyYWN0ZXIgdHlwZWRcbiAgICAgICAgbGFzdC50byA9IGNoYW5nZUVuZChjaGFuZ2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWRkIG5ldyBzdWItZXZlbnRcbiAgICAgICAgY3VyLmNoYW5nZXMucHVzaChoaXN0b3J5Q2hhbmdlRnJvbUNoYW5nZShkb2MsIGNoYW5nZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYW4gbm90IGJlIG1lcmdlZCwgc3RhcnQgYSBuZXcgZXZlbnQuXG4gICAgICB2YXIgYmVmb3JlID0gbHN0KGhpc3QuZG9uZSk7XG4gICAgICBpZiAoIWJlZm9yZSB8fCAhYmVmb3JlLnJhbmdlcylcbiAgICAgICAgeyBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KGRvYy5zZWwsIGhpc3QuZG9uZSk7IH1cbiAgICAgIGN1ciA9IHtjaGFuZ2VzOiBbaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpXSxcbiAgICAgICAgICAgICBnZW5lcmF0aW9uOiBoaXN0LmdlbmVyYXRpb259O1xuICAgICAgaGlzdC5kb25lLnB1c2goY3VyKTtcbiAgICAgIHdoaWxlIChoaXN0LmRvbmUubGVuZ3RoID4gaGlzdC51bmRvRGVwdGgpIHtcbiAgICAgICAgaGlzdC5kb25lLnNoaWZ0KCk7XG4gICAgICAgIGlmICghaGlzdC5kb25lWzBdLnJhbmdlcykgeyBoaXN0LmRvbmUuc2hpZnQoKTsgfVxuICAgICAgfVxuICAgIH1cbiAgICBoaXN0LmRvbmUucHVzaChzZWxBZnRlcik7XG4gICAgaGlzdC5nZW5lcmF0aW9uID0gKytoaXN0Lm1heEdlbmVyYXRpb247XG4gICAgaGlzdC5sYXN0TW9kVGltZSA9IGhpc3QubGFzdFNlbFRpbWUgPSB0aW1lO1xuICAgIGhpc3QubGFzdE9wID0gaGlzdC5sYXN0U2VsT3AgPSBvcElkO1xuICAgIGhpc3QubGFzdE9yaWdpbiA9IGhpc3QubGFzdFNlbE9yaWdpbiA9IGNoYW5nZS5vcmlnaW47XG5cbiAgICBpZiAoIWxhc3QpIHsgc2lnbmFsKGRvYywgXCJoaXN0b3J5QWRkZWRcIik7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdGlvbkV2ZW50Q2FuQmVNZXJnZWQoZG9jLCBvcmlnaW4sIHByZXYsIHNlbCkge1xuICAgIHZhciBjaCA9IG9yaWdpbi5jaGFyQXQoMCk7XG4gICAgcmV0dXJuIGNoID09IFwiKlwiIHx8XG4gICAgICBjaCA9PSBcIitcIiAmJlxuICAgICAgcHJldi5yYW5nZXMubGVuZ3RoID09IHNlbC5yYW5nZXMubGVuZ3RoICYmXG4gICAgICBwcmV2LnNvbWV0aGluZ1NlbGVjdGVkKCkgPT0gc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCkgJiZcbiAgICAgIG5ldyBEYXRlIC0gZG9jLmhpc3RvcnkubGFzdFNlbFRpbWUgPD0gKGRvYy5jbSA/IGRvYy5jbS5vcHRpb25zLmhpc3RvcnlFdmVudERlbGF5IDogNTAwKVxuICB9XG5cbiAgLy8gQ2FsbGVkIHdoZW5ldmVyIHRoZSBzZWxlY3Rpb24gY2hhbmdlcywgc2V0cyB0aGUgbmV3IHNlbGVjdGlvbiBhc1xuICAvLyB0aGUgcGVuZGluZyBzZWxlY3Rpb24gaW4gdGhlIGhpc3RvcnksIGFuZCBwdXNoZXMgdGhlIG9sZCBwZW5kaW5nXG4gIC8vIHNlbGVjdGlvbiBpbnRvIHRoZSAnZG9uZScgYXJyYXkgd2hlbiBpdCB3YXMgc2lnbmlmaWNhbnRseVxuICAvLyBkaWZmZXJlbnQgKGluIG51bWJlciBvZiBzZWxlY3RlZCByYW5nZXMsIGVtcHRpbmVzcywgb3IgdGltZSkuXG4gIGZ1bmN0aW9uIGFkZFNlbGVjdGlvblRvSGlzdG9yeShkb2MsIHNlbCwgb3BJZCwgb3B0aW9ucykge1xuICAgIHZhciBoaXN0ID0gZG9jLmhpc3RvcnksIG9yaWdpbiA9IG9wdGlvbnMgJiYgb3B0aW9ucy5vcmlnaW47XG5cbiAgICAvLyBBIG5ldyBldmVudCBpcyBzdGFydGVkIHdoZW4gdGhlIHByZXZpb3VzIG9yaWdpbiBkb2VzIG5vdCBtYXRjaFxuICAgIC8vIHRoZSBjdXJyZW50LCBvciB0aGUgb3JpZ2lucyBkb24ndCBhbGxvdyBtYXRjaGluZy4gT3JpZ2luc1xuICAgIC8vIHN0YXJ0aW5nIHdpdGggKiBhcmUgYWx3YXlzIG1lcmdlZCwgdGhvc2Ugc3RhcnRpbmcgd2l0aCArIGFyZVxuICAgIC8vIG1lcmdlZCB3aGVuIHNpbWlsYXIgYW5kIGNsb3NlIHRvZ2V0aGVyIGluIHRpbWUuXG4gICAgaWYgKG9wSWQgPT0gaGlzdC5sYXN0U2VsT3AgfHxcbiAgICAgICAgKG9yaWdpbiAmJiBoaXN0Lmxhc3RTZWxPcmlnaW4gPT0gb3JpZ2luICYmXG4gICAgICAgICAoaGlzdC5sYXN0TW9kVGltZSA9PSBoaXN0Lmxhc3RTZWxUaW1lICYmIGhpc3QubGFzdE9yaWdpbiA9PSBvcmlnaW4gfHxcbiAgICAgICAgICBzZWxlY3Rpb25FdmVudENhbkJlTWVyZ2VkKGRvYywgb3JpZ2luLCBsc3QoaGlzdC5kb25lKSwgc2VsKSkpKVxuICAgICAgeyBoaXN0LmRvbmVbaGlzdC5kb25lLmxlbmd0aCAtIDFdID0gc2VsOyB9XG4gICAgZWxzZVxuICAgICAgeyBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCwgaGlzdC5kb25lKTsgfVxuXG4gICAgaGlzdC5sYXN0U2VsVGltZSA9ICtuZXcgRGF0ZTtcbiAgICBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBvcmlnaW47XG4gICAgaGlzdC5sYXN0U2VsT3AgPSBvcElkO1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuY2xlYXJSZWRvICE9PSBmYWxzZSlcbiAgICAgIHsgY2xlYXJTZWxlY3Rpb25FdmVudHMoaGlzdC51bmRvbmUpOyB9XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoU2VsZWN0aW9uVG9IaXN0b3J5KHNlbCwgZGVzdCkge1xuICAgIHZhciB0b3AgPSBsc3QoZGVzdCk7XG4gICAgaWYgKCEodG9wICYmIHRvcC5yYW5nZXMgJiYgdG9wLmVxdWFscyhzZWwpKSlcbiAgICAgIHsgZGVzdC5wdXNoKHNlbCk7IH1cbiAgfVxuXG4gIC8vIFVzZWQgdG8gc3RvcmUgbWFya2VkIHNwYW4gaW5mb3JtYXRpb24gaW4gdGhlIGhpc3RvcnkuXG4gIGZ1bmN0aW9uIGF0dGFjaExvY2FsU3BhbnMoZG9jLCBjaGFuZ2UsIGZyb20sIHRvKSB7XG4gICAgdmFyIGV4aXN0aW5nID0gY2hhbmdlW1wic3BhbnNfXCIgKyBkb2MuaWRdLCBuID0gMDtcbiAgICBkb2MuaXRlcihNYXRoLm1heChkb2MuZmlyc3QsIGZyb20pLCBNYXRoLm1pbihkb2MuZmlyc3QgKyBkb2Muc2l6ZSwgdG8pLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmUubWFya2VkU3BhbnMpXG4gICAgICAgIHsgKGV4aXN0aW5nIHx8IChleGlzdGluZyA9IGNoYW5nZVtcInNwYW5zX1wiICsgZG9jLmlkXSA9IHt9KSlbbl0gPSBsaW5lLm1hcmtlZFNwYW5zOyB9XG4gICAgICArK247XG4gICAgfSk7XG4gIH1cblxuICAvLyBXaGVuIHVuL3JlLWRvaW5nIHJlc3RvcmVzIHRleHQgY29udGFpbmluZyBtYXJrZWQgc3BhbnMsIHRob3NlXG4gIC8vIHRoYXQgaGF2ZSBiZWVuIGV4cGxpY2l0bHkgY2xlYXJlZCBzaG91bGQgbm90IGJlIHJlc3RvcmVkLlxuICBmdW5jdGlvbiByZW1vdmVDbGVhcmVkU3BhbnMoc3BhbnMpIHtcbiAgICBpZiAoIXNwYW5zKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgb3V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChzcGFuc1tpXS5tYXJrZXIuZXhwbGljaXRseUNsZWFyZWQpIHsgaWYgKCFvdXQpIHsgb3V0ID0gc3BhbnMuc2xpY2UoMCwgaSk7IH0gfVxuICAgICAgZWxzZSBpZiAob3V0KSB7IG91dC5wdXNoKHNwYW5zW2ldKTsgfVxuICAgIH1cbiAgICByZXR1cm4gIW91dCA/IHNwYW5zIDogb3V0Lmxlbmd0aCA/IG91dCA6IG51bGxcbiAgfVxuXG4gIC8vIFJldHJpZXZlIGFuZCBmaWx0ZXIgdGhlIG9sZCBtYXJrZWQgc3BhbnMgc3RvcmVkIGluIGEgY2hhbmdlIGV2ZW50LlxuICBmdW5jdGlvbiBnZXRPbGRTcGFucyhkb2MsIGNoYW5nZSkge1xuICAgIHZhciBmb3VuZCA9IGNoYW5nZVtcInNwYW5zX1wiICsgZG9jLmlkXTtcbiAgICBpZiAoIWZvdW5kKSB7IHJldHVybiBudWxsIH1cbiAgICB2YXIgbncgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoYW5nZS50ZXh0Lmxlbmd0aDsgKytpKVxuICAgICAgeyBudy5wdXNoKHJlbW92ZUNsZWFyZWRTcGFucyhmb3VuZFtpXSkpOyB9XG4gICAgcmV0dXJuIG53XG4gIH1cblxuICAvLyBVc2VkIGZvciB1bi9yZS1kb2luZyBjaGFuZ2VzIGZyb20gdGhlIGhpc3RvcnkuIENvbWJpbmVzIHRoZVxuICAvLyByZXN1bHQgb2YgY29tcHV0aW5nIHRoZSBleGlzdGluZyBzcGFucyB3aXRoIHRoZSBzZXQgb2Ygc3BhbnMgdGhhdFxuICAvLyBleGlzdGVkIGluIHRoZSBoaXN0b3J5IChzbyB0aGF0IGRlbGV0aW5nIGFyb3VuZCBhIHNwYW4gYW5kIHRoZW5cbiAgLy8gdW5kb2luZyBicmluZ3MgYmFjayB0aGUgc3BhbikuXG4gIGZ1bmN0aW9uIG1lcmdlT2xkU3BhbnMoZG9jLCBjaGFuZ2UpIHtcbiAgICB2YXIgb2xkID0gZ2V0T2xkU3BhbnMoZG9jLCBjaGFuZ2UpO1xuICAgIHZhciBzdHJldGNoZWQgPSBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKTtcbiAgICBpZiAoIW9sZCkgeyByZXR1cm4gc3RyZXRjaGVkIH1cbiAgICBpZiAoIXN0cmV0Y2hlZCkgeyByZXR1cm4gb2xkIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2xkLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgb2xkQ3VyID0gb2xkW2ldLCBzdHJldGNoQ3VyID0gc3RyZXRjaGVkW2ldO1xuICAgICAgaWYgKG9sZEN1ciAmJiBzdHJldGNoQ3VyKSB7XG4gICAgICAgIHNwYW5zOiBmb3IgKHZhciBqID0gMDsgaiA8IHN0cmV0Y2hDdXIubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICB2YXIgc3BhbiA9IHN0cmV0Y2hDdXJbal07XG4gICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBvbGRDdXIubGVuZ3RoOyArK2spXG4gICAgICAgICAgICB7IGlmIChvbGRDdXJba10ubWFya2VyID09IHNwYW4ubWFya2VyKSB7IGNvbnRpbnVlIHNwYW5zIH0gfVxuICAgICAgICAgIG9sZEN1ci5wdXNoKHNwYW4pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmV0Y2hDdXIpIHtcbiAgICAgICAgb2xkW2ldID0gc3RyZXRjaEN1cjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9sZFxuICB9XG5cbiAgLy8gVXNlZCBib3RoIHRvIHByb3ZpZGUgYSBKU09OLXNhZmUgb2JqZWN0IGluIC5nZXRIaXN0b3J5LCBhbmQsIHdoZW5cbiAgLy8gZGV0YWNoaW5nIGEgZG9jdW1lbnQsIHRvIHNwbGl0IHRoZSBoaXN0b3J5IGluIHR3b1xuICBmdW5jdGlvbiBjb3B5SGlzdG9yeUFycmF5KGV2ZW50cywgbmV3R3JvdXAsIGluc3RhbnRpYXRlU2VsKSB7XG4gICAgdmFyIGNvcHkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGV2ZW50ID0gZXZlbnRzW2ldO1xuICAgICAgaWYgKGV2ZW50LnJhbmdlcykge1xuICAgICAgICBjb3B5LnB1c2goaW5zdGFudGlhdGVTZWwgPyBTZWxlY3Rpb24ucHJvdG90eXBlLmRlZXBDb3B5LmNhbGwoZXZlbnQpIDogZXZlbnQpO1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgdmFyIGNoYW5nZXMgPSBldmVudC5jaGFuZ2VzLCBuZXdDaGFuZ2VzID0gW107XG4gICAgICBjb3B5LnB1c2goe2NoYW5nZXM6IG5ld0NoYW5nZXN9KTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2hhbmdlcy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tqXSwgbSA9ICh2b2lkIDApO1xuICAgICAgICBuZXdDaGFuZ2VzLnB1c2goe2Zyb206IGNoYW5nZS5mcm9tLCB0bzogY2hhbmdlLnRvLCB0ZXh0OiBjaGFuZ2UudGV4dH0pO1xuICAgICAgICBpZiAobmV3R3JvdXApIHsgZm9yICh2YXIgcHJvcCBpbiBjaGFuZ2UpIHsgaWYgKG0gPSBwcm9wLm1hdGNoKC9ec3BhbnNfKFxcZCspJC8pKSB7XG4gICAgICAgICAgaWYgKGluZGV4T2YobmV3R3JvdXAsIE51bWJlcihtWzFdKSkgPiAtMSkge1xuICAgICAgICAgICAgbHN0KG5ld0NoYW5nZXMpW3Byb3BdID0gY2hhbmdlW3Byb3BdO1xuICAgICAgICAgICAgZGVsZXRlIGNoYW5nZVtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gfSB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjb3B5XG4gIH1cblxuICAvLyBUaGUgJ3Njcm9sbCcgcGFyYW1ldGVyIGdpdmVuIHRvIG1hbnkgb2YgdGhlc2UgaW5kaWNhdGVkIHdoZXRoZXJcbiAgLy8gdGhlIG5ldyBjdXJzb3IgcG9zaXRpb24gc2hvdWxkIGJlIHNjcm9sbGVkIGludG8gdmlldyBhZnRlclxuICAvLyBtb2RpZnlpbmcgdGhlIHNlbGVjdGlvbi5cblxuICAvLyBJZiBzaGlmdCBpcyBoZWxkIG9yIHRoZSBleHRlbmQgZmxhZyBpcyBzZXQsIGV4dGVuZHMgYSByYW5nZSB0b1xuICAvLyBpbmNsdWRlIGEgZ2l2ZW4gcG9zaXRpb24gKGFuZCBvcHRpb25hbGx5IGEgc2Vjb25kIHBvc2l0aW9uKS5cbiAgLy8gT3RoZXJ3aXNlLCBzaW1wbHkgcmV0dXJucyB0aGUgcmFuZ2UgYmV0d2VlbiB0aGUgZ2l2ZW4gcG9zaXRpb25zLlxuICAvLyBVc2VkIGZvciBjdXJzb3IgbW90aW9uIGFuZCBzdWNoLlxuICBmdW5jdGlvbiBleHRlbmRSYW5nZShyYW5nZSwgaGVhZCwgb3RoZXIsIGV4dGVuZCkge1xuICAgIGlmIChleHRlbmQpIHtcbiAgICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3I7XG4gICAgICBpZiAob3RoZXIpIHtcbiAgICAgICAgdmFyIHBvc0JlZm9yZSA9IGNtcChoZWFkLCBhbmNob3IpIDwgMDtcbiAgICAgICAgaWYgKHBvc0JlZm9yZSAhPSAoY21wKG90aGVyLCBhbmNob3IpIDwgMCkpIHtcbiAgICAgICAgICBhbmNob3IgPSBoZWFkO1xuICAgICAgICAgIGhlYWQgPSBvdGhlcjtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NCZWZvcmUgIT0gKGNtcChoZWFkLCBvdGhlcikgPCAwKSkge1xuICAgICAgICAgIGhlYWQgPSBvdGhlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBSYW5nZShhbmNob3IsIGhlYWQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgUmFuZ2Uob3RoZXIgfHwgaGVhZCwgaGVhZClcbiAgICB9XG4gIH1cblxuICAvLyBFeHRlbmQgdGhlIHByaW1hcnkgc2VsZWN0aW9uIHJhbmdlLCBkaXNjYXJkIHRoZSByZXN0LlxuICBmdW5jdGlvbiBleHRlbmRTZWxlY3Rpb24oZG9jLCBoZWFkLCBvdGhlciwgb3B0aW9ucywgZXh0ZW5kKSB7XG4gICAgaWYgKGV4dGVuZCA9PSBudWxsKSB7IGV4dGVuZCA9IGRvYy5jbSAmJiAoZG9jLmNtLmRpc3BsYXkuc2hpZnQgfHwgZG9jLmV4dGVuZCk7IH1cbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBuZXcgU2VsZWN0aW9uKFtleHRlbmRSYW5nZShkb2Muc2VsLnByaW1hcnkoKSwgaGVhZCwgb3RoZXIsIGV4dGVuZCldLCAwKSwgb3B0aW9ucyk7XG4gIH1cblxuICAvLyBFeHRlbmQgYWxsIHNlbGVjdGlvbnMgKHBvcyBpcyBhbiBhcnJheSBvZiBzZWxlY3Rpb25zIHdpdGggbGVuZ3RoXG4gIC8vIGVxdWFsIHRoZSBudW1iZXIgb2Ygc2VsZWN0aW9ucylcbiAgZnVuY3Rpb24gZXh0ZW5kU2VsZWN0aW9ucyhkb2MsIGhlYWRzLCBvcHRpb25zKSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHZhciBleHRlbmQgPSBkb2MuY20gJiYgKGRvYy5jbS5kaXNwbGF5LnNoaWZ0IHx8IGRvYy5leHRlbmQpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICB7IG91dFtpXSA9IGV4dGVuZFJhbmdlKGRvYy5zZWwucmFuZ2VzW2ldLCBoZWFkc1tpXSwgbnVsbCwgZXh0ZW5kKTsgfVxuICAgIHZhciBuZXdTZWwgPSBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCBvdXQsIGRvYy5zZWwucHJpbUluZGV4KTtcbiAgICBzZXRTZWxlY3Rpb24oZG9jLCBuZXdTZWwsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gVXBkYXRlcyBhIHNpbmdsZSByYW5nZSBpbiB0aGUgc2VsZWN0aW9uLlxuICBmdW5jdGlvbiByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgaSwgcmFuZ2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgcmFuZ2VzID0gZG9jLnNlbC5yYW5nZXMuc2xpY2UoMCk7XG4gICAgcmFuZ2VzW2ldID0gcmFuZ2U7XG4gICAgc2V0U2VsZWN0aW9uKGRvYywgbm9ybWFsaXplU2VsZWN0aW9uKGRvYy5jbSwgcmFuZ2VzLCBkb2Muc2VsLnByaW1JbmRleCksIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gUmVzZXQgdGhlIHNlbGVjdGlvbiB0byBhIHNpbmdsZSByYW5nZS5cbiAgZnVuY3Rpb24gc2V0U2ltcGxlU2VsZWN0aW9uKGRvYywgYW5jaG9yLCBoZWFkLCBvcHRpb25zKSB7XG4gICAgc2V0U2VsZWN0aW9uKGRvYywgc2ltcGxlU2VsZWN0aW9uKGFuY2hvciwgaGVhZCksIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gR2l2ZSBiZWZvcmVTZWxlY3Rpb25DaGFuZ2UgaGFuZGxlcnMgYSBjaGFuZ2UgdG8gaW5mbHVlbmNlIGFcbiAgLy8gc2VsZWN0aW9uIHVwZGF0ZS5cbiAgZnVuY3Rpb24gZmlsdGVyU2VsZWN0aW9uQ2hhbmdlKGRvYywgc2VsLCBvcHRpb25zKSB7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIHJhbmdlczogc2VsLnJhbmdlcyxcbiAgICAgIHVwZGF0ZTogZnVuY3Rpb24ocmFuZ2VzKSB7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgIHsgdGhpcy5yYW5nZXNbaV0gPSBuZXcgUmFuZ2UoY2xpcFBvcyhkb2MsIHJhbmdlc1tpXS5hbmNob3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBQb3MoZG9jLCByYW5nZXNbaV0uaGVhZCkpOyB9XG4gICAgICB9LFxuICAgICAgb3JpZ2luOiBvcHRpb25zICYmIG9wdGlvbnMub3JpZ2luXG4gICAgfTtcbiAgICBzaWduYWwoZG9jLCBcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiLCBkb2MsIG9iaik7XG4gICAgaWYgKGRvYy5jbSkgeyBzaWduYWwoZG9jLmNtLCBcImJlZm9yZVNlbGVjdGlvbkNoYW5nZVwiLCBkb2MuY20sIG9iaik7IH1cbiAgICBpZiAob2JqLnJhbmdlcyAhPSBzZWwucmFuZ2VzKSB7IHJldHVybiBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCBvYmoucmFuZ2VzLCBvYmoucmFuZ2VzLmxlbmd0aCAtIDEpIH1cbiAgICBlbHNlIHsgcmV0dXJuIHNlbCB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeShkb2MsIHNlbCwgb3B0aW9ucykge1xuICAgIHZhciBkb25lID0gZG9jLmhpc3RvcnkuZG9uZSwgbGFzdCA9IGxzdChkb25lKTtcbiAgICBpZiAobGFzdCAmJiBsYXN0LnJhbmdlcykge1xuICAgICAgZG9uZVtkb25lLmxlbmd0aCAtIDFdID0gc2VsO1xuICAgICAgc2V0U2VsZWN0aW9uTm9VbmRvKGRvYywgc2VsLCBvcHRpb25zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgc2VsLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvLyBTZXQgYSBuZXcgc2VsZWN0aW9uLlxuICBmdW5jdGlvbiBzZXRTZWxlY3Rpb24oZG9jLCBzZWwsIG9wdGlvbnMpIHtcbiAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWwsIG9wdGlvbnMpO1xuICAgIGFkZFNlbGVjdGlvblRvSGlzdG9yeShkb2MsIGRvYy5zZWwsIGRvYy5jbSA/IGRvYy5jbS5jdXJPcC5pZCA6IE5hTiwgb3B0aW9ucyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWwsIG9wdGlvbnMpIHtcbiAgICBpZiAoaGFzSGFuZGxlcihkb2MsIFwiYmVmb3JlU2VsZWN0aW9uQ2hhbmdlXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXCJiZWZvcmVTZWxlY3Rpb25DaGFuZ2VcIikpXG4gICAgICB7IHNlbCA9IGZpbHRlclNlbGVjdGlvbkNoYW5nZShkb2MsIHNlbCwgb3B0aW9ucyk7IH1cblxuICAgIHZhciBiaWFzID0gb3B0aW9ucyAmJiBvcHRpb25zLmJpYXMgfHxcbiAgICAgIChjbXAoc2VsLnByaW1hcnkoKS5oZWFkLCBkb2Muc2VsLnByaW1hcnkoKS5oZWFkKSA8IDAgPyAtMSA6IDEpO1xuICAgIHNldFNlbGVjdGlvbklubmVyKGRvYywgc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgc2VsLCBiaWFzLCB0cnVlKSk7XG5cbiAgICBpZiAoIShvcHRpb25zICYmIG9wdGlvbnMuc2Nyb2xsID09PSBmYWxzZSkgJiYgZG9jLmNtICYmIGRvYy5jbS5nZXRPcHRpb24oXCJyZWFkT25seVwiKSAhPSBcIm5vY3Vyc29yXCIpXG4gICAgICB7IGVuc3VyZUN1cnNvclZpc2libGUoZG9jLmNtKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0U2VsZWN0aW9uSW5uZXIoZG9jLCBzZWwpIHtcbiAgICBpZiAoc2VsLmVxdWFscyhkb2Muc2VsKSkgeyByZXR1cm4gfVxuXG4gICAgZG9jLnNlbCA9IHNlbDtcblxuICAgIGlmIChkb2MuY20pIHtcbiAgICAgIGRvYy5jbS5jdXJPcC51cGRhdGVJbnB1dCA9IDE7XG4gICAgICBkb2MuY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7XG4gICAgICBzaWduYWxDdXJzb3JBY3Rpdml0eShkb2MuY20pO1xuICAgIH1cbiAgICBzaWduYWxMYXRlcihkb2MsIFwiY3Vyc29yQWN0aXZpdHlcIiwgZG9jKTtcbiAgfVxuXG4gIC8vIFZlcmlmeSB0aGF0IHRoZSBzZWxlY3Rpb24gZG9lcyBub3QgcGFydGlhbGx5IHNlbGVjdCBhbnkgYXRvbWljXG4gIC8vIG1hcmtlZCByYW5nZXMuXG4gIGZ1bmN0aW9uIHJlQ2hlY2tTZWxlY3Rpb24oZG9jKSB7XG4gICAgc2V0U2VsZWN0aW9uSW5uZXIoZG9jLCBza2lwQXRvbWljSW5TZWxlY3Rpb24oZG9jLCBkb2Muc2VsLCBudWxsLCBmYWxzZSkpO1xuICB9XG5cbiAgLy8gUmV0dXJuIGEgc2VsZWN0aW9uIHRoYXQgZG9lcyBub3QgcGFydGlhbGx5IHNlbGVjdCBhbnkgYXRvbWljXG4gIC8vIHJhbmdlcy5cbiAgZnVuY3Rpb24gc2tpcEF0b21pY0luU2VsZWN0aW9uKGRvYywgc2VsLCBiaWFzLCBtYXlDbGVhcikge1xuICAgIHZhciBvdXQ7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgdmFyIG9sZCA9IHNlbC5yYW5nZXMubGVuZ3RoID09IGRvYy5zZWwucmFuZ2VzLmxlbmd0aCAmJiBkb2Muc2VsLnJhbmdlc1tpXTtcbiAgICAgIHZhciBuZXdBbmNob3IgPSBza2lwQXRvbWljKGRvYywgcmFuZ2UuYW5jaG9yLCBvbGQgJiYgb2xkLmFuY2hvciwgYmlhcywgbWF5Q2xlYXIpO1xuICAgICAgdmFyIG5ld0hlYWQgPSBza2lwQXRvbWljKGRvYywgcmFuZ2UuaGVhZCwgb2xkICYmIG9sZC5oZWFkLCBiaWFzLCBtYXlDbGVhcik7XG4gICAgICBpZiAob3V0IHx8IG5ld0FuY2hvciAhPSByYW5nZS5hbmNob3IgfHwgbmV3SGVhZCAhPSByYW5nZS5oZWFkKSB7XG4gICAgICAgIGlmICghb3V0KSB7IG91dCA9IHNlbC5yYW5nZXMuc2xpY2UoMCwgaSk7IH1cbiAgICAgICAgb3V0W2ldID0gbmV3IFJhbmdlKG5ld0FuY2hvciwgbmV3SGVhZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQgPyBub3JtYWxpemVTZWxlY3Rpb24oZG9jLmNtLCBvdXQsIHNlbC5wcmltSW5kZXgpIDogc2VsXG4gIH1cblxuICBmdW5jdGlvbiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgZGlyLCBtYXlDbGVhcikge1xuICAgIHZhciBsaW5lID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKTtcbiAgICBpZiAobGluZS5tYXJrZWRTcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubWFya2VkU3BhbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBzcCA9IGxpbmUubWFya2VkU3BhbnNbaV0sIG0gPSBzcC5tYXJrZXI7XG5cbiAgICAgIC8vIERldGVybWluZSBpZiB3ZSBzaG91bGQgcHJldmVudCB0aGUgY3Vyc29yIGJlaW5nIHBsYWNlZCB0byB0aGUgbGVmdC9yaWdodCBvZiBhbiBhdG9taWMgbWFya2VyXG4gICAgICAvLyBIaXN0b3JpY2FsbHkgdGhpcyB3YXMgZGV0ZXJtaW5lZCB1c2luZyB0aGUgaW5jbHVzaXZlTGVmdC9SaWdodCBvcHRpb24sIGJ1dCB0aGUgbmV3IHdheSB0byBjb250cm9sIGl0XG4gICAgICAvLyBpcyB3aXRoIHNlbGVjdExlZnQvUmlnaHRcbiAgICAgIHZhciBwcmV2ZW50Q3Vyc29yTGVmdCA9IChcInNlbGVjdExlZnRcIiBpbiBtKSA/ICFtLnNlbGVjdExlZnQgOiBtLmluY2x1c2l2ZUxlZnQ7XG4gICAgICB2YXIgcHJldmVudEN1cnNvclJpZ2h0ID0gKFwic2VsZWN0UmlnaHRcIiBpbiBtKSA/ICFtLnNlbGVjdFJpZ2h0IDogbS5pbmNsdXNpdmVSaWdodDtcblxuICAgICAgaWYgKChzcC5mcm9tID09IG51bGwgfHwgKHByZXZlbnRDdXJzb3JMZWZ0ID8gc3AuZnJvbSA8PSBwb3MuY2ggOiBzcC5mcm9tIDwgcG9zLmNoKSkgJiZcbiAgICAgICAgICAoc3AudG8gPT0gbnVsbCB8fCAocHJldmVudEN1cnNvclJpZ2h0ID8gc3AudG8gPj0gcG9zLmNoIDogc3AudG8gPiBwb3MuY2gpKSkge1xuICAgICAgICBpZiAobWF5Q2xlYXIpIHtcbiAgICAgICAgICBzaWduYWwobSwgXCJiZWZvcmVDdXJzb3JFbnRlclwiKTtcbiAgICAgICAgICBpZiAobS5leHBsaWNpdGx5Q2xlYXJlZCkge1xuICAgICAgICAgICAgaWYgKCFsaW5lLm1hcmtlZFNwYW5zKSB7IGJyZWFrIH1cbiAgICAgICAgICAgIGVsc2Ugey0taTsgY29udGludWV9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbS5hdG9taWMpIHsgY29udGludWUgfVxuXG4gICAgICAgIGlmIChvbGRQb3MpIHtcbiAgICAgICAgICB2YXIgbmVhciA9IG0uZmluZChkaXIgPCAwID8gMSA6IC0xKSwgZGlmZiA9ICh2b2lkIDApO1xuICAgICAgICAgIGlmIChkaXIgPCAwID8gcHJldmVudEN1cnNvclJpZ2h0IDogcHJldmVudEN1cnNvckxlZnQpXG4gICAgICAgICAgICB7IG5lYXIgPSBtb3ZlUG9zKGRvYywgbmVhciwgLWRpciwgbmVhciAmJiBuZWFyLmxpbmUgPT0gcG9zLmxpbmUgPyBsaW5lIDogbnVsbCk7IH1cbiAgICAgICAgICBpZiAobmVhciAmJiBuZWFyLmxpbmUgPT0gcG9zLmxpbmUgJiYgKGRpZmYgPSBjbXAobmVhciwgb2xkUG9zKSkgJiYgKGRpciA8IDAgPyBkaWZmIDwgMCA6IGRpZmYgPiAwKSlcbiAgICAgICAgICAgIHsgcmV0dXJuIHNraXBBdG9taWNJbm5lcihkb2MsIG5lYXIsIHBvcywgZGlyLCBtYXlDbGVhcikgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZhciA9IG0uZmluZChkaXIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgaWYgKGRpciA8IDAgPyBwcmV2ZW50Q3Vyc29yTGVmdCA6IHByZXZlbnRDdXJzb3JSaWdodClcbiAgICAgICAgICB7IGZhciA9IG1vdmVQb3MoZG9jLCBmYXIsIGRpciwgZmFyLmxpbmUgPT0gcG9zLmxpbmUgPyBsaW5lIDogbnVsbCk7IH1cbiAgICAgICAgcmV0dXJuIGZhciA/IHNraXBBdG9taWNJbm5lcihkb2MsIGZhciwgcG9zLCBkaXIsIG1heUNsZWFyKSA6IG51bGxcbiAgICAgIH1cbiAgICB9IH1cbiAgICByZXR1cm4gcG9zXG4gIH1cblxuICAvLyBFbnN1cmUgYSBnaXZlbiBwb3NpdGlvbiBpcyBub3QgaW5zaWRlIGFuIGF0b21pYyByYW5nZS5cbiAgZnVuY3Rpb24gc2tpcEF0b21pYyhkb2MsIHBvcywgb2xkUG9zLCBiaWFzLCBtYXlDbGVhcikge1xuICAgIHZhciBkaXIgPSBiaWFzIHx8IDE7XG4gICAgdmFyIGZvdW5kID0gc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIGRpciwgbWF5Q2xlYXIpIHx8XG4gICAgICAgICghbWF5Q2xlYXIgJiYgc2tpcEF0b21pY0lubmVyKGRvYywgcG9zLCBvbGRQb3MsIGRpciwgdHJ1ZSkpIHx8XG4gICAgICAgIHNraXBBdG9taWNJbm5lcihkb2MsIHBvcywgb2xkUG9zLCAtZGlyLCBtYXlDbGVhcikgfHxcbiAgICAgICAgKCFtYXlDbGVhciAmJiBza2lwQXRvbWljSW5uZXIoZG9jLCBwb3MsIG9sZFBvcywgLWRpciwgdHJ1ZSkpO1xuICAgIGlmICghZm91bmQpIHtcbiAgICAgIGRvYy5jYW50RWRpdCA9IHRydWU7XG4gICAgICByZXR1cm4gUG9zKGRvYy5maXJzdCwgMClcbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kXG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlUG9zKGRvYywgcG9zLCBkaXIsIGxpbmUpIHtcbiAgICBpZiAoZGlyIDwgMCAmJiBwb3MuY2ggPT0gMCkge1xuICAgICAgaWYgKHBvcy5saW5lID4gZG9jLmZpcnN0KSB7IHJldHVybiBjbGlwUG9zKGRvYywgUG9zKHBvcy5saW5lIC0gMSkpIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gbnVsbCB9XG4gICAgfSBlbHNlIGlmIChkaXIgPiAwICYmIHBvcy5jaCA9PSAobGluZSB8fCBnZXRMaW5lKGRvYywgcG9zLmxpbmUpKS50ZXh0Lmxlbmd0aCkge1xuICAgICAgaWYgKHBvcy5saW5lIDwgZG9jLmZpcnN0ICsgZG9jLnNpemUgLSAxKSB7IHJldHVybiBQb3MocG9zLmxpbmUgKyAxLCAwKSB9XG4gICAgICBlbHNlIHsgcmV0dXJuIG51bGwgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFBvcyhwb3MubGluZSwgcG9zLmNoICsgZGlyKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNlbGVjdEFsbChjbSkge1xuICAgIGNtLnNldFNlbGVjdGlvbihQb3MoY20uZmlyc3RMaW5lKCksIDApLCBQb3MoY20ubGFzdExpbmUoKSksIHNlbF9kb250U2Nyb2xsKTtcbiAgfVxuXG4gIC8vIFVQREFUSU5HXG5cbiAgLy8gQWxsb3cgXCJiZWZvcmVDaGFuZ2VcIiBldmVudCBoYW5kbGVycyB0byBpbmZsdWVuY2UgYSBjaGFuZ2VcbiAgZnVuY3Rpb24gZmlsdGVyQ2hhbmdlKGRvYywgY2hhbmdlLCB1cGRhdGUpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgY2FuY2VsZWQ6IGZhbHNlLFxuICAgICAgZnJvbTogY2hhbmdlLmZyb20sXG4gICAgICB0bzogY2hhbmdlLnRvLFxuICAgICAgdGV4dDogY2hhbmdlLnRleHQsXG4gICAgICBvcmlnaW46IGNoYW5nZS5vcmlnaW4sXG4gICAgICBjYW5jZWw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9iai5jYW5jZWxlZCA9IHRydWU7IH1cbiAgICB9O1xuICAgIGlmICh1cGRhdGUpIHsgb2JqLnVwZGF0ZSA9IGZ1bmN0aW9uIChmcm9tLCB0bywgdGV4dCwgb3JpZ2luKSB7XG4gICAgICBpZiAoZnJvbSkgeyBvYmouZnJvbSA9IGNsaXBQb3MoZG9jLCBmcm9tKTsgfVxuICAgICAgaWYgKHRvKSB7IG9iai50byA9IGNsaXBQb3MoZG9jLCB0byk7IH1cbiAgICAgIGlmICh0ZXh0KSB7IG9iai50ZXh0ID0gdGV4dDsgfVxuICAgICAgaWYgKG9yaWdpbiAhPT0gdW5kZWZpbmVkKSB7IG9iai5vcmlnaW4gPSBvcmlnaW47IH1cbiAgICB9OyB9XG4gICAgc2lnbmFsKGRvYywgXCJiZWZvcmVDaGFuZ2VcIiwgZG9jLCBvYmopO1xuICAgIGlmIChkb2MuY20pIHsgc2lnbmFsKGRvYy5jbSwgXCJiZWZvcmVDaGFuZ2VcIiwgZG9jLmNtLCBvYmopOyB9XG5cbiAgICBpZiAob2JqLmNhbmNlbGVkKSB7XG4gICAgICBpZiAoZG9jLmNtKSB7IGRvYy5jbS5jdXJPcC51cGRhdGVJbnB1dCA9IDI7IH1cbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHJldHVybiB7ZnJvbTogb2JqLmZyb20sIHRvOiBvYmoudG8sIHRleHQ6IG9iai50ZXh0LCBvcmlnaW46IG9iai5vcmlnaW59XG4gIH1cblxuICAvLyBBcHBseSBhIGNoYW5nZSB0byBhIGRvY3VtZW50LCBhbmQgYWRkIGl0IHRvIHRoZSBkb2N1bWVudCdzXG4gIC8vIGhpc3RvcnksIGFuZCBwcm9wYWdhdGluZyBpdCB0byBhbGwgbGlua2VkIGRvY3VtZW50cy5cbiAgZnVuY3Rpb24gbWFrZUNoYW5nZShkb2MsIGNoYW5nZSwgaWdub3JlUmVhZE9ubHkpIHtcbiAgICBpZiAoZG9jLmNtKSB7XG4gICAgICBpZiAoIWRvYy5jbS5jdXJPcCkgeyByZXR1cm4gb3BlcmF0aW9uKGRvYy5jbSwgbWFrZUNoYW5nZSkoZG9jLCBjaGFuZ2UsIGlnbm9yZVJlYWRPbmx5KSB9XG4gICAgICBpZiAoZG9jLmNtLnN0YXRlLnN1cHByZXNzRWRpdHMpIHsgcmV0dXJuIH1cbiAgICB9XG5cbiAgICBpZiAoaGFzSGFuZGxlcihkb2MsIFwiYmVmb3JlQ2hhbmdlXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXCJiZWZvcmVDaGFuZ2VcIikpIHtcbiAgICAgIGNoYW5nZSA9IGZpbHRlckNoYW5nZShkb2MsIGNoYW5nZSwgdHJ1ZSk7XG4gICAgICBpZiAoIWNoYW5nZSkgeyByZXR1cm4gfVxuICAgIH1cblxuICAgIC8vIFBvc3NpYmx5IHNwbGl0IG9yIHN1cHByZXNzIHRoZSB1cGRhdGUgYmFzZWQgb24gdGhlIHByZXNlbmNlXG4gICAgLy8gb2YgcmVhZC1vbmx5IHNwYW5zIGluIGl0cyByYW5nZS5cbiAgICB2YXIgc3BsaXQgPSBzYXdSZWFkT25seVNwYW5zICYmICFpZ25vcmVSZWFkT25seSAmJiByZW1vdmVSZWFkT25seVJhbmdlcyhkb2MsIGNoYW5nZS5mcm9tLCBjaGFuZ2UudG8pO1xuICAgIGlmIChzcGxpdCkge1xuICAgICAgZm9yICh2YXIgaSA9IHNwbGl0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKVxuICAgICAgICB7IG1ha2VDaGFuZ2VJbm5lcihkb2MsIHtmcm9tOiBzcGxpdFtpXS5mcm9tLCB0bzogc3BsaXRbaV0udG8sIHRleHQ6IGkgPyBbXCJcIl0gOiBjaGFuZ2UudGV4dCwgb3JpZ2luOiBjaGFuZ2Uub3JpZ2lufSk7IH1cbiAgICB9IGVsc2Uge1xuICAgICAgbWFrZUNoYW5nZUlubmVyKGRvYywgY2hhbmdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlSW5uZXIoZG9jLCBjaGFuZ2UpIHtcbiAgICBpZiAoY2hhbmdlLnRleHQubGVuZ3RoID09IDEgJiYgY2hhbmdlLnRleHRbMF0gPT0gXCJcIiAmJiBjbXAoY2hhbmdlLmZyb20sIGNoYW5nZS50bykgPT0gMCkgeyByZXR1cm4gfVxuICAgIHZhciBzZWxBZnRlciA9IGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSk7XG4gICAgYWRkQ2hhbmdlVG9IaXN0b3J5KGRvYywgY2hhbmdlLCBzZWxBZnRlciwgZG9jLmNtID8gZG9jLmNtLmN1ck9wLmlkIDogTmFOKTtcblxuICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIHNlbEFmdGVyLCBzdHJldGNoU3BhbnNPdmVyQ2hhbmdlKGRvYywgY2hhbmdlKSk7XG4gICAgdmFyIHJlYmFzZWQgPSBbXTtcblxuICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbiAoZG9jLCBzaGFyZWRIaXN0KSB7XG4gICAgICBpZiAoIXNoYXJlZEhpc3QgJiYgaW5kZXhPZihyZWJhc2VkLCBkb2MuaGlzdG9yeSkgPT0gLTEpIHtcbiAgICAgICAgcmViYXNlSGlzdChkb2MuaGlzdG9yeSwgY2hhbmdlKTtcbiAgICAgICAgcmViYXNlZC5wdXNoKGRvYy5oaXN0b3J5KTtcbiAgICAgIH1cbiAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIG51bGwsIHN0cmV0Y2hTcGFuc092ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFJldmVydCBhIGNoYW5nZSBzdG9yZWQgaW4gYSBkb2N1bWVudCdzIGhpc3RvcnkuXG4gIGZ1bmN0aW9uIG1ha2VDaGFuZ2VGcm9tSGlzdG9yeShkb2MsIHR5cGUsIGFsbG93U2VsZWN0aW9uT25seSkge1xuICAgIHZhciBzdXBwcmVzcyA9IGRvYy5jbSAmJiBkb2MuY20uc3RhdGUuc3VwcHJlc3NFZGl0cztcbiAgICBpZiAoc3VwcHJlc3MgJiYgIWFsbG93U2VsZWN0aW9uT25seSkgeyByZXR1cm4gfVxuXG4gICAgdmFyIGhpc3QgPSBkb2MuaGlzdG9yeSwgZXZlbnQsIHNlbEFmdGVyID0gZG9jLnNlbDtcbiAgICB2YXIgc291cmNlID0gdHlwZSA9PSBcInVuZG9cIiA/IGhpc3QuZG9uZSA6IGhpc3QudW5kb25lLCBkZXN0ID0gdHlwZSA9PSBcInVuZG9cIiA/IGhpc3QudW5kb25lIDogaGlzdC5kb25lO1xuXG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlcmUgaXMgYSB1c2VhYmxlIGV2ZW50IChzbyB0aGF0IGN0cmwteiB3b24ndFxuICAgIC8vIG5lZWRsZXNzbHkgY2xlYXIgc2VsZWN0aW9uIGV2ZW50cylcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yICg7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgIGV2ZW50ID0gc291cmNlW2ldO1xuICAgICAgaWYgKGFsbG93U2VsZWN0aW9uT25seSA/IGV2ZW50LnJhbmdlcyAmJiAhZXZlbnQuZXF1YWxzKGRvYy5zZWwpIDogIWV2ZW50LnJhbmdlcylcbiAgICAgICAgeyBicmVhayB9XG4gICAgfVxuICAgIGlmIChpID09IHNvdXJjZS5sZW5ndGgpIHsgcmV0dXJuIH1cbiAgICBoaXN0Lmxhc3RPcmlnaW4gPSBoaXN0Lmxhc3RTZWxPcmlnaW4gPSBudWxsO1xuXG4gICAgZm9yICg7Oykge1xuICAgICAgZXZlbnQgPSBzb3VyY2UucG9wKCk7XG4gICAgICBpZiAoZXZlbnQucmFuZ2VzKSB7XG4gICAgICAgIHB1c2hTZWxlY3Rpb25Ub0hpc3RvcnkoZXZlbnQsIGRlc3QpO1xuICAgICAgICBpZiAoYWxsb3dTZWxlY3Rpb25Pbmx5ICYmICFldmVudC5lcXVhbHMoZG9jLnNlbCkpIHtcbiAgICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBldmVudCwge2NsZWFyUmVkbzogZmFsc2V9KTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBzZWxBZnRlciA9IGV2ZW50O1xuICAgICAgfSBlbHNlIGlmIChzdXBwcmVzcykge1xuICAgICAgICBzb3VyY2UucHVzaChldmVudCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfSBlbHNlIHsgYnJlYWsgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIHVwIGEgcmV2ZXJzZSBjaGFuZ2Ugb2JqZWN0IHRvIGFkZCB0byB0aGUgb3Bwb3NpdGUgaGlzdG9yeVxuICAgIC8vIHN0YWNrIChyZWRvIHdoZW4gdW5kb2luZywgYW5kIHZpY2UgdmVyc2EpLlxuICAgIHZhciBhbnRpQ2hhbmdlcyA9IFtdO1xuICAgIHB1c2hTZWxlY3Rpb25Ub0hpc3Rvcnkoc2VsQWZ0ZXIsIGRlc3QpO1xuICAgIGRlc3QucHVzaCh7Y2hhbmdlczogYW50aUNoYW5nZXMsIGdlbmVyYXRpb246IGhpc3QuZ2VuZXJhdGlvbn0pO1xuICAgIGhpc3QuZ2VuZXJhdGlvbiA9IGV2ZW50LmdlbmVyYXRpb24gfHwgKytoaXN0Lm1heEdlbmVyYXRpb247XG5cbiAgICB2YXIgZmlsdGVyID0gaGFzSGFuZGxlcihkb2MsIFwiYmVmb3JlQ2hhbmdlXCIpIHx8IGRvYy5jbSAmJiBoYXNIYW5kbGVyKGRvYy5jbSwgXCJiZWZvcmVDaGFuZ2VcIik7XG5cbiAgICB2YXIgbG9vcCA9IGZ1bmN0aW9uICggaSApIHtcbiAgICAgIHZhciBjaGFuZ2UgPSBldmVudC5jaGFuZ2VzW2ldO1xuICAgICAgY2hhbmdlLm9yaWdpbiA9IHR5cGU7XG4gICAgICBpZiAoZmlsdGVyICYmICFmaWx0ZXJDaGFuZ2UoZG9jLCBjaGFuZ2UsIGZhbHNlKSkge1xuICAgICAgICBzb3VyY2UubGVuZ3RoID0gMDtcbiAgICAgICAgcmV0dXJuIHt9XG4gICAgICB9XG5cbiAgICAgIGFudGlDaGFuZ2VzLnB1c2goaGlzdG9yeUNoYW5nZUZyb21DaGFuZ2UoZG9jLCBjaGFuZ2UpKTtcblxuICAgICAgdmFyIGFmdGVyID0gaSA/IGNvbXB1dGVTZWxBZnRlckNoYW5nZShkb2MsIGNoYW5nZSkgOiBsc3Qoc291cmNlKTtcbiAgICAgIG1ha2VDaGFuZ2VTaW5nbGVEb2MoZG9jLCBjaGFuZ2UsIGFmdGVyLCBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSk7XG4gICAgICBpZiAoIWkgJiYgZG9jLmNtKSB7IGRvYy5jbS5zY3JvbGxJbnRvVmlldyh7ZnJvbTogY2hhbmdlLmZyb20sIHRvOiBjaGFuZ2VFbmQoY2hhbmdlKX0pOyB9XG4gICAgICB2YXIgcmViYXNlZCA9IFtdO1xuXG4gICAgICAvLyBQcm9wYWdhdGUgdG8gdGhlIGxpbmtlZCBkb2N1bWVudHNcbiAgICAgIGxpbmtlZERvY3MoZG9jLCBmdW5jdGlvbiAoZG9jLCBzaGFyZWRIaXN0KSB7XG4gICAgICAgIGlmICghc2hhcmVkSGlzdCAmJiBpbmRleE9mKHJlYmFzZWQsIGRvYy5oaXN0b3J5KSA9PSAtMSkge1xuICAgICAgICAgIHJlYmFzZUhpc3QoZG9jLmhpc3RvcnksIGNoYW5nZSk7XG4gICAgICAgICAgcmViYXNlZC5wdXNoKGRvYy5oaXN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBudWxsLCBtZXJnZU9sZFNwYW5zKGRvYywgY2hhbmdlKSk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSQxID0gZXZlbnQuY2hhbmdlcy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgLS1pJDEpIHtcbiAgICAgIHZhciByZXR1cm5lZCA9IGxvb3AoIGkkMSApO1xuXG4gICAgICBpZiAoIHJldHVybmVkICkgcmV0dXJuIHJldHVybmVkLnY7XG4gICAgfVxuICB9XG5cbiAgLy8gU3ViLXZpZXdzIG5lZWQgdGhlaXIgbGluZSBudW1iZXJzIHNoaWZ0ZWQgd2hlbiB0ZXh0IGlzIGFkZGVkXG4gIC8vIGFib3ZlIG9yIGJlbG93IHRoZW0gaW4gdGhlIHBhcmVudCBkb2N1bWVudC5cbiAgZnVuY3Rpb24gc2hpZnREb2MoZG9jLCBkaXN0YW5jZSkge1xuICAgIGlmIChkaXN0YW5jZSA9PSAwKSB7IHJldHVybiB9XG4gICAgZG9jLmZpcnN0ICs9IGRpc3RhbmNlO1xuICAgIGRvYy5zZWwgPSBuZXcgU2VsZWN0aW9uKG1hcChkb2Muc2VsLnJhbmdlcywgZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBuZXcgUmFuZ2UoXG4gICAgICBQb3MocmFuZ2UuYW5jaG9yLmxpbmUgKyBkaXN0YW5jZSwgcmFuZ2UuYW5jaG9yLmNoKSxcbiAgICAgIFBvcyhyYW5nZS5oZWFkLmxpbmUgKyBkaXN0YW5jZSwgcmFuZ2UuaGVhZC5jaClcbiAgICApOyB9KSwgZG9jLnNlbC5wcmltSW5kZXgpO1xuICAgIGlmIChkb2MuY20pIHtcbiAgICAgIHJlZ0NoYW5nZShkb2MuY20sIGRvYy5maXJzdCwgZG9jLmZpcnN0IC0gZGlzdGFuY2UsIGRpc3RhbmNlKTtcbiAgICAgIGZvciAodmFyIGQgPSBkb2MuY20uZGlzcGxheSwgbCA9IGQudmlld0Zyb207IGwgPCBkLnZpZXdUbzsgbCsrKVxuICAgICAgICB7IHJlZ0xpbmVDaGFuZ2UoZG9jLmNtLCBsLCBcImd1dHRlclwiKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIE1vcmUgbG93ZXItbGV2ZWwgY2hhbmdlIGZ1bmN0aW9uLCBoYW5kbGluZyBvbmx5IGEgc2luZ2xlIGRvY3VtZW50XG4gIC8vIChub3QgbGlua2VkIG9uZXMpLlxuICBmdW5jdGlvbiBtYWtlQ2hhbmdlU2luZ2xlRG9jKGRvYywgY2hhbmdlLCBzZWxBZnRlciwgc3BhbnMpIHtcbiAgICBpZiAoZG9jLmNtICYmICFkb2MuY20uY3VyT3ApXG4gICAgICB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYWtlQ2hhbmdlU2luZ2xlRG9jKShkb2MsIGNoYW5nZSwgc2VsQWZ0ZXIsIHNwYW5zKSB9XG5cbiAgICBpZiAoY2hhbmdlLnRvLmxpbmUgPCBkb2MuZmlyc3QpIHtcbiAgICAgIHNoaWZ0RG9jKGRvYywgY2hhbmdlLnRleHQubGVuZ3RoIC0gMSAtIChjaGFuZ2UudG8ubGluZSAtIGNoYW5nZS5mcm9tLmxpbmUpKTtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoY2hhbmdlLmZyb20ubGluZSA+IGRvYy5sYXN0TGluZSgpKSB7IHJldHVybiB9XG5cbiAgICAvLyBDbGlwIHRoZSBjaGFuZ2UgdG8gdGhlIHNpemUgb2YgdGhpcyBkb2NcbiAgICBpZiAoY2hhbmdlLmZyb20ubGluZSA8IGRvYy5maXJzdCkge1xuICAgICAgdmFyIHNoaWZ0ID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gMSAtIChkb2MuZmlyc3QgLSBjaGFuZ2UuZnJvbS5saW5lKTtcbiAgICAgIHNoaWZ0RG9jKGRvYywgc2hpZnQpO1xuICAgICAgY2hhbmdlID0ge2Zyb206IFBvcyhkb2MuZmlyc3QsIDApLCB0bzogUG9zKGNoYW5nZS50by5saW5lICsgc2hpZnQsIGNoYW5nZS50by5jaCksXG4gICAgICAgICAgICAgICAgdGV4dDogW2xzdChjaGFuZ2UudGV4dCldLCBvcmlnaW46IGNoYW5nZS5vcmlnaW59O1xuICAgIH1cbiAgICB2YXIgbGFzdCA9IGRvYy5sYXN0TGluZSgpO1xuICAgIGlmIChjaGFuZ2UudG8ubGluZSA+IGxhc3QpIHtcbiAgICAgIGNoYW5nZSA9IHtmcm9tOiBjaGFuZ2UuZnJvbSwgdG86IFBvcyhsYXN0LCBnZXRMaW5lKGRvYywgbGFzdCkudGV4dC5sZW5ndGgpLFxuICAgICAgICAgICAgICAgIHRleHQ6IFtjaGFuZ2UudGV4dFswXV0sIG9yaWdpbjogY2hhbmdlLm9yaWdpbn07XG4gICAgfVxuXG4gICAgY2hhbmdlLnJlbW92ZWQgPSBnZXRCZXR3ZWVuKGRvYywgY2hhbmdlLmZyb20sIGNoYW5nZS50byk7XG5cbiAgICBpZiAoIXNlbEFmdGVyKSB7IHNlbEFmdGVyID0gY29tcHV0ZVNlbEFmdGVyQ2hhbmdlKGRvYywgY2hhbmdlKTsgfVxuICAgIGlmIChkb2MuY20pIHsgbWFrZUNoYW5nZVNpbmdsZURvY0luRWRpdG9yKGRvYy5jbSwgY2hhbmdlLCBzcGFucyk7IH1cbiAgICBlbHNlIHsgdXBkYXRlRG9jKGRvYywgY2hhbmdlLCBzcGFucyk7IH1cbiAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oZG9jLCBzZWxBZnRlciwgc2VsX2RvbnRTY3JvbGwpO1xuXG4gICAgaWYgKGRvYy5jYW50RWRpdCAmJiBza2lwQXRvbWljKGRvYywgUG9zKGRvYy5maXJzdExpbmUoKSwgMCkpKVxuICAgICAgeyBkb2MuY2FudEVkaXQgPSBmYWxzZTsgfVxuICB9XG5cbiAgLy8gSGFuZGxlIHRoZSBpbnRlcmFjdGlvbiBvZiBhIGNoYW5nZSB0byBhIGRvY3VtZW50IHdpdGggdGhlIGVkaXRvclxuICAvLyB0aGF0IHRoaXMgZG9jdW1lbnQgaXMgcGFydCBvZi5cbiAgZnVuY3Rpb24gbWFrZUNoYW5nZVNpbmdsZURvY0luRWRpdG9yKGNtLCBjaGFuZ2UsIHNwYW5zKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgZGlzcGxheSA9IGNtLmRpc3BsYXksIGZyb20gPSBjaGFuZ2UuZnJvbSwgdG8gPSBjaGFuZ2UudG87XG5cbiAgICB2YXIgcmVjb21wdXRlTWF4TGVuZ3RoID0gZmFsc2UsIGNoZWNrV2lkdGhTdGFydCA9IGZyb20ubGluZTtcbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICBjaGVja1dpZHRoU3RhcnQgPSBsaW5lTm8odmlzdWFsTGluZShnZXRMaW5lKGRvYywgZnJvbS5saW5lKSkpO1xuICAgICAgZG9jLml0ZXIoY2hlY2tXaWR0aFN0YXJ0LCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgaWYgKGxpbmUgPT0gZGlzcGxheS5tYXhMaW5lKSB7XG4gICAgICAgICAgcmVjb21wdXRlTWF4TGVuZ3RoID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZG9jLnNlbC5jb250YWlucyhjaGFuZ2UuZnJvbSwgY2hhbmdlLnRvKSA+IC0xKVxuICAgICAgeyBzaWduYWxDdXJzb3JBY3Rpdml0eShjbSk7IH1cblxuICAgIHVwZGF0ZURvYyhkb2MsIGNoYW5nZSwgc3BhbnMsIGVzdGltYXRlSGVpZ2h0KGNtKSk7XG5cbiAgICBpZiAoIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7XG4gICAgICBkb2MuaXRlcihjaGVja1dpZHRoU3RhcnQsIGZyb20ubGluZSArIGNoYW5nZS50ZXh0Lmxlbmd0aCwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIGxlbiA9IGxpbmVMZW5ndGgobGluZSk7XG4gICAgICAgIGlmIChsZW4gPiBkaXNwbGF5Lm1heExpbmVMZW5ndGgpIHtcbiAgICAgICAgICBkaXNwbGF5Lm1heExpbmUgPSBsaW5lO1xuICAgICAgICAgIGRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGxlbjtcbiAgICAgICAgICBkaXNwbGF5Lm1heExpbmVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICByZWNvbXB1dGVNYXhMZW5ndGggPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAocmVjb21wdXRlTWF4TGVuZ3RoKSB7IGNtLmN1ck9wLnVwZGF0ZU1heExpbmUgPSB0cnVlOyB9XG4gICAgfVxuXG4gICAgcmV0cmVhdEZyb250aWVyKGRvYywgZnJvbS5saW5lKTtcbiAgICBzdGFydFdvcmtlcihjbSwgNDAwKTtcblxuICAgIHZhciBsZW5kaWZmID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gKHRvLmxpbmUgLSBmcm9tLmxpbmUpIC0gMTtcbiAgICAvLyBSZW1lbWJlciB0aGF0IHRoZXNlIGxpbmVzIGNoYW5nZWQsIGZvciB1cGRhdGluZyB0aGUgZGlzcGxheVxuICAgIGlmIChjaGFuZ2UuZnVsbClcbiAgICAgIHsgcmVnQ2hhbmdlKGNtKTsgfVxuICAgIGVsc2UgaWYgKGZyb20ubGluZSA9PSB0by5saW5lICYmIGNoYW5nZS50ZXh0Lmxlbmd0aCA9PSAxICYmICFpc1dob2xlTGluZVVwZGF0ZShjbS5kb2MsIGNoYW5nZSkpXG4gICAgICB7IHJlZ0xpbmVDaGFuZ2UoY20sIGZyb20ubGluZSwgXCJ0ZXh0XCIpOyB9XG4gICAgZWxzZVxuICAgICAgeyByZWdDaGFuZ2UoY20sIGZyb20ubGluZSwgdG8ubGluZSArIDEsIGxlbmRpZmYpOyB9XG5cbiAgICB2YXIgY2hhbmdlc0hhbmRsZXIgPSBoYXNIYW5kbGVyKGNtLCBcImNoYW5nZXNcIiksIGNoYW5nZUhhbmRsZXIgPSBoYXNIYW5kbGVyKGNtLCBcImNoYW5nZVwiKTtcbiAgICBpZiAoY2hhbmdlSGFuZGxlciB8fCBjaGFuZ2VzSGFuZGxlcikge1xuICAgICAgdmFyIG9iaiA9IHtcbiAgICAgICAgZnJvbTogZnJvbSwgdG86IHRvLFxuICAgICAgICB0ZXh0OiBjaGFuZ2UudGV4dCxcbiAgICAgICAgcmVtb3ZlZDogY2hhbmdlLnJlbW92ZWQsXG4gICAgICAgIG9yaWdpbjogY2hhbmdlLm9yaWdpblxuICAgICAgfTtcbiAgICAgIGlmIChjaGFuZ2VIYW5kbGVyKSB7IHNpZ25hbExhdGVyKGNtLCBcImNoYW5nZVwiLCBjbSwgb2JqKTsgfVxuICAgICAgaWYgKGNoYW5nZXNIYW5kbGVyKSB7IChjbS5jdXJPcC5jaGFuZ2VPYmpzIHx8IChjbS5jdXJPcC5jaGFuZ2VPYmpzID0gW10pKS5wdXNoKG9iaik7IH1cbiAgICB9XG4gICAgY20uZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlUmFuZ2UoZG9jLCBjb2RlLCBmcm9tLCB0bywgb3JpZ2luKSB7XG4gICAgdmFyIGFzc2lnbjtcblxuICAgIGlmICghdG8pIHsgdG8gPSBmcm9tOyB9XG4gICAgaWYgKGNtcCh0bywgZnJvbSkgPCAwKSB7IChhc3NpZ24gPSBbdG8sIGZyb21dLCBmcm9tID0gYXNzaWduWzBdLCB0byA9IGFzc2lnblsxXSk7IH1cbiAgICBpZiAodHlwZW9mIGNvZGUgPT0gXCJzdHJpbmdcIikgeyBjb2RlID0gZG9jLnNwbGl0TGluZXMoY29kZSk7IH1cbiAgICBtYWtlQ2hhbmdlKGRvYywge2Zyb206IGZyb20sIHRvOiB0bywgdGV4dDogY29kZSwgb3JpZ2luOiBvcmlnaW59KTtcbiAgfVxuXG4gIC8vIFJlYmFzaW5nL3Jlc2V0dGluZyBoaXN0b3J5IHRvIGRlYWwgd2l0aCBleHRlcm5hbGx5LXNvdXJjZWQgY2hhbmdlc1xuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3RTZWxTaW5nbGUocG9zLCBmcm9tLCB0bywgZGlmZikge1xuICAgIGlmICh0byA8IHBvcy5saW5lKSB7XG4gICAgICBwb3MubGluZSArPSBkaWZmO1xuICAgIH0gZWxzZSBpZiAoZnJvbSA8IHBvcy5saW5lKSB7XG4gICAgICBwb3MubGluZSA9IGZyb207XG4gICAgICBwb3MuY2ggPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRyaWVzIHRvIHJlYmFzZSBhbiBhcnJheSBvZiBoaXN0b3J5IGV2ZW50cyBnaXZlbiBhIGNoYW5nZSBpbiB0aGVcbiAgLy8gZG9jdW1lbnQuIElmIHRoZSBjaGFuZ2UgdG91Y2hlcyB0aGUgc2FtZSBsaW5lcyBhcyB0aGUgZXZlbnQsIHRoZVxuICAvLyBldmVudCwgYW5kIGV2ZXJ5dGhpbmcgJ2JlaGluZCcgaXQsIGlzIGRpc2NhcmRlZC4gSWYgdGhlIGNoYW5nZSBpc1xuICAvLyBiZWZvcmUgdGhlIGV2ZW50LCB0aGUgZXZlbnQncyBwb3NpdGlvbnMgYXJlIHVwZGF0ZWQuIFVzZXMgYVxuICAvLyBjb3B5LW9uLXdyaXRlIHNjaGVtZSBmb3IgdGhlIHBvc2l0aW9ucywgdG8gYXZvaWQgaGF2aW5nIHRvXG4gIC8vIHJlYWxsb2NhdGUgdGhlbSBhbGwgb24gZXZlcnkgcmViYXNlLCBidXQgYWxzbyBhdm9pZCBwcm9ibGVtcyB3aXRoXG4gIC8vIHNoYXJlZCBwb3NpdGlvbiBvYmplY3RzIGJlaW5nIHVuc2FmZWx5IHVwZGF0ZWQuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3RBcnJheShhcnJheSwgZnJvbSwgdG8sIGRpZmYpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgc3ViID0gYXJyYXlbaV0sIG9rID0gdHJ1ZTtcbiAgICAgIGlmIChzdWIucmFuZ2VzKSB7XG4gICAgICAgIGlmICghc3ViLmNvcGllZCkgeyBzdWIgPSBhcnJheVtpXSA9IHN1Yi5kZWVwQ29weSgpOyBzdWIuY29waWVkID0gdHJ1ZTsgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN1Yi5yYW5nZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICByZWJhc2VIaXN0U2VsU2luZ2xlKHN1Yi5yYW5nZXNbal0uYW5jaG9yLCBmcm9tLCB0bywgZGlmZik7XG4gICAgICAgICAgcmViYXNlSGlzdFNlbFNpbmdsZShzdWIucmFuZ2VzW2pdLmhlYWQsIGZyb20sIHRvLCBkaWZmKTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaiQxID0gMDsgaiQxIDwgc3ViLmNoYW5nZXMubGVuZ3RoOyArK2okMSkge1xuICAgICAgICB2YXIgY3VyID0gc3ViLmNoYW5nZXNbaiQxXTtcbiAgICAgICAgaWYgKHRvIDwgY3VyLmZyb20ubGluZSkge1xuICAgICAgICAgIGN1ci5mcm9tID0gUG9zKGN1ci5mcm9tLmxpbmUgKyBkaWZmLCBjdXIuZnJvbS5jaCk7XG4gICAgICAgICAgY3VyLnRvID0gUG9zKGN1ci50by5saW5lICsgZGlmZiwgY3VyLnRvLmNoKTtcbiAgICAgICAgfSBlbHNlIGlmIChmcm9tIDw9IGN1ci50by5saW5lKSB7XG4gICAgICAgICAgb2sgPSBmYWxzZTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIW9rKSB7XG4gICAgICAgIGFycmF5LnNwbGljZSgwLCBpICsgMSk7XG4gICAgICAgIGkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYmFzZUhpc3QoaGlzdCwgY2hhbmdlKSB7XG4gICAgdmFyIGZyb20gPSBjaGFuZ2UuZnJvbS5saW5lLCB0byA9IGNoYW5nZS50by5saW5lLCBkaWZmID0gY2hhbmdlLnRleHQubGVuZ3RoIC0gKHRvIC0gZnJvbSkgLSAxO1xuICAgIHJlYmFzZUhpc3RBcnJheShoaXN0LmRvbmUsIGZyb20sIHRvLCBkaWZmKTtcbiAgICByZWJhc2VIaXN0QXJyYXkoaGlzdC51bmRvbmUsIGZyb20sIHRvLCBkaWZmKTtcbiAgfVxuXG4gIC8vIFV0aWxpdHkgZm9yIGFwcGx5aW5nIGEgY2hhbmdlIHRvIGEgbGluZSBieSBoYW5kbGUgb3IgbnVtYmVyLFxuICAvLyByZXR1cm5pbmcgdGhlIG51bWJlciBhbmQgb3B0aW9uYWxseSByZWdpc3RlcmluZyB0aGUgbGluZSBhc1xuICAvLyBjaGFuZ2VkLlxuICBmdW5jdGlvbiBjaGFuZ2VMaW5lKGRvYywgaGFuZGxlLCBjaGFuZ2VUeXBlLCBvcCkge1xuICAgIHZhciBubyA9IGhhbmRsZSwgbGluZSA9IGhhbmRsZTtcbiAgICBpZiAodHlwZW9mIGhhbmRsZSA9PSBcIm51bWJlclwiKSB7IGxpbmUgPSBnZXRMaW5lKGRvYywgY2xpcExpbmUoZG9jLCBoYW5kbGUpKTsgfVxuICAgIGVsc2UgeyBubyA9IGxpbmVObyhoYW5kbGUpOyB9XG4gICAgaWYgKG5vID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgIGlmIChvcChsaW5lLCBubykgJiYgZG9jLmNtKSB7IHJlZ0xpbmVDaGFuZ2UoZG9jLmNtLCBubywgY2hhbmdlVHlwZSk7IH1cbiAgICByZXR1cm4gbGluZVxuICB9XG5cbiAgLy8gVGhlIGRvY3VtZW50IGlzIHJlcHJlc2VudGVkIGFzIGEgQlRyZWUgY29uc2lzdGluZyBvZiBsZWF2ZXMsIHdpdGhcbiAgLy8gY2h1bmsgb2YgbGluZXMgaW4gdGhlbSwgYW5kIGJyYW5jaGVzLCB3aXRoIHVwIHRvIHRlbiBsZWF2ZXMgb3JcbiAgLy8gb3RoZXIgYnJhbmNoIG5vZGVzIGJlbG93IHRoZW0uIFRoZSB0b3Agbm9kZSBpcyBhbHdheXMgYSBicmFuY2hcbiAgLy8gbm9kZSwgYW5kIGlzIHRoZSBkb2N1bWVudCBvYmplY3QgaXRzZWxmIChtZWFuaW5nIGl0IGhhc1xuICAvLyBhZGRpdGlvbmFsIG1ldGhvZHMgYW5kIHByb3BlcnRpZXMpLlxuICAvL1xuICAvLyBBbGwgbm9kZXMgaGF2ZSBwYXJlbnQgbGlua3MuIFRoZSB0cmVlIGlzIHVzZWQgYm90aCB0byBnbyBmcm9tXG4gIC8vIGxpbmUgbnVtYmVycyB0byBsaW5lIG9iamVjdHMsIGFuZCB0byBnbyBmcm9tIG9iamVjdHMgdG8gbnVtYmVycy5cbiAgLy8gSXQgYWxzbyBpbmRleGVzIGJ5IGhlaWdodCwgYW5kIGlzIHVzZWQgdG8gY29udmVydCBiZXR3ZWVuIGhlaWdodFxuICAvLyBhbmQgbGluZSBvYmplY3QsIGFuZCB0byBmaW5kIHRoZSB0b3RhbCBoZWlnaHQgb2YgdGhlIGRvY3VtZW50LlxuICAvL1xuICAvLyBTZWUgYWxzbyBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Jsb2cvY29kZW1pcnJvci1saW5lLXRyZWUuaHRtbFxuXG4gIGZ1bmN0aW9uIExlYWZDaHVuayhsaW5lcykge1xuICAgIHRoaXMubGluZXMgPSBsaW5lcztcbiAgICB0aGlzLnBhcmVudCA9IG51bGw7XG4gICAgdmFyIGhlaWdodCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgbGluZXNbaV0ucGFyZW50ID0gdGhpcztcbiAgICAgIGhlaWdodCArPSBsaW5lc1tpXS5oZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICB9XG5cbiAgTGVhZkNodW5rLnByb3RvdHlwZSA9IHtcbiAgICBjaHVua1NpemU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5saW5lcy5sZW5ndGggfSxcblxuICAgIC8vIFJlbW92ZSB0aGUgbiBsaW5lcyBhdCBvZmZzZXQgJ2F0Jy5cbiAgICByZW1vdmVJbm5lcjogZnVuY3Rpb24oYXQsIG4pIHtcbiAgICAgIGZvciAodmFyIGkgPSBhdCwgZSA9IGF0ICsgbjsgaSA8IGU7ICsraSkge1xuICAgICAgICB2YXIgbGluZSA9IHRoaXMubGluZXNbaV07XG4gICAgICAgIHRoaXMuaGVpZ2h0IC09IGxpbmUuaGVpZ2h0O1xuICAgICAgICBjbGVhblVwTGluZShsaW5lKTtcbiAgICAgICAgc2lnbmFsTGF0ZXIobGluZSwgXCJkZWxldGVcIik7XG4gICAgICB9XG4gICAgICB0aGlzLmxpbmVzLnNwbGljZShhdCwgbik7XG4gICAgfSxcblxuICAgIC8vIEhlbHBlciB1c2VkIHRvIGNvbGxhcHNlIGEgc21hbGwgYnJhbmNoIGludG8gYSBzaW5nbGUgbGVhZi5cbiAgICBjb2xsYXBzZTogZnVuY3Rpb24obGluZXMpIHtcbiAgICAgIGxpbmVzLnB1c2guYXBwbHkobGluZXMsIHRoaXMubGluZXMpO1xuICAgIH0sXG5cbiAgICAvLyBJbnNlcnQgdGhlIGdpdmVuIGFycmF5IG9mIGxpbmVzIGF0IG9mZnNldCAnYXQnLCBjb3VudCB0aGVtIGFzXG4gICAgLy8gaGF2aW5nIHRoZSBnaXZlbiBoZWlnaHQuXG4gICAgaW5zZXJ0SW5uZXI6IGZ1bmN0aW9uKGF0LCBsaW5lcywgaGVpZ2h0KSB7XG4gICAgICB0aGlzLmhlaWdodCArPSBoZWlnaHQ7XG4gICAgICB0aGlzLmxpbmVzID0gdGhpcy5saW5lcy5zbGljZSgwLCBhdCkuY29uY2F0KGxpbmVzKS5jb25jYXQodGhpcy5saW5lcy5zbGljZShhdCkpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkgeyBsaW5lc1tpXS5wYXJlbnQgPSB0aGlzOyB9XG4gICAgfSxcblxuICAgIC8vIFVzZWQgdG8gaXRlcmF0ZSBvdmVyIGEgcGFydCBvZiB0aGUgdHJlZS5cbiAgICBpdGVyTjogZnVuY3Rpb24oYXQsIG4sIG9wKSB7XG4gICAgICBmb3IgKHZhciBlID0gYXQgKyBuOyBhdCA8IGU7ICsrYXQpXG4gICAgICAgIHsgaWYgKG9wKHRoaXMubGluZXNbYXRdKSkgeyByZXR1cm4gdHJ1ZSB9IH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gQnJhbmNoQ2h1bmsoY2hpbGRyZW4pIHtcbiAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgdmFyIHNpemUgPSAwLCBoZWlnaHQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBjaCA9IGNoaWxkcmVuW2ldO1xuICAgICAgc2l6ZSArPSBjaC5jaHVua1NpemUoKTsgaGVpZ2h0ICs9IGNoLmhlaWdodDtcbiAgICAgIGNoLnBhcmVudCA9IHRoaXM7XG4gICAgfVxuICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICB9XG5cbiAgQnJhbmNoQ2h1bmsucHJvdG90eXBlID0ge1xuICAgIGNodW5rU2l6ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNpemUgfSxcblxuICAgIHJlbW92ZUlubmVyOiBmdW5jdGlvbihhdCwgbikge1xuICAgICAgdGhpcy5zaXplIC09IG47XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGNoaWxkID0gdGhpcy5jaGlsZHJlbltpXSwgc3ogPSBjaGlsZC5jaHVua1NpemUoKTtcbiAgICAgICAgaWYgKGF0IDwgc3opIHtcbiAgICAgICAgICB2YXIgcm0gPSBNYXRoLm1pbihuLCBzeiAtIGF0KSwgb2xkSGVpZ2h0ID0gY2hpbGQuaGVpZ2h0O1xuICAgICAgICAgIGNoaWxkLnJlbW92ZUlubmVyKGF0LCBybSk7XG4gICAgICAgICAgdGhpcy5oZWlnaHQgLT0gb2xkSGVpZ2h0IC0gY2hpbGQuaGVpZ2h0O1xuICAgICAgICAgIGlmIChzeiA9PSBybSkgeyB0aGlzLmNoaWxkcmVuLnNwbGljZShpLS0sIDEpOyBjaGlsZC5wYXJlbnQgPSBudWxsOyB9XG4gICAgICAgICAgaWYgKChuIC09IHJtKSA9PSAwKSB7IGJyZWFrIH1cbiAgICAgICAgICBhdCA9IDA7XG4gICAgICAgIH0gZWxzZSB7IGF0IC09IHN6OyB9XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGUgcmVzdWx0IGlzIHNtYWxsZXIgdGhhbiAyNSBsaW5lcywgZW5zdXJlIHRoYXQgaXQgaXMgYVxuICAgICAgLy8gc2luZ2xlIGxlYWYgbm9kZS5cbiAgICAgIGlmICh0aGlzLnNpemUgLSBuIDwgMjUgJiZcbiAgICAgICAgICAodGhpcy5jaGlsZHJlbi5sZW5ndGggPiAxIHx8ICEodGhpcy5jaGlsZHJlblswXSBpbnN0YW5jZW9mIExlYWZDaHVuaykpKSB7XG4gICAgICAgIHZhciBsaW5lcyA9IFtdO1xuICAgICAgICB0aGlzLmNvbGxhcHNlKGxpbmVzKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IFtuZXcgTGVhZkNodW5rKGxpbmVzKV07XG4gICAgICAgIHRoaXMuY2hpbGRyZW5bMF0ucGFyZW50ID0gdGhpcztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29sbGFwc2U6IGZ1bmN0aW9uKGxpbmVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2hpbGRyZW4ubGVuZ3RoOyArK2kpIHsgdGhpcy5jaGlsZHJlbltpXS5jb2xsYXBzZShsaW5lcyk7IH1cbiAgICB9LFxuXG4gICAgaW5zZXJ0SW5uZXI6IGZ1bmN0aW9uKGF0LCBsaW5lcywgaGVpZ2h0KSB7XG4gICAgICB0aGlzLnNpemUgKz0gbGluZXMubGVuZ3RoO1xuICAgICAgdGhpcy5oZWlnaHQgKz0gaGVpZ2h0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNoaWxkcmVuLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IHRoaXMuY2hpbGRyZW5baV0sIHN6ID0gY2hpbGQuY2h1bmtTaXplKCk7XG4gICAgICAgIGlmIChhdCA8PSBzeikge1xuICAgICAgICAgIGNoaWxkLmluc2VydElubmVyKGF0LCBsaW5lcywgaGVpZ2h0KTtcbiAgICAgICAgICBpZiAoY2hpbGQubGluZXMgJiYgY2hpbGQubGluZXMubGVuZ3RoID4gNTApIHtcbiAgICAgICAgICAgIC8vIFRvIGF2b2lkIG1lbW9yeSB0aHJhc2hpbmcgd2hlbiBjaGlsZC5saW5lcyBpcyBodWdlIChlLmcuIGZpcnN0IHZpZXcgb2YgYSBsYXJnZSBmaWxlKSwgaXQncyBuZXZlciBzcGxpY2VkLlxuICAgICAgICAgICAgLy8gSW5zdGVhZCwgc21hbGwgc2xpY2VzIGFyZSB0YWtlbi4gVGhleSdyZSB0YWtlbiBpbiBvcmRlciBiZWNhdXNlIHNlcXVlbnRpYWwgbWVtb3J5IGFjY2Vzc2VzIGFyZSBmYXN0ZXN0LlxuICAgICAgICAgICAgdmFyIHJlbWFpbmluZyA9IGNoaWxkLmxpbmVzLmxlbmd0aCAlIDI1ICsgMjU7XG4gICAgICAgICAgICBmb3IgKHZhciBwb3MgPSByZW1haW5pbmc7IHBvcyA8IGNoaWxkLmxpbmVzLmxlbmd0aDspIHtcbiAgICAgICAgICAgICAgdmFyIGxlYWYgPSBuZXcgTGVhZkNodW5rKGNoaWxkLmxpbmVzLnNsaWNlKHBvcywgcG9zICs9IDI1KSk7XG4gICAgICAgICAgICAgIGNoaWxkLmhlaWdodCAtPSBsZWFmLmhlaWdodDtcbiAgICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5zcGxpY2UoKytpLCAwLCBsZWFmKTtcbiAgICAgICAgICAgICAgbGVhZi5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQubGluZXMgPSBjaGlsZC5saW5lcy5zbGljZSgwLCByZW1haW5pbmcpO1xuICAgICAgICAgICAgdGhpcy5tYXliZVNwaWxsKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgYXQgLT0gc3o7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFdoZW4gYSBub2RlIGhhcyBncm93biwgY2hlY2sgd2hldGhlciBpdCBzaG91bGQgYmUgc3BsaXQuXG4gICAgbWF5YmVTcGlsbDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gMTApIHsgcmV0dXJuIH1cbiAgICAgIHZhciBtZSA9IHRoaXM7XG4gICAgICBkbyB7XG4gICAgICAgIHZhciBzcGlsbGVkID0gbWUuY2hpbGRyZW4uc3BsaWNlKG1lLmNoaWxkcmVuLmxlbmd0aCAtIDUsIDUpO1xuICAgICAgICB2YXIgc2libGluZyA9IG5ldyBCcmFuY2hDaHVuayhzcGlsbGVkKTtcbiAgICAgICAgaWYgKCFtZS5wYXJlbnQpIHsgLy8gQmVjb21lIHRoZSBwYXJlbnQgbm9kZVxuICAgICAgICAgIHZhciBjb3B5ID0gbmV3IEJyYW5jaENodW5rKG1lLmNoaWxkcmVuKTtcbiAgICAgICAgICBjb3B5LnBhcmVudCA9IG1lO1xuICAgICAgICAgIG1lLmNoaWxkcmVuID0gW2NvcHksIHNpYmxpbmddO1xuICAgICAgICAgIG1lID0gY29weTtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1lLnNpemUgLT0gc2libGluZy5zaXplO1xuICAgICAgICAgIG1lLmhlaWdodCAtPSBzaWJsaW5nLmhlaWdodDtcbiAgICAgICAgICB2YXIgbXlJbmRleCA9IGluZGV4T2YobWUucGFyZW50LmNoaWxkcmVuLCBtZSk7XG4gICAgICAgICAgbWUucGFyZW50LmNoaWxkcmVuLnNwbGljZShteUluZGV4ICsgMSwgMCwgc2libGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgc2libGluZy5wYXJlbnQgPSBtZS5wYXJlbnQ7XG4gICAgICB9IHdoaWxlIChtZS5jaGlsZHJlbi5sZW5ndGggPiAxMClcbiAgICAgIG1lLnBhcmVudC5tYXliZVNwaWxsKCk7XG4gICAgfSxcblxuICAgIGl0ZXJOOiBmdW5jdGlvbihhdCwgbiwgb3ApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgY2hpbGQgPSB0aGlzLmNoaWxkcmVuW2ldLCBzeiA9IGNoaWxkLmNodW5rU2l6ZSgpO1xuICAgICAgICBpZiAoYXQgPCBzeikge1xuICAgICAgICAgIHZhciB1c2VkID0gTWF0aC5taW4obiwgc3ogLSBhdCk7XG4gICAgICAgICAgaWYgKGNoaWxkLml0ZXJOKGF0LCB1c2VkLCBvcCkpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgICAgIGlmICgobiAtPSB1c2VkKSA9PSAwKSB7IGJyZWFrIH1cbiAgICAgICAgICBhdCA9IDA7XG4gICAgICAgIH0gZWxzZSB7IGF0IC09IHN6OyB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIExpbmUgd2lkZ2V0cyBhcmUgYmxvY2sgZWxlbWVudHMgZGlzcGxheWVkIGFib3ZlIG9yIGJlbG93IGEgbGluZS5cblxuICB2YXIgTGluZVdpZGdldCA9IGZ1bmN0aW9uKGRvYywgbm9kZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zKSB7IGZvciAodmFyIG9wdCBpbiBvcHRpb25zKSB7IGlmIChvcHRpb25zLmhhc093blByb3BlcnR5KG9wdCkpXG4gICAgICB7IHRoaXNbb3B0XSA9IG9wdGlvbnNbb3B0XTsgfSB9IH1cbiAgICB0aGlzLmRvYyA9IGRvYztcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICB9O1xuXG4gIExpbmVXaWRnZXQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjbSA9IHRoaXMuZG9jLmNtLCB3cyA9IHRoaXMubGluZS53aWRnZXRzLCBsaW5lID0gdGhpcy5saW5lLCBubyA9IGxpbmVObyhsaW5lKTtcbiAgICBpZiAobm8gPT0gbnVsbCB8fCAhd3MpIHsgcmV0dXJuIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdzLmxlbmd0aDsgKytpKSB7IGlmICh3c1tpXSA9PSB0aGlzKSB7IHdzLnNwbGljZShpLS0sIDEpOyB9IH1cbiAgICBpZiAoIXdzLmxlbmd0aCkgeyBsaW5lLndpZGdldHMgPSBudWxsOyB9XG4gICAgdmFyIGhlaWdodCA9IHdpZGdldEhlaWdodCh0aGlzKTtcbiAgICB1cGRhdGVMaW5lSGVpZ2h0KGxpbmUsIE1hdGgubWF4KDAsIGxpbmUuaGVpZ2h0IC0gaGVpZ2h0KSk7XG4gICAgaWYgKGNtKSB7XG4gICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFkanVzdFNjcm9sbFdoZW5BYm92ZVZpc2libGUoY20sIGxpbmUsIC1oZWlnaHQpO1xuICAgICAgICByZWdMaW5lQ2hhbmdlKGNtLCBubywgXCJ3aWRnZXRcIik7XG4gICAgICB9KTtcbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcImxpbmVXaWRnZXRDbGVhcmVkXCIsIGNtLCB0aGlzLCBubyk7XG4gICAgfVxuICB9O1xuXG4gIExpbmVXaWRnZXQucHJvdG90eXBlLmNoYW5nZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBvbGRIID0gdGhpcy5oZWlnaHQsIGNtID0gdGhpcy5kb2MuY20sIGxpbmUgPSB0aGlzLmxpbmU7XG4gICAgdGhpcy5oZWlnaHQgPSBudWxsO1xuICAgIHZhciBkaWZmID0gd2lkZ2V0SGVpZ2h0KHRoaXMpIC0gb2xkSDtcbiAgICBpZiAoIWRpZmYpIHsgcmV0dXJuIH1cbiAgICBpZiAoIWxpbmVJc0hpZGRlbih0aGlzLmRvYywgbGluZSkpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRpZmYpOyB9XG4gICAgaWYgKGNtKSB7XG4gICAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNtLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgZGlmZik7XG4gICAgICAgIHNpZ25hbExhdGVyKGNtLCBcImxpbmVXaWRnZXRDaGFuZ2VkXCIsIGNtLCB0aGlzJDEsIGxpbmVObyhsaW5lKSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGV2ZW50TWl4aW4oTGluZVdpZGdldCk7XG5cbiAgZnVuY3Rpb24gYWRqdXN0U2Nyb2xsV2hlbkFib3ZlVmlzaWJsZShjbSwgbGluZSwgZGlmZikge1xuICAgIGlmIChoZWlnaHRBdExpbmUobGluZSkgPCAoKGNtLmN1ck9wICYmIGNtLmN1ck9wLnNjcm9sbFRvcCkgfHwgY20uZG9jLnNjcm9sbFRvcCkpXG4gICAgICB7IGFkZFRvU2Nyb2xsVG9wKGNtLCBkaWZmKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkTGluZVdpZGdldChkb2MsIGhhbmRsZSwgbm9kZSwgb3B0aW9ucykge1xuICAgIHZhciB3aWRnZXQgPSBuZXcgTGluZVdpZGdldChkb2MsIG5vZGUsIG9wdGlvbnMpO1xuICAgIHZhciBjbSA9IGRvYy5jbTtcbiAgICBpZiAoY20gJiYgd2lkZ2V0Lm5vSFNjcm9sbCkgeyBjbS5kaXNwbGF5LmFsaWduV2lkZ2V0cyA9IHRydWU7IH1cbiAgICBjaGFuZ2VMaW5lKGRvYywgaGFuZGxlLCBcIndpZGdldFwiLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgdmFyIHdpZGdldHMgPSBsaW5lLndpZGdldHMgfHwgKGxpbmUud2lkZ2V0cyA9IFtdKTtcbiAgICAgIGlmICh3aWRnZXQuaW5zZXJ0QXQgPT0gbnVsbCkgeyB3aWRnZXRzLnB1c2god2lkZ2V0KTsgfVxuICAgICAgZWxzZSB7IHdpZGdldHMuc3BsaWNlKE1hdGgubWluKHdpZGdldHMubGVuZ3RoLCBNYXRoLm1heCgwLCB3aWRnZXQuaW5zZXJ0QXQpKSwgMCwgd2lkZ2V0KTsgfVxuICAgICAgd2lkZ2V0LmxpbmUgPSBsaW5lO1xuICAgICAgaWYgKGNtICYmICFsaW5lSXNIaWRkZW4oZG9jLCBsaW5lKSkge1xuICAgICAgICB2YXIgYWJvdmVWaXNpYmxlID0gaGVpZ2h0QXRMaW5lKGxpbmUpIDwgZG9jLnNjcm9sbFRvcDtcbiAgICAgICAgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIHdpZGdldEhlaWdodCh3aWRnZXQpKTtcbiAgICAgICAgaWYgKGFib3ZlVmlzaWJsZSkgeyBhZGRUb1Njcm9sbFRvcChjbSwgd2lkZ2V0LmhlaWdodCk7IH1cbiAgICAgICAgY20uY3VyT3AuZm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9KTtcbiAgICBpZiAoY20pIHsgc2lnbmFsTGF0ZXIoY20sIFwibGluZVdpZGdldEFkZGVkXCIsIGNtLCB3aWRnZXQsIHR5cGVvZiBoYW5kbGUgPT0gXCJudW1iZXJcIiA/IGhhbmRsZSA6IGxpbmVObyhoYW5kbGUpKTsgfVxuICAgIHJldHVybiB3aWRnZXRcbiAgfVxuXG4gIC8vIFRFWFRNQVJLRVJTXG5cbiAgLy8gQ3JlYXRlZCB3aXRoIG1hcmtUZXh0IGFuZCBzZXRCb29rbWFyayBtZXRob2RzLiBBIFRleHRNYXJrZXIgaXMgYVxuICAvLyBoYW5kbGUgdGhhdCBjYW4gYmUgdXNlZCB0byBjbGVhciBvciBmaW5kIGEgbWFya2VkIHBvc2l0aW9uIGluIHRoZVxuICAvLyBkb2N1bWVudC4gTGluZSBvYmplY3RzIGhvbGQgYXJyYXlzIChtYXJrZWRTcGFucykgY29udGFpbmluZ1xuICAvLyB7ZnJvbSwgdG8sIG1hcmtlcn0gb2JqZWN0IHBvaW50aW5nIHRvIHN1Y2ggbWFya2VyIG9iamVjdHMsIGFuZFxuICAvLyBpbmRpY2F0aW5nIHRoYXQgc3VjaCBhIG1hcmtlciBpcyBwcmVzZW50IG9uIHRoYXQgbGluZS4gTXVsdGlwbGVcbiAgLy8gbGluZXMgbWF5IHBvaW50IHRvIHRoZSBzYW1lIG1hcmtlciB3aGVuIGl0IHNwYW5zIGFjcm9zcyBsaW5lcy5cbiAgLy8gVGhlIHNwYW5zIHdpbGwgaGF2ZSBudWxsIGZvciB0aGVpciBmcm9tL3RvIHByb3BlcnRpZXMgd2hlbiB0aGVcbiAgLy8gbWFya2VyIGNvbnRpbnVlcyBiZXlvbmQgdGhlIHN0YXJ0L2VuZCBvZiB0aGUgbGluZS4gTWFya2VycyBoYXZlXG4gIC8vIGxpbmtzIGJhY2sgdG8gdGhlIGxpbmVzIHRoZXkgY3VycmVudGx5IHRvdWNoLlxuXG4gIC8vIENvbGxhcHNlZCBtYXJrZXJzIGhhdmUgdW5pcXVlIGlkcywgaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBvcmRlclxuICAvLyB0aGVtLCB3aGljaCBpcyBuZWVkZWQgZm9yIHVuaXF1ZWx5IGRldGVybWluaW5nIGFuIG91dGVyIG1hcmtlclxuICAvLyB3aGVuIHRoZXkgb3ZlcmxhcCAodGhleSBtYXkgbmVzdCwgYnV0IG5vdCBwYXJ0aWFsbHkgb3ZlcmxhcCkuXG4gIHZhciBuZXh0TWFya2VySWQgPSAwO1xuXG4gIHZhciBUZXh0TWFya2VyID0gZnVuY3Rpb24oZG9jLCB0eXBlKSB7XG4gICAgdGhpcy5saW5lcyA9IFtdO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5kb2MgPSBkb2M7XG4gICAgdGhpcy5pZCA9ICsrbmV4dE1hcmtlcklkO1xuICB9O1xuXG4gIC8vIENsZWFyIHRoZSBtYXJrZXIuXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSB7IHJldHVybiB9XG4gICAgdmFyIGNtID0gdGhpcy5kb2MuY20sIHdpdGhPcCA9IGNtICYmICFjbS5jdXJPcDtcbiAgICBpZiAod2l0aE9wKSB7IHN0YXJ0T3BlcmF0aW9uKGNtKTsgfVxuICAgIGlmIChoYXNIYW5kbGVyKHRoaXMsIFwiY2xlYXJcIikpIHtcbiAgICAgIHZhciBmb3VuZCA9IHRoaXMuZmluZCgpO1xuICAgICAgaWYgKGZvdW5kKSB7IHNpZ25hbExhdGVyKHRoaXMsIFwiY2xlYXJcIiwgZm91bmQuZnJvbSwgZm91bmQudG8pOyB9XG4gICAgfVxuICAgIHZhciBtaW4gPSBudWxsLCBtYXggPSBudWxsO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuICAgICAgdmFyIHNwYW4gPSBnZXRNYXJrZWRTcGFuRm9yKGxpbmUubWFya2VkU3BhbnMsIHRoaXMpO1xuICAgICAgaWYgKGNtICYmICF0aGlzLmNvbGxhcHNlZCkgeyByZWdMaW5lQ2hhbmdlKGNtLCBsaW5lTm8obGluZSksIFwidGV4dFwiKTsgfVxuICAgICAgZWxzZSBpZiAoY20pIHtcbiAgICAgICAgaWYgKHNwYW4udG8gIT0gbnVsbCkgeyBtYXggPSBsaW5lTm8obGluZSk7IH1cbiAgICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsKSB7IG1pbiA9IGxpbmVObyhsaW5lKTsgfVxuICAgICAgfVxuICAgICAgbGluZS5tYXJrZWRTcGFucyA9IHJlbW92ZU1hcmtlZFNwYW4obGluZS5tYXJrZWRTcGFucywgc3Bhbik7XG4gICAgICBpZiAoc3Bhbi5mcm9tID09IG51bGwgJiYgdGhpcy5jb2xsYXBzZWQgJiYgIWxpbmVJc0hpZGRlbih0aGlzLmRvYywgbGluZSkgJiYgY20pXG4gICAgICAgIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCB0ZXh0SGVpZ2h0KGNtLmRpc3BsYXkpKTsgfVxuICAgIH1cbiAgICBpZiAoY20gJiYgdGhpcy5jb2xsYXBzZWQgJiYgIWNtLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHRoaXMubGluZXMubGVuZ3RoOyArK2kkMSkge1xuICAgICAgdmFyIHZpc3VhbCA9IHZpc3VhbExpbmUodGhpcy5saW5lc1tpJDFdKSwgbGVuID0gbGluZUxlbmd0aCh2aXN1YWwpO1xuICAgICAgaWYgKGxlbiA+IGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCkge1xuICAgICAgICBjbS5kaXNwbGF5Lm1heExpbmUgPSB2aXN1YWw7XG4gICAgICAgIGNtLmRpc3BsYXkubWF4TGluZUxlbmd0aCA9IGxlbjtcbiAgICAgICAgY20uZGlzcGxheS5tYXhMaW5lQ2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSB9XG5cbiAgICBpZiAobWluICE9IG51bGwgJiYgY20gJiYgdGhpcy5jb2xsYXBzZWQpIHsgcmVnQ2hhbmdlKGNtLCBtaW4sIG1heCArIDEpOyB9XG4gICAgdGhpcy5saW5lcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZXhwbGljaXRseUNsZWFyZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLmF0b21pYyAmJiB0aGlzLmRvYy5jYW50RWRpdCkge1xuICAgICAgdGhpcy5kb2MuY2FudEVkaXQgPSBmYWxzZTtcbiAgICAgIGlmIChjbSkgeyByZUNoZWNrU2VsZWN0aW9uKGNtLmRvYyk7IH1cbiAgICB9XG4gICAgaWYgKGNtKSB7IHNpZ25hbExhdGVyKGNtLCBcIm1hcmtlckNsZWFyZWRcIiwgY20sIHRoaXMsIG1pbiwgbWF4KTsgfVxuICAgIGlmICh3aXRoT3ApIHsgZW5kT3BlcmF0aW9uKGNtKTsgfVxuICAgIGlmICh0aGlzLnBhcmVudCkgeyB0aGlzLnBhcmVudC5jbGVhcigpOyB9XG4gIH07XG5cbiAgLy8gRmluZCB0aGUgcG9zaXRpb24gb2YgdGhlIG1hcmtlciBpbiB0aGUgZG9jdW1lbnQuIFJldHVybnMgYSB7ZnJvbSxcbiAgLy8gdG99IG9iamVjdCBieSBkZWZhdWx0LiBTaWRlIGNhbiBiZSBwYXNzZWQgdG8gZ2V0IGEgc3BlY2lmaWMgc2lkZVxuICAvLyAtLSAwIChib3RoKSwgLTEgKGxlZnQpLCBvciAxIChyaWdodCkuIFdoZW4gbGluZU9iaiBpcyB0cnVlLCB0aGVcbiAgLy8gUG9zIG9iamVjdHMgcmV0dXJuZWQgY29udGFpbiBhIGxpbmUgb2JqZWN0LCByYXRoZXIgdGhhbiBhIGxpbmVcbiAgLy8gbnVtYmVyICh1c2VkIHRvIHByZXZlbnQgbG9va2luZyB1cCB0aGUgc2FtZSBsaW5lIHR3aWNlKS5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uIChzaWRlLCBsaW5lT2JqKSB7XG4gICAgaWYgKHNpZGUgPT0gbnVsbCAmJiB0aGlzLnR5cGUgPT0gXCJib29rbWFya1wiKSB7IHNpZGUgPSAxOyB9XG4gICAgdmFyIGZyb20sIHRvO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5saW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmVzW2ldO1xuICAgICAgdmFyIHNwYW4gPSBnZXRNYXJrZWRTcGFuRm9yKGxpbmUubWFya2VkU3BhbnMsIHRoaXMpO1xuICAgICAgaWYgKHNwYW4uZnJvbSAhPSBudWxsKSB7XG4gICAgICAgIGZyb20gPSBQb3MobGluZU9iaiA/IGxpbmUgOiBsaW5lTm8obGluZSksIHNwYW4uZnJvbSk7XG4gICAgICAgIGlmIChzaWRlID09IC0xKSB7IHJldHVybiBmcm9tIH1cbiAgICAgIH1cbiAgICAgIGlmIChzcGFuLnRvICE9IG51bGwpIHtcbiAgICAgICAgdG8gPSBQb3MobGluZU9iaiA/IGxpbmUgOiBsaW5lTm8obGluZSksIHNwYW4udG8pO1xuICAgICAgICBpZiAoc2lkZSA9PSAxKSB7IHJldHVybiB0byB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmcm9tICYmIHtmcm9tOiBmcm9tLCB0bzogdG99XG4gIH07XG5cbiAgLy8gU2lnbmFscyB0aGF0IHRoZSBtYXJrZXIncyB3aWRnZXQgY2hhbmdlZCwgYW5kIHN1cnJvdW5kaW5nIGxheW91dFxuICAvLyBzaG91bGQgYmUgcmVjb21wdXRlZC5cbiAgVGV4dE1hcmtlci5wcm90b3R5cGUuY2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHBvcyA9IHRoaXMuZmluZCgtMSwgdHJ1ZSksIHdpZGdldCA9IHRoaXMsIGNtID0gdGhpcy5kb2MuY207XG4gICAgaWYgKCFwb3MgfHwgIWNtKSB7IHJldHVybiB9XG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGxpbmUgPSBwb3MubGluZSwgbGluZU4gPSBsaW5lTm8ocG9zLmxpbmUpO1xuICAgICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIGxpbmVOKTtcbiAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgIGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGVGb3Iodmlldyk7XG4gICAgICAgIGNtLmN1ck9wLnNlbGVjdGlvbkNoYW5nZWQgPSBjbS5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZTtcbiAgICAgIGlmICghbGluZUlzSGlkZGVuKHdpZGdldC5kb2MsIGxpbmUpICYmIHdpZGdldC5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgb2xkSGVpZ2h0ID0gd2lkZ2V0LmhlaWdodDtcbiAgICAgICAgd2lkZ2V0LmhlaWdodCA9IG51bGw7XG4gICAgICAgIHZhciBkSGVpZ2h0ID0gd2lkZ2V0SGVpZ2h0KHdpZGdldCkgLSBvbGRIZWlnaHQ7XG4gICAgICAgIGlmIChkSGVpZ2h0KVxuICAgICAgICAgIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCBsaW5lLmhlaWdodCArIGRIZWlnaHQpOyB9XG4gICAgICB9XG4gICAgICBzaWduYWxMYXRlcihjbSwgXCJtYXJrZXJDaGFuZ2VkXCIsIGNtLCB0aGlzJDEpO1xuICAgIH0pO1xuICB9O1xuXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmF0dGFjaExpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIGlmICghdGhpcy5saW5lcy5sZW5ndGggJiYgdGhpcy5kb2MuY20pIHtcbiAgICAgIHZhciBvcCA9IHRoaXMuZG9jLmNtLmN1ck9wO1xuICAgICAgaWYgKCFvcC5tYXliZUhpZGRlbk1hcmtlcnMgfHwgaW5kZXhPZihvcC5tYXliZUhpZGRlbk1hcmtlcnMsIHRoaXMpID09IC0xKVxuICAgICAgICB7IChvcC5tYXliZVVuaGlkZGVuTWFya2VycyB8fCAob3AubWF5YmVVbmhpZGRlbk1hcmtlcnMgPSBbXSkpLnB1c2godGhpcyk7IH1cbiAgICB9XG4gICAgdGhpcy5saW5lcy5wdXNoKGxpbmUpO1xuICB9O1xuXG4gIFRleHRNYXJrZXIucHJvdG90eXBlLmRldGFjaExpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgIHRoaXMubGluZXMuc3BsaWNlKGluZGV4T2YodGhpcy5saW5lcywgbGluZSksIDEpO1xuICAgIGlmICghdGhpcy5saW5lcy5sZW5ndGggJiYgdGhpcy5kb2MuY20pIHtcbiAgICAgIHZhciBvcCA9IHRoaXMuZG9jLmNtLmN1ck9wXG4gICAgICA7KG9wLm1heWJlSGlkZGVuTWFya2VycyB8fCAob3AubWF5YmVIaWRkZW5NYXJrZXJzID0gW10pKS5wdXNoKHRoaXMpO1xuICAgIH1cbiAgfTtcbiAgZXZlbnRNaXhpbihUZXh0TWFya2VyKTtcblxuICAvLyBDcmVhdGUgYSBtYXJrZXIsIHdpcmUgaXQgdXAgdG8gdGhlIHJpZ2h0IGxpbmVzLCBhbmRcbiAgZnVuY3Rpb24gbWFya1RleHQoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkge1xuICAgIC8vIFNoYXJlZCBtYXJrZXJzIChhY3Jvc3MgbGlua2VkIGRvY3VtZW50cykgYXJlIGhhbmRsZWQgc2VwYXJhdGVseVxuICAgIC8vIChtYXJrVGV4dFNoYXJlZCB3aWxsIGNhbGwgb3V0IHRvIHRoaXMgYWdhaW4sIG9uY2UgcGVyXG4gICAgLy8gZG9jdW1lbnQpLlxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuc2hhcmVkKSB7IHJldHVybiBtYXJrVGV4dFNoYXJlZChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB9XG4gICAgLy8gRW5zdXJlIHdlIGFyZSBpbiBhbiBvcGVyYXRpb24uXG4gICAgaWYgKGRvYy5jbSAmJiAhZG9jLmNtLmN1ck9wKSB7IHJldHVybiBvcGVyYXRpb24oZG9jLmNtLCBtYXJrVGV4dCkoZG9jLCBmcm9tLCB0bywgb3B0aW9ucywgdHlwZSkgfVxuXG4gICAgdmFyIG1hcmtlciA9IG5ldyBUZXh0TWFya2VyKGRvYywgdHlwZSksIGRpZmYgPSBjbXAoZnJvbSwgdG8pO1xuICAgIGlmIChvcHRpb25zKSB7IGNvcHlPYmoob3B0aW9ucywgbWFya2VyLCBmYWxzZSk7IH1cbiAgICAvLyBEb24ndCBjb25uZWN0IGVtcHR5IG1hcmtlcnMgdW5sZXNzIGNsZWFyV2hlbkVtcHR5IGlzIGZhbHNlXG4gICAgaWYgKGRpZmYgPiAwIHx8IGRpZmYgPT0gMCAmJiBtYXJrZXIuY2xlYXJXaGVuRW1wdHkgIT09IGZhbHNlKVxuICAgICAgeyByZXR1cm4gbWFya2VyIH1cbiAgICBpZiAobWFya2VyLnJlcGxhY2VkV2l0aCkge1xuICAgICAgLy8gU2hvd2luZyB1cCBhcyBhIHdpZGdldCBpbXBsaWVzIGNvbGxhcHNlZCAod2lkZ2V0IHJlcGxhY2VzIHRleHQpXG4gICAgICBtYXJrZXIuY29sbGFwc2VkID0gdHJ1ZTtcbiAgICAgIG1hcmtlci53aWRnZXROb2RlID0gZWx0UChcInNwYW5cIiwgW21hcmtlci5yZXBsYWNlZFdpdGhdLCBcIkNvZGVNaXJyb3Itd2lkZ2V0XCIpO1xuICAgICAgaWYgKCFvcHRpb25zLmhhbmRsZU1vdXNlRXZlbnRzKSB7IG1hcmtlci53aWRnZXROb2RlLnNldEF0dHJpYnV0ZShcImNtLWlnbm9yZS1ldmVudHNcIiwgXCJ0cnVlXCIpOyB9XG4gICAgICBpZiAob3B0aW9ucy5pbnNlcnRMZWZ0KSB7IG1hcmtlci53aWRnZXROb2RlLmluc2VydExlZnQgPSB0cnVlOyB9XG4gICAgfVxuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7XG4gICAgICBpZiAoY29uZmxpY3RpbmdDb2xsYXBzZWRSYW5nZShkb2MsIGZyb20ubGluZSwgZnJvbSwgdG8sIG1hcmtlcikgfHxcbiAgICAgICAgICBmcm9tLmxpbmUgIT0gdG8ubGluZSAmJiBjb25mbGljdGluZ0NvbGxhcHNlZFJhbmdlKGRvYywgdG8ubGluZSwgZnJvbSwgdG8sIG1hcmtlcikpXG4gICAgICAgIHsgdGhyb3cgbmV3IEVycm9yKFwiSW5zZXJ0aW5nIGNvbGxhcHNlZCBtYXJrZXIgcGFydGlhbGx5IG92ZXJsYXBwaW5nIGFuIGV4aXN0aW5nIG9uZVwiKSB9XG4gICAgICBzZWVDb2xsYXBzZWRTcGFucygpO1xuICAgIH1cblxuICAgIGlmIChtYXJrZXIuYWRkVG9IaXN0b3J5KVxuICAgICAgeyBhZGRDaGFuZ2VUb0hpc3RvcnkoZG9jLCB7ZnJvbTogZnJvbSwgdG86IHRvLCBvcmlnaW46IFwibWFya1RleHRcIn0sIGRvYy5zZWwsIE5hTik7IH1cblxuICAgIHZhciBjdXJMaW5lID0gZnJvbS5saW5lLCBjbSA9IGRvYy5jbSwgdXBkYXRlTWF4TGluZTtcbiAgICBkb2MuaXRlcihjdXJMaW5lLCB0by5saW5lICsgMSwgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGlmIChjbSAmJiBtYXJrZXIuY29sbGFwc2VkICYmICFjbS5vcHRpb25zLmxpbmVXcmFwcGluZyAmJiB2aXN1YWxMaW5lKGxpbmUpID09IGNtLmRpc3BsYXkubWF4TGluZSlcbiAgICAgICAgeyB1cGRhdGVNYXhMaW5lID0gdHJ1ZTsgfVxuICAgICAgaWYgKG1hcmtlci5jb2xsYXBzZWQgJiYgY3VyTGluZSAhPSBmcm9tLmxpbmUpIHsgdXBkYXRlTGluZUhlaWdodChsaW5lLCAwKTsgfVxuICAgICAgYWRkTWFya2VkU3BhbihsaW5lLCBuZXcgTWFya2VkU3BhbihtYXJrZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxpbmUgPT0gZnJvbS5saW5lID8gZnJvbS5jaCA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxpbmUgPT0gdG8ubGluZSA/IHRvLmNoIDogbnVsbCkpO1xuICAgICAgKytjdXJMaW5lO1xuICAgIH0pO1xuICAgIC8vIGxpbmVJc0hpZGRlbiBkZXBlbmRzIG9uIHRoZSBwcmVzZW5jZSBvZiB0aGUgc3BhbnMsIHNvIG5lZWRzIGEgc2Vjb25kIHBhc3NcbiAgICBpZiAobWFya2VyLmNvbGxhcHNlZCkgeyBkb2MuaXRlcihmcm9tLmxpbmUsIHRvLmxpbmUgKyAxLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgaWYgKGxpbmVJc0hpZGRlbihkb2MsIGxpbmUpKSB7IHVwZGF0ZUxpbmVIZWlnaHQobGluZSwgMCk7IH1cbiAgICB9KTsgfVxuXG4gICAgaWYgKG1hcmtlci5jbGVhck9uRW50ZXIpIHsgb24obWFya2VyLCBcImJlZm9yZUN1cnNvckVudGVyXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hcmtlci5jbGVhcigpOyB9KTsgfVxuXG4gICAgaWYgKG1hcmtlci5yZWFkT25seSkge1xuICAgICAgc2VlUmVhZE9ubHlTcGFucygpO1xuICAgICAgaWYgKGRvYy5oaXN0b3J5LmRvbmUubGVuZ3RoIHx8IGRvYy5oaXN0b3J5LnVuZG9uZS5sZW5ndGgpXG4gICAgICAgIHsgZG9jLmNsZWFySGlzdG9yeSgpOyB9XG4gICAgfVxuICAgIGlmIChtYXJrZXIuY29sbGFwc2VkKSB7XG4gICAgICBtYXJrZXIuaWQgPSArK25leHRNYXJrZXJJZDtcbiAgICAgIG1hcmtlci5hdG9taWMgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY20pIHtcbiAgICAgIC8vIFN5bmMgZWRpdG9yIHN0YXRlXG4gICAgICBpZiAodXBkYXRlTWF4TGluZSkgeyBjbS5jdXJPcC51cGRhdGVNYXhMaW5lID0gdHJ1ZTsgfVxuICAgICAgaWYgKG1hcmtlci5jb2xsYXBzZWQpXG4gICAgICAgIHsgcmVnQ2hhbmdlKGNtLCBmcm9tLmxpbmUsIHRvLmxpbmUgKyAxKTsgfVxuICAgICAgZWxzZSBpZiAobWFya2VyLmNsYXNzTmFtZSB8fCBtYXJrZXIuc3RhcnRTdHlsZSB8fCBtYXJrZXIuZW5kU3R5bGUgfHwgbWFya2VyLmNzcyB8fFxuICAgICAgICAgICAgICAgbWFya2VyLmF0dHJpYnV0ZXMgfHwgbWFya2VyLnRpdGxlKVxuICAgICAgICB7IGZvciAodmFyIGkgPSBmcm9tLmxpbmU7IGkgPD0gdG8ubGluZTsgaSsrKSB7IHJlZ0xpbmVDaGFuZ2UoY20sIGksIFwidGV4dFwiKTsgfSB9XG4gICAgICBpZiAobWFya2VyLmF0b21pYykgeyByZUNoZWNrU2VsZWN0aW9uKGNtLmRvYyk7IH1cbiAgICAgIHNpZ25hbExhdGVyKGNtLCBcIm1hcmtlckFkZGVkXCIsIGNtLCBtYXJrZXIpO1xuICAgIH1cbiAgICByZXR1cm4gbWFya2VyXG4gIH1cblxuICAvLyBTSEFSRUQgVEVYVE1BUktFUlNcblxuICAvLyBBIHNoYXJlZCBtYXJrZXIgc3BhbnMgbXVsdGlwbGUgbGlua2VkIGRvY3VtZW50cy4gSXQgaXNcbiAgLy8gaW1wbGVtZW50ZWQgYXMgYSBtZXRhLW1hcmtlci1vYmplY3QgY29udHJvbGxpbmcgbXVsdGlwbGUgbm9ybWFsXG4gIC8vIG1hcmtlcnMuXG4gIHZhciBTaGFyZWRUZXh0TWFya2VyID0gZnVuY3Rpb24obWFya2VycywgcHJpbWFyeSkge1xuICAgIHRoaXMubWFya2VycyA9IG1hcmtlcnM7XG4gICAgdGhpcy5wcmltYXJ5ID0gcHJpbWFyeTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1hcmtlcnMubGVuZ3RoOyArK2kpXG4gICAgICB7IG1hcmtlcnNbaV0ucGFyZW50ID0gdGhpczsgfVxuICB9O1xuXG4gIFNoYXJlZFRleHRNYXJrZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmV4cGxpY2l0bHlDbGVhcmVkKSB7IHJldHVybiB9XG4gICAgdGhpcy5leHBsaWNpdGx5Q2xlYXJlZCA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyArK2kpXG4gICAgICB7IHRoaXMubWFya2Vyc1tpXS5jbGVhcigpOyB9XG4gICAgc2lnbmFsTGF0ZXIodGhpcywgXCJjbGVhclwiKTtcbiAgfTtcblxuICBTaGFyZWRUZXh0TWFya2VyLnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24gKHNpZGUsIGxpbmVPYmopIHtcbiAgICByZXR1cm4gdGhpcy5wcmltYXJ5LmZpbmQoc2lkZSwgbGluZU9iailcbiAgfTtcbiAgZXZlbnRNaXhpbihTaGFyZWRUZXh0TWFya2VyKTtcblxuICBmdW5jdGlvbiBtYXJrVGV4dFNoYXJlZChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKSB7XG4gICAgb3B0aW9ucyA9IGNvcHlPYmoob3B0aW9ucyk7XG4gICAgb3B0aW9ucy5zaGFyZWQgPSBmYWxzZTtcbiAgICB2YXIgbWFya2VycyA9IFttYXJrVGV4dChkb2MsIGZyb20sIHRvLCBvcHRpb25zLCB0eXBlKV0sIHByaW1hcnkgPSBtYXJrZXJzWzBdO1xuICAgIHZhciB3aWRnZXQgPSBvcHRpb25zLndpZGdldE5vZGU7XG4gICAgbGlua2VkRG9jcyhkb2MsIGZ1bmN0aW9uIChkb2MpIHtcbiAgICAgIGlmICh3aWRnZXQpIHsgb3B0aW9ucy53aWRnZXROb2RlID0gd2lkZ2V0LmNsb25lTm9kZSh0cnVlKTsgfVxuICAgICAgbWFya2Vycy5wdXNoKG1hcmtUZXh0KGRvYywgY2xpcFBvcyhkb2MsIGZyb20pLCBjbGlwUG9zKGRvYywgdG8pLCBvcHRpb25zLCB0eXBlKSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvYy5saW5rZWQubGVuZ3RoOyArK2kpXG4gICAgICAgIHsgaWYgKGRvYy5saW5rZWRbaV0uaXNQYXJlbnQpIHsgcmV0dXJuIH0gfVxuICAgICAgcHJpbWFyeSA9IGxzdChtYXJrZXJzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFNoYXJlZFRleHRNYXJrZXIobWFya2VycywgcHJpbWFyeSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRTaGFyZWRNYXJrZXJzKGRvYykge1xuICAgIHJldHVybiBkb2MuZmluZE1hcmtzKFBvcyhkb2MuZmlyc3QsIDApLCBkb2MuY2xpcFBvcyhQb3MoZG9jLmxhc3RMaW5lKCkpKSwgZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0ucGFyZW50OyB9KVxuICB9XG5cbiAgZnVuY3Rpb24gY29weVNoYXJlZE1hcmtlcnMoZG9jLCBtYXJrZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpXSwgcG9zID0gbWFya2VyLmZpbmQoKTtcbiAgICAgIHZhciBtRnJvbSA9IGRvYy5jbGlwUG9zKHBvcy5mcm9tKSwgbVRvID0gZG9jLmNsaXBQb3MocG9zLnRvKTtcbiAgICAgIGlmIChjbXAobUZyb20sIG1UbykpIHtcbiAgICAgICAgdmFyIHN1Yk1hcmsgPSBtYXJrVGV4dChkb2MsIG1Gcm9tLCBtVG8sIG1hcmtlci5wcmltYXJ5LCBtYXJrZXIucHJpbWFyeS50eXBlKTtcbiAgICAgICAgbWFya2VyLm1hcmtlcnMucHVzaChzdWJNYXJrKTtcbiAgICAgICAgc3ViTWFyay5wYXJlbnQgPSBtYXJrZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoU2hhcmVkTWFya2VycyhtYXJrZXJzKSB7XG4gICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGkgKSB7XG4gICAgICB2YXIgbWFya2VyID0gbWFya2Vyc1tpXSwgbGlua2VkID0gW21hcmtlci5wcmltYXJ5LmRvY107XG4gICAgICBsaW5rZWREb2NzKG1hcmtlci5wcmltYXJ5LmRvYywgZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGxpbmtlZC5wdXNoKGQpOyB9KTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFya2VyLm1hcmtlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdmFyIHN1Yk1hcmtlciA9IG1hcmtlci5tYXJrZXJzW2pdO1xuICAgICAgICBpZiAoaW5kZXhPZihsaW5rZWQsIHN1Yk1hcmtlci5kb2MpID09IC0xKSB7XG4gICAgICAgICAgc3ViTWFya2VyLnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgbWFya2VyLm1hcmtlcnMuc3BsaWNlKGotLSwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXJrZXJzLmxlbmd0aDsgaSsrKSBsb29wKCBpICk7XG4gIH1cblxuICB2YXIgbmV4dERvY0lkID0gMDtcbiAgdmFyIERvYyA9IGZ1bmN0aW9uKHRleHQsIG1vZGUsIGZpcnN0TGluZSwgbGluZVNlcCwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERvYykpIHsgcmV0dXJuIG5ldyBEb2ModGV4dCwgbW9kZSwgZmlyc3RMaW5lLCBsaW5lU2VwLCBkaXJlY3Rpb24pIH1cbiAgICBpZiAoZmlyc3RMaW5lID09IG51bGwpIHsgZmlyc3RMaW5lID0gMDsgfVxuXG4gICAgQnJhbmNoQ2h1bmsuY2FsbCh0aGlzLCBbbmV3IExlYWZDaHVuayhbbmV3IExpbmUoXCJcIiwgbnVsbCldKV0pO1xuICAgIHRoaXMuZmlyc3QgPSBmaXJzdExpbmU7XG4gICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbExlZnQgPSAwO1xuICAgIHRoaXMuY2FudEVkaXQgPSBmYWxzZTtcbiAgICB0aGlzLmNsZWFuR2VuZXJhdGlvbiA9IDE7XG4gICAgdGhpcy5tb2RlRnJvbnRpZXIgPSB0aGlzLmhpZ2hsaWdodEZyb250aWVyID0gZmlyc3RMaW5lO1xuICAgIHZhciBzdGFydCA9IFBvcyhmaXJzdExpbmUsIDApO1xuICAgIHRoaXMuc2VsID0gc2ltcGxlU2VsZWN0aW9uKHN0YXJ0KTtcbiAgICB0aGlzLmhpc3RvcnkgPSBuZXcgSGlzdG9yeShudWxsKTtcbiAgICB0aGlzLmlkID0gKytuZXh0RG9jSWQ7XG4gICAgdGhpcy5tb2RlT3B0aW9uID0gbW9kZTtcbiAgICB0aGlzLmxpbmVTZXAgPSBsaW5lU2VwO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gKGRpcmVjdGlvbiA9PSBcInJ0bFwiKSA/IFwicnRsXCIgOiBcImx0clwiO1xuICAgIHRoaXMuZXh0ZW5kID0gZmFsc2U7XG5cbiAgICBpZiAodHlwZW9mIHRleHQgPT0gXCJzdHJpbmdcIikgeyB0ZXh0ID0gdGhpcy5zcGxpdExpbmVzKHRleHQpOyB9XG4gICAgdXBkYXRlRG9jKHRoaXMsIHtmcm9tOiBzdGFydCwgdG86IHN0YXJ0LCB0ZXh0OiB0ZXh0fSk7XG4gICAgc2V0U2VsZWN0aW9uKHRoaXMsIHNpbXBsZVNlbGVjdGlvbihzdGFydCksIHNlbF9kb250U2Nyb2xsKTtcbiAgfTtcblxuICBEb2MucHJvdG90eXBlID0gY3JlYXRlT2JqKEJyYW5jaENodW5rLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiBEb2MsXG4gICAgLy8gSXRlcmF0ZSBvdmVyIHRoZSBkb2N1bWVudC4gU3VwcG9ydHMgdHdvIGZvcm1zIC0tIHdpdGggb25seSBvbmVcbiAgICAvLyBhcmd1bWVudCwgaXQgY2FsbHMgdGhhdCBmb3IgZWFjaCBsaW5lIGluIHRoZSBkb2N1bWVudC4gV2l0aFxuICAgIC8vIHRocmVlLCBpdCBpdGVyYXRlcyBvdmVyIHRoZSByYW5nZSBnaXZlbiBieSB0aGUgZmlyc3QgdHdvICh3aXRoXG4gICAgLy8gdGhlIHNlY29uZCBiZWluZyBub24taW5jbHVzaXZlKS5cbiAgICBpdGVyOiBmdW5jdGlvbihmcm9tLCB0bywgb3ApIHtcbiAgICAgIGlmIChvcCkgeyB0aGlzLml0ZXJOKGZyb20gLSB0aGlzLmZpcnN0LCB0byAtIGZyb20sIG9wKTsgfVxuICAgICAgZWxzZSB7IHRoaXMuaXRlck4odGhpcy5maXJzdCwgdGhpcy5maXJzdCArIHRoaXMuc2l6ZSwgZnJvbSk7IH1cbiAgICB9LFxuXG4gICAgLy8gTm9uLXB1YmxpYyBpbnRlcmZhY2UgZm9yIGFkZGluZyBhbmQgcmVtb3ZpbmcgbGluZXMuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbihhdCwgbGluZXMpIHtcbiAgICAgIHZhciBoZWlnaHQgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkgeyBoZWlnaHQgKz0gbGluZXNbaV0uaGVpZ2h0OyB9XG4gICAgICB0aGlzLmluc2VydElubmVyKGF0IC0gdGhpcy5maXJzdCwgbGluZXMsIGhlaWdodCk7XG4gICAgfSxcbiAgICByZW1vdmU6IGZ1bmN0aW9uKGF0LCBuKSB7IHRoaXMucmVtb3ZlSW5uZXIoYXQgLSB0aGlzLmZpcnN0LCBuKTsgfSxcblxuICAgIC8vIEZyb20gaGVyZSwgdGhlIG1ldGhvZHMgYXJlIHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuIE1vc3RcbiAgICAvLyBhcmUgYWxzbyBhdmFpbGFibGUgZnJvbSBDb2RlTWlycm9yIChlZGl0b3IpIGluc3RhbmNlcy5cblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbihsaW5lU2VwKSB7XG4gICAgICB2YXIgbGluZXMgPSBnZXRMaW5lcyh0aGlzLCB0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplKTtcbiAgICAgIGlmIChsaW5lU2VwID09PSBmYWxzZSkgeyByZXR1cm4gbGluZXMgfVxuICAgICAgcmV0dXJuIGxpbmVzLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSlcbiAgICB9LFxuICAgIHNldFZhbHVlOiBkb2NNZXRob2RPcChmdW5jdGlvbihjb2RlKSB7XG4gICAgICB2YXIgdG9wID0gUG9zKHRoaXMuZmlyc3QsIDApLCBsYXN0ID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZSAtIDE7XG4gICAgICBtYWtlQ2hhbmdlKHRoaXMsIHtmcm9tOiB0b3AsIHRvOiBQb3MobGFzdCwgZ2V0TGluZSh0aGlzLCBsYXN0KS50ZXh0Lmxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiB0aGlzLnNwbGl0TGluZXMoY29kZSksIG9yaWdpbjogXCJzZXRWYWx1ZVwiLCBmdWxsOiB0cnVlfSwgdHJ1ZSk7XG4gICAgICBpZiAodGhpcy5jbSkgeyBzY3JvbGxUb0Nvb3Jkcyh0aGlzLmNtLCAwLCAwKTsgfVxuICAgICAgc2V0U2VsZWN0aW9uKHRoaXMsIHNpbXBsZVNlbGVjdGlvbih0b3ApLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgfSksXG4gICAgcmVwbGFjZVJhbmdlOiBmdW5jdGlvbihjb2RlLCBmcm9tLCB0bywgb3JpZ2luKSB7XG4gICAgICBmcm9tID0gY2xpcFBvcyh0aGlzLCBmcm9tKTtcbiAgICAgIHRvID0gdG8gPyBjbGlwUG9zKHRoaXMsIHRvKSA6IGZyb207XG4gICAgICByZXBsYWNlUmFuZ2UodGhpcywgY29kZSwgZnJvbSwgdG8sIG9yaWdpbik7XG4gICAgfSxcbiAgICBnZXRSYW5nZTogZnVuY3Rpb24oZnJvbSwgdG8sIGxpbmVTZXApIHtcbiAgICAgIHZhciBsaW5lcyA9IGdldEJldHdlZW4odGhpcywgY2xpcFBvcyh0aGlzLCBmcm9tKSwgY2xpcFBvcyh0aGlzLCB0bykpO1xuICAgICAgaWYgKGxpbmVTZXAgPT09IGZhbHNlKSB7IHJldHVybiBsaW5lcyB9XG4gICAgICByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKVxuICAgIH0sXG5cbiAgICBnZXRMaW5lOiBmdW5jdGlvbihsaW5lKSB7dmFyIGwgPSB0aGlzLmdldExpbmVIYW5kbGUobGluZSk7IHJldHVybiBsICYmIGwudGV4dH0sXG5cbiAgICBnZXRMaW5lSGFuZGxlOiBmdW5jdGlvbihsaW5lKSB7aWYgKGlzTGluZSh0aGlzLCBsaW5lKSkgeyByZXR1cm4gZ2V0TGluZSh0aGlzLCBsaW5lKSB9fSxcbiAgICBnZXRMaW5lTnVtYmVyOiBmdW5jdGlvbihsaW5lKSB7cmV0dXJuIGxpbmVObyhsaW5lKX0sXG5cbiAgICBnZXRMaW5lSGFuZGxlVmlzdWFsU3RhcnQ6IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIGlmICh0eXBlb2YgbGluZSA9PSBcIm51bWJlclwiKSB7IGxpbmUgPSBnZXRMaW5lKHRoaXMsIGxpbmUpOyB9XG4gICAgICByZXR1cm4gdmlzdWFsTGluZShsaW5lKVxuICAgIH0sXG5cbiAgICBsaW5lQ291bnQ6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLnNpemV9LFxuICAgIGZpcnN0TGluZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMuZmlyc3R9LFxuICAgIGxhc3RMaW5lOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5maXJzdCArIHRoaXMuc2l6ZSAtIDF9LFxuXG4gICAgY2xpcFBvczogZnVuY3Rpb24ocG9zKSB7cmV0dXJuIGNsaXBQb3ModGhpcywgcG9zKX0sXG5cbiAgICBnZXRDdXJzb3I6IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgICB2YXIgcmFuZ2UgPSB0aGlzLnNlbC5wcmltYXJ5KCksIHBvcztcbiAgICAgIGlmIChzdGFydCA9PSBudWxsIHx8IHN0YXJ0ID09IFwiaGVhZFwiKSB7IHBvcyA9IHJhbmdlLmhlYWQ7IH1cbiAgICAgIGVsc2UgaWYgKHN0YXJ0ID09IFwiYW5jaG9yXCIpIHsgcG9zID0gcmFuZ2UuYW5jaG9yOyB9XG4gICAgICBlbHNlIGlmIChzdGFydCA9PSBcImVuZFwiIHx8IHN0YXJ0ID09IFwidG9cIiB8fCBzdGFydCA9PT0gZmFsc2UpIHsgcG9zID0gcmFuZ2UudG8oKTsgfVxuICAgICAgZWxzZSB7IHBvcyA9IHJhbmdlLmZyb20oKTsgfVxuICAgICAgcmV0dXJuIHBvc1xuICAgIH0sXG4gICAgbGlzdFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zZWwucmFuZ2VzIH0sXG4gICAgc29tZXRoaW5nU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge3JldHVybiB0aGlzLnNlbC5zb21ldGhpbmdTZWxlY3RlZCgpfSxcblxuICAgIHNldEN1cnNvcjogZG9jTWV0aG9kT3AoZnVuY3Rpb24obGluZSwgY2gsIG9wdGlvbnMpIHtcbiAgICAgIHNldFNpbXBsZVNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIHR5cGVvZiBsaW5lID09IFwibnVtYmVyXCIgPyBQb3MobGluZSwgY2ggfHwgMCkgOiBsaW5lKSwgbnVsbCwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgc2V0U2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICAgIHNldFNpbXBsZVNlbGVjdGlvbih0aGlzLCBjbGlwUG9zKHRoaXMsIGFuY2hvciksIGNsaXBQb3ModGhpcywgaGVhZCB8fCBhbmNob3IpLCBvcHRpb25zKTtcbiAgICB9KSxcbiAgICBleHRlbmRTZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhlYWQsIG90aGVyLCBvcHRpb25zKSB7XG4gICAgICBleHRlbmRTZWxlY3Rpb24odGhpcywgY2xpcFBvcyh0aGlzLCBoZWFkKSwgb3RoZXIgJiYgY2xpcFBvcyh0aGlzLCBvdGhlciksIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIGV4dGVuZFNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhlYWRzLCBvcHRpb25zKSB7XG4gICAgICBleHRlbmRTZWxlY3Rpb25zKHRoaXMsIGNsaXBQb3NBcnJheSh0aGlzLCBoZWFkcyksIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIGV4dGVuZFNlbGVjdGlvbnNCeTogZG9jTWV0aG9kT3AoZnVuY3Rpb24oZiwgb3B0aW9ucykge1xuICAgICAgdmFyIGhlYWRzID0gbWFwKHRoaXMuc2VsLnJhbmdlcywgZik7XG4gICAgICBleHRlbmRTZWxlY3Rpb25zKHRoaXMsIGNsaXBQb3NBcnJheSh0aGlzLCBoZWFkcyksIG9wdGlvbnMpO1xuICAgIH0pLFxuICAgIHNldFNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKHJhbmdlcywgcHJpbWFyeSwgb3B0aW9ucykge1xuICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKSB7IHJldHVybiB9XG4gICAgICB2YXIgb3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgeyBvdXRbaV0gPSBuZXcgUmFuZ2UoY2xpcFBvcyh0aGlzLCByYW5nZXNbaV0uYW5jaG9yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaXBQb3ModGhpcywgcmFuZ2VzW2ldLmhlYWQpKTsgfVxuICAgICAgaWYgKHByaW1hcnkgPT0gbnVsbCkgeyBwcmltYXJ5ID0gTWF0aC5taW4ocmFuZ2VzLmxlbmd0aCAtIDEsIHRoaXMuc2VsLnByaW1JbmRleCk7IH1cbiAgICAgIHNldFNlbGVjdGlvbih0aGlzLCBub3JtYWxpemVTZWxlY3Rpb24odGhpcy5jbSwgb3V0LCBwcmltYXJ5KSwgb3B0aW9ucyk7XG4gICAgfSksXG4gICAgYWRkU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbihhbmNob3IsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByYW5nZXMgPSB0aGlzLnNlbC5yYW5nZXMuc2xpY2UoMCk7XG4gICAgICByYW5nZXMucHVzaChuZXcgUmFuZ2UoY2xpcFBvcyh0aGlzLCBhbmNob3IpLCBjbGlwUG9zKHRoaXMsIGhlYWQgfHwgYW5jaG9yKSkpO1xuICAgICAgc2V0U2VsZWN0aW9uKHRoaXMsIG5vcm1hbGl6ZVNlbGVjdGlvbih0aGlzLmNtLCByYW5nZXMsIHJhbmdlcy5sZW5ndGggLSAxKSwgb3B0aW9ucyk7XG4gICAgfSksXG5cbiAgICBnZXRTZWxlY3Rpb246IGZ1bmN0aW9uKGxpbmVTZXApIHtcbiAgICAgIHZhciByYW5nZXMgPSB0aGlzLnNlbC5yYW5nZXMsIGxpbmVzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlbCA9IGdldEJldHdlZW4odGhpcywgcmFuZ2VzW2ldLmZyb20oKSwgcmFuZ2VzW2ldLnRvKCkpO1xuICAgICAgICBsaW5lcyA9IGxpbmVzID8gbGluZXMuY29uY2F0KHNlbCkgOiBzZWw7XG4gICAgICB9XG4gICAgICBpZiAobGluZVNlcCA9PT0gZmFsc2UpIHsgcmV0dXJuIGxpbmVzIH1cbiAgICAgIGVsc2UgeyByZXR1cm4gbGluZXMuam9pbihsaW5lU2VwIHx8IHRoaXMubGluZVNlcGFyYXRvcigpKSB9XG4gICAgfSxcbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbihsaW5lU2VwKSB7XG4gICAgICB2YXIgcGFydHMgPSBbXSwgcmFuZ2VzID0gdGhpcy5zZWwucmFuZ2VzO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlbCA9IGdldEJldHdlZW4odGhpcywgcmFuZ2VzW2ldLmZyb20oKSwgcmFuZ2VzW2ldLnRvKCkpO1xuICAgICAgICBpZiAobGluZVNlcCAhPT0gZmFsc2UpIHsgc2VsID0gc2VsLmpvaW4obGluZVNlcCB8fCB0aGlzLmxpbmVTZXBhcmF0b3IoKSk7IH1cbiAgICAgICAgcGFydHNbaV0gPSBzZWw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFydHNcbiAgICB9LFxuICAgIHJlcGxhY2VTZWxlY3Rpb246IGZ1bmN0aW9uKGNvZGUsIGNvbGxhcHNlLCBvcmlnaW4pIHtcbiAgICAgIHZhciBkdXAgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zZWwucmFuZ2VzLmxlbmd0aDsgaSsrKVxuICAgICAgICB7IGR1cFtpXSA9IGNvZGU7IH1cbiAgICAgIHRoaXMucmVwbGFjZVNlbGVjdGlvbnMoZHVwLCBjb2xsYXBzZSwgb3JpZ2luIHx8IFwiK2lucHV0XCIpO1xuICAgIH0sXG4gICAgcmVwbGFjZVNlbGVjdGlvbnM6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGNvZGUsIGNvbGxhcHNlLCBvcmlnaW4pIHtcbiAgICAgIHZhciBjaGFuZ2VzID0gW10sIHNlbCA9IHRoaXMuc2VsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWwucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaV07XG4gICAgICAgIGNoYW5nZXNbaV0gPSB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmFuZ2UudG8oKSwgdGV4dDogdGhpcy5zcGxpdExpbmVzKGNvZGVbaV0pLCBvcmlnaW46IG9yaWdpbn07XG4gICAgICB9XG4gICAgICB2YXIgbmV3U2VsID0gY29sbGFwc2UgJiYgY29sbGFwc2UgIT0gXCJlbmRcIiAmJiBjb21wdXRlUmVwbGFjZWRTZWwodGhpcywgY2hhbmdlcywgY29sbGFwc2UpO1xuICAgICAgZm9yICh2YXIgaSQxID0gY2hhbmdlcy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgaSQxLS0pXG4gICAgICAgIHsgbWFrZUNoYW5nZSh0aGlzLCBjaGFuZ2VzW2kkMV0pOyB9XG4gICAgICBpZiAobmV3U2VsKSB7IHNldFNlbGVjdGlvblJlcGxhY2VIaXN0b3J5KHRoaXMsIG5ld1NlbCk7IH1cbiAgICAgIGVsc2UgaWYgKHRoaXMuY20pIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzLmNtKTsgfVxuICAgIH0pLFxuICAgIHVuZG86IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInVuZG9cIik7fSksXG4gICAgcmVkbzogZG9jTWV0aG9kT3AoZnVuY3Rpb24oKSB7bWFrZUNoYW5nZUZyb21IaXN0b3J5KHRoaXMsIFwicmVkb1wiKTt9KSxcbiAgICB1bmRvU2VsZWN0aW9uOiBkb2NNZXRob2RPcChmdW5jdGlvbigpIHttYWtlQ2hhbmdlRnJvbUhpc3RvcnkodGhpcywgXCJ1bmRvXCIsIHRydWUpO30pLFxuICAgIHJlZG9TZWxlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uKCkge21ha2VDaGFuZ2VGcm9tSGlzdG9yeSh0aGlzLCBcInJlZG9cIiwgdHJ1ZSk7fSksXG5cbiAgICBzZXRFeHRlbmRpbmc6IGZ1bmN0aW9uKHZhbCkge3RoaXMuZXh0ZW5kID0gdmFsO30sXG4gICAgZ2V0RXh0ZW5kaW5nOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5leHRlbmR9LFxuXG4gICAgaGlzdG9yeVNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGhpc3QgPSB0aGlzLmhpc3RvcnksIGRvbmUgPSAwLCB1bmRvbmUgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaXN0LmRvbmUubGVuZ3RoOyBpKyspIHsgaWYgKCFoaXN0LmRvbmVbaV0ucmFuZ2VzKSB7ICsrZG9uZTsgfSB9XG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBoaXN0LnVuZG9uZS5sZW5ndGg7IGkkMSsrKSB7IGlmICghaGlzdC51bmRvbmVbaSQxXS5yYW5nZXMpIHsgKyt1bmRvbmU7IH0gfVxuICAgICAgcmV0dXJuIHt1bmRvOiBkb25lLCByZWRvOiB1bmRvbmV9XG4gICAgfSxcbiAgICBjbGVhckhpc3Rvcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICAgIHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMuaGlzdG9yeS5tYXhHZW5lcmF0aW9uKTtcbiAgICAgIGxpbmtlZERvY3ModGhpcywgZnVuY3Rpb24gKGRvYykgeyByZXR1cm4gZG9jLmhpc3RvcnkgPSB0aGlzJDEuaGlzdG9yeTsgfSwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIG1hcmtDbGVhbjogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNsZWFuR2VuZXJhdGlvbiA9IHRoaXMuY2hhbmdlR2VuZXJhdGlvbih0cnVlKTtcbiAgICB9LFxuICAgIGNoYW5nZUdlbmVyYXRpb246IGZ1bmN0aW9uKGZvcmNlU3BsaXQpIHtcbiAgICAgIGlmIChmb3JjZVNwbGl0KVxuICAgICAgICB7IHRoaXMuaGlzdG9yeS5sYXN0T3AgPSB0aGlzLmhpc3RvcnkubGFzdFNlbE9wID0gdGhpcy5oaXN0b3J5Lmxhc3RPcmlnaW4gPSBudWxsOyB9XG4gICAgICByZXR1cm4gdGhpcy5oaXN0b3J5LmdlbmVyYXRpb25cbiAgICB9LFxuICAgIGlzQ2xlYW46IGZ1bmN0aW9uIChnZW4pIHtcbiAgICAgIHJldHVybiB0aGlzLmhpc3RvcnkuZ2VuZXJhdGlvbiA9PSAoZ2VuIHx8IHRoaXMuY2xlYW5HZW5lcmF0aW9uKVxuICAgIH0sXG5cbiAgICBnZXRIaXN0b3J5OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7ZG9uZTogY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkuZG9uZSksXG4gICAgICAgICAgICAgIHVuZG9uZTogY29weUhpc3RvcnlBcnJheSh0aGlzLmhpc3RvcnkudW5kb25lKX1cbiAgICB9LFxuICAgIHNldEhpc3Rvcnk6IGZ1bmN0aW9uKGhpc3REYXRhKSB7XG4gICAgICB2YXIgaGlzdCA9IHRoaXMuaGlzdG9yeSA9IG5ldyBIaXN0b3J5KHRoaXMuaGlzdG9yeS5tYXhHZW5lcmF0aW9uKTtcbiAgICAgIGhpc3QuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkoaGlzdERhdGEuZG9uZS5zbGljZSgwKSwgbnVsbCwgdHJ1ZSk7XG4gICAgICBoaXN0LnVuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkoaGlzdERhdGEudW5kb25lLnNsaWNlKDApLCBudWxsLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgc2V0R3V0dGVyTWFya2VyOiBkb2NNZXRob2RPcChmdW5jdGlvbihsaW5lLCBndXR0ZXJJRCwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGxpbmUsIFwiZ3V0dGVyXCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBtYXJrZXJzID0gbGluZS5ndXR0ZXJNYXJrZXJzIHx8IChsaW5lLmd1dHRlck1hcmtlcnMgPSB7fSk7XG4gICAgICAgIG1hcmtlcnNbZ3V0dGVySURdID0gdmFsdWU7XG4gICAgICAgIGlmICghdmFsdWUgJiYgaXNFbXB0eShtYXJrZXJzKSkgeyBsaW5lLmd1dHRlck1hcmtlcnMgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH0pLFxuXG4gICAgY2xlYXJHdXR0ZXI6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGd1dHRlcklEKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIGlmIChsaW5lLmd1dHRlck1hcmtlcnMgJiYgbGluZS5ndXR0ZXJNYXJrZXJzW2d1dHRlcklEXSkge1xuICAgICAgICAgIGNoYW5nZUxpbmUodGhpcyQxLCBsaW5lLCBcImd1dHRlclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsaW5lLmd1dHRlck1hcmtlcnNbZ3V0dGVySURdID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KGxpbmUuZ3V0dGVyTWFya2VycykpIHsgbGluZS5ndXR0ZXJNYXJrZXJzID0gbnVsbDsgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSksXG5cbiAgICBsaW5lSW5mbzogZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIG47XG4gICAgICBpZiAodHlwZW9mIGxpbmUgPT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoIWlzTGluZSh0aGlzLCBsaW5lKSkgeyByZXR1cm4gbnVsbCB9XG4gICAgICAgIG4gPSBsaW5lO1xuICAgICAgICBsaW5lID0gZ2V0TGluZSh0aGlzLCBsaW5lKTtcbiAgICAgICAgaWYgKCFsaW5lKSB7IHJldHVybiBudWxsIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSBsaW5lTm8obGluZSk7XG4gICAgICAgIGlmIChuID09IG51bGwpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHtsaW5lOiBuLCBoYW5kbGU6IGxpbmUsIHRleHQ6IGxpbmUudGV4dCwgZ3V0dGVyTWFya2VyczogbGluZS5ndXR0ZXJNYXJrZXJzLFxuICAgICAgICAgICAgICB0ZXh0Q2xhc3M6IGxpbmUudGV4dENsYXNzLCBiZ0NsYXNzOiBsaW5lLmJnQ2xhc3MsIHdyYXBDbGFzczogbGluZS53cmFwQ2xhc3MsXG4gICAgICAgICAgICAgIHdpZGdldHM6IGxpbmUud2lkZ2V0c31cbiAgICB9LFxuXG4gICAgYWRkTGluZUNsYXNzOiBkb2NNZXRob2RPcChmdW5jdGlvbihoYW5kbGUsIHdoZXJlLCBjbHMpIHtcbiAgICAgIHJldHVybiBjaGFuZ2VMaW5lKHRoaXMsIGhhbmRsZSwgd2hlcmUgPT0gXCJndXR0ZXJcIiA/IFwiZ3V0dGVyXCIgOiBcImNsYXNzXCIsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBwcm9wID0gd2hlcmUgPT0gXCJ0ZXh0XCIgPyBcInRleHRDbGFzc1wiXG4gICAgICAgICAgICAgICAgIDogd2hlcmUgPT0gXCJiYWNrZ3JvdW5kXCIgPyBcImJnQ2xhc3NcIlxuICAgICAgICAgICAgICAgICA6IHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlckNsYXNzXCIgOiBcIndyYXBDbGFzc1wiO1xuICAgICAgICBpZiAoIWxpbmVbcHJvcF0pIHsgbGluZVtwcm9wXSA9IGNsczsgfVxuICAgICAgICBlbHNlIGlmIChjbGFzc1Rlc3QoY2xzKS50ZXN0KGxpbmVbcHJvcF0pKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgIGVsc2UgeyBsaW5lW3Byb3BdICs9IFwiIFwiICsgY2xzOyB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9KVxuICAgIH0pLFxuICAgIHJlbW92ZUxpbmVDbGFzczogZG9jTWV0aG9kT3AoZnVuY3Rpb24oaGFuZGxlLCB3aGVyZSwgY2xzKSB7XG4gICAgICByZXR1cm4gY2hhbmdlTGluZSh0aGlzLCBoYW5kbGUsIHdoZXJlID09IFwiZ3V0dGVyXCIgPyBcImd1dHRlclwiIDogXCJjbGFzc1wiLCBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICB2YXIgcHJvcCA9IHdoZXJlID09IFwidGV4dFwiID8gXCJ0ZXh0Q2xhc3NcIlxuICAgICAgICAgICAgICAgICA6IHdoZXJlID09IFwiYmFja2dyb3VuZFwiID8gXCJiZ0NsYXNzXCJcbiAgICAgICAgICAgICAgICAgOiB3aGVyZSA9PSBcImd1dHRlclwiID8gXCJndXR0ZXJDbGFzc1wiIDogXCJ3cmFwQ2xhc3NcIjtcbiAgICAgICAgdmFyIGN1ciA9IGxpbmVbcHJvcF07XG4gICAgICAgIGlmICghY3VyKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICAgIGVsc2UgaWYgKGNscyA9PSBudWxsKSB7IGxpbmVbcHJvcF0gPSBudWxsOyB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGN1ci5tYXRjaChjbGFzc1Rlc3QoY2xzKSk7XG4gICAgICAgICAgaWYgKCFmb3VuZCkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICAgIHZhciBlbmQgPSBmb3VuZC5pbmRleCArIGZvdW5kWzBdLmxlbmd0aDtcbiAgICAgICAgICBsaW5lW3Byb3BdID0gY3VyLnNsaWNlKDAsIGZvdW5kLmluZGV4KSArICghZm91bmQuaW5kZXggfHwgZW5kID09IGN1ci5sZW5ndGggPyBcIlwiIDogXCIgXCIpICsgY3VyLnNsaWNlKGVuZCkgfHwgbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfSlcbiAgICB9KSxcblxuICAgIGFkZExpbmVXaWRnZXQ6IGRvY01ldGhvZE9wKGZ1bmN0aW9uKGhhbmRsZSwgbm9kZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGFkZExpbmVXaWRnZXQodGhpcywgaGFuZGxlLCBub2RlLCBvcHRpb25zKVxuICAgIH0pLFxuICAgIHJlbW92ZUxpbmVXaWRnZXQ6IGZ1bmN0aW9uKHdpZGdldCkgeyB3aWRnZXQuY2xlYXIoKTsgfSxcblxuICAgIG1hcmtUZXh0OiBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIGNsaXBQb3ModGhpcywgZnJvbSksIGNsaXBQb3ModGhpcywgdG8pLCBvcHRpb25zLCBvcHRpb25zICYmIG9wdGlvbnMudHlwZSB8fCBcInJhbmdlXCIpXG4gICAgfSxcbiAgICBzZXRCb29rbWFyazogZnVuY3Rpb24ocG9zLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcmVhbE9wdHMgPSB7cmVwbGFjZWRXaXRoOiBvcHRpb25zICYmIChvcHRpb25zLm5vZGVUeXBlID09IG51bGwgPyBvcHRpb25zLndpZGdldCA6IG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICAgIGluc2VydExlZnQ6IG9wdGlvbnMgJiYgb3B0aW9ucy5pbnNlcnRMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgIGNsZWFyV2hlbkVtcHR5OiBmYWxzZSwgc2hhcmVkOiBvcHRpb25zICYmIG9wdGlvbnMuc2hhcmVkLFxuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZU1vdXNlRXZlbnRzOiBvcHRpb25zICYmIG9wdGlvbnMuaGFuZGxlTW91c2VFdmVudHN9O1xuICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpO1xuICAgICAgcmV0dXJuIG1hcmtUZXh0KHRoaXMsIHBvcywgcG9zLCByZWFsT3B0cywgXCJib29rbWFya1wiKVxuICAgIH0sXG4gICAgZmluZE1hcmtzQXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgcG9zID0gY2xpcFBvcyh0aGlzLCBwb3MpO1xuICAgICAgdmFyIG1hcmtlcnMgPSBbXSwgc3BhbnMgPSBnZXRMaW5lKHRoaXMsIHBvcy5saW5lKS5tYXJrZWRTcGFucztcbiAgICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzcGFuID0gc3BhbnNbaV07XG4gICAgICAgIGlmICgoc3Bhbi5mcm9tID09IG51bGwgfHwgc3Bhbi5mcm9tIDw9IHBvcy5jaCkgJiZcbiAgICAgICAgICAgIChzcGFuLnRvID09IG51bGwgfHwgc3Bhbi50byA+PSBwb3MuY2gpKVxuICAgICAgICAgIHsgbWFya2Vycy5wdXNoKHNwYW4ubWFya2VyLnBhcmVudCB8fCBzcGFuLm1hcmtlcik7IH1cbiAgICAgIH0gfVxuICAgICAgcmV0dXJuIG1hcmtlcnNcbiAgICB9LFxuICAgIGZpbmRNYXJrczogZnVuY3Rpb24oZnJvbSwgdG8sIGZpbHRlcikge1xuICAgICAgZnJvbSA9IGNsaXBQb3ModGhpcywgZnJvbSk7IHRvID0gY2xpcFBvcyh0aGlzLCB0byk7XG4gICAgICB2YXIgZm91bmQgPSBbXSwgbGluZU5vID0gZnJvbS5saW5lO1xuICAgICAgdGhpcy5pdGVyKGZyb20ubGluZSwgdG8ubGluZSArIDEsIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBzcGFucyA9IGxpbmUubWFya2VkU3BhbnM7XG4gICAgICAgIGlmIChzcGFucykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHNwYW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHNwYW4gPSBzcGFuc1tpXTtcbiAgICAgICAgICBpZiAoIShzcGFuLnRvICE9IG51bGwgJiYgbGluZU5vID09IGZyb20ubGluZSAmJiBmcm9tLmNoID49IHNwYW4udG8gfHxcbiAgICAgICAgICAgICAgICBzcGFuLmZyb20gPT0gbnVsbCAmJiBsaW5lTm8gIT0gZnJvbS5saW5lIHx8XG4gICAgICAgICAgICAgICAgc3Bhbi5mcm9tICE9IG51bGwgJiYgbGluZU5vID09IHRvLmxpbmUgJiYgc3Bhbi5mcm9tID49IHRvLmNoKSAmJlxuICAgICAgICAgICAgICAoIWZpbHRlciB8fCBmaWx0ZXIoc3Bhbi5tYXJrZXIpKSlcbiAgICAgICAgICAgIHsgZm91bmQucHVzaChzcGFuLm1hcmtlci5wYXJlbnQgfHwgc3Bhbi5tYXJrZXIpOyB9XG4gICAgICAgIH0gfVxuICAgICAgICArK2xpbmVObztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGZvdW5kXG4gICAgfSxcbiAgICBnZXRBbGxNYXJrczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbWFya2VycyA9IFtdO1xuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBzcHMgPSBsaW5lLm1hcmtlZFNwYW5zO1xuICAgICAgICBpZiAoc3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgc3BzLmxlbmd0aDsgKytpKVxuICAgICAgICAgIHsgaWYgKHNwc1tpXS5mcm9tICE9IG51bGwpIHsgbWFya2Vycy5wdXNoKHNwc1tpXS5tYXJrZXIpOyB9IH0gfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWFya2Vyc1xuICAgIH0sXG5cbiAgICBwb3NGcm9tSW5kZXg6IGZ1bmN0aW9uKG9mZikge1xuICAgICAgdmFyIGNoLCBsaW5lTm8gPSB0aGlzLmZpcnN0LCBzZXBTaXplID0gdGhpcy5saW5lU2VwYXJhdG9yKCkubGVuZ3RoO1xuICAgICAgdGhpcy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIHZhciBzeiA9IGxpbmUudGV4dC5sZW5ndGggKyBzZXBTaXplO1xuICAgICAgICBpZiAoc3ogPiBvZmYpIHsgY2ggPSBvZmY7IHJldHVybiB0cnVlIH1cbiAgICAgICAgb2ZmIC09IHN6O1xuICAgICAgICArK2xpbmVObztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNsaXBQb3ModGhpcywgUG9zKGxpbmVObywgY2gpKVxuICAgIH0sXG4gICAgaW5kZXhGcm9tUG9zOiBmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICBjb29yZHMgPSBjbGlwUG9zKHRoaXMsIGNvb3Jkcyk7XG4gICAgICB2YXIgaW5kZXggPSBjb29yZHMuY2g7XG4gICAgICBpZiAoY29vcmRzLmxpbmUgPCB0aGlzLmZpcnN0IHx8IGNvb3Jkcy5jaCA8IDApIHsgcmV0dXJuIDAgfVxuICAgICAgdmFyIHNlcFNpemUgPSB0aGlzLmxpbmVTZXBhcmF0b3IoKS5sZW5ndGg7XG4gICAgICB0aGlzLml0ZXIodGhpcy5maXJzdCwgY29vcmRzLmxpbmUsIGZ1bmN0aW9uIChsaW5lKSB7IC8vIGl0ZXIgYWJvcnRzIHdoZW4gY2FsbGJhY2sgcmV0dXJucyBhIHRydXRoeSB2YWx1ZVxuICAgICAgICBpbmRleCArPSBsaW5lLnRleHQubGVuZ3RoICsgc2VwU2l6ZTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGluZGV4XG4gICAgfSxcblxuICAgIGNvcHk6IGZ1bmN0aW9uKGNvcHlIaXN0b3J5KSB7XG4gICAgICB2YXIgZG9jID0gbmV3IERvYyhnZXRMaW5lcyh0aGlzLCB0aGlzLmZpcnN0LCB0aGlzLmZpcnN0ICsgdGhpcy5zaXplKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZU9wdGlvbiwgdGhpcy5maXJzdCwgdGhpcy5saW5lU2VwLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgICBkb2Muc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3A7IGRvYy5zY3JvbGxMZWZ0ID0gdGhpcy5zY3JvbGxMZWZ0O1xuICAgICAgZG9jLnNlbCA9IHRoaXMuc2VsO1xuICAgICAgZG9jLmV4dGVuZCA9IGZhbHNlO1xuICAgICAgaWYgKGNvcHlIaXN0b3J5KSB7XG4gICAgICAgIGRvYy5oaXN0b3J5LnVuZG9EZXB0aCA9IHRoaXMuaGlzdG9yeS51bmRvRGVwdGg7XG4gICAgICAgIGRvYy5zZXRIaXN0b3J5KHRoaXMuZ2V0SGlzdG9yeSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb2NcbiAgICB9LFxuXG4gICAgbGlua2VkRG9jOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBpZiAoIW9wdGlvbnMpIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICB2YXIgZnJvbSA9IHRoaXMuZmlyc3QsIHRvID0gdGhpcy5maXJzdCArIHRoaXMuc2l6ZTtcbiAgICAgIGlmIChvcHRpb25zLmZyb20gIT0gbnVsbCAmJiBvcHRpb25zLmZyb20gPiBmcm9tKSB7IGZyb20gPSBvcHRpb25zLmZyb207IH1cbiAgICAgIGlmIChvcHRpb25zLnRvICE9IG51bGwgJiYgb3B0aW9ucy50byA8IHRvKSB7IHRvID0gb3B0aW9ucy50bzsgfVxuICAgICAgdmFyIGNvcHkgPSBuZXcgRG9jKGdldExpbmVzKHRoaXMsIGZyb20sIHRvKSwgb3B0aW9ucy5tb2RlIHx8IHRoaXMubW9kZU9wdGlvbiwgZnJvbSwgdGhpcy5saW5lU2VwLCB0aGlzLmRpcmVjdGlvbik7XG4gICAgICBpZiAob3B0aW9ucy5zaGFyZWRIaXN0KSB7IGNvcHkuaGlzdG9yeSA9IHRoaXMuaGlzdG9yeVxuICAgICAgOyB9KHRoaXMubGlua2VkIHx8ICh0aGlzLmxpbmtlZCA9IFtdKSkucHVzaCh7ZG9jOiBjb3B5LCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3R9KTtcbiAgICAgIGNvcHkubGlua2VkID0gW3tkb2M6IHRoaXMsIGlzUGFyZW50OiB0cnVlLCBzaGFyZWRIaXN0OiBvcHRpb25zLnNoYXJlZEhpc3R9XTtcbiAgICAgIGNvcHlTaGFyZWRNYXJrZXJzKGNvcHksIGZpbmRTaGFyZWRNYXJrZXJzKHRoaXMpKTtcbiAgICAgIHJldHVybiBjb3B5XG4gICAgfSxcbiAgICB1bmxpbmtEb2M6IGZ1bmN0aW9uKG90aGVyKSB7XG4gICAgICBpZiAob3RoZXIgaW5zdGFuY2VvZiBDb2RlTWlycm9yKSB7IG90aGVyID0gb3RoZXIuZG9jOyB9XG4gICAgICBpZiAodGhpcy5saW5rZWQpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxpbmtlZC5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbGluayA9IHRoaXMubGlua2VkW2ldO1xuICAgICAgICBpZiAobGluay5kb2MgIT0gb3RoZXIpIHsgY29udGludWUgfVxuICAgICAgICB0aGlzLmxpbmtlZC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIG90aGVyLnVubGlua0RvYyh0aGlzKTtcbiAgICAgICAgZGV0YWNoU2hhcmVkTWFya2VycyhmaW5kU2hhcmVkTWFya2Vycyh0aGlzKSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IH1cbiAgICAgIC8vIElmIHRoZSBoaXN0b3JpZXMgd2VyZSBzaGFyZWQsIHNwbGl0IHRoZW0gYWdhaW5cbiAgICAgIGlmIChvdGhlci5oaXN0b3J5ID09IHRoaXMuaGlzdG9yeSkge1xuICAgICAgICB2YXIgc3BsaXRJZHMgPSBbb3RoZXIuaWRdO1xuICAgICAgICBsaW5rZWREb2NzKG90aGVyLCBmdW5jdGlvbiAoZG9jKSB7IHJldHVybiBzcGxpdElkcy5wdXNoKGRvYy5pZCk7IH0sIHRydWUpO1xuICAgICAgICBvdGhlci5oaXN0b3J5ID0gbmV3IEhpc3RvcnkobnVsbCk7XG4gICAgICAgIG90aGVyLmhpc3RvcnkuZG9uZSA9IGNvcHlIaXN0b3J5QXJyYXkodGhpcy5oaXN0b3J5LmRvbmUsIHNwbGl0SWRzKTtcbiAgICAgICAgb3RoZXIuaGlzdG9yeS51bmRvbmUgPSBjb3B5SGlzdG9yeUFycmF5KHRoaXMuaGlzdG9yeS51bmRvbmUsIHNwbGl0SWRzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGl0ZXJMaW5rZWREb2NzOiBmdW5jdGlvbihmKSB7bGlua2VkRG9jcyh0aGlzLCBmKTt9LFxuXG4gICAgZ2V0TW9kZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMubW9kZX0sXG4gICAgZ2V0RWRpdG9yOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5jbX0sXG5cbiAgICBzcGxpdExpbmVzOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmICh0aGlzLmxpbmVTZXApIHsgcmV0dXJuIHN0ci5zcGxpdCh0aGlzLmxpbmVTZXApIH1cbiAgICAgIHJldHVybiBzcGxpdExpbmVzQXV0byhzdHIpXG4gICAgfSxcbiAgICBsaW5lU2VwYXJhdG9yOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubGluZVNlcCB8fCBcIlxcblwiIH0sXG5cbiAgICBzZXREaXJlY3Rpb246IGRvY01ldGhvZE9wKGZ1bmN0aW9uIChkaXIpIHtcbiAgICAgIGlmIChkaXIgIT0gXCJydGxcIikgeyBkaXIgPSBcImx0clwiOyB9XG4gICAgICBpZiAoZGlyID09IHRoaXMuZGlyZWN0aW9uKSB7IHJldHVybiB9XG4gICAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcjtcbiAgICAgIHRoaXMuaXRlcihmdW5jdGlvbiAobGluZSkgeyByZXR1cm4gbGluZS5vcmRlciA9IG51bGw7IH0pO1xuICAgICAgaWYgKHRoaXMuY20pIHsgZGlyZWN0aW9uQ2hhbmdlZCh0aGlzLmNtKTsgfVxuICAgIH0pXG4gIH0pO1xuXG4gIC8vIFB1YmxpYyBhbGlhcy5cbiAgRG9jLnByb3RvdHlwZS5lYWNoTGluZSA9IERvYy5wcm90b3R5cGUuaXRlcjtcblxuICAvLyBLbHVkZ2UgdG8gd29yayBhcm91bmQgc3RyYW5nZSBJRSBiZWhhdmlvciB3aGVyZSBpdCdsbCBzb21ldGltZXNcbiAgLy8gcmUtZmlyZSBhIHNlcmllcyBvZiBkcmFnLXJlbGF0ZWQgZXZlbnRzIHJpZ2h0IGFmdGVyIHRoZSBkcm9wICgjMTU1MSlcbiAgdmFyIGxhc3REcm9wID0gMDtcblxuICBmdW5jdGlvbiBvbkRyb3AoZSkge1xuICAgIHZhciBjbSA9IHRoaXM7XG4gICAgY2xlYXJEcmFnQ3Vyc29yKGNtKTtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpXG4gICAgICB7IHJldHVybiB9XG4gICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICBpZiAoaWUpIHsgbGFzdERyb3AgPSArbmV3IERhdGU7IH1cbiAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlKSwgZmlsZXMgPSBlLmRhdGFUcmFuc2Zlci5maWxlcztcbiAgICBpZiAoIXBvcyB8fCBjbS5pc1JlYWRPbmx5KCkpIHsgcmV0dXJuIH1cbiAgICAvLyBNaWdodCBiZSBhIGZpbGUgZHJvcCwgaW4gd2hpY2ggY2FzZSB3ZSBzaW1wbHkgZXh0cmFjdCB0aGUgdGV4dFxuICAgIC8vIGFuZCBpbnNlcnQgaXQuXG4gICAgaWYgKGZpbGVzICYmIGZpbGVzLmxlbmd0aCAmJiB3aW5kb3cuRmlsZVJlYWRlciAmJiB3aW5kb3cuRmlsZSkge1xuICAgICAgdmFyIG4gPSBmaWxlcy5sZW5ndGgsIHRleHQgPSBBcnJheShuKSwgcmVhZCA9IDA7XG4gICAgICB2YXIgbWFya0FzUmVhZEFuZFBhc3RlSWZBbGxGaWxlc0FyZVJlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICgrK3JlYWQgPT0gbikge1xuICAgICAgICAgIG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcG9zID0gY2xpcFBvcyhjbS5kb2MsIHBvcyk7XG4gICAgICAgICAgICB2YXIgY2hhbmdlID0ge2Zyb206IHBvcywgdG86IHBvcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY20uZG9jLnNwbGl0TGluZXMoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LmZpbHRlcihmdW5jdGlvbiAodCkgeyByZXR1cm4gdCAhPSBudWxsOyB9KS5qb2luKGNtLmRvYy5saW5lU2VwYXJhdG9yKCkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInBhc3RlXCJ9O1xuICAgICAgICAgICAgbWFrZUNoYW5nZShjbS5kb2MsIGNoYW5nZSk7XG4gICAgICAgICAgICBzZXRTZWxlY3Rpb25SZXBsYWNlSGlzdG9yeShjbS5kb2MsIHNpbXBsZVNlbGVjdGlvbihjbGlwUG9zKGNtLmRvYywgcG9zKSwgY2xpcFBvcyhjbS5kb2MsIGNoYW5nZUVuZChjaGFuZ2UpKSkpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgcmVhZFRleHRGcm9tRmlsZSA9IGZ1bmN0aW9uIChmaWxlLCBpKSB7XG4gICAgICAgIGlmIChjbS5vcHRpb25zLmFsbG93RHJvcEZpbGVUeXBlcyAmJlxuICAgICAgICAgICAgaW5kZXhPZihjbS5vcHRpb25zLmFsbG93RHJvcEZpbGVUeXBlcywgZmlsZS50eXBlKSA9PSAtMSkge1xuICAgICAgICAgIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7IH07XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnQgPSByZWFkZXIucmVzdWx0O1xuICAgICAgICAgIGlmICgvW1xceDAwLVxceDA4XFx4MGUtXFx4MWZdezJ9Ly50ZXN0KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICBtYXJrQXNSZWFkQW5kUGFzdGVJZkFsbEZpbGVzQXJlUmVhZCgpO1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIHRleHRbaV0gPSBjb250ZW50O1xuICAgICAgICAgIG1hcmtBc1JlYWRBbmRQYXN0ZUlmQWxsRmlsZXNBcmVSZWFkKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgICAgfTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsZXMubGVuZ3RoOyBpKyspIHsgcmVhZFRleHRGcm9tRmlsZShmaWxlc1tpXSwgaSk7IH1cbiAgICB9IGVsc2UgeyAvLyBOb3JtYWwgZHJvcFxuICAgICAgLy8gRG9uJ3QgZG8gYSByZXBsYWNlIGlmIHRoZSBkcm9wIGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgc2VsZWN0ZWQgdGV4dC5cbiAgICAgIGlmIChjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgJiYgY20uZG9jLnNlbC5jb250YWlucyhwb3MpID4gLTEpIHtcbiAgICAgICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0KGUpO1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGVkaXRvciBpcyByZS1mb2N1c2VkXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY20uZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAyMCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHRleHQkMSA9IGUuZGF0YVRyYW5zZmVyLmdldERhdGEoXCJUZXh0XCIpO1xuICAgICAgICBpZiAodGV4dCQxKSB7XG4gICAgICAgICAgdmFyIHNlbGVjdGVkO1xuICAgICAgICAgIGlmIChjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgJiYgIWNtLnN0YXRlLmRyYWdnaW5nVGV4dC5jb3B5KVxuICAgICAgICAgICAgeyBzZWxlY3RlZCA9IGNtLmxpc3RTZWxlY3Rpb25zKCk7IH1cbiAgICAgICAgICBzZXRTZWxlY3Rpb25Ob1VuZG8oY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24ocG9zLCBwb3MpKTtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHsgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgc2VsZWN0ZWQubGVuZ3RoOyArK2kkMSlcbiAgICAgICAgICAgIHsgcmVwbGFjZVJhbmdlKGNtLmRvYywgXCJcIiwgc2VsZWN0ZWRbaSQxXS5hbmNob3IsIHNlbGVjdGVkW2kkMV0uaGVhZCwgXCJkcmFnXCIpOyB9IH1cbiAgICAgICAgICBjbS5yZXBsYWNlU2VsZWN0aW9uKHRleHQkMSwgXCJhcm91bmRcIiwgXCJwYXN0ZVwiKTtcbiAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNhdGNoKGUkMSl7fVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRHJhZ1N0YXJ0KGNtLCBlKSB7XG4gICAgaWYgKGllICYmICghY20uc3RhdGUuZHJhZ2dpbmdUZXh0IHx8ICtuZXcgRGF0ZSAtIGxhc3REcm9wIDwgMTAwKSkgeyBlX3N0b3AoZSk7IHJldHVybiB9XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpKSB7IHJldHVybiB9XG5cbiAgICBlLmRhdGFUcmFuc2Zlci5zZXREYXRhKFwiVGV4dFwiLCBjbS5nZXRTZWxlY3Rpb24oKSk7XG4gICAgZS5kYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9IFwiY29weU1vdmVcIjtcblxuICAgIC8vIFVzZSBkdW1teSBpbWFnZSBpbnN0ZWFkIG9mIGRlZmF1bHQgYnJvd3NlcnMgaW1hZ2UuXG4gICAgLy8gUmVjZW50IFNhZmFyaSAofjYuMC4yKSBoYXZlIGEgdGVuZGVuY3kgdG8gc2VnZmF1bHQgd2hlbiB0aGlzIGhhcHBlbnMsIHNvIHdlIGRvbid0IGRvIGl0IHRoZXJlLlxuICAgIGlmIChlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UgJiYgIXNhZmFyaSkge1xuICAgICAgdmFyIGltZyA9IGVsdChcImltZ1wiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiBmaXhlZDsgbGVmdDogMDsgdG9wOiAwO1wiKTtcbiAgICAgIGltZy5zcmMgPSBcImRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUFBQUNINUJBRUtBQUVBTEFBQUFBQUJBQUVBQUFJQ1RBRUFPdz09XCI7XG4gICAgICBpZiAocHJlc3RvKSB7XG4gICAgICAgIGltZy53aWR0aCA9IGltZy5oZWlnaHQgPSAxO1xuICAgICAgICBjbS5kaXNwbGF5LndyYXBwZXIuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgLy8gRm9yY2UgYSByZWxheW91dCwgb3IgT3BlcmEgd29uJ3QgdXNlIG91ciBpbWFnZSBmb3Igc29tZSBvYnNjdXJlIHJlYXNvblxuICAgICAgICBpbWcuX3RvcCA9IGltZy5vZmZzZXRUb3A7XG4gICAgICB9XG4gICAgICBlLmRhdGFUcmFuc2Zlci5zZXREcmFnSW1hZ2UoaW1nLCAwLCAwKTtcbiAgICAgIGlmIChwcmVzdG8pIHsgaW1nLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaW1nKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uRHJhZ092ZXIoY20sIGUpIHtcbiAgICB2YXIgcG9zID0gcG9zRnJvbU1vdXNlKGNtLCBlKTtcbiAgICBpZiAoIXBvcykgeyByZXR1cm4gfVxuICAgIHZhciBmcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgIGRyYXdTZWxlY3Rpb25DdXJzb3IoY20sIHBvcywgZnJhZyk7XG4gICAgaWYgKCFjbS5kaXNwbGF5LmRyYWdDdXJzb3IpIHtcbiAgICAgIGNtLmRpc3BsYXkuZHJhZ0N1cnNvciA9IGVsdChcImRpdlwiLCBudWxsLCBcIkNvZGVNaXJyb3ItY3Vyc29ycyBDb2RlTWlycm9yLWRyYWdjdXJzb3JzXCIpO1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UuaW5zZXJ0QmVmb3JlKGNtLmRpc3BsYXkuZHJhZ0N1cnNvciwgY20uZGlzcGxheS5jdXJzb3JEaXYpO1xuICAgIH1cbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChjbS5kaXNwbGF5LmRyYWdDdXJzb3IsIGZyYWcpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2xlYXJEcmFnQ3Vyc29yKGNtKSB7XG4gICAgaWYgKGNtLmRpc3BsYXkuZHJhZ0N1cnNvcikge1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UucmVtb3ZlQ2hpbGQoY20uZGlzcGxheS5kcmFnQ3Vyc29yKTtcbiAgICAgIGNtLmRpc3BsYXkuZHJhZ0N1cnNvciA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgLy8gVGhlc2UgbXVzdCBiZSBoYW5kbGVkIGNhcmVmdWxseSwgYmVjYXVzZSBuYWl2ZWx5IHJlZ2lzdGVyaW5nIGFcbiAgLy8gaGFuZGxlciBmb3IgZWFjaCBlZGl0b3Igd2lsbCBjYXVzZSB0aGUgZWRpdG9ycyB0byBuZXZlciBiZVxuICAvLyBnYXJiYWdlIGNvbGxlY3RlZC5cblxuICBmdW5jdGlvbiBmb3JFYWNoQ29kZU1pcnJvcihmKSB7XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKSB7IHJldHVybiB9XG4gICAgdmFyIGJ5Q2xhc3MgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiQ29kZU1pcnJvclwiKSwgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnlDbGFzcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNtID0gYnlDbGFzc1tpXS5Db2RlTWlycm9yO1xuICAgICAgaWYgKGNtKSB7IGVkaXRvcnMucHVzaChjbSk7IH1cbiAgICB9XG4gICAgaWYgKGVkaXRvcnMubGVuZ3RoKSB7IGVkaXRvcnNbMF0ub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRpdG9ycy5sZW5ndGg7IGkrKykgeyBmKGVkaXRvcnNbaV0pOyB9XG4gICAgfSk7IH1cbiAgfVxuXG4gIHZhciBnbG9iYWxzUmVnaXN0ZXJlZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBlbnN1cmVHbG9iYWxIYW5kbGVycygpIHtcbiAgICBpZiAoZ2xvYmFsc1JlZ2lzdGVyZWQpIHsgcmV0dXJuIH1cbiAgICByZWdpc3Rlckdsb2JhbEhhbmRsZXJzKCk7XG4gICAgZ2xvYmFsc1JlZ2lzdGVyZWQgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyR2xvYmFsSGFuZGxlcnMoKSB7XG4gICAgLy8gV2hlbiB0aGUgd2luZG93IHJlc2l6ZXMsIHdlIG5lZWQgdG8gcmVmcmVzaCBhY3RpdmUgZWRpdG9ycy5cbiAgICB2YXIgcmVzaXplVGltZXI7XG4gICAgb24od2luZG93LCBcInJlc2l6ZVwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAocmVzaXplVGltZXIgPT0gbnVsbCkgeyByZXNpemVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNpemVUaW1lciA9IG51bGw7XG4gICAgICAgIGZvckVhY2hDb2RlTWlycm9yKG9uUmVzaXplKTtcbiAgICAgIH0sIDEwMCk7IH1cbiAgICB9KTtcbiAgICAvLyBXaGVuIHRoZSB3aW5kb3cgbG9zZXMgZm9jdXMsIHdlIHdhbnQgdG8gc2hvdyB0aGUgZWRpdG9yIGFzIGJsdXJyZWRcbiAgICBvbih3aW5kb3csIFwiYmx1clwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmb3JFYWNoQ29kZU1pcnJvcihvbkJsdXIpOyB9KTtcbiAgfVxuICAvLyBDYWxsZWQgd2hlbiB0aGUgd2luZG93IHJlc2l6ZXNcbiAgZnVuY3Rpb24gb25SZXNpemUoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XG4gICAgLy8gTWlnaHQgYmUgYSB0ZXh0IHNjYWxpbmcgb3BlcmF0aW9uLCBjbGVhciBzaXplIGNhY2hlcy5cbiAgICBkLmNhY2hlZENoYXJXaWR0aCA9IGQuY2FjaGVkVGV4dEhlaWdodCA9IGQuY2FjaGVkUGFkZGluZ0ggPSBudWxsO1xuICAgIGQuc2Nyb2xsYmFyc0NsaXBwZWQgPSBmYWxzZTtcbiAgICBjbS5zZXRTaXplKCk7XG4gIH1cblxuICB2YXIga2V5TmFtZXMgPSB7XG4gICAgMzogXCJQYXVzZVwiLCA4OiBcIkJhY2tzcGFjZVwiLCA5OiBcIlRhYlwiLCAxMzogXCJFbnRlclwiLCAxNjogXCJTaGlmdFwiLCAxNzogXCJDdHJsXCIsIDE4OiBcIkFsdFwiLFxuICAgIDE5OiBcIlBhdXNlXCIsIDIwOiBcIkNhcHNMb2NrXCIsIDI3OiBcIkVzY1wiLCAzMjogXCJTcGFjZVwiLCAzMzogXCJQYWdlVXBcIiwgMzQ6IFwiUGFnZURvd25cIiwgMzU6IFwiRW5kXCIsXG4gICAgMzY6IFwiSG9tZVwiLCAzNzogXCJMZWZ0XCIsIDM4OiBcIlVwXCIsIDM5OiBcIlJpZ2h0XCIsIDQwOiBcIkRvd25cIiwgNDQ6IFwiUHJpbnRTY3JuXCIsIDQ1OiBcIkluc2VydFwiLFxuICAgIDQ2OiBcIkRlbGV0ZVwiLCA1OTogXCI7XCIsIDYxOiBcIj1cIiwgOTE6IFwiTW9kXCIsIDkyOiBcIk1vZFwiLCA5MzogXCJNb2RcIixcbiAgICAxMDY6IFwiKlwiLCAxMDc6IFwiPVwiLCAxMDk6IFwiLVwiLCAxMTA6IFwiLlwiLCAxMTE6IFwiL1wiLCAxNDU6IFwiU2Nyb2xsTG9ja1wiLFxuICAgIDE3MzogXCItXCIsIDE4NjogXCI7XCIsIDE4NzogXCI9XCIsIDE4ODogXCIsXCIsIDE4OTogXCItXCIsIDE5MDogXCIuXCIsIDE5MTogXCIvXCIsIDE5MjogXCJgXCIsIDIxOTogXCJbXCIsIDIyMDogXCJcXFxcXCIsXG4gICAgMjIxOiBcIl1cIiwgMjIyOiBcIidcIiwgMjI0OiBcIk1vZFwiLCA2MzIzMjogXCJVcFwiLCA2MzIzMzogXCJEb3duXCIsIDYzMjM0OiBcIkxlZnRcIiwgNjMyMzU6IFwiUmlnaHRcIiwgNjMyNzI6IFwiRGVsZXRlXCIsXG4gICAgNjMyNzM6IFwiSG9tZVwiLCA2MzI3NTogXCJFbmRcIiwgNjMyNzY6IFwiUGFnZVVwXCIsIDYzMjc3OiBcIlBhZ2VEb3duXCIsIDYzMzAyOiBcIkluc2VydFwiXG4gIH07XG5cbiAgLy8gTnVtYmVyIGtleXNcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7IGtleU5hbWVzW2kgKyA0OF0gPSBrZXlOYW1lc1tpICsgOTZdID0gU3RyaW5nKGkpOyB9XG4gIC8vIEFscGhhYmV0aWMga2V5c1xuICBmb3IgKHZhciBpJDEgPSA2NTsgaSQxIDw9IDkwOyBpJDErKykgeyBrZXlOYW1lc1tpJDFdID0gU3RyaW5nLmZyb21DaGFyQ29kZShpJDEpOyB9XG4gIC8vIEZ1bmN0aW9uIGtleXNcbiAgZm9yICh2YXIgaSQyID0gMTsgaSQyIDw9IDEyOyBpJDIrKykgeyBrZXlOYW1lc1tpJDIgKyAxMTFdID0ga2V5TmFtZXNbaSQyICsgNjMyMzVdID0gXCJGXCIgKyBpJDI7IH1cblxuICB2YXIga2V5TWFwID0ge307XG5cbiAga2V5TWFwLmJhc2ljID0ge1xuICAgIFwiTGVmdFwiOiBcImdvQ2hhckxlZnRcIiwgXCJSaWdodFwiOiBcImdvQ2hhclJpZ2h0XCIsIFwiVXBcIjogXCJnb0xpbmVVcFwiLCBcIkRvd25cIjogXCJnb0xpbmVEb3duXCIsXG4gICAgXCJFbmRcIjogXCJnb0xpbmVFbmRcIiwgXCJIb21lXCI6IFwiZ29MaW5lU3RhcnRTbWFydFwiLCBcIlBhZ2VVcFwiOiBcImdvUGFnZVVwXCIsIFwiUGFnZURvd25cIjogXCJnb1BhZ2VEb3duXCIsXG4gICAgXCJEZWxldGVcIjogXCJkZWxDaGFyQWZ0ZXJcIiwgXCJCYWNrc3BhY2VcIjogXCJkZWxDaGFyQmVmb3JlXCIsIFwiU2hpZnQtQmFja3NwYWNlXCI6IFwiZGVsQ2hhckJlZm9yZVwiLFxuICAgIFwiVGFiXCI6IFwiZGVmYXVsdFRhYlwiLCBcIlNoaWZ0LVRhYlwiOiBcImluZGVudEF1dG9cIixcbiAgICBcIkVudGVyXCI6IFwibmV3bGluZUFuZEluZGVudFwiLCBcIkluc2VydFwiOiBcInRvZ2dsZU92ZXJ3cml0ZVwiLFxuICAgIFwiRXNjXCI6IFwic2luZ2xlU2VsZWN0aW9uXCJcbiAgfTtcbiAgLy8gTm90ZSB0aGF0IHRoZSBzYXZlIGFuZCBmaW5kLXJlbGF0ZWQgY29tbWFuZHMgYXJlbid0IGRlZmluZWQgYnlcbiAgLy8gZGVmYXVsdC4gVXNlciBjb2RlIG9yIGFkZG9ucyBjYW4gZGVmaW5lIHRoZW0uIFVua25vd24gY29tbWFuZHNcbiAgLy8gYXJlIHNpbXBseSBpZ25vcmVkLlxuICBrZXlNYXAucGNEZWZhdWx0ID0ge1xuICAgIFwiQ3RybC1BXCI6IFwic2VsZWN0QWxsXCIsIFwiQ3RybC1EXCI6IFwiZGVsZXRlTGluZVwiLCBcIkN0cmwtWlwiOiBcInVuZG9cIiwgXCJTaGlmdC1DdHJsLVpcIjogXCJyZWRvXCIsIFwiQ3RybC1ZXCI6IFwicmVkb1wiLFxuICAgIFwiQ3RybC1Ib21lXCI6IFwiZ29Eb2NTdGFydFwiLCBcIkN0cmwtRW5kXCI6IFwiZ29Eb2NFbmRcIiwgXCJDdHJsLVVwXCI6IFwiZ29MaW5lVXBcIiwgXCJDdHJsLURvd25cIjogXCJnb0xpbmVEb3duXCIsXG4gICAgXCJDdHJsLUxlZnRcIjogXCJnb0dyb3VwTGVmdFwiLCBcIkN0cmwtUmlnaHRcIjogXCJnb0dyb3VwUmlnaHRcIiwgXCJBbHQtTGVmdFwiOiBcImdvTGluZVN0YXJ0XCIsIFwiQWx0LVJpZ2h0XCI6IFwiZ29MaW5lRW5kXCIsXG4gICAgXCJDdHJsLUJhY2tzcGFjZVwiOiBcImRlbEdyb3VwQmVmb3JlXCIsIFwiQ3RybC1EZWxldGVcIjogXCJkZWxHcm91cEFmdGVyXCIsIFwiQ3RybC1TXCI6IFwic2F2ZVwiLCBcIkN0cmwtRlwiOiBcImZpbmRcIixcbiAgICBcIkN0cmwtR1wiOiBcImZpbmROZXh0XCIsIFwiU2hpZnQtQ3RybC1HXCI6IFwiZmluZFByZXZcIiwgXCJTaGlmdC1DdHJsLUZcIjogXCJyZXBsYWNlXCIsIFwiU2hpZnQtQ3RybC1SXCI6IFwicmVwbGFjZUFsbFwiLFxuICAgIFwiQ3RybC1bXCI6IFwiaW5kZW50TGVzc1wiLCBcIkN0cmwtXVwiOiBcImluZGVudE1vcmVcIixcbiAgICBcIkN0cmwtVVwiOiBcInVuZG9TZWxlY3Rpb25cIiwgXCJTaGlmdC1DdHJsLVVcIjogXCJyZWRvU2VsZWN0aW9uXCIsIFwiQWx0LVVcIjogXCJyZWRvU2VsZWN0aW9uXCIsXG4gICAgXCJmYWxsdGhyb3VnaFwiOiBcImJhc2ljXCJcbiAgfTtcbiAgLy8gVmVyeSBiYXNpYyByZWFkbGluZS9lbWFjcy1zdHlsZSBiaW5kaW5ncywgd2hpY2ggYXJlIHN0YW5kYXJkIG9uIE1hYy5cbiAga2V5TWFwLmVtYWNzeSA9IHtcbiAgICBcIkN0cmwtRlwiOiBcImdvQ2hhclJpZ2h0XCIsIFwiQ3RybC1CXCI6IFwiZ29DaGFyTGVmdFwiLCBcIkN0cmwtUFwiOiBcImdvTGluZVVwXCIsIFwiQ3RybC1OXCI6IFwiZ29MaW5lRG93blwiLFxuICAgIFwiQWx0LUZcIjogXCJnb1dvcmRSaWdodFwiLCBcIkFsdC1CXCI6IFwiZ29Xb3JkTGVmdFwiLCBcIkN0cmwtQVwiOiBcImdvTGluZVN0YXJ0XCIsIFwiQ3RybC1FXCI6IFwiZ29MaW5lRW5kXCIsXG4gICAgXCJDdHJsLVZcIjogXCJnb1BhZ2VEb3duXCIsIFwiU2hpZnQtQ3RybC1WXCI6IFwiZ29QYWdlVXBcIiwgXCJDdHJsLURcIjogXCJkZWxDaGFyQWZ0ZXJcIiwgXCJDdHJsLUhcIjogXCJkZWxDaGFyQmVmb3JlXCIsXG4gICAgXCJBbHQtRFwiOiBcImRlbFdvcmRBZnRlclwiLCBcIkFsdC1CYWNrc3BhY2VcIjogXCJkZWxXb3JkQmVmb3JlXCIsIFwiQ3RybC1LXCI6IFwia2lsbExpbmVcIiwgXCJDdHJsLVRcIjogXCJ0cmFuc3Bvc2VDaGFyc1wiLFxuICAgIFwiQ3RybC1PXCI6IFwib3BlbkxpbmVcIlxuICB9O1xuICBrZXlNYXAubWFjRGVmYXVsdCA9IHtcbiAgICBcIkNtZC1BXCI6IFwic2VsZWN0QWxsXCIsIFwiQ21kLURcIjogXCJkZWxldGVMaW5lXCIsIFwiQ21kLVpcIjogXCJ1bmRvXCIsIFwiU2hpZnQtQ21kLVpcIjogXCJyZWRvXCIsIFwiQ21kLVlcIjogXCJyZWRvXCIsXG4gICAgXCJDbWQtSG9tZVwiOiBcImdvRG9jU3RhcnRcIiwgXCJDbWQtVXBcIjogXCJnb0RvY1N0YXJ0XCIsIFwiQ21kLUVuZFwiOiBcImdvRG9jRW5kXCIsIFwiQ21kLURvd25cIjogXCJnb0RvY0VuZFwiLCBcIkFsdC1MZWZ0XCI6IFwiZ29Hcm91cExlZnRcIixcbiAgICBcIkFsdC1SaWdodFwiOiBcImdvR3JvdXBSaWdodFwiLCBcIkNtZC1MZWZ0XCI6IFwiZ29MaW5lTGVmdFwiLCBcIkNtZC1SaWdodFwiOiBcImdvTGluZVJpZ2h0XCIsIFwiQWx0LUJhY2tzcGFjZVwiOiBcImRlbEdyb3VwQmVmb3JlXCIsXG4gICAgXCJDdHJsLUFsdC1CYWNrc3BhY2VcIjogXCJkZWxHcm91cEFmdGVyXCIsIFwiQWx0LURlbGV0ZVwiOiBcImRlbEdyb3VwQWZ0ZXJcIiwgXCJDbWQtU1wiOiBcInNhdmVcIiwgXCJDbWQtRlwiOiBcImZpbmRcIixcbiAgICBcIkNtZC1HXCI6IFwiZmluZE5leHRcIiwgXCJTaGlmdC1DbWQtR1wiOiBcImZpbmRQcmV2XCIsIFwiQ21kLUFsdC1GXCI6IFwicmVwbGFjZVwiLCBcIlNoaWZ0LUNtZC1BbHQtRlwiOiBcInJlcGxhY2VBbGxcIixcbiAgICBcIkNtZC1bXCI6IFwiaW5kZW50TGVzc1wiLCBcIkNtZC1dXCI6IFwiaW5kZW50TW9yZVwiLCBcIkNtZC1CYWNrc3BhY2VcIjogXCJkZWxXcmFwcGVkTGluZUxlZnRcIiwgXCJDbWQtRGVsZXRlXCI6IFwiZGVsV3JhcHBlZExpbmVSaWdodFwiLFxuICAgIFwiQ21kLVVcIjogXCJ1bmRvU2VsZWN0aW9uXCIsIFwiU2hpZnQtQ21kLVVcIjogXCJyZWRvU2VsZWN0aW9uXCIsIFwiQ3RybC1VcFwiOiBcImdvRG9jU3RhcnRcIiwgXCJDdHJsLURvd25cIjogXCJnb0RvY0VuZFwiLFxuICAgIFwiZmFsbHRocm91Z2hcIjogW1wiYmFzaWNcIiwgXCJlbWFjc3lcIl1cbiAgfTtcbiAga2V5TWFwW1wiZGVmYXVsdFwiXSA9IG1hYyA/IGtleU1hcC5tYWNEZWZhdWx0IDoga2V5TWFwLnBjRGVmYXVsdDtcblxuICAvLyBLRVlNQVAgRElTUEFUQ0hcblxuICBmdW5jdGlvbiBub3JtYWxpemVLZXlOYW1lKG5hbWUpIHtcbiAgICB2YXIgcGFydHMgPSBuYW1lLnNwbGl0KC8tKD8hJCkvKTtcbiAgICBuYW1lID0gcGFydHNbcGFydHMubGVuZ3RoIC0gMV07XG4gICAgdmFyIGFsdCwgY3RybCwgc2hpZnQsIGNtZDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgdmFyIG1vZCA9IHBhcnRzW2ldO1xuICAgICAgaWYgKC9eKGNtZHxtZXRhfG0pJC9pLnRlc3QobW9kKSkgeyBjbWQgPSB0cnVlOyB9XG4gICAgICBlbHNlIGlmICgvXmEobHQpPyQvaS50ZXN0KG1vZCkpIHsgYWx0ID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoL14oY3xjdHJsfGNvbnRyb2wpJC9pLnRlc3QobW9kKSkgeyBjdHJsID0gdHJ1ZTsgfVxuICAgICAgZWxzZSBpZiAoL15zKGhpZnQpPyQvaS50ZXN0KG1vZCkpIHsgc2hpZnQgPSB0cnVlOyB9XG4gICAgICBlbHNlIHsgdGhyb3cgbmV3IEVycm9yKFwiVW5yZWNvZ25pemVkIG1vZGlmaWVyIG5hbWU6IFwiICsgbW9kKSB9XG4gICAgfVxuICAgIGlmIChhbHQpIHsgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTsgfVxuICAgIGlmIChjdHJsKSB7IG5hbWUgPSBcIkN0cmwtXCIgKyBuYW1lOyB9XG4gICAgaWYgKGNtZCkgeyBuYW1lID0gXCJDbWQtXCIgKyBuYW1lOyB9XG4gICAgaWYgKHNoaWZ0KSB7IG5hbWUgPSBcIlNoaWZ0LVwiICsgbmFtZTsgfVxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvLyBUaGlzIGlzIGEga2x1ZGdlIHRvIGtlZXAga2V5bWFwcyBtb3N0bHkgd29ya2luZyBhcyByYXcgb2JqZWN0c1xuICAvLyAoYmFja3dhcmRzIGNvbXBhdGliaWxpdHkpIHdoaWxlIGF0IHRoZSBzYW1lIHRpbWUgc3VwcG9ydCBmZWF0dXJlc1xuICAvLyBsaWtlIG5vcm1hbGl6YXRpb24gYW5kIG11bHRpLXN0cm9rZSBrZXkgYmluZGluZ3MuIEl0IGNvbXBpbGVzIGFcbiAgLy8gbmV3IG5vcm1hbGl6ZWQga2V5bWFwLCBhbmQgdGhlbiB1cGRhdGVzIHRoZSBvbGQgb2JqZWN0IHRvIHJlZmxlY3RcbiAgLy8gdGhpcy5cbiAgZnVuY3Rpb24gbm9ybWFsaXplS2V5TWFwKGtleW1hcCkge1xuICAgIHZhciBjb3B5ID0ge307XG4gICAgZm9yICh2YXIga2V5bmFtZSBpbiBrZXltYXApIHsgaWYgKGtleW1hcC5oYXNPd25Qcm9wZXJ0eShrZXluYW1lKSkge1xuICAgICAgdmFyIHZhbHVlID0ga2V5bWFwW2tleW5hbWVdO1xuICAgICAgaWYgKC9eKG5hbWV8ZmFsbHRocm91Z2h8KGRlfGF0KXRhY2gpJC8udGVzdChrZXluYW1lKSkgeyBjb250aW51ZSB9XG4gICAgICBpZiAodmFsdWUgPT0gXCIuLi5cIikgeyBkZWxldGUga2V5bWFwW2tleW5hbWVdOyBjb250aW51ZSB9XG5cbiAgICAgIHZhciBrZXlzID0gbWFwKGtleW5hbWUuc3BsaXQoXCIgXCIpLCBub3JtYWxpemVLZXlOYW1lKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmFsID0gKHZvaWQgMCksIG5hbWUgPSAodm9pZCAwKTtcbiAgICAgICAgaWYgKGkgPT0ga2V5cy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgbmFtZSA9IGtleXMuam9pbihcIiBcIik7XG4gICAgICAgICAgdmFsID0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmFtZSA9IGtleXMuc2xpY2UoMCwgaSArIDEpLmpvaW4oXCIgXCIpO1xuICAgICAgICAgIHZhbCA9IFwiLi4uXCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXYgPSBjb3B5W25hbWVdO1xuICAgICAgICBpZiAoIXByZXYpIHsgY29weVtuYW1lXSA9IHZhbDsgfVxuICAgICAgICBlbHNlIGlmIChwcmV2ICE9IHZhbCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJJbmNvbnNpc3RlbnQgYmluZGluZ3MgZm9yIFwiICsgbmFtZSkgfVxuICAgICAgfVxuICAgICAgZGVsZXRlIGtleW1hcFtrZXluYW1lXTtcbiAgICB9IH1cbiAgICBmb3IgKHZhciBwcm9wIGluIGNvcHkpIHsga2V5bWFwW3Byb3BdID0gY29weVtwcm9wXTsgfVxuICAgIHJldHVybiBrZXltYXBcbiAgfVxuXG4gIGZ1bmN0aW9uIGxvb2t1cEtleShrZXksIG1hcCwgaGFuZGxlLCBjb250ZXh0KSB7XG4gICAgbWFwID0gZ2V0S2V5TWFwKG1hcCk7XG4gICAgdmFyIGZvdW5kID0gbWFwLmNhbGwgPyBtYXAuY2FsbChrZXksIGNvbnRleHQpIDogbWFwW2tleV07XG4gICAgaWYgKGZvdW5kID09PSBmYWxzZSkgeyByZXR1cm4gXCJub3RoaW5nXCIgfVxuICAgIGlmIChmb3VuZCA9PT0gXCIuLi5cIikgeyByZXR1cm4gXCJtdWx0aVwiIH1cbiAgICBpZiAoZm91bmQgIT0gbnVsbCAmJiBoYW5kbGUoZm91bmQpKSB7IHJldHVybiBcImhhbmRsZWRcIiB9XG5cbiAgICBpZiAobWFwLmZhbGx0aHJvdWdoKSB7XG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG1hcC5mYWxsdGhyb3VnaCkgIT0gXCJbb2JqZWN0IEFycmF5XVwiKVxuICAgICAgICB7IHJldHVybiBsb29rdXBLZXkoa2V5LCBtYXAuZmFsbHRocm91Z2gsIGhhbmRsZSwgY29udGV4dCkgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtYXAuZmFsbHRocm91Z2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGxvb2t1cEtleShrZXksIG1hcC5mYWxsdGhyb3VnaFtpXSwgaGFuZGxlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0IH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBNb2RpZmllciBrZXkgcHJlc3NlcyBkb24ndCBjb3VudCBhcyAncmVhbCcga2V5IHByZXNzZXMgZm9yIHRoZVxuICAvLyBwdXJwb3NlIG9mIGtleW1hcCBmYWxsdGhyb3VnaC5cbiAgZnVuY3Rpb24gaXNNb2RpZmllcktleSh2YWx1ZSkge1xuICAgIHZhciBuYW1lID0gdHlwZW9mIHZhbHVlID09IFwic3RyaW5nXCIgPyB2YWx1ZSA6IGtleU5hbWVzW3ZhbHVlLmtleUNvZGVdO1xuICAgIHJldHVybiBuYW1lID09IFwiQ3RybFwiIHx8IG5hbWUgPT0gXCJBbHRcIiB8fCBuYW1lID09IFwiU2hpZnRcIiB8fCBuYW1lID09IFwiTW9kXCJcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZE1vZGlmaWVyTmFtZXMobmFtZSwgZXZlbnQsIG5vU2hpZnQpIHtcbiAgICB2YXIgYmFzZSA9IG5hbWU7XG4gICAgaWYgKGV2ZW50LmFsdEtleSAmJiBiYXNlICE9IFwiQWx0XCIpIHsgbmFtZSA9IFwiQWx0LVwiICsgbmFtZTsgfVxuICAgIGlmICgoZmxpcEN0cmxDbWQgPyBldmVudC5tZXRhS2V5IDogZXZlbnQuY3RybEtleSkgJiYgYmFzZSAhPSBcIkN0cmxcIikgeyBuYW1lID0gXCJDdHJsLVwiICsgbmFtZTsgfVxuICAgIGlmICgoZmxpcEN0cmxDbWQgPyBldmVudC5jdHJsS2V5IDogZXZlbnQubWV0YUtleSkgJiYgYmFzZSAhPSBcIk1vZFwiKSB7IG5hbWUgPSBcIkNtZC1cIiArIG5hbWU7IH1cbiAgICBpZiAoIW5vU2hpZnQgJiYgZXZlbnQuc2hpZnRLZXkgJiYgYmFzZSAhPSBcIlNoaWZ0XCIpIHsgbmFtZSA9IFwiU2hpZnQtXCIgKyBuYW1lOyB9XG4gICAgcmV0dXJuIG5hbWVcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIG5hbWUgb2YgYSBrZXkgYXMgaW5kaWNhdGVkIGJ5IGFuIGV2ZW50IG9iamVjdC5cbiAgZnVuY3Rpb24ga2V5TmFtZShldmVudCwgbm9TaGlmdCkge1xuICAgIGlmIChwcmVzdG8gJiYgZXZlbnQua2V5Q29kZSA9PSAzNCAmJiBldmVudFtcImNoYXJcIl0pIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgbmFtZSA9IGtleU5hbWVzW2V2ZW50LmtleUNvZGVdO1xuICAgIGlmIChuYW1lID09IG51bGwgfHwgZXZlbnQuYWx0R3JhcGhLZXkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAvLyBDdHJsLVNjcm9sbExvY2sgaGFzIGtleUNvZGUgMywgc2FtZSBhcyBDdHJsLVBhdXNlLFxuICAgIC8vIHNvIHdlJ2xsIHVzZSBldmVudC5jb2RlIHdoZW4gYXZhaWxhYmxlIChDaHJvbWUgNDgrLCBGRiAzOCssIFNhZmFyaSAxMC4xKylcbiAgICBpZiAoZXZlbnQua2V5Q29kZSA9PSAzICYmIGV2ZW50LmNvZGUpIHsgbmFtZSA9IGV2ZW50LmNvZGU7IH1cbiAgICByZXR1cm4gYWRkTW9kaWZpZXJOYW1lcyhuYW1lLCBldmVudCwgbm9TaGlmdClcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEtleU1hcCh2YWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PSBcInN0cmluZ1wiID8ga2V5TWFwW3ZhbF0gOiB2YWxcbiAgfVxuXG4gIC8vIEhlbHBlciBmb3IgZGVsZXRpbmcgdGV4dCBuZWFyIHRoZSBzZWxlY3Rpb24ocyksIHVzZWQgdG8gaW1wbGVtZW50XG4gIC8vIGJhY2tzcGFjZSwgZGVsZXRlLCBhbmQgc2ltaWxhciBmdW5jdGlvbmFsaXR5LlxuICBmdW5jdGlvbiBkZWxldGVOZWFyU2VsZWN0aW9uKGNtLCBjb21wdXRlKSB7XG4gICAgdmFyIHJhbmdlcyA9IGNtLmRvYy5zZWwucmFuZ2VzLCBraWxsID0gW107XG4gICAgLy8gQnVpbGQgdXAgYSBzZXQgb2YgcmFuZ2VzIHRvIGtpbGwgZmlyc3QsIG1lcmdpbmcgb3ZlcmxhcHBpbmdcbiAgICAvLyByYW5nZXMuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB0b0tpbGwgPSBjb21wdXRlKHJhbmdlc1tpXSk7XG4gICAgICB3aGlsZSAoa2lsbC5sZW5ndGggJiYgY21wKHRvS2lsbC5mcm9tLCBsc3Qoa2lsbCkudG8pIDw9IDApIHtcbiAgICAgICAgdmFyIHJlcGxhY2VkID0ga2lsbC5wb3AoKTtcbiAgICAgICAgaWYgKGNtcChyZXBsYWNlZC5mcm9tLCB0b0tpbGwuZnJvbSkgPCAwKSB7XG4gICAgICAgICAgdG9LaWxsLmZyb20gPSByZXBsYWNlZC5mcm9tO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGtpbGwucHVzaCh0b0tpbGwpO1xuICAgIH1cbiAgICAvLyBOZXh0LCByZW1vdmUgdGhvc2UgYWN0dWFsIHJhbmdlcy5cbiAgICBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBpID0ga2lsbC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgeyByZXBsYWNlUmFuZ2UoY20uZG9jLCBcIlwiLCBraWxsW2ldLmZyb20sIGtpbGxbaV0udG8sIFwiK2RlbGV0ZVwiKTsgfVxuICAgICAgZW5zdXJlQ3Vyc29yVmlzaWJsZShjbSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlQ2hhckxvZ2ljYWxseShsaW5lLCBjaCwgZGlyKSB7XG4gICAgdmFyIHRhcmdldCA9IHNraXBFeHRlbmRpbmdDaGFycyhsaW5lLnRleHQsIGNoICsgZGlyLCBkaXIpO1xuICAgIHJldHVybiB0YXJnZXQgPCAwIHx8IHRhcmdldCA+IGxpbmUudGV4dC5sZW5ndGggPyBudWxsIDogdGFyZ2V0XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlTG9naWNhbGx5KGxpbmUsIHN0YXJ0LCBkaXIpIHtcbiAgICB2YXIgY2ggPSBtb3ZlQ2hhckxvZ2ljYWxseShsaW5lLCBzdGFydC5jaCwgZGlyKTtcbiAgICByZXR1cm4gY2ggPT0gbnVsbCA/IG51bGwgOiBuZXcgUG9zKHN0YXJ0LmxpbmUsIGNoLCBkaXIgPCAwID8gXCJhZnRlclwiIDogXCJiZWZvcmVcIilcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZE9mTGluZSh2aXN1YWxseSwgY20sIGxpbmVPYmosIGxpbmVObywgZGlyKSB7XG4gICAgaWYgKHZpc3VhbGx5KSB7XG4gICAgICBpZiAoY20uZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiKSB7IGRpciA9IC1kaXI7IH1cbiAgICAgIHZhciBvcmRlciA9IGdldE9yZGVyKGxpbmVPYmosIGNtLmRvYy5kaXJlY3Rpb24pO1xuICAgICAgaWYgKG9yZGVyKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gZGlyIDwgMCA/IGxzdChvcmRlcikgOiBvcmRlclswXTtcbiAgICAgICAgdmFyIG1vdmVJblN0b3JhZ2VPcmRlciA9IChkaXIgPCAwKSA9PSAocGFydC5sZXZlbCA9PSAxKTtcbiAgICAgICAgdmFyIHN0aWNreSA9IG1vdmVJblN0b3JhZ2VPcmRlciA/IFwiYWZ0ZXJcIiA6IFwiYmVmb3JlXCI7XG4gICAgICAgIHZhciBjaDtcbiAgICAgICAgLy8gV2l0aCBhIHdyYXBwZWQgcnRsIGNodW5rIChwb3NzaWJseSBzcGFubmluZyBtdWx0aXBsZSBiaWRpIHBhcnRzKSxcbiAgICAgICAgLy8gaXQgY291bGQgYmUgdGhhdCB0aGUgbGFzdCBiaWRpIHBhcnQgaXMgbm90IG9uIHRoZSBsYXN0IHZpc3VhbCBsaW5lLFxuICAgICAgICAvLyBzaW5jZSB2aXN1YWwgbGluZXMgY29udGFpbiBjb250ZW50IG9yZGVyLWNvbnNlY3V0aXZlIGNodW5rcy5cbiAgICAgICAgLy8gVGh1cywgaW4gcnRsLCB3ZSBhcmUgbG9va2luZyBmb3IgdGhlIGZpcnN0IChjb250ZW50LW9yZGVyKSBjaGFyYWN0ZXJcbiAgICAgICAgLy8gaW4gdGhlIHJ0bCBjaHVuayB0aGF0IGlzIG9uIHRoZSBsYXN0IGxpbmUgKHRoYXQgaXMsIHRoZSBzYW1lIGxpbmVcbiAgICAgICAgLy8gYXMgdGhlIGxhc3QgKGNvbnRlbnQtb3JkZXIpIGNoYXJhY3RlcikuXG4gICAgICAgIGlmIChwYXJ0LmxldmVsID4gMCB8fCBjbS5kb2MuZGlyZWN0aW9uID09IFwicnRsXCIpIHtcbiAgICAgICAgICB2YXIgcHJlcCA9IHByZXBhcmVNZWFzdXJlRm9yTGluZShjbSwgbGluZU9iaik7XG4gICAgICAgICAgY2ggPSBkaXIgPCAwID8gbGluZU9iai50ZXh0Lmxlbmd0aCAtIDEgOiAwO1xuICAgICAgICAgIHZhciB0YXJnZXRUb3AgPSBtZWFzdXJlQ2hhclByZXBhcmVkKGNtLCBwcmVwLCBjaCkudG9wO1xuICAgICAgICAgIGNoID0gZmluZEZpcnN0KGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gbWVhc3VyZUNoYXJQcmVwYXJlZChjbSwgcHJlcCwgY2gpLnRvcCA9PSB0YXJnZXRUb3A7IH0sIChkaXIgPCAwKSA9PSAocGFydC5sZXZlbCA9PSAxKSA/IHBhcnQuZnJvbSA6IHBhcnQudG8gLSAxLCBjaCk7XG4gICAgICAgICAgaWYgKHN0aWNreSA9PSBcImJlZm9yZVwiKSB7IGNoID0gbW92ZUNoYXJMb2dpY2FsbHkobGluZU9iaiwgY2gsIDEpOyB9XG4gICAgICAgIH0gZWxzZSB7IGNoID0gZGlyIDwgMCA/IHBhcnQudG8gOiBwYXJ0LmZyb207IH1cbiAgICAgICAgcmV0dXJuIG5ldyBQb3MobGluZU5vLCBjaCwgc3RpY2t5KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFBvcyhsaW5lTm8sIGRpciA8IDAgPyBsaW5lT2JqLnRleHQubGVuZ3RoIDogMCwgZGlyIDwgMCA/IFwiYmVmb3JlXCIgOiBcImFmdGVyXCIpXG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlVmlzdWFsbHkoY20sIGxpbmUsIHN0YXJ0LCBkaXIpIHtcbiAgICB2YXIgYmlkaSA9IGdldE9yZGVyKGxpbmUsIGNtLmRvYy5kaXJlY3Rpb24pO1xuICAgIGlmICghYmlkaSkgeyByZXR1cm4gbW92ZUxvZ2ljYWxseShsaW5lLCBzdGFydCwgZGlyKSB9XG4gICAgaWYgKHN0YXJ0LmNoID49IGxpbmUudGV4dC5sZW5ndGgpIHtcbiAgICAgIHN0YXJ0LmNoID0gbGluZS50ZXh0Lmxlbmd0aDtcbiAgICAgIHN0YXJ0LnN0aWNreSA9IFwiYmVmb3JlXCI7XG4gICAgfSBlbHNlIGlmIChzdGFydC5jaCA8PSAwKSB7XG4gICAgICBzdGFydC5jaCA9IDA7XG4gICAgICBzdGFydC5zdGlja3kgPSBcImFmdGVyXCI7XG4gICAgfVxuICAgIHZhciBwYXJ0UG9zID0gZ2V0QmlkaVBhcnRBdChiaWRpLCBzdGFydC5jaCwgc3RhcnQuc3RpY2t5KSwgcGFydCA9IGJpZGlbcGFydFBvc107XG4gICAgaWYgKGNtLmRvYy5kaXJlY3Rpb24gPT0gXCJsdHJcIiAmJiBwYXJ0LmxldmVsICUgMiA9PSAwICYmIChkaXIgPiAwID8gcGFydC50byA+IHN0YXJ0LmNoIDogcGFydC5mcm9tIDwgc3RhcnQuY2gpKSB7XG4gICAgICAvLyBDYXNlIDE6IFdlIG1vdmUgd2l0aGluIGFuIGx0ciBwYXJ0IGluIGFuIGx0ciBlZGl0b3IuIEV2ZW4gd2l0aCB3cmFwcGVkIGxpbmVzLFxuICAgICAgLy8gbm90aGluZyBpbnRlcmVzdGluZyBoYXBwZW5zLlxuICAgICAgcmV0dXJuIG1vdmVMb2dpY2FsbHkobGluZSwgc3RhcnQsIGRpcilcbiAgICB9XG5cbiAgICB2YXIgbXYgPSBmdW5jdGlvbiAocG9zLCBkaXIpIHsgcmV0dXJuIG1vdmVDaGFyTG9naWNhbGx5KGxpbmUsIHBvcyBpbnN0YW5jZW9mIFBvcyA/IHBvcy5jaCA6IHBvcywgZGlyKTsgfTtcbiAgICB2YXIgcHJlcDtcbiAgICB2YXIgZ2V0V3JhcHBlZExpbmVFeHRlbnQgPSBmdW5jdGlvbiAoY2gpIHtcbiAgICAgIGlmICghY20ub3B0aW9ucy5saW5lV3JhcHBpbmcpIHsgcmV0dXJuIHtiZWdpbjogMCwgZW5kOiBsaW5lLnRleHQubGVuZ3RofSB9XG4gICAgICBwcmVwID0gcHJlcCB8fCBwcmVwYXJlTWVhc3VyZUZvckxpbmUoY20sIGxpbmUpO1xuICAgICAgcmV0dXJuIHdyYXBwZWRMaW5lRXh0ZW50Q2hhcihjbSwgbGluZSwgcHJlcCwgY2gpXG4gICAgfTtcbiAgICB2YXIgd3JhcHBlZExpbmVFeHRlbnQgPSBnZXRXcmFwcGVkTGluZUV4dGVudChzdGFydC5zdGlja3kgPT0gXCJiZWZvcmVcIiA/IG12KHN0YXJ0LCAtMSkgOiBzdGFydC5jaCk7XG5cbiAgICBpZiAoY20uZG9jLmRpcmVjdGlvbiA9PSBcInJ0bFwiIHx8IHBhcnQubGV2ZWwgPT0gMSkge1xuICAgICAgdmFyIG1vdmVJblN0b3JhZ2VPcmRlciA9IChwYXJ0LmxldmVsID09IDEpID09IChkaXIgPCAwKTtcbiAgICAgIHZhciBjaCA9IG12KHN0YXJ0LCBtb3ZlSW5TdG9yYWdlT3JkZXIgPyAxIDogLTEpO1xuICAgICAgaWYgKGNoICE9IG51bGwgJiYgKCFtb3ZlSW5TdG9yYWdlT3JkZXIgPyBjaCA+PSBwYXJ0LmZyb20gJiYgY2ggPj0gd3JhcHBlZExpbmVFeHRlbnQuYmVnaW4gOiBjaCA8PSBwYXJ0LnRvICYmIGNoIDw9IHdyYXBwZWRMaW5lRXh0ZW50LmVuZCkpIHtcbiAgICAgICAgLy8gQ2FzZSAyOiBXZSBtb3ZlIHdpdGhpbiBhbiBydGwgcGFydCBvciBpbiBhbiBydGwgZWRpdG9yIG9uIHRoZSBzYW1lIHZpc3VhbCBsaW5lXG4gICAgICAgIHZhciBzdGlja3kgPSBtb3ZlSW5TdG9yYWdlT3JkZXIgPyBcImJlZm9yZVwiIDogXCJhZnRlclwiO1xuICAgICAgICByZXR1cm4gbmV3IFBvcyhzdGFydC5saW5lLCBjaCwgc3RpY2t5KVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIENhc2UgMzogQ291bGQgbm90IG1vdmUgd2l0aGluIHRoaXMgYmlkaSBwYXJ0IGluIHRoaXMgdmlzdWFsIGxpbmUsIHNvIGxlYXZlXG4gICAgLy8gdGhlIGN1cnJlbnQgYmlkaSBwYXJ0XG5cbiAgICB2YXIgc2VhcmNoSW5WaXN1YWxMaW5lID0gZnVuY3Rpb24gKHBhcnRQb3MsIGRpciwgd3JhcHBlZExpbmVFeHRlbnQpIHtcbiAgICAgIHZhciBnZXRSZXMgPSBmdW5jdGlvbiAoY2gsIG1vdmVJblN0b3JhZ2VPcmRlcikgeyByZXR1cm4gbW92ZUluU3RvcmFnZU9yZGVyXG4gICAgICAgID8gbmV3IFBvcyhzdGFydC5saW5lLCBtdihjaCwgMSksIFwiYmVmb3JlXCIpXG4gICAgICAgIDogbmV3IFBvcyhzdGFydC5saW5lLCBjaCwgXCJhZnRlclwiKTsgfTtcblxuICAgICAgZm9yICg7IHBhcnRQb3MgPj0gMCAmJiBwYXJ0UG9zIDwgYmlkaS5sZW5ndGg7IHBhcnRQb3MgKz0gZGlyKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gYmlkaVtwYXJ0UG9zXTtcbiAgICAgICAgdmFyIG1vdmVJblN0b3JhZ2VPcmRlciA9IChkaXIgPiAwKSA9PSAocGFydC5sZXZlbCAhPSAxKTtcbiAgICAgICAgdmFyIGNoID0gbW92ZUluU3RvcmFnZU9yZGVyID8gd3JhcHBlZExpbmVFeHRlbnQuYmVnaW4gOiBtdih3cmFwcGVkTGluZUV4dGVudC5lbmQsIC0xKTtcbiAgICAgICAgaWYgKHBhcnQuZnJvbSA8PSBjaCAmJiBjaCA8IHBhcnQudG8pIHsgcmV0dXJuIGdldFJlcyhjaCwgbW92ZUluU3RvcmFnZU9yZGVyKSB9XG4gICAgICAgIGNoID0gbW92ZUluU3RvcmFnZU9yZGVyID8gcGFydC5mcm9tIDogbXYocGFydC50bywgLTEpO1xuICAgICAgICBpZiAod3JhcHBlZExpbmVFeHRlbnQuYmVnaW4gPD0gY2ggJiYgY2ggPCB3cmFwcGVkTGluZUV4dGVudC5lbmQpIHsgcmV0dXJuIGdldFJlcyhjaCwgbW92ZUluU3RvcmFnZU9yZGVyKSB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIENhc2UgM2E6IExvb2sgZm9yIG90aGVyIGJpZGkgcGFydHMgb24gdGhlIHNhbWUgdmlzdWFsIGxpbmVcbiAgICB2YXIgcmVzID0gc2VhcmNoSW5WaXN1YWxMaW5lKHBhcnRQb3MgKyBkaXIsIGRpciwgd3JhcHBlZExpbmVFeHRlbnQpO1xuICAgIGlmIChyZXMpIHsgcmV0dXJuIHJlcyB9XG5cbiAgICAvLyBDYXNlIDNiOiBMb29rIGZvciBvdGhlciBiaWRpIHBhcnRzIG9uIHRoZSBuZXh0IHZpc3VhbCBsaW5lXG4gICAgdmFyIG5leHRDaCA9IGRpciA+IDAgPyB3cmFwcGVkTGluZUV4dGVudC5lbmQgOiBtdih3cmFwcGVkTGluZUV4dGVudC5iZWdpbiwgLTEpO1xuICAgIGlmIChuZXh0Q2ggIT0gbnVsbCAmJiAhKGRpciA+IDAgJiYgbmV4dENoID09IGxpbmUudGV4dC5sZW5ndGgpKSB7XG4gICAgICByZXMgPSBzZWFyY2hJblZpc3VhbExpbmUoZGlyID4gMCA/IDAgOiBiaWRpLmxlbmd0aCAtIDEsIGRpciwgZ2V0V3JhcHBlZExpbmVFeHRlbnQobmV4dENoKSk7XG4gICAgICBpZiAocmVzKSB7IHJldHVybiByZXMgfVxuICAgIH1cblxuICAgIC8vIENhc2UgNDogTm93aGVyZSB0byBtb3ZlXG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8vIENvbW1hbmRzIGFyZSBwYXJhbWV0ZXItbGVzcyBhY3Rpb25zIHRoYXQgY2FuIGJlIHBlcmZvcm1lZCBvbiBhblxuICAvLyBlZGl0b3IsIG1vc3RseSB1c2VkIGZvciBrZXliaW5kaW5ncy5cbiAgdmFyIGNvbW1hbmRzID0ge1xuICAgIHNlbGVjdEFsbDogc2VsZWN0QWxsLFxuICAgIHNpbmdsZVNlbGVjdGlvbjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5zZXRTZWxlY3Rpb24oY20uZ2V0Q3Vyc29yKFwiYW5jaG9yXCIpLCBjbS5nZXRDdXJzb3IoXCJoZWFkXCIpLCBzZWxfZG9udFNjcm9sbCk7IH0sXG4gICAga2lsbExpbmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICBpZiAocmFuZ2UuZW1wdHkoKSkge1xuICAgICAgICB2YXIgbGVuID0gZ2V0TGluZShjbS5kb2MsIHJhbmdlLmhlYWQubGluZSkudGV4dC5sZW5ndGg7XG4gICAgICAgIGlmIChyYW5nZS5oZWFkLmNoID09IGxlbiAmJiByYW5nZS5oZWFkLmxpbmUgPCBjbS5sYXN0TGluZSgpKVxuICAgICAgICAgIHsgcmV0dXJuIHtmcm9tOiByYW5nZS5oZWFkLCB0bzogUG9zKHJhbmdlLmhlYWQubGluZSArIDEsIDApfSB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB7IHJldHVybiB7ZnJvbTogcmFuZ2UuaGVhZCwgdG86IFBvcyhyYW5nZS5oZWFkLmxpbmUsIGxlbil9IH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB7ZnJvbTogcmFuZ2UuZnJvbSgpLCB0bzogcmFuZ2UudG8oKX1cbiAgICAgIH1cbiAgICB9KTsgfSxcbiAgICBkZWxldGVMaW5lOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGRlbGV0ZU5lYXJTZWxlY3Rpb24oY20sIGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gKHtcbiAgICAgIGZyb206IFBvcyhyYW5nZS5mcm9tKCkubGluZSwgMCksXG4gICAgICB0bzogY2xpcFBvcyhjbS5kb2MsIFBvcyhyYW5nZS50bygpLmxpbmUgKyAxLCAwKSlcbiAgICB9KTsgfSk7IH0sXG4gICAgZGVsTGluZUxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiAoe1xuICAgICAgZnJvbTogUG9zKHJhbmdlLmZyb20oKS5saW5lLCAwKSwgdG86IHJhbmdlLmZyb20oKVxuICAgIH0pOyB9KTsgfSxcbiAgICBkZWxXcmFwcGVkTGluZUxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgdmFyIGxlZnRQb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpO1xuICAgICAgcmV0dXJuIHtmcm9tOiBsZWZ0UG9zLCB0bzogcmFuZ2UuZnJvbSgpfVxuICAgIH0pOyB9LFxuICAgIGRlbFdyYXBwZWRMaW5lUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gZGVsZXRlTmVhclNlbGVjdGlvbihjbSwgZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgdG9wID0gY20uY2hhckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgdmFyIHJpZ2h0UG9zID0gY20uY29vcmRzQ2hhcih7bGVmdDogY20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoICsgMTAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpO1xuICAgICAgcmV0dXJuIHtmcm9tOiByYW5nZS5mcm9tKCksIHRvOiByaWdodFBvcyB9XG4gICAgfSk7IH0sXG4gICAgdW5kbzogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS51bmRvKCk7IH0sXG4gICAgcmVkbzogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWRvKCk7IH0sXG4gICAgdW5kb1NlbGVjdGlvbjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS51bmRvU2VsZWN0aW9uKCk7IH0sXG4gICAgcmVkb1NlbGVjdGlvbjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5yZWRvU2VsZWN0aW9uKCk7IH0sXG4gICAgZ29Eb2NTdGFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb24oUG9zKGNtLmZpcnN0TGluZSgpLCAwKSk7IH0sXG4gICAgZ29Eb2NFbmQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uKFBvcyhjbS5sYXN0TGluZSgpKSk7IH0sXG4gICAgZ29MaW5lU3RhcnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gbGluZVN0YXJ0KGNtLCByYW5nZS5oZWFkLmxpbmUpOyB9LFxuICAgICAge29yaWdpbjogXCIrbW92ZVwiLCBiaWFzOiAxfVxuICAgICk7IH0sXG4gICAgZ29MaW5lU3RhcnRTbWFydDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7IHJldHVybiBsaW5lU3RhcnRTbWFydChjbSwgcmFuZ2UuaGVhZCk7IH0sXG4gICAgICB7b3JpZ2luOiBcIittb3ZlXCIsIGJpYXM6IDF9XG4gICAgKTsgfSxcbiAgICBnb0xpbmVFbmQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkgeyByZXR1cm4gbGluZUVuZChjbSwgcmFuZ2UuaGVhZC5saW5lKTsgfSxcbiAgICAgIHtvcmlnaW46IFwiK21vdmVcIiwgYmlhczogLTF9XG4gICAgKTsgfSxcbiAgICBnb0xpbmVSaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5leHRlbmRTZWxlY3Rpb25zQnkoZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICB2YXIgdG9wID0gY20uY3Vyc29yQ29vcmRzKHJhbmdlLmhlYWQsIFwiZGl2XCIpLnRvcCArIDU7XG4gICAgICByZXR1cm4gY20uY29vcmRzQ2hhcih7bGVmdDogY20uZGlzcGxheS5saW5lRGl2Lm9mZnNldFdpZHRoICsgMTAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpXG4gICAgfSwgc2VsX21vdmUpOyB9LFxuICAgIGdvTGluZUxlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgdmFyIHRvcCA9IGNtLmN1cnNvckNvb3JkcyhyYW5nZS5oZWFkLCBcImRpdlwiKS50b3AgKyA1O1xuICAgICAgcmV0dXJuIGNtLmNvb3Jkc0NoYXIoe2xlZnQ6IDAsIHRvcDogdG9wfSwgXCJkaXZcIilcbiAgICB9LCBzZWxfbW92ZSk7IH0sXG4gICAgZ29MaW5lTGVmdFNtYXJ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgIHZhciB0b3AgPSBjbS5jdXJzb3JDb29yZHMocmFuZ2UuaGVhZCwgXCJkaXZcIikudG9wICsgNTtcbiAgICAgIHZhciBwb3MgPSBjbS5jb29yZHNDaGFyKHtsZWZ0OiAwLCB0b3A6IHRvcH0sIFwiZGl2XCIpO1xuICAgICAgaWYgKHBvcy5jaCA8IGNtLmdldExpbmUocG9zLmxpbmUpLnNlYXJjaCgvXFxTLykpIHsgcmV0dXJuIGxpbmVTdGFydFNtYXJ0KGNtLCByYW5nZS5oZWFkKSB9XG4gICAgICByZXR1cm4gcG9zXG4gICAgfSwgc2VsX21vdmUpOyB9LFxuICAgIGdvTGluZVVwOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKC0xLCBcImxpbmVcIik7IH0sXG4gICAgZ29MaW5lRG93bjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlVigxLCBcImxpbmVcIik7IH0sXG4gICAgZ29QYWdlVXA6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZVYoLTEsIFwicGFnZVwiKTsgfSxcbiAgICBnb1BhZ2VEb3duOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVWKDEsIFwicGFnZVwiKTsgfSxcbiAgICBnb0NoYXJMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcImNoYXJcIik7IH0sXG4gICAgZ29DaGFyUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXCJjaGFyXCIpOyB9LFxuICAgIGdvQ29sdW1uTGVmdDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgtMSwgXCJjb2x1bW5cIik7IH0sXG4gICAgZ29Db2x1bW5SaWdodDogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5tb3ZlSCgxLCBcImNvbHVtblwiKTsgfSxcbiAgICBnb1dvcmRMZWZ0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKC0xLCBcIndvcmRcIik7IH0sXG4gICAgZ29Hcm91cFJpZ2h0OiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLm1vdmVIKDEsIFwiZ3JvdXBcIik7IH0sXG4gICAgZ29Hcm91cExlZnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoLTEsIFwiZ3JvdXBcIik7IH0sXG4gICAgZ29Xb3JkUmlnaHQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ubW92ZUgoMSwgXCJ3b3JkXCIpOyB9LFxuICAgIGRlbENoYXJCZWZvcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgtMSwgXCJjb2RlcG9pbnRcIik7IH0sXG4gICAgZGVsQ2hhckFmdGVyOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLmRlbGV0ZUgoMSwgXCJjaGFyXCIpOyB9LFxuICAgIGRlbFdvcmRCZWZvcmU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgtMSwgXCJ3b3JkXCIpOyB9LFxuICAgIGRlbFdvcmRBZnRlcjogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKDEsIFwid29yZFwiKTsgfSxcbiAgICBkZWxHcm91cEJlZm9yZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5kZWxldGVIKC0xLCBcImdyb3VwXCIpOyB9LFxuICAgIGRlbEdyb3VwQWZ0ZXI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uZGVsZXRlSCgxLCBcImdyb3VwXCIpOyB9LFxuICAgIGluZGVudEF1dG86IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20uaW5kZW50U2VsZWN0aW9uKFwic21hcnRcIik7IH0sXG4gICAgaW5kZW50TW9yZTogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5pbmRlbnRTZWxlY3Rpb24oXCJhZGRcIik7IH0sXG4gICAgaW5kZW50TGVzczogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBjbS5pbmRlbnRTZWxlY3Rpb24oXCJzdWJ0cmFjdFwiKTsgfSxcbiAgICBpbnNlcnRUYWI6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVwbGFjZVNlbGVjdGlvbihcIlxcdFwiKTsgfSxcbiAgICBpbnNlcnRTb2Z0VGFiOiBmdW5jdGlvbiAoY20pIHtcbiAgICAgIHZhciBzcGFjZXMgPSBbXSwgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgdGFiU2l6ZSA9IGNtLm9wdGlvbnMudGFiU2l6ZTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwb3MgPSByYW5nZXNbaV0uZnJvbSgpO1xuICAgICAgICB2YXIgY29sID0gY291bnRDb2x1bW4oY20uZ2V0TGluZShwb3MubGluZSksIHBvcy5jaCwgdGFiU2l6ZSk7XG4gICAgICAgIHNwYWNlcy5wdXNoKHNwYWNlU3RyKHRhYlNpemUgLSBjb2wgJSB0YWJTaXplKSk7XG4gICAgICB9XG4gICAgICBjbS5yZXBsYWNlU2VsZWN0aW9ucyhzcGFjZXMpO1xuICAgIH0sXG4gICAgZGVmYXVsdFRhYjogZnVuY3Rpb24gKGNtKSB7XG4gICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkgeyBjbS5pbmRlbnRTZWxlY3Rpb24oXCJhZGRcIik7IH1cbiAgICAgIGVsc2UgeyBjbS5leGVjQ29tbWFuZChcImluc2VydFRhYlwiKTsgfVxuICAgIH0sXG4gICAgLy8gU3dhcCB0aGUgdHdvIGNoYXJzIGxlZnQgYW5kIHJpZ2h0IG9mIGVhY2ggc2VsZWN0aW9uJ3MgaGVhZC5cbiAgICAvLyBNb3ZlIGN1cnNvciBiZWhpbmQgdGhlIHR3byBzd2FwcGVkIGNoYXJhY3RlcnMgYWZ0ZXJ3YXJkcy5cbiAgICAvL1xuICAgIC8vIERvZXNuJ3QgY29uc2lkZXIgbGluZSBmZWVkcyBhIGNoYXJhY3Rlci5cbiAgICAvLyBEb2Vzbid0IHNjYW4gbW9yZSB0aGFuIG9uZSBsaW5lIGFib3ZlIHRvIGZpbmQgYSBjaGFyYWN0ZXIuXG4gICAgLy8gRG9lc24ndCBkbyBhbnl0aGluZyBvbiBhbiBlbXB0eSBsaW5lLlxuICAgIC8vIERvZXNuJ3QgZG8gYW55dGhpbmcgd2l0aCBub24tZW1wdHkgc2VsZWN0aW9ucy5cbiAgICB0cmFuc3Bvc2VDaGFyczogZnVuY3Rpb24gKGNtKSB7IHJldHVybiBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmFuZ2VzID0gY20ubGlzdFNlbGVjdGlvbnMoKSwgbmV3U2VsID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXJhbmdlc1tpXS5lbXB0eSgpKSB7IGNvbnRpbnVlIH1cbiAgICAgICAgdmFyIGN1ciA9IHJhbmdlc1tpXS5oZWFkLCBsaW5lID0gZ2V0TGluZShjbS5kb2MsIGN1ci5saW5lKS50ZXh0O1xuICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgIGlmIChjdXIuY2ggPT0gbGluZS5sZW5ndGgpIHsgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgY3VyLmNoIC0gMSk7IH1cbiAgICAgICAgICBpZiAoY3VyLmNoID4gMCkge1xuICAgICAgICAgICAgY3VyID0gbmV3IFBvcyhjdXIubGluZSwgY3VyLmNoICsgMSk7XG4gICAgICAgICAgICBjbS5yZXBsYWNlUmFuZ2UobGluZS5jaGFyQXQoY3VyLmNoIC0gMSkgKyBsaW5lLmNoYXJBdChjdXIuY2ggLSAyKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3MoY3VyLmxpbmUsIGN1ci5jaCAtIDIpLCBjdXIsIFwiK3RyYW5zcG9zZVwiKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGN1ci5saW5lID4gY20uZG9jLmZpcnN0KSB7XG4gICAgICAgICAgICB2YXIgcHJldiA9IGdldExpbmUoY20uZG9jLCBjdXIubGluZSAtIDEpLnRleHQ7XG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICBjdXIgPSBuZXcgUG9zKGN1ci5saW5lLCAxKTtcbiAgICAgICAgICAgICAgY20ucmVwbGFjZVJhbmdlKGxpbmUuY2hhckF0KDApICsgY20uZG9jLmxpbmVTZXBhcmF0b3IoKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2LmNoYXJBdChwcmV2Lmxlbmd0aCAtIDEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUG9zKGN1ci5saW5lIC0gMSwgcHJldi5sZW5ndGggLSAxKSwgY3VyLCBcIit0cmFuc3Bvc2VcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5ld1NlbC5wdXNoKG5ldyBSYW5nZShjdXIsIGN1cikpO1xuICAgICAgfVxuICAgICAgY20uc2V0U2VsZWN0aW9ucyhuZXdTZWwpO1xuICAgIH0pOyB9LFxuICAgIG5ld2xpbmVBbmRJbmRlbnQ6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHNlbHMgPSBjbS5saXN0U2VsZWN0aW9ucygpO1xuICAgICAgZm9yICh2YXIgaSA9IHNlbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG4gICAgICAgIHsgY20ucmVwbGFjZVJhbmdlKGNtLmRvYy5saW5lU2VwYXJhdG9yKCksIHNlbHNbaV0uYW5jaG9yLCBzZWxzW2ldLmhlYWQsIFwiK2lucHV0XCIpOyB9XG4gICAgICBzZWxzID0gY20ubGlzdFNlbGVjdGlvbnMoKTtcbiAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IHNlbHMubGVuZ3RoOyBpJDErKylcbiAgICAgICAgeyBjbS5pbmRlbnRMaW5lKHNlbHNbaSQxXS5mcm9tKCkubGluZSwgbnVsbCwgdHJ1ZSk7IH1cbiAgICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xuICAgIH0pOyB9LFxuICAgIG9wZW5MaW5lOiBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcXG5cIiwgXCJzdGFydFwiKTsgfSxcbiAgICB0b2dnbGVPdmVyd3JpdGU6IGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20udG9nZ2xlT3ZlcndyaXRlKCk7IH1cbiAgfTtcblxuXG4gIGZ1bmN0aW9uIGxpbmVTdGFydChjbSwgbGluZU4pIHtcbiAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBsaW5lTik7XG4gICAgdmFyIHZpc3VhbCA9IHZpc3VhbExpbmUobGluZSk7XG4gICAgaWYgKHZpc3VhbCAhPSBsaW5lKSB7IGxpbmVOID0gbGluZU5vKHZpc3VhbCk7IH1cbiAgICByZXR1cm4gZW5kT2ZMaW5lKHRydWUsIGNtLCB2aXN1YWwsIGxpbmVOLCAxKVxuICB9XG4gIGZ1bmN0aW9uIGxpbmVFbmQoY20sIGxpbmVOKSB7XG4gICAgdmFyIGxpbmUgPSBnZXRMaW5lKGNtLmRvYywgbGluZU4pO1xuICAgIHZhciB2aXN1YWwgPSB2aXN1YWxMaW5lRW5kKGxpbmUpO1xuICAgIGlmICh2aXN1YWwgIT0gbGluZSkgeyBsaW5lTiA9IGxpbmVObyh2aXN1YWwpOyB9XG4gICAgcmV0dXJuIGVuZE9mTGluZSh0cnVlLCBjbSwgbGluZSwgbGluZU4sIC0xKVxuICB9XG4gIGZ1bmN0aW9uIGxpbmVTdGFydFNtYXJ0KGNtLCBwb3MpIHtcbiAgICB2YXIgc3RhcnQgPSBsaW5lU3RhcnQoY20sIHBvcy5saW5lKTtcbiAgICB2YXIgbGluZSA9IGdldExpbmUoY20uZG9jLCBzdGFydC5saW5lKTtcbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKTtcbiAgICBpZiAoIW9yZGVyIHx8IG9yZGVyWzBdLmxldmVsID09IDApIHtcbiAgICAgIHZhciBmaXJzdE5vbldTID0gTWF0aC5tYXgoc3RhcnQuY2gsIGxpbmUudGV4dC5zZWFyY2goL1xcUy8pKTtcbiAgICAgIHZhciBpbldTID0gcG9zLmxpbmUgPT0gc3RhcnQubGluZSAmJiBwb3MuY2ggPD0gZmlyc3ROb25XUyAmJiBwb3MuY2g7XG4gICAgICByZXR1cm4gUG9zKHN0YXJ0LmxpbmUsIGluV1MgPyAwIDogZmlyc3ROb25XUywgc3RhcnQuc3RpY2t5KVxuICAgIH1cbiAgICByZXR1cm4gc3RhcnRcbiAgfVxuXG4gIC8vIFJ1biBhIGhhbmRsZXIgdGhhdCB3YXMgYm91bmQgdG8gYSBrZXkuXG4gIGZ1bmN0aW9uIGRvSGFuZGxlQmluZGluZyhjbSwgYm91bmQsIGRyb3BTaGlmdCkge1xuICAgIGlmICh0eXBlb2YgYm91bmQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgYm91bmQgPSBjb21tYW5kc1tib3VuZF07XG4gICAgICBpZiAoIWJvdW5kKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIC8vIEVuc3VyZSBwcmV2aW91cyBpbnB1dCBoYXMgYmVlbiByZWFkLCBzbyB0aGF0IHRoZSBoYW5kbGVyIHNlZXMgYVxuICAgIC8vIGNvbnNpc3RlbnQgdmlldyBvZiB0aGUgZG9jdW1lbnRcbiAgICBjbS5kaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpO1xuICAgIHZhciBwcmV2U2hpZnQgPSBjbS5kaXNwbGF5LnNoaWZ0LCBkb25lID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChjbS5pc1JlYWRPbmx5KCkpIHsgY20uc3RhdGUuc3VwcHJlc3NFZGl0cyA9IHRydWU7IH1cbiAgICAgIGlmIChkcm9wU2hpZnQpIHsgY20uZGlzcGxheS5zaGlmdCA9IGZhbHNlOyB9XG4gICAgICBkb25lID0gYm91bmQoY20pICE9IFBhc3M7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGNtLmRpc3BsYXkuc2hpZnQgPSBwcmV2U2hpZnQ7XG4gICAgICBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBkb25lXG4gIH1cblxuICBmdW5jdGlvbiBsb29rdXBLZXlGb3JFZGl0b3IoY20sIG5hbWUsIGhhbmRsZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uc3RhdGUua2V5TWFwcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvb2t1cEtleShuYW1lLCBjbS5zdGF0ZS5rZXlNYXBzW2ldLCBoYW5kbGUsIGNtKTtcbiAgICAgIGlmIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdCB9XG4gICAgfVxuICAgIHJldHVybiAoY20ub3B0aW9ucy5leHRyYUtleXMgJiYgbG9va3VwS2V5KG5hbWUsIGNtLm9wdGlvbnMuZXh0cmFLZXlzLCBoYW5kbGUsIGNtKSlcbiAgICAgIHx8IGxvb2t1cEtleShuYW1lLCBjbS5vcHRpb25zLmtleU1hcCwgaGFuZGxlLCBjbSlcbiAgfVxuXG4gIC8vIE5vdGUgdGhhdCwgZGVzcGl0ZSB0aGUgbmFtZSwgdGhpcyBmdW5jdGlvbiBpcyBhbHNvIHVzZWQgdG8gY2hlY2tcbiAgLy8gZm9yIGJvdW5kIG1vdXNlIGNsaWNrcy5cblxuICB2YXIgc3RvcFNlcSA9IG5ldyBEZWxheWVkO1xuXG4gIGZ1bmN0aW9uIGRpc3BhdGNoS2V5KGNtLCBuYW1lLCBlLCBoYW5kbGUpIHtcbiAgICB2YXIgc2VxID0gY20uc3RhdGUua2V5U2VxO1xuICAgIGlmIChzZXEpIHtcbiAgICAgIGlmIChpc01vZGlmaWVyS2V5KG5hbWUpKSB7IHJldHVybiBcImhhbmRsZWRcIiB9XG4gICAgICBpZiAoL1xcJyQvLnRlc3QobmFtZSkpXG4gICAgICAgIHsgY20uc3RhdGUua2V5U2VxID0gbnVsbDsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IHN0b3BTZXEuc2V0KDUwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGNtLnN0YXRlLmtleVNlcSA9PSBzZXEpIHtcbiAgICAgICAgICAgIGNtLnN0YXRlLmtleVNlcSA9IG51bGw7XG4gICAgICAgICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTsgfVxuICAgICAgaWYgKGRpc3BhdGNoS2V5SW5uZXIoY20sIHNlcSArIFwiIFwiICsgbmFtZSwgZSwgaGFuZGxlKSkgeyByZXR1cm4gdHJ1ZSB9XG4gICAgfVxuICAgIHJldHVybiBkaXNwYXRjaEtleUlubmVyKGNtLCBuYW1lLCBlLCBoYW5kbGUpXG4gIH1cblxuICBmdW5jdGlvbiBkaXNwYXRjaEtleUlubmVyKGNtLCBuYW1lLCBlLCBoYW5kbGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gbG9va3VwS2V5Rm9yRWRpdG9yKGNtLCBuYW1lLCBoYW5kbGUpO1xuXG4gICAgaWYgKHJlc3VsdCA9PSBcIm11bHRpXCIpXG4gICAgICB7IGNtLnN0YXRlLmtleVNlcSA9IG5hbWU7IH1cbiAgICBpZiAocmVzdWx0ID09IFwiaGFuZGxlZFwiKVxuICAgICAgeyBzaWduYWxMYXRlcihjbSwgXCJrZXlIYW5kbGVkXCIsIGNtLCBuYW1lLCBlKTsgfVxuXG4gICAgaWYgKHJlc3VsdCA9PSBcImhhbmRsZWRcIiB8fCByZXN1bHQgPT0gXCJtdWx0aVwiKSB7XG4gICAgICBlX3ByZXZlbnREZWZhdWx0KGUpO1xuICAgICAgcmVzdGFydEJsaW5rKGNtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gISFyZXN1bHRcbiAgfVxuXG4gIC8vIEhhbmRsZSBhIGtleSBmcm9tIHRoZSBrZXlkb3duIGV2ZW50LlxuICBmdW5jdGlvbiBoYW5kbGVLZXlCaW5kaW5nKGNtLCBlKSB7XG4gICAgdmFyIG5hbWUgPSBrZXlOYW1lKGUsIHRydWUpO1xuICAgIGlmICghbmFtZSkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgaWYgKGUuc2hpZnRLZXkgJiYgIWNtLnN0YXRlLmtleVNlcSkge1xuICAgICAgLy8gRmlyc3QgdHJ5IHRvIHJlc29sdmUgZnVsbCBuYW1lIChpbmNsdWRpbmcgJ1NoaWZ0LScpLiBGYWlsaW5nXG4gICAgICAvLyB0aGF0LCBzZWUgaWYgdGhlcmUgaXMgYSBjdXJzb3ItbW90aW9uIGNvbW1hbmQgKHN0YXJ0aW5nIHdpdGhcbiAgICAgIC8vICdnbycpIGJvdW5kIHRvIHRoZSBrZXluYW1lIHdpdGhvdXQgJ1NoaWZ0LScuXG4gICAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sIFwiU2hpZnQtXCIgKyBuYW1lLCBlLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiLCB0cnVlKTsgfSlcbiAgICAgICAgICB8fCBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiID8gL15nb1tBLVpdLy50ZXN0KGIpIDogYi5tb3Rpb24pXG4gICAgICAgICAgICAgICAgIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYikgfVxuICAgICAgICAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgbmFtZSwgZSwgZnVuY3Rpb24gKGIpIHsgcmV0dXJuIGRvSGFuZGxlQmluZGluZyhjbSwgYik7IH0pXG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxlIGEga2V5IGZyb20gdGhlIGtleXByZXNzIGV2ZW50XG4gIGZ1bmN0aW9uIGhhbmRsZUNoYXJCaW5kaW5nKGNtLCBlLCBjaCkge1xuICAgIHJldHVybiBkaXNwYXRjaEtleShjbSwgXCInXCIgKyBjaCArIFwiJ1wiLCBlLCBmdW5jdGlvbiAoYikgeyByZXR1cm4gZG9IYW5kbGVCaW5kaW5nKGNtLCBiLCB0cnVlKTsgfSlcbiAgfVxuXG4gIHZhciBsYXN0U3RvcHBlZEtleSA9IG51bGw7XG4gIGZ1bmN0aW9uIG9uS2V5RG93bihlKSB7XG4gICAgdmFyIGNtID0gdGhpcztcbiAgICBpZiAoZS50YXJnZXQgJiYgZS50YXJnZXQgIT0gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpKSB7IHJldHVybiB9XG4gICAgY20uY3VyT3AuZm9jdXMgPSBhY3RpdmVFbHQoKTtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XG4gICAgLy8gSUUgZG9lcyBzdHJhbmdlIHRoaW5ncyB3aXRoIGVzY2FwZS5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExICYmIGUua2V5Q29kZSA9PSAyNykgeyBlLnJldHVyblZhbHVlID0gZmFsc2U7IH1cbiAgICB2YXIgY29kZSA9IGUua2V5Q29kZTtcbiAgICBjbS5kaXNwbGF5LnNoaWZ0ID0gY29kZSA9PSAxNiB8fCBlLnNoaWZ0S2V5O1xuICAgIHZhciBoYW5kbGVkID0gaGFuZGxlS2V5QmluZGluZyhjbSwgZSk7XG4gICAgaWYgKHByZXN0bykge1xuICAgICAgbGFzdFN0b3BwZWRLZXkgPSBoYW5kbGVkID8gY29kZSA6IG51bGw7XG4gICAgICAvLyBPcGVyYSBoYXMgbm8gY3V0IGV2ZW50Li4uIHdlIHRyeSB0byBhdCBsZWFzdCBjYXRjaCB0aGUga2V5IGNvbWJvXG4gICAgICBpZiAoIWhhbmRsZWQgJiYgY29kZSA9PSA4OCAmJiAhaGFzQ29weUV2ZW50ICYmIChtYWMgPyBlLm1ldGFLZXkgOiBlLmN0cmxLZXkpKVxuICAgICAgICB7IGNtLnJlcGxhY2VTZWxlY3Rpb24oXCJcIiwgbnVsbCwgXCJjdXRcIik7IH1cbiAgICB9XG4gICAgaWYgKGdlY2tvICYmICFtYWMgJiYgIWhhbmRsZWQgJiYgY29kZSA9PSA0NiAmJiBlLnNoaWZ0S2V5ICYmICFlLmN0cmxLZXkgJiYgZG9jdW1lbnQuZXhlY0NvbW1hbmQpXG4gICAgICB7IGRvY3VtZW50LmV4ZWNDb21tYW5kKFwiY3V0XCIpOyB9XG5cbiAgICAvLyBUdXJuIG1vdXNlIGludG8gY3Jvc3NoYWlyIHdoZW4gQWx0IGlzIGhlbGQgb24gTWFjLlxuICAgIGlmIChjb2RlID09IDE4ICYmICEvXFxiQ29kZU1pcnJvci1jcm9zc2hhaXJcXGIvLnRlc3QoY20uZGlzcGxheS5saW5lRGl2LmNsYXNzTmFtZSkpXG4gICAgICB7IHNob3dDcm9zc0hhaXIoY20pOyB9XG4gIH1cblxuICBmdW5jdGlvbiBzaG93Q3Jvc3NIYWlyKGNtKSB7XG4gICAgdmFyIGxpbmVEaXYgPSBjbS5kaXNwbGF5LmxpbmVEaXY7XG4gICAgYWRkQ2xhc3MobGluZURpdiwgXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTtcblxuICAgIGZ1bmN0aW9uIHVwKGUpIHtcbiAgICAgIGlmIChlLmtleUNvZGUgPT0gMTggfHwgIWUuYWx0S2V5KSB7XG4gICAgICAgIHJtQ2xhc3MobGluZURpdiwgXCJDb2RlTWlycm9yLWNyb3NzaGFpclwiKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCBcImtleXVwXCIsIHVwKTtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCBcIm1vdXNlb3ZlclwiLCB1cCk7XG4gICAgICB9XG4gICAgfVxuICAgIG9uKGRvY3VtZW50LCBcImtleXVwXCIsIHVwKTtcbiAgICBvbihkb2N1bWVudCwgXCJtb3VzZW92ZXJcIiwgdXApO1xuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlVcChlKSB7XG4gICAgaWYgKGUua2V5Q29kZSA9PSAxNikgeyB0aGlzLmRvYy5zZWwuc2hpZnQgPSBmYWxzZTsgfVxuICAgIHNpZ25hbERPTUV2ZW50KHRoaXMsIGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25LZXlQcmVzcyhlKSB7XG4gICAgdmFyIGNtID0gdGhpcztcbiAgICBpZiAoZS50YXJnZXQgJiYgZS50YXJnZXQgIT0gY20uZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpKSB7IHJldHVybiB9XG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGUuY3RybEtleSAmJiAhZS5hbHRLZXkgfHwgbWFjICYmIGUubWV0YUtleSkgeyByZXR1cm4gfVxuICAgIHZhciBrZXlDb2RlID0gZS5rZXlDb2RlLCBjaGFyQ29kZSA9IGUuY2hhckNvZGU7XG4gICAgaWYgKHByZXN0byAmJiBrZXlDb2RlID09IGxhc3RTdG9wcGVkS2V5KSB7bGFzdFN0b3BwZWRLZXkgPSBudWxsOyBlX3ByZXZlbnREZWZhdWx0KGUpOyByZXR1cm59XG4gICAgaWYgKChwcmVzdG8gJiYgKCFlLndoaWNoIHx8IGUud2hpY2ggPCAxMCkpICYmIGhhbmRsZUtleUJpbmRpbmcoY20sIGUpKSB7IHJldHVybiB9XG4gICAgdmFyIGNoID0gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSA9PSBudWxsID8ga2V5Q29kZSA6IGNoYXJDb2RlKTtcbiAgICAvLyBTb21lIGJyb3dzZXJzIGZpcmUga2V5cHJlc3MgZXZlbnRzIGZvciBiYWNrc3BhY2VcbiAgICBpZiAoY2ggPT0gXCJcXHgwOFwiKSB7IHJldHVybiB9XG4gICAgaWYgKGhhbmRsZUNoYXJCaW5kaW5nKGNtLCBlLCBjaCkpIHsgcmV0dXJuIH1cbiAgICBjbS5kaXNwbGF5LmlucHV0Lm9uS2V5UHJlc3MoZSk7XG4gIH1cblxuICB2YXIgRE9VQkxFQ0xJQ0tfREVMQVkgPSA0MDA7XG5cbiAgdmFyIFBhc3RDbGljayA9IGZ1bmN0aW9uKHRpbWUsIHBvcywgYnV0dG9uKSB7XG4gICAgdGhpcy50aW1lID0gdGltZTtcbiAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB0aGlzLmJ1dHRvbiA9IGJ1dHRvbjtcbiAgfTtcblxuICBQYXN0Q2xpY2sucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAodGltZSwgcG9zLCBidXR0b24pIHtcbiAgICByZXR1cm4gdGhpcy50aW1lICsgRE9VQkxFQ0xJQ0tfREVMQVkgPiB0aW1lICYmXG4gICAgICBjbXAocG9zLCB0aGlzLnBvcykgPT0gMCAmJiBidXR0b24gPT0gdGhpcy5idXR0b25cbiAgfTtcblxuICB2YXIgbGFzdENsaWNrLCBsYXN0RG91YmxlQ2xpY2s7XG4gIGZ1bmN0aW9uIGNsaWNrUmVwZWF0KHBvcywgYnV0dG9uKSB7XG4gICAgdmFyIG5vdyA9ICtuZXcgRGF0ZTtcbiAgICBpZiAobGFzdERvdWJsZUNsaWNrICYmIGxhc3REb3VibGVDbGljay5jb21wYXJlKG5vdywgcG9zLCBidXR0b24pKSB7XG4gICAgICBsYXN0Q2xpY2sgPSBsYXN0RG91YmxlQ2xpY2sgPSBudWxsO1xuICAgICAgcmV0dXJuIFwidHJpcGxlXCJcbiAgICB9IGVsc2UgaWYgKGxhc3RDbGljayAmJiBsYXN0Q2xpY2suY29tcGFyZShub3csIHBvcywgYnV0dG9uKSkge1xuICAgICAgbGFzdERvdWJsZUNsaWNrID0gbmV3IFBhc3RDbGljayhub3csIHBvcywgYnV0dG9uKTtcbiAgICAgIGxhc3RDbGljayA9IG51bGw7XG4gICAgICByZXR1cm4gXCJkb3VibGVcIlxuICAgIH0gZWxzZSB7XG4gICAgICBsYXN0Q2xpY2sgPSBuZXcgUGFzdENsaWNrKG5vdywgcG9zLCBidXR0b24pO1xuICAgICAgbGFzdERvdWJsZUNsaWNrID0gbnVsbDtcbiAgICAgIHJldHVybiBcInNpbmdsZVwiXG4gICAgfVxuICB9XG5cbiAgLy8gQSBtb3VzZSBkb3duIGNhbiBiZSBhIHNpbmdsZSBjbGljaywgZG91YmxlIGNsaWNrLCB0cmlwbGUgY2xpY2ssXG4gIC8vIHN0YXJ0IG9mIHNlbGVjdGlvbiBkcmFnLCBzdGFydCBvZiB0ZXh0IGRyYWcsIG5ldyBjdXJzb3JcbiAgLy8gKGN0cmwtY2xpY2spLCByZWN0YW5nbGUgZHJhZyAoYWx0LWRyYWcpLCBvciB4d2luXG4gIC8vIG1pZGRsZS1jbGljay1wYXN0ZS4gT3IgaXQgbWlnaHQgYmUgYSBjbGljayBvbiBzb21ldGhpbmcgd2Ugc2hvdWxkXG4gIC8vIG5vdCBpbnRlcmZlcmUgd2l0aCwgc3VjaCBhcyBhIHNjcm9sbGJhciBvciB3aWRnZXQuXG4gIGZ1bmN0aW9uIG9uTW91c2VEb3duKGUpIHtcbiAgICB2YXIgY20gPSB0aGlzLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGRpc3BsYXkuYWN0aXZlVG91Y2ggJiYgZGlzcGxheS5pbnB1dC5zdXBwb3J0c1RvdWNoKCkpIHsgcmV0dXJuIH1cbiAgICBkaXNwbGF5LmlucHV0LmVuc3VyZVBvbGxlZCgpO1xuICAgIGRpc3BsYXkuc2hpZnQgPSBlLnNoaWZ0S2V5O1xuXG4gICAgaWYgKGV2ZW50SW5XaWRnZXQoZGlzcGxheSwgZSkpIHtcbiAgICAgIGlmICghd2Via2l0KSB7XG4gICAgICAgIC8vIEJyaWVmbHkgdHVybiBvZmYgZHJhZ2dhYmlsaXR5LCB0byBhbGxvdyB3aWRnZXRzIHRvIGRvXG4gICAgICAgIC8vIG5vcm1hbCBkcmFnZ2luZyB0aGluZ3MuXG4gICAgICAgIGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ2dhYmxlID0gZmFsc2U7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSB0cnVlOyB9LCAxMDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChjbGlja0luR3V0dGVyKGNtLCBlKSkgeyByZXR1cm4gfVxuICAgIHZhciBwb3MgPSBwb3NGcm9tTW91c2UoY20sIGUpLCBidXR0b24gPSBlX2J1dHRvbihlKSwgcmVwZWF0ID0gcG9zID8gY2xpY2tSZXBlYXQocG9zLCBidXR0b24pIDogXCJzaW5nbGVcIjtcbiAgICB3aW5kb3cuZm9jdXMoKTtcblxuICAgIC8vICMzMjYxOiBtYWtlIHN1cmUsIHRoYXQgd2UncmUgbm90IHN0YXJ0aW5nIGEgc2Vjb25kIHNlbGVjdGlvblxuICAgIGlmIChidXR0b24gPT0gMSAmJiBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0KVxuICAgICAgeyBjbS5zdGF0ZS5zZWxlY3RpbmdUZXh0KGUpOyB9XG5cbiAgICBpZiAocG9zICYmIGhhbmRsZU1hcHBlZEJ1dHRvbihjbSwgYnV0dG9uLCBwb3MsIHJlcGVhdCwgZSkpIHsgcmV0dXJuIH1cblxuICAgIGlmIChidXR0b24gPT0gMSkge1xuICAgICAgaWYgKHBvcykgeyBsZWZ0QnV0dG9uRG93bihjbSwgcG9zLCByZXBlYXQsIGUpOyB9XG4gICAgICBlbHNlIGlmIChlX3RhcmdldChlKSA9PSBkaXNwbGF5LnNjcm9sbGVyKSB7IGVfcHJldmVudERlZmF1bHQoZSk7IH1cbiAgICB9IGVsc2UgaWYgKGJ1dHRvbiA9PSAyKSB7XG4gICAgICBpZiAocG9zKSB7IGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHBvcyk7IH1cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9LCAyMCk7XG4gICAgfSBlbHNlIGlmIChidXR0b24gPT0gMykge1xuICAgICAgaWYgKGNhcHR1cmVSaWdodENsaWNrKSB7IGNtLmRpc3BsYXkuaW5wdXQub25Db250ZXh0TWVudShlKTsgfVxuICAgICAgZWxzZSB7IGRlbGF5Qmx1ckV2ZW50KGNtKTsgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGhhbmRsZU1hcHBlZEJ1dHRvbihjbSwgYnV0dG9uLCBwb3MsIHJlcGVhdCwgZXZlbnQpIHtcbiAgICB2YXIgbmFtZSA9IFwiQ2xpY2tcIjtcbiAgICBpZiAocmVwZWF0ID09IFwiZG91YmxlXCIpIHsgbmFtZSA9IFwiRG91YmxlXCIgKyBuYW1lOyB9XG4gICAgZWxzZSBpZiAocmVwZWF0ID09IFwidHJpcGxlXCIpIHsgbmFtZSA9IFwiVHJpcGxlXCIgKyBuYW1lOyB9XG4gICAgbmFtZSA9IChidXR0b24gPT0gMSA/IFwiTGVmdFwiIDogYnV0dG9uID09IDIgPyBcIk1pZGRsZVwiIDogXCJSaWdodFwiKSArIG5hbWU7XG5cbiAgICByZXR1cm4gZGlzcGF0Y2hLZXkoY20sICBhZGRNb2RpZmllck5hbWVzKG5hbWUsIGV2ZW50KSwgZXZlbnQsIGZ1bmN0aW9uIChib3VuZCkge1xuICAgICAgaWYgKHR5cGVvZiBib3VuZCA9PSBcInN0cmluZ1wiKSB7IGJvdW5kID0gY29tbWFuZHNbYm91bmRdOyB9XG4gICAgICBpZiAoIWJvdW5kKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICB2YXIgZG9uZSA9IGZhbHNlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGNtLmlzUmVhZE9ubHkoKSkgeyBjbS5zdGF0ZS5zdXBwcmVzc0VkaXRzID0gdHJ1ZTsgfVxuICAgICAgICBkb25lID0gYm91bmQoY20sIHBvcykgIT0gUGFzcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNtLnN0YXRlLnN1cHByZXNzRWRpdHMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkb25lXG4gICAgfSlcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZU1vdXNlKGNtLCByZXBlYXQsIGV2ZW50KSB7XG4gICAgdmFyIG9wdGlvbiA9IGNtLmdldE9wdGlvbihcImNvbmZpZ3VyZU1vdXNlXCIpO1xuICAgIHZhciB2YWx1ZSA9IG9wdGlvbiA/IG9wdGlvbihjbSwgcmVwZWF0LCBldmVudCkgOiB7fTtcbiAgICBpZiAodmFsdWUudW5pdCA9PSBudWxsKSB7XG4gICAgICB2YXIgcmVjdCA9IGNocm9tZU9TID8gZXZlbnQuc2hpZnRLZXkgJiYgZXZlbnQubWV0YUtleSA6IGV2ZW50LmFsdEtleTtcbiAgICAgIHZhbHVlLnVuaXQgPSByZWN0ID8gXCJyZWN0YW5nbGVcIiA6IHJlcGVhdCA9PSBcInNpbmdsZVwiID8gXCJjaGFyXCIgOiByZXBlYXQgPT0gXCJkb3VibGVcIiA/IFwid29yZFwiIDogXCJsaW5lXCI7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5leHRlbmQgPT0gbnVsbCB8fCBjbS5kb2MuZXh0ZW5kKSB7IHZhbHVlLmV4dGVuZCA9IGNtLmRvYy5leHRlbmQgfHwgZXZlbnQuc2hpZnRLZXk7IH1cbiAgICBpZiAodmFsdWUuYWRkTmV3ID09IG51bGwpIHsgdmFsdWUuYWRkTmV3ID0gbWFjID8gZXZlbnQubWV0YUtleSA6IGV2ZW50LmN0cmxLZXk7IH1cbiAgICBpZiAodmFsdWUubW92ZU9uRHJhZyA9PSBudWxsKSB7IHZhbHVlLm1vdmVPbkRyYWcgPSAhKG1hYyA/IGV2ZW50LmFsdEtleSA6IGV2ZW50LmN0cmxLZXkpOyB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICBmdW5jdGlvbiBsZWZ0QnV0dG9uRG93bihjbSwgcG9zLCByZXBlYXQsIGV2ZW50KSB7XG4gICAgaWYgKGllKSB7IHNldFRpbWVvdXQoYmluZChlbnN1cmVGb2N1cywgY20pLCAwKTsgfVxuICAgIGVsc2UgeyBjbS5jdXJPcC5mb2N1cyA9IGFjdGl2ZUVsdCgpOyB9XG5cbiAgICB2YXIgYmVoYXZpb3IgPSBjb25maWd1cmVNb3VzZShjbSwgcmVwZWF0LCBldmVudCk7XG5cbiAgICB2YXIgc2VsID0gY20uZG9jLnNlbCwgY29udGFpbmVkO1xuICAgIGlmIChjbS5vcHRpb25zLmRyYWdEcm9wICYmIGRyYWdBbmREcm9wICYmICFjbS5pc1JlYWRPbmx5KCkgJiZcbiAgICAgICAgcmVwZWF0ID09IFwic2luZ2xlXCIgJiYgKGNvbnRhaW5lZCA9IHNlbC5jb250YWlucyhwb3MpKSA+IC0xICYmXG4gICAgICAgIChjbXAoKGNvbnRhaW5lZCA9IHNlbC5yYW5nZXNbY29udGFpbmVkXSkuZnJvbSgpLCBwb3MpIDwgMCB8fCBwb3MueFJlbCA+IDApICYmXG4gICAgICAgIChjbXAoY29udGFpbmVkLnRvKCksIHBvcykgPiAwIHx8IHBvcy54UmVsIDwgMCkpXG4gICAgICB7IGxlZnRCdXR0b25TdGFydERyYWcoY20sIGV2ZW50LCBwb3MsIGJlaGF2aW9yKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgbGVmdEJ1dHRvblNlbGVjdChjbSwgZXZlbnQsIHBvcywgYmVoYXZpb3IpOyB9XG4gIH1cblxuICAvLyBTdGFydCBhIHRleHQgZHJhZy4gV2hlbiBpdCBlbmRzLCBzZWUgaWYgYW55IGRyYWdnaW5nIGFjdHVhbGx5XG4gIC8vIGhhcHBlbiwgYW5kIHRyZWF0IGFzIGEgY2xpY2sgaWYgaXQgZGlkbid0LlxuICBmdW5jdGlvbiBsZWZ0QnV0dG9uU3RhcnREcmFnKGNtLCBldmVudCwgcG9zLCBiZWhhdmlvcikge1xuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgbW92ZWQgPSBmYWxzZTtcbiAgICB2YXIgZHJhZ0VuZCA9IG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICh3ZWJraXQpIHsgZGlzcGxheS5zY3JvbGxlci5kcmFnZ2FibGUgPSBmYWxzZTsgfVxuICAgICAgY20uc3RhdGUuZHJhZ2dpbmdUZXh0ID0gZmFsc2U7XG4gICAgICBpZiAoY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQpIHtcbiAgICAgICAgaWYgKGNtLmhhc0ZvY3VzKCkpIHsgY20uc3RhdGUuZGVsYXlpbmdCbHVyRXZlbnQgPSBmYWxzZTsgfVxuICAgICAgICBlbHNlIHsgZGVsYXlCbHVyRXZlbnQoY20pOyB9XG4gICAgICB9XG4gICAgICBvZmYoZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2V1cFwiLCBkcmFnRW5kKTtcbiAgICAgIG9mZihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgbW91c2VNb3ZlKTtcbiAgICAgIG9mZihkaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdzdGFydFwiLCBkcmFnU3RhcnQpO1xuICAgICAgb2ZmKGRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJvcFwiLCBkcmFnRW5kKTtcbiAgICAgIGlmICghbW92ZWQpIHtcbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgaWYgKCFiZWhhdmlvci5hZGROZXcpXG4gICAgICAgICAgeyBleHRlbmRTZWxlY3Rpb24oY20uZG9jLCBwb3MsIG51bGwsIG51bGwsIGJlaGF2aW9yLmV4dGVuZCk7IH1cbiAgICAgICAgLy8gV29yayBhcm91bmQgdW5leHBsYWluYWJsZSBmb2N1cyBwcm9ibGVtIGluIElFOSAoIzIxMjcpIGFuZCBDaHJvbWUgKCMzMDgxKVxuICAgICAgICBpZiAoKHdlYmtpdCAmJiAhc2FmYXJpKSB8fCBpZSAmJiBpZV92ZXJzaW9uID09IDkpXG4gICAgICAgICAgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudC5ib2R5LmZvY3VzKHtwcmV2ZW50U2Nyb2xsOiB0cnVlfSk7IGRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LCAyMCk7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgZGlzcGxheS5pbnB1dC5mb2N1cygpOyB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIG1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICBtb3ZlZCA9IG1vdmVkIHx8IE1hdGguYWJzKGV2ZW50LmNsaWVudFggLSBlMi5jbGllbnRYKSArIE1hdGguYWJzKGV2ZW50LmNsaWVudFkgLSBlMi5jbGllbnRZKSA+PSAxMDtcbiAgICB9O1xuICAgIHZhciBkcmFnU3RhcnQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBtb3ZlZCA9IHRydWU7IH07XG4gICAgLy8gTGV0IHRoZSBkcmFnIGhhbmRsZXIgaGFuZGxlIHRoaXMuXG4gICAgaWYgKHdlYmtpdCkgeyBkaXNwbGF5LnNjcm9sbGVyLmRyYWdnYWJsZSA9IHRydWU7IH1cbiAgICBjbS5zdGF0ZS5kcmFnZ2luZ1RleHQgPSBkcmFnRW5kO1xuICAgIGRyYWdFbmQuY29weSA9ICFiZWhhdmlvci5tb3ZlT25EcmFnO1xuICAgIG9uKGRpc3BsYXkud3JhcHBlci5vd25lckRvY3VtZW50LCBcIm1vdXNldXBcIiwgZHJhZ0VuZCk7XG4gICAgb24oZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2Vtb3ZlXCIsIG1vdXNlTW92ZSk7XG4gICAgb24oZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnc3RhcnRcIiwgZHJhZ1N0YXJ0KTtcbiAgICBvbihkaXNwbGF5LnNjcm9sbGVyLCBcImRyb3BcIiwgZHJhZ0VuZCk7XG5cbiAgICBjbS5zdGF0ZS5kZWxheWluZ0JsdXJFdmVudCA9IHRydWU7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBkaXNwbGF5LmlucHV0LmZvY3VzKCk7IH0sIDIwKTtcbiAgICAvLyBJRSdzIGFwcHJvYWNoIHRvIGRyYWdnYWJsZVxuICAgIGlmIChkaXNwbGF5LnNjcm9sbGVyLmRyYWdEcm9wKSB7IGRpc3BsYXkuc2Nyb2xsZXIuZHJhZ0Ryb3AoKTsgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmFuZ2VGb3JVbml0KGNtLCBwb3MsIHVuaXQpIHtcbiAgICBpZiAodW5pdCA9PSBcImNoYXJcIikgeyByZXR1cm4gbmV3IFJhbmdlKHBvcywgcG9zKSB9XG4gICAgaWYgKHVuaXQgPT0gXCJ3b3JkXCIpIHsgcmV0dXJuIGNtLmZpbmRXb3JkQXQocG9zKSB9XG4gICAgaWYgKHVuaXQgPT0gXCJsaW5lXCIpIHsgcmV0dXJuIG5ldyBSYW5nZShQb3MocG9zLmxpbmUsIDApLCBjbGlwUG9zKGNtLmRvYywgUG9zKHBvcy5saW5lICsgMSwgMCkpKSB9XG4gICAgdmFyIHJlc3VsdCA9IHVuaXQoY20sIHBvcyk7XG4gICAgcmV0dXJuIG5ldyBSYW5nZShyZXN1bHQuZnJvbSwgcmVzdWx0LnRvKVxuICB9XG5cbiAgLy8gTm9ybWFsIHNlbGVjdGlvbiwgYXMgb3Bwb3NlZCB0byB0ZXh0IGRyYWdnaW5nLlxuICBmdW5jdGlvbiBsZWZ0QnV0dG9uU2VsZWN0KGNtLCBldmVudCwgc3RhcnQsIGJlaGF2aW9yKSB7XG4gICAgaWYgKGllKSB7IGRlbGF5Qmx1ckV2ZW50KGNtKTsgfVxuICAgIHZhciBkaXNwbGF5ID0gY20uZGlzcGxheSwgZG9jID0gY20uZG9jO1xuICAgIGVfcHJldmVudERlZmF1bHQoZXZlbnQpO1xuXG4gICAgdmFyIG91clJhbmdlLCBvdXJJbmRleCwgc3RhcnRTZWwgPSBkb2Muc2VsLCByYW5nZXMgPSBzdGFydFNlbC5yYW5nZXM7XG4gICAgaWYgKGJlaGF2aW9yLmFkZE5ldyAmJiAhYmVoYXZpb3IuZXh0ZW5kKSB7XG4gICAgICBvdXJJbmRleCA9IGRvYy5zZWwuY29udGFpbnMoc3RhcnQpO1xuICAgICAgaWYgKG91ckluZGV4ID4gLTEpXG4gICAgICAgIHsgb3VyUmFuZ2UgPSByYW5nZXNbb3VySW5kZXhdOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgb3VyUmFuZ2UgPSBuZXcgUmFuZ2Uoc3RhcnQsIHN0YXJ0KTsgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXJSYW5nZSA9IGRvYy5zZWwucHJpbWFyeSgpO1xuICAgICAgb3VySW5kZXggPSBkb2Muc2VsLnByaW1JbmRleDtcbiAgICB9XG5cbiAgICBpZiAoYmVoYXZpb3IudW5pdCA9PSBcInJlY3RhbmdsZVwiKSB7XG4gICAgICBpZiAoIWJlaGF2aW9yLmFkZE5ldykgeyBvdXJSYW5nZSA9IG5ldyBSYW5nZShzdGFydCwgc3RhcnQpOyB9XG4gICAgICBzdGFydCA9IHBvc0Zyb21Nb3VzZShjbSwgZXZlbnQsIHRydWUsIHRydWUpO1xuICAgICAgb3VySW5kZXggPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHJhbmdlID0gcmFuZ2VGb3JVbml0KGNtLCBzdGFydCwgYmVoYXZpb3IudW5pdCk7XG4gICAgICBpZiAoYmVoYXZpb3IuZXh0ZW5kKVxuICAgICAgICB7IG91clJhbmdlID0gZXh0ZW5kUmFuZ2Uob3VyUmFuZ2UsIHJhbmdlLmFuY2hvciwgcmFuZ2UuaGVhZCwgYmVoYXZpb3IuZXh0ZW5kKTsgfVxuICAgICAgZWxzZVxuICAgICAgICB7IG91clJhbmdlID0gcmFuZ2U7IH1cbiAgICB9XG5cbiAgICBpZiAoIWJlaGF2aW9yLmFkZE5ldykge1xuICAgICAgb3VySW5kZXggPSAwO1xuICAgICAgc2V0U2VsZWN0aW9uKGRvYywgbmV3IFNlbGVjdGlvbihbb3VyUmFuZ2VdLCAwKSwgc2VsX21vdXNlKTtcbiAgICAgIHN0YXJ0U2VsID0gZG9jLnNlbDtcbiAgICB9IGVsc2UgaWYgKG91ckluZGV4ID09IC0xKSB7XG4gICAgICBvdXJJbmRleCA9IHJhbmdlcy5sZW5ndGg7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcy5jb25jYXQoW291clJhbmdlXSksIG91ckluZGV4KSxcbiAgICAgICAgICAgICAgICAgICB7c2Nyb2xsOiBmYWxzZSwgb3JpZ2luOiBcIiptb3VzZVwifSk7XG4gICAgfSBlbHNlIGlmIChyYW5nZXMubGVuZ3RoID4gMSAmJiByYW5nZXNbb3VySW5kZXhdLmVtcHR5KCkgJiYgYmVoYXZpb3IudW5pdCA9PSBcImNoYXJcIiAmJiAhYmVoYXZpb3IuZXh0ZW5kKSB7XG4gICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlcy5zbGljZShvdXJJbmRleCArIDEpKSwgMCksXG4gICAgICAgICAgICAgICAgICAge3Njcm9sbDogZmFsc2UsIG9yaWdpbjogXCIqbW91c2VcIn0pO1xuICAgICAgc3RhcnRTZWwgPSBkb2Muc2VsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXBsYWNlT25lU2VsZWN0aW9uKGRvYywgb3VySW5kZXgsIG91clJhbmdlLCBzZWxfbW91c2UpO1xuICAgIH1cblxuICAgIHZhciBsYXN0UG9zID0gc3RhcnQ7XG4gICAgZnVuY3Rpb24gZXh0ZW5kVG8ocG9zKSB7XG4gICAgICBpZiAoY21wKGxhc3RQb3MsIHBvcykgPT0gMCkgeyByZXR1cm4gfVxuICAgICAgbGFzdFBvcyA9IHBvcztcblxuICAgICAgaWYgKGJlaGF2aW9yLnVuaXQgPT0gXCJyZWN0YW5nbGVcIikge1xuICAgICAgICB2YXIgcmFuZ2VzID0gW10sIHRhYlNpemUgPSBjbS5vcHRpb25zLnRhYlNpemU7XG4gICAgICAgIHZhciBzdGFydENvbCA9IGNvdW50Q29sdW1uKGdldExpbmUoZG9jLCBzdGFydC5saW5lKS50ZXh0LCBzdGFydC5jaCwgdGFiU2l6ZSk7XG4gICAgICAgIHZhciBwb3NDb2wgPSBjb3VudENvbHVtbihnZXRMaW5lKGRvYywgcG9zLmxpbmUpLnRleHQsIHBvcy5jaCwgdGFiU2l6ZSk7XG4gICAgICAgIHZhciBsZWZ0ID0gTWF0aC5taW4oc3RhcnRDb2wsIHBvc0NvbCksIHJpZ2h0ID0gTWF0aC5tYXgoc3RhcnRDb2wsIHBvc0NvbCk7XG4gICAgICAgIGZvciAodmFyIGxpbmUgPSBNYXRoLm1pbihzdGFydC5saW5lLCBwb3MubGluZSksIGVuZCA9IE1hdGgubWluKGNtLmxhc3RMaW5lKCksIE1hdGgubWF4KHN0YXJ0LmxpbmUsIHBvcy5saW5lKSk7XG4gICAgICAgICAgICAgbGluZSA8PSBlbmQ7IGxpbmUrKykge1xuICAgICAgICAgIHZhciB0ZXh0ID0gZ2V0TGluZShkb2MsIGxpbmUpLnRleHQsIGxlZnRQb3MgPSBmaW5kQ29sdW1uKHRleHQsIGxlZnQsIHRhYlNpemUpO1xuICAgICAgICAgIGlmIChsZWZ0ID09IHJpZ2h0KVxuICAgICAgICAgICAgeyByYW5nZXMucHVzaChuZXcgUmFuZ2UoUG9zKGxpbmUsIGxlZnRQb3MpLCBQb3MobGluZSwgbGVmdFBvcykpKTsgfVxuICAgICAgICAgIGVsc2UgaWYgKHRleHQubGVuZ3RoID4gbGVmdFBvcylcbiAgICAgICAgICAgIHsgcmFuZ2VzLnB1c2gobmV3IFJhbmdlKFBvcyhsaW5lLCBsZWZ0UG9zKSwgUG9zKGxpbmUsIGZpbmRDb2x1bW4odGV4dCwgcmlnaHQsIHRhYlNpemUpKSkpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyYW5nZXMubGVuZ3RoKSB7IHJhbmdlcy5wdXNoKG5ldyBSYW5nZShzdGFydCwgc3RhcnQpKTsgfVxuICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHN0YXJ0U2VsLnJhbmdlcy5zbGljZSgwLCBvdXJJbmRleCkuY29uY2F0KHJhbmdlcyksIG91ckluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgIHtvcmlnaW46IFwiKm1vdXNlXCIsIHNjcm9sbDogZmFsc2V9KTtcbiAgICAgICAgY20uc2Nyb2xsSW50b1ZpZXcocG9zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBvbGRSYW5nZSA9IG91clJhbmdlO1xuICAgICAgICB2YXIgcmFuZ2UgPSByYW5nZUZvclVuaXQoY20sIHBvcywgYmVoYXZpb3IudW5pdCk7XG4gICAgICAgIHZhciBhbmNob3IgPSBvbGRSYW5nZS5hbmNob3IsIGhlYWQ7XG4gICAgICAgIGlmIChjbXAocmFuZ2UuYW5jaG9yLCBhbmNob3IpID4gMCkge1xuICAgICAgICAgIGhlYWQgPSByYW5nZS5oZWFkO1xuICAgICAgICAgIGFuY2hvciA9IG1pblBvcyhvbGRSYW5nZS5mcm9tKCksIHJhbmdlLmFuY2hvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGVhZCA9IHJhbmdlLmFuY2hvcjtcbiAgICAgICAgICBhbmNob3IgPSBtYXhQb3Mob2xkUmFuZ2UudG8oKSwgcmFuZ2UuaGVhZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlcyQxID0gc3RhcnRTZWwucmFuZ2VzLnNsaWNlKDApO1xuICAgICAgICByYW5nZXMkMVtvdXJJbmRleF0gPSBiaWRpU2ltcGxpZnkoY20sIG5ldyBSYW5nZShjbGlwUG9zKGRvYywgYW5jaG9yKSwgaGVhZCkpO1xuICAgICAgICBzZXRTZWxlY3Rpb24oZG9jLCBub3JtYWxpemVTZWxlY3Rpb24oY20sIHJhbmdlcyQxLCBvdXJJbmRleCksIHNlbF9tb3VzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGVkaXRvclNpemUgPSBkaXNwbGF5LndyYXBwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgLy8gVXNlZCB0byBlbnN1cmUgdGltZW91dCByZS10cmllcyBkb24ndCBmaXJlIHdoZW4gYW5vdGhlciBleHRlbmRcbiAgICAvLyBoYXBwZW5lZCBpbiB0aGUgbWVhbnRpbWUgKGNsZWFyVGltZW91dCBpc24ndCByZWxpYWJsZSAtLSBhdFxuICAgIC8vIGxlYXN0IG9uIENocm9tZSwgdGhlIHRpbWVvdXRzIHN0aWxsIGhhcHBlbiBldmVuIHdoZW4gY2xlYXJlZCxcbiAgICAvLyBpZiB0aGUgY2xlYXIgaGFwcGVucyBhZnRlciB0aGVpciBzY2hlZHVsZWQgZmlyaW5nIHRpbWUpLlxuICAgIHZhciBjb3VudGVyID0gMDtcblxuICAgIGZ1bmN0aW9uIGV4dGVuZChlKSB7XG4gICAgICB2YXIgY3VyQ291bnQgPSArK2NvdW50ZXI7XG4gICAgICB2YXIgY3VyID0gcG9zRnJvbU1vdXNlKGNtLCBlLCB0cnVlLCBiZWhhdmlvci51bml0ID09IFwicmVjdGFuZ2xlXCIpO1xuICAgICAgaWYgKCFjdXIpIHsgcmV0dXJuIH1cbiAgICAgIGlmIChjbXAoY3VyLCBsYXN0UG9zKSAhPSAwKSB7XG4gICAgICAgIGNtLmN1ck9wLmZvY3VzID0gYWN0aXZlRWx0KCk7XG4gICAgICAgIGV4dGVuZFRvKGN1cik7XG4gICAgICAgIHZhciB2aXNpYmxlID0gdmlzaWJsZUxpbmVzKGRpc3BsYXksIGRvYyk7XG4gICAgICAgIGlmIChjdXIubGluZSA+PSB2aXNpYmxlLnRvIHx8IGN1ci5saW5lIDwgdmlzaWJsZS5mcm9tKVxuICAgICAgICAgIHsgc2V0VGltZW91dChvcGVyYXRpb24oY20sIGZ1bmN0aW9uICgpIHtpZiAoY291bnRlciA9PSBjdXJDb3VudCkgeyBleHRlbmQoZSk7IH19KSwgMTUwKTsgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG91dHNpZGUgPSBlLmNsaWVudFkgPCBlZGl0b3JTaXplLnRvcCA/IC0yMCA6IGUuY2xpZW50WSA+IGVkaXRvclNpemUuYm90dG9tID8gMjAgOiAwO1xuICAgICAgICBpZiAob3V0c2lkZSkgeyBzZXRUaW1lb3V0KG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChjb3VudGVyICE9IGN1ckNvdW50KSB7IHJldHVybiB9XG4gICAgICAgICAgZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgKz0gb3V0c2lkZTtcbiAgICAgICAgICBleHRlbmQoZSk7XG4gICAgICAgIH0pLCA1MCk7IH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkb25lKGUpIHtcbiAgICAgIGNtLnN0YXRlLnNlbGVjdGluZ1RleHQgPSBmYWxzZTtcbiAgICAgIGNvdW50ZXIgPSBJbmZpbml0eTtcbiAgICAgIC8vIElmIGUgaXMgbnVsbCBvciB1bmRlZmluZWQgd2UgaW50ZXJwcmV0IHRoaXMgYXMgc29tZW9uZSB0cnlpbmdcbiAgICAgIC8vIHRvIGV4cGxpY2l0bHkgY2FuY2VsIHRoZSBzZWxlY3Rpb24gcmF0aGVyIHRoYW4gdGhlIHVzZXJcbiAgICAgIC8vIGxldHRpbmcgZ28gb2YgdGhlIG1vdXNlIGJ1dHRvbi5cbiAgICAgIGlmIChlKSB7XG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICAgIGRpc3BsYXkuaW5wdXQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICAgIG9mZihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG4gICAgICBvZmYoZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2V1cFwiLCB1cCk7XG4gICAgICBkb2MuaGlzdG9yeS5sYXN0U2VsT3JpZ2luID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgbW92ZSA9IG9wZXJhdGlvbihjbSwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChlLmJ1dHRvbnMgPT09IDAgfHwgIWVfYnV0dG9uKGUpKSB7IGRvbmUoZSk7IH1cbiAgICAgIGVsc2UgeyBleHRlbmQoZSk7IH1cbiAgICB9KTtcbiAgICB2YXIgdXAgPSBvcGVyYXRpb24oY20sIGRvbmUpO1xuICAgIGNtLnN0YXRlLnNlbGVjdGluZ1RleHQgPSB1cDtcbiAgICBvbihkaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudCwgXCJtb3VzZW1vdmVcIiwgbW92ZSk7XG4gICAgb24oZGlzcGxheS53cmFwcGVyLm93bmVyRG9jdW1lbnQsIFwibW91c2V1cFwiLCB1cCk7XG4gIH1cblxuICAvLyBVc2VkIHdoZW4gbW91c2Utc2VsZWN0aW5nIHRvIGFkanVzdCB0aGUgYW5jaG9yIHRvIHRoZSBwcm9wZXIgc2lkZVxuICAvLyBvZiBhIGJpZGkganVtcCBkZXBlbmRpbmcgb24gdGhlIHZpc3VhbCBwb3NpdGlvbiBvZiB0aGUgaGVhZC5cbiAgZnVuY3Rpb24gYmlkaVNpbXBsaWZ5KGNtLCByYW5nZSkge1xuICAgIHZhciBhbmNob3IgPSByYW5nZS5hbmNob3I7XG4gICAgdmFyIGhlYWQgPSByYW5nZS5oZWFkO1xuICAgIHZhciBhbmNob3JMaW5lID0gZ2V0TGluZShjbS5kb2MsIGFuY2hvci5saW5lKTtcbiAgICBpZiAoY21wKGFuY2hvciwgaGVhZCkgPT0gMCAmJiBhbmNob3Iuc3RpY2t5ID09IGhlYWQuc3RpY2t5KSB7IHJldHVybiByYW5nZSB9XG4gICAgdmFyIG9yZGVyID0gZ2V0T3JkZXIoYW5jaG9yTGluZSk7XG4gICAgaWYgKCFvcmRlcikgeyByZXR1cm4gcmFuZ2UgfVxuICAgIHZhciBpbmRleCA9IGdldEJpZGlQYXJ0QXQob3JkZXIsIGFuY2hvci5jaCwgYW5jaG9yLnN0aWNreSksIHBhcnQgPSBvcmRlcltpbmRleF07XG4gICAgaWYgKHBhcnQuZnJvbSAhPSBhbmNob3IuY2ggJiYgcGFydC50byAhPSBhbmNob3IuY2gpIHsgcmV0dXJuIHJhbmdlIH1cbiAgICB2YXIgYm91bmRhcnkgPSBpbmRleCArICgocGFydC5mcm9tID09IGFuY2hvci5jaCkgPT0gKHBhcnQubGV2ZWwgIT0gMSkgPyAwIDogMSk7XG4gICAgaWYgKGJvdW5kYXJ5ID09IDAgfHwgYm91bmRhcnkgPT0gb3JkZXIubGVuZ3RoKSB7IHJldHVybiByYW5nZSB9XG5cbiAgICAvLyBDb21wdXRlIHRoZSByZWxhdGl2ZSB2aXN1YWwgcG9zaXRpb24gb2YgdGhlIGhlYWQgY29tcGFyZWQgdG8gdGhlXG4gICAgLy8gYW5jaG9yICg8MCBpcyB0byB0aGUgbGVmdCwgPjAgdG8gdGhlIHJpZ2h0KVxuICAgIHZhciBsZWZ0U2lkZTtcbiAgICBpZiAoaGVhZC5saW5lICE9IGFuY2hvci5saW5lKSB7XG4gICAgICBsZWZ0U2lkZSA9IChoZWFkLmxpbmUgLSBhbmNob3IubGluZSkgKiAoY20uZG9jLmRpcmVjdGlvbiA9PSBcImx0clwiID8gMSA6IC0xKSA+IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBoZWFkSW5kZXggPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBoZWFkLmNoLCBoZWFkLnN0aWNreSk7XG4gICAgICB2YXIgZGlyID0gaGVhZEluZGV4IC0gaW5kZXggfHwgKGhlYWQuY2ggLSBhbmNob3IuY2gpICogKHBhcnQubGV2ZWwgPT0gMSA/IC0xIDogMSk7XG4gICAgICBpZiAoaGVhZEluZGV4ID09IGJvdW5kYXJ5IC0gMSB8fCBoZWFkSW5kZXggPT0gYm91bmRhcnkpXG4gICAgICAgIHsgbGVmdFNpZGUgPSBkaXIgPCAwOyB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgbGVmdFNpZGUgPSBkaXIgPiAwOyB9XG4gICAgfVxuXG4gICAgdmFyIHVzZVBhcnQgPSBvcmRlcltib3VuZGFyeSArIChsZWZ0U2lkZSA/IC0xIDogMCldO1xuICAgIHZhciBmcm9tID0gbGVmdFNpZGUgPT0gKHVzZVBhcnQubGV2ZWwgPT0gMSk7XG4gICAgdmFyIGNoID0gZnJvbSA/IHVzZVBhcnQuZnJvbSA6IHVzZVBhcnQudG8sIHN0aWNreSA9IGZyb20gPyBcImFmdGVyXCIgOiBcImJlZm9yZVwiO1xuICAgIHJldHVybiBhbmNob3IuY2ggPT0gY2ggJiYgYW5jaG9yLnN0aWNreSA9PSBzdGlja3kgPyByYW5nZSA6IG5ldyBSYW5nZShuZXcgUG9zKGFuY2hvci5saW5lLCBjaCwgc3RpY2t5KSwgaGVhZClcbiAgfVxuXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIGFuIGV2ZW50IGhhcHBlbmVkIGluIHRoZSBndXR0ZXIsIGFuZCBmaXJlcyB0aGVcbiAgLy8gaGFuZGxlcnMgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50LlxuICBmdW5jdGlvbiBndXR0ZXJFdmVudChjbSwgZSwgdHlwZSwgcHJldmVudCkge1xuICAgIHZhciBtWCwgbVk7XG4gICAgaWYgKGUudG91Y2hlcykge1xuICAgICAgbVggPSBlLnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgIG1ZID0gZS50b3VjaGVzWzBdLmNsaWVudFk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7IG1YID0gZS5jbGllbnRYOyBtWSA9IGUuY2xpZW50WTsgfVxuICAgICAgY2F0Y2goZSQxKSB7IHJldHVybiBmYWxzZSB9XG4gICAgfVxuICAgIGlmIChtWCA+PSBNYXRoLmZsb29yKGNtLmRpc3BsYXkuZ3V0dGVycy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCkpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAocHJldmVudCkgeyBlX3ByZXZlbnREZWZhdWx0KGUpOyB9XG5cbiAgICB2YXIgZGlzcGxheSA9IGNtLmRpc3BsYXk7XG4gICAgdmFyIGxpbmVCb3ggPSBkaXNwbGF5LmxpbmVEaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICBpZiAobVkgPiBsaW5lQm94LmJvdHRvbSB8fCAhaGFzSGFuZGxlcihjbSwgdHlwZSkpIHsgcmV0dXJuIGVfZGVmYXVsdFByZXZlbnRlZChlKSB9XG4gICAgbVkgLT0gbGluZUJveC50b3AgLSBkaXNwbGF5LnZpZXdPZmZzZXQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBnID0gZGlzcGxheS5ndXR0ZXJzLmNoaWxkTm9kZXNbaV07XG4gICAgICBpZiAoZyAmJiBnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnJpZ2h0ID49IG1YKSB7XG4gICAgICAgIHZhciBsaW5lID0gbGluZUF0SGVpZ2h0KGNtLmRvYywgbVkpO1xuICAgICAgICB2YXIgZ3V0dGVyID0gY20uZGlzcGxheS5ndXR0ZXJTcGVjc1tpXTtcbiAgICAgICAgc2lnbmFsKGNtLCB0eXBlLCBjbSwgbGluZSwgZ3V0dGVyLmNsYXNzTmFtZSwgZSk7XG4gICAgICAgIHJldHVybiBlX2RlZmF1bHRQcmV2ZW50ZWQoZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjbGlja0luR3V0dGVyKGNtLCBlKSB7XG4gICAgcmV0dXJuIGd1dHRlckV2ZW50KGNtLCBlLCBcImd1dHRlckNsaWNrXCIsIHRydWUpXG4gIH1cblxuICAvLyBDT05URVhUIE1FTlUgSEFORExJTkdcblxuICAvLyBUbyBtYWtlIHRoZSBjb250ZXh0IG1lbnUgd29yaywgd2UgbmVlZCB0byBicmllZmx5IHVuaGlkZSB0aGVcbiAgLy8gdGV4dGFyZWEgKG1ha2luZyBpdCBhcyB1bm9idHJ1c2l2ZSBhcyBwb3NzaWJsZSkgdG8gbGV0IHRoZVxuICAvLyByaWdodC1jbGljayB0YWtlIGVmZmVjdCBvbiBpdC5cbiAgZnVuY3Rpb24gb25Db250ZXh0TWVudShjbSwgZSkge1xuICAgIGlmIChldmVudEluV2lkZ2V0KGNtLmRpc3BsYXksIGUpIHx8IGNvbnRleHRNZW51SW5HdXR0ZXIoY20sIGUpKSB7IHJldHVybiB9XG4gICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlLCBcImNvbnRleHRtZW51XCIpKSB7IHJldHVybiB9XG4gICAgaWYgKCFjYXB0dXJlUmlnaHRDbGljaykgeyBjbS5kaXNwbGF5LmlucHV0Lm9uQ29udGV4dE1lbnUoZSk7IH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnRleHRNZW51SW5HdXR0ZXIoY20sIGUpIHtcbiAgICBpZiAoIWhhc0hhbmRsZXIoY20sIFwiZ3V0dGVyQ29udGV4dE1lbnVcIikpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICByZXR1cm4gZ3V0dGVyRXZlbnQoY20sIGUsIFwiZ3V0dGVyQ29udGV4dE1lbnVcIiwgZmFsc2UpXG4gIH1cblxuICBmdW5jdGlvbiB0aGVtZUNoYW5nZWQoY20pIHtcbiAgICBjbS5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lID0gY20uZGlzcGxheS53cmFwcGVyLmNsYXNzTmFtZS5yZXBsYWNlKC9cXHMqY20tcy1cXFMrL2csIFwiXCIpICtcbiAgICAgIGNtLm9wdGlvbnMudGhlbWUucmVwbGFjZSgvKF58XFxzKVxccyovZywgXCIgY20tcy1cIik7XG4gICAgY2xlYXJDYWNoZXMoY20pO1xuICB9XG5cbiAgdmFyIEluaXQgPSB7dG9TdHJpbmc6IGZ1bmN0aW9uKCl7cmV0dXJuIFwiQ29kZU1pcnJvci5Jbml0XCJ9fTtcblxuICB2YXIgZGVmYXVsdHMgPSB7fTtcbiAgdmFyIG9wdGlvbkhhbmRsZXJzID0ge307XG5cbiAgZnVuY3Rpb24gZGVmaW5lT3B0aW9ucyhDb2RlTWlycm9yKSB7XG4gICAgdmFyIG9wdGlvbkhhbmRsZXJzID0gQ29kZU1pcnJvci5vcHRpb25IYW5kbGVycztcblxuICAgIGZ1bmN0aW9uIG9wdGlvbihuYW1lLCBkZWZsdCwgaGFuZGxlLCBub3RPbkluaXQpIHtcbiAgICAgIENvZGVNaXJyb3IuZGVmYXVsdHNbbmFtZV0gPSBkZWZsdDtcbiAgICAgIGlmIChoYW5kbGUpIHsgb3B0aW9uSGFuZGxlcnNbbmFtZV0gPVxuICAgICAgICBub3RPbkluaXQgPyBmdW5jdGlvbiAoY20sIHZhbCwgb2xkKSB7aWYgKG9sZCAhPSBJbml0KSB7IGhhbmRsZShjbSwgdmFsLCBvbGQpOyB9fSA6IGhhbmRsZTsgfVxuICAgIH1cblxuICAgIENvZGVNaXJyb3IuZGVmaW5lT3B0aW9uID0gb3B0aW9uO1xuXG4gICAgLy8gUGFzc2VkIHRvIG9wdGlvbiBoYW5kbGVycyB3aGVuIHRoZXJlIGlzIG5vIG9sZCB2YWx1ZS5cbiAgICBDb2RlTWlycm9yLkluaXQgPSBJbml0O1xuXG4gICAgLy8gVGhlc2UgdHdvIGFyZSwgb24gaW5pdCwgY2FsbGVkIGZyb20gdGhlIGNvbnN0cnVjdG9yIGJlY2F1c2UgdGhleVxuICAgIC8vIGhhdmUgdG8gYmUgaW5pdGlhbGl6ZWQgYmVmb3JlIHRoZSBlZGl0b3IgY2FuIHN0YXJ0IGF0IGFsbC5cbiAgICBvcHRpb24oXCJ2YWx1ZVwiLCBcIlwiLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uc2V0VmFsdWUodmFsKTsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwibW9kZVwiLCBudWxsLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgY20uZG9jLm1vZGVPcHRpb24gPSB2YWw7XG4gICAgICBsb2FkTW9kZShjbSk7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICBvcHRpb24oXCJpbmRlbnRVbml0XCIsIDIsIGxvYWRNb2RlLCB0cnVlKTtcbiAgICBvcHRpb24oXCJpbmRlbnRXaXRoVGFic1wiLCBmYWxzZSk7XG4gICAgb3B0aW9uKFwic21hcnRJbmRlbnRcIiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwidGFiU2l6ZVwiLCA0LCBmdW5jdGlvbiAoY20pIHtcbiAgICAgIHJlc2V0TW9kZVN0YXRlKGNtKTtcbiAgICAgIGNsZWFyQ2FjaGVzKGNtKTtcbiAgICAgIHJlZ0NoYW5nZShjbSk7XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICBvcHRpb24oXCJsaW5lU2VwYXJhdG9yXCIsIG51bGwsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICBjbS5kb2MubGluZVNlcCA9IHZhbDtcbiAgICAgIGlmICghdmFsKSB7IHJldHVybiB9XG4gICAgICB2YXIgbmV3QnJlYWtzID0gW10sIGxpbmVObyA9IGNtLmRvYy5maXJzdDtcbiAgICAgIGNtLmRvYy5pdGVyKGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgIGZvciAodmFyIHBvcyA9IDA7Oykge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGxpbmUudGV4dC5pbmRleE9mKHZhbCwgcG9zKTtcbiAgICAgICAgICBpZiAoZm91bmQgPT0gLTEpIHsgYnJlYWsgfVxuICAgICAgICAgIHBvcyA9IGZvdW5kICsgdmFsLmxlbmd0aDtcbiAgICAgICAgICBuZXdCcmVha3MucHVzaChQb3MobGluZU5vLCBmb3VuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGxpbmVObysrO1xuICAgICAgfSk7XG4gICAgICBmb3IgKHZhciBpID0gbmV3QnJlYWtzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuICAgICAgICB7IHJlcGxhY2VSYW5nZShjbS5kb2MsIHZhbCwgbmV3QnJlYWtzW2ldLCBQb3MobmV3QnJlYWtzW2ldLmxpbmUsIG5ld0JyZWFrc1tpXS5jaCArIHZhbC5sZW5ndGgpKTsgfVxuICAgIH0pO1xuICAgIG9wdGlvbihcInNwZWNpYWxDaGFyc1wiLCAvW1xcdTAwMDAtXFx1MDAxZlxcdTAwN2YtXFx1MDA5ZlxcdTAwYWRcXHUwNjFjXFx1MjAwYi1cXHUyMDBjXFx1MjAwZVxcdTIwMGZcXHUyMDI4XFx1MjAyOVxcdWZlZmZcXHVmZmY5LVxcdWZmZmNdL2csIGZ1bmN0aW9uIChjbSwgdmFsLCBvbGQpIHtcbiAgICAgIGNtLnN0YXRlLnNwZWNpYWxDaGFycyA9IG5ldyBSZWdFeHAodmFsLnNvdXJjZSArICh2YWwudGVzdChcIlxcdFwiKSA/IFwiXCIgOiBcInxcXHRcIiksIFwiZ1wiKTtcbiAgICAgIGlmIChvbGQgIT0gSW5pdCkgeyBjbS5yZWZyZXNoKCk7IH1cbiAgICB9KTtcbiAgICBvcHRpb24oXCJzcGVjaWFsQ2hhclBsYWNlaG9sZGVyXCIsIGRlZmF1bHRTcGVjaWFsQ2hhclBsYWNlaG9sZGVyLCBmdW5jdGlvbiAoY20pIHsgcmV0dXJuIGNtLnJlZnJlc2goKTsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiZWxlY3RyaWNDaGFyc1wiLCB0cnVlKTtcbiAgICBvcHRpb24oXCJpbnB1dFN0eWxlXCIsIG1vYmlsZSA/IFwiY29udGVudGVkaXRhYmxlXCIgOiBcInRleHRhcmVhXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlucHV0U3R5bGUgY2FuIG5vdCAoeWV0KSBiZSBjaGFuZ2VkIGluIGEgcnVubmluZyBlZGl0b3JcIikgLy8gRklYTUVcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJzcGVsbGNoZWNrXCIsIGZhbHNlLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZ2V0SW5wdXRGaWVsZCgpLnNwZWxsY2hlY2sgPSB2YWw7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcImF1dG9jb3JyZWN0XCIsIGZhbHNlLCBmdW5jdGlvbiAoY20sIHZhbCkgeyByZXR1cm4gY20uZ2V0SW5wdXRGaWVsZCgpLmF1dG9jb3JyZWN0ID0gdmFsOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJhdXRvY2FwaXRhbGl6ZVwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLmdldElucHV0RmllbGQoKS5hdXRvY2FwaXRhbGl6ZSA9IHZhbDsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwicnRsTW92ZVZpc3VhbGx5XCIsICF3aW5kb3dzKTtcbiAgICBvcHRpb24oXCJ3aG9sZUxpbmVVcGRhdGVCZWZvcmVcIiwgdHJ1ZSk7XG5cbiAgICBvcHRpb24oXCJ0aGVtZVwiLCBcImRlZmF1bHRcIiwgZnVuY3Rpb24gKGNtKSB7XG4gICAgICB0aGVtZUNoYW5nZWQoY20pO1xuICAgICAgdXBkYXRlR3V0dGVycyhjbSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwia2V5TWFwXCIsIFwiZGVmYXVsdFwiLCBmdW5jdGlvbiAoY20sIHZhbCwgb2xkKSB7XG4gICAgICB2YXIgbmV4dCA9IGdldEtleU1hcCh2YWwpO1xuICAgICAgdmFyIHByZXYgPSBvbGQgIT0gSW5pdCAmJiBnZXRLZXlNYXAob2xkKTtcbiAgICAgIGlmIChwcmV2ICYmIHByZXYuZGV0YWNoKSB7IHByZXYuZGV0YWNoKGNtLCBuZXh0KTsgfVxuICAgICAgaWYgKG5leHQuYXR0YWNoKSB7IG5leHQuYXR0YWNoKGNtLCBwcmV2IHx8IG51bGwpOyB9XG4gICAgfSk7XG4gICAgb3B0aW9uKFwiZXh0cmFLZXlzXCIsIG51bGwpO1xuICAgIG9wdGlvbihcImNvbmZpZ3VyZU1vdXNlXCIsIG51bGwpO1xuXG4gICAgb3B0aW9uKFwibGluZVdyYXBwaW5nXCIsIGZhbHNlLCB3cmFwcGluZ0NoYW5nZWQsIHRydWUpO1xuICAgIG9wdGlvbihcImd1dHRlcnNcIiwgW10sIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICBjbS5kaXNwbGF5Lmd1dHRlclNwZWNzID0gZ2V0R3V0dGVycyh2YWwsIGNtLm9wdGlvbnMubGluZU51bWJlcnMpO1xuICAgICAgdXBkYXRlR3V0dGVycyhjbSk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiZml4ZWRHdXR0ZXJcIiwgdHJ1ZSwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIGNtLmRpc3BsYXkuZ3V0dGVycy5zdHlsZS5sZWZ0ID0gdmFsID8gY29tcGVuc2F0ZUZvckhTY3JvbGwoY20uZGlzcGxheSkgKyBcInB4XCIgOiBcIjBcIjtcbiAgICAgIGNtLnJlZnJlc2goKTtcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJjb3Zlckd1dHRlck5leHRUb1Njcm9sbGJhclwiLCBmYWxzZSwgZnVuY3Rpb24gKGNtKSB7IHJldHVybiB1cGRhdGVTY3JvbGxiYXJzKGNtKTsgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwic2Nyb2xsYmFyU3R5bGVcIiwgXCJuYXRpdmVcIiwgZnVuY3Rpb24gKGNtKSB7XG4gICAgICBpbml0U2Nyb2xsYmFycyhjbSk7XG4gICAgICB1cGRhdGVTY3JvbGxiYXJzKGNtKTtcbiAgICAgIGNtLmRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AoY20uZG9jLnNjcm9sbFRvcCk7XG4gICAgICBjbS5kaXNwbGF5LnNjcm9sbGJhcnMuc2V0U2Nyb2xsTGVmdChjbS5kb2Muc2Nyb2xsTGVmdCk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwibGluZU51bWJlcnNcIiwgZmFsc2UsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICBjbS5kaXNwbGF5Lmd1dHRlclNwZWNzID0gZ2V0R3V0dGVycyhjbS5vcHRpb25zLmd1dHRlcnMsIHZhbCk7XG4gICAgICB1cGRhdGVHdXR0ZXJzKGNtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJmaXJzdExpbmVOdW1iZXJcIiwgMSwgdXBkYXRlR3V0dGVycywgdHJ1ZSk7XG4gICAgb3B0aW9uKFwibGluZU51bWJlckZvcm1hdHRlclwiLCBmdW5jdGlvbiAoaW50ZWdlcikgeyByZXR1cm4gaW50ZWdlcjsgfSwgdXBkYXRlR3V0dGVycywgdHJ1ZSk7XG4gICAgb3B0aW9uKFwic2hvd0N1cnNvcldoZW5TZWxlY3RpbmdcIiwgZmFsc2UsIHVwZGF0ZVNlbGVjdGlvbiwgdHJ1ZSk7XG5cbiAgICBvcHRpb24oXCJyZXNldFNlbGVjdGlvbk9uQ29udGV4dE1lbnVcIiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwibGluZVdpc2VDb3B5Q3V0XCIsIHRydWUpO1xuICAgIG9wdGlvbihcInBhc3RlTGluZXNQZXJTZWxlY3Rpb25cIiwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwic2VsZWN0aW9uc01heVRvdWNoXCIsIGZhbHNlKTtcblxuICAgIG9wdGlvbihcInJlYWRPbmx5XCIsIGZhbHNlLCBmdW5jdGlvbiAoY20sIHZhbCkge1xuICAgICAgaWYgKHZhbCA9PSBcIm5vY3Vyc29yXCIpIHtcbiAgICAgICAgb25CbHVyKGNtKTtcbiAgICAgICAgY20uZGlzcGxheS5pbnB1dC5ibHVyKCk7XG4gICAgICB9XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnJlYWRPbmx5Q2hhbmdlZCh2YWwpO1xuICAgIH0pO1xuXG4gICAgb3B0aW9uKFwic2NyZWVuUmVhZGVyTGFiZWxcIiwgbnVsbCwgZnVuY3Rpb24gKGNtLCB2YWwpIHtcbiAgICAgIHZhbCA9ICh2YWwgPT09ICcnKSA/IG51bGwgOiB2YWw7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZCh2YWwpO1xuICAgIH0pO1xuXG4gICAgb3B0aW9uKFwiZGlzYWJsZUlucHV0XCIsIGZhbHNlLCBmdW5jdGlvbiAoY20sIHZhbCkge2lmICghdmFsKSB7IGNtLmRpc3BsYXkuaW5wdXQucmVzZXQoKTsgfX0sIHRydWUpO1xuICAgIG9wdGlvbihcImRyYWdEcm9wXCIsIHRydWUsIGRyYWdEcm9wQ2hhbmdlZCk7XG4gICAgb3B0aW9uKFwiYWxsb3dEcm9wRmlsZVR5cGVzXCIsIG51bGwpO1xuXG4gICAgb3B0aW9uKFwiY3Vyc29yQmxpbmtSYXRlXCIsIDUzMCk7XG4gICAgb3B0aW9uKFwiY3Vyc29yU2Nyb2xsTWFyZ2luXCIsIDApO1xuICAgIG9wdGlvbihcImN1cnNvckhlaWdodFwiLCAxLCB1cGRhdGVTZWxlY3Rpb24sIHRydWUpO1xuICAgIG9wdGlvbihcInNpbmdsZUN1cnNvckhlaWdodFBlckxpbmVcIiwgdHJ1ZSwgdXBkYXRlU2VsZWN0aW9uLCB0cnVlKTtcbiAgICBvcHRpb24oXCJ3b3JrVGltZVwiLCAxMDApO1xuICAgIG9wdGlvbihcIndvcmtEZWxheVwiLCAxMDApO1xuICAgIG9wdGlvbihcImZsYXR0ZW5TcGFuc1wiLCB0cnVlLCByZXNldE1vZGVTdGF0ZSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwiYWRkTW9kZUNsYXNzXCIsIGZhbHNlLCByZXNldE1vZGVTdGF0ZSwgdHJ1ZSk7XG4gICAgb3B0aW9uKFwicG9sbEludGVydmFsXCIsIDEwMCk7XG4gICAgb3B0aW9uKFwidW5kb0RlcHRoXCIsIDIwMCwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLmRvYy5oaXN0b3J5LnVuZG9EZXB0aCA9IHZhbDsgfSk7XG4gICAgb3B0aW9uKFwiaGlzdG9yeUV2ZW50RGVsYXlcIiwgMTI1MCk7XG4gICAgb3B0aW9uKFwidmlld3BvcnRNYXJnaW5cIiwgMTAsIGZ1bmN0aW9uIChjbSkgeyByZXR1cm4gY20ucmVmcmVzaCgpOyB9LCB0cnVlKTtcbiAgICBvcHRpb24oXCJtYXhIaWdobGlnaHRMZW5ndGhcIiwgMTAwMDAsIHJlc2V0TW9kZVN0YXRlLCB0cnVlKTtcbiAgICBvcHRpb24oXCJtb3ZlSW5wdXRXaXRoQ3Vyc29yXCIsIHRydWUsIGZ1bmN0aW9uIChjbSwgdmFsKSB7XG4gICAgICBpZiAoIXZhbCkgeyBjbS5kaXNwbGF5LmlucHV0LnJlc2V0UG9zaXRpb24oKTsgfVxuICAgIH0pO1xuXG4gICAgb3B0aW9uKFwidGFiaW5kZXhcIiwgbnVsbCwgZnVuY3Rpb24gKGNtLCB2YWwpIHsgcmV0dXJuIGNtLmRpc3BsYXkuaW5wdXQuZ2V0RmllbGQoKS50YWJJbmRleCA9IHZhbCB8fCBcIlwiOyB9KTtcbiAgICBvcHRpb24oXCJhdXRvZm9jdXNcIiwgbnVsbCk7XG4gICAgb3B0aW9uKFwiZGlyZWN0aW9uXCIsIFwibHRyXCIsIGZ1bmN0aW9uIChjbSwgdmFsKSB7IHJldHVybiBjbS5kb2Muc2V0RGlyZWN0aW9uKHZhbCk7IH0sIHRydWUpO1xuICAgIG9wdGlvbihcInBocmFzZXNcIiwgbnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBkcmFnRHJvcENoYW5nZWQoY20sIHZhbHVlLCBvbGQpIHtcbiAgICB2YXIgd2FzT24gPSBvbGQgJiYgb2xkICE9IEluaXQ7XG4gICAgaWYgKCF2YWx1ZSAhPSAhd2FzT24pIHtcbiAgICAgIHZhciBmdW5jcyA9IGNtLmRpc3BsYXkuZHJhZ0Z1bmN0aW9ucztcbiAgICAgIHZhciB0b2dnbGUgPSB2YWx1ZSA/IG9uIDogb2ZmO1xuICAgICAgdG9nZ2xlKGNtLmRpc3BsYXkuc2Nyb2xsZXIsIFwiZHJhZ3N0YXJ0XCIsIGZ1bmNzLnN0YXJ0KTtcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdlbnRlclwiLCBmdW5jcy5lbnRlcik7XG4gICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcmFnb3ZlclwiLCBmdW5jcy5vdmVyKTtcbiAgICAgIHRvZ2dsZShjbS5kaXNwbGF5LnNjcm9sbGVyLCBcImRyYWdsZWF2ZVwiLCBmdW5jcy5sZWF2ZSk7XG4gICAgICB0b2dnbGUoY20uZGlzcGxheS5zY3JvbGxlciwgXCJkcm9wXCIsIGZ1bmNzLmRyb3ApO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXBwaW5nQ2hhbmdlZChjbSkge1xuICAgIGlmIChjbS5vcHRpb25zLmxpbmVXcmFwcGluZykge1xuICAgICAgYWRkQ2xhc3MoY20uZGlzcGxheS53cmFwcGVyLCBcIkNvZGVNaXJyb3Itd3JhcFwiKTtcbiAgICAgIGNtLmRpc3BsYXkuc2l6ZXIuc3R5bGUubWluV2lkdGggPSBcIlwiO1xuICAgICAgY20uZGlzcGxheS5zaXplcldpZHRoID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcm1DbGFzcyhjbS5kaXNwbGF5LndyYXBwZXIsIFwiQ29kZU1pcnJvci13cmFwXCIpO1xuICAgICAgZmluZE1heExpbmUoY20pO1xuICAgIH1cbiAgICBlc3RpbWF0ZUxpbmVIZWlnaHRzKGNtKTtcbiAgICByZWdDaGFuZ2UoY20pO1xuICAgIGNsZWFyQ2FjaGVzKGNtKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVwZGF0ZVNjcm9sbGJhcnMoY20pOyB9LCAxMDApO1xuICB9XG5cbiAgLy8gQSBDb2RlTWlycm9yIGluc3RhbmNlIHJlcHJlc2VudHMgYW4gZWRpdG9yLiBUaGlzIGlzIHRoZSBvYmplY3RcbiAgLy8gdGhhdCB1c2VyIGNvZGUgaXMgdXN1YWxseSBkZWFsaW5nIHdpdGguXG5cbiAgZnVuY3Rpb24gQ29kZU1pcnJvcihwbGFjZSwgb3B0aW9ucykge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIENvZGVNaXJyb3IpKSB7IHJldHVybiBuZXcgQ29kZU1pcnJvcihwbGFjZSwgb3B0aW9ucykgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucyA9IG9wdGlvbnMgPyBjb3B5T2JqKG9wdGlvbnMpIDoge307XG4gICAgLy8gRGV0ZXJtaW5lIGVmZmVjdGl2ZSBvcHRpb25zIGJhc2VkIG9uIGdpdmVuIHZhbHVlcyBhbmQgZGVmYXVsdHMuXG4gICAgY29weU9iaihkZWZhdWx0cywgb3B0aW9ucywgZmFsc2UpO1xuXG4gICAgdmFyIGRvYyA9IG9wdGlvbnMudmFsdWU7XG4gICAgaWYgKHR5cGVvZiBkb2MgPT0gXCJzdHJpbmdcIikgeyBkb2MgPSBuZXcgRG9jKGRvYywgb3B0aW9ucy5tb2RlLCBudWxsLCBvcHRpb25zLmxpbmVTZXBhcmF0b3IsIG9wdGlvbnMuZGlyZWN0aW9uKTsgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMubW9kZSkgeyBkb2MubW9kZU9wdGlvbiA9IG9wdGlvbnMubW9kZTsgfVxuICAgIHRoaXMuZG9jID0gZG9jO1xuXG4gICAgdmFyIGlucHV0ID0gbmV3IENvZGVNaXJyb3IuaW5wdXRTdHlsZXNbb3B0aW9ucy5pbnB1dFN0eWxlXSh0aGlzKTtcbiAgICB2YXIgZGlzcGxheSA9IHRoaXMuZGlzcGxheSA9IG5ldyBEaXNwbGF5KHBsYWNlLCBkb2MsIGlucHV0LCBvcHRpb25zKTtcbiAgICBkaXNwbGF5LndyYXBwZXIuQ29kZU1pcnJvciA9IHRoaXM7XG4gICAgdGhlbWVDaGFuZ2VkKHRoaXMpO1xuICAgIGlmIChvcHRpb25zLmxpbmVXcmFwcGluZylcbiAgICAgIHsgdGhpcy5kaXNwbGF5LndyYXBwZXIuY2xhc3NOYW1lICs9IFwiIENvZGVNaXJyb3Itd3JhcFwiOyB9XG4gICAgaW5pdFNjcm9sbGJhcnModGhpcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAga2V5TWFwczogW10sICAvLyBzdG9yZXMgbWFwcyBhZGRlZCBieSBhZGRLZXlNYXBcbiAgICAgIG92ZXJsYXlzOiBbXSwgLy8gaGlnaGxpZ2h0aW5nIG92ZXJsYXlzLCBhcyBhZGRlZCBieSBhZGRPdmVybGF5XG4gICAgICBtb2RlR2VuOiAwLCAgIC8vIGJ1bXBlZCB3aGVuIG1vZGUvb3ZlcmxheSBjaGFuZ2VzLCB1c2VkIHRvIGludmFsaWRhdGUgaGlnaGxpZ2h0aW5nIGluZm9cbiAgICAgIG92ZXJ3cml0ZTogZmFsc2UsXG4gICAgICBkZWxheWluZ0JsdXJFdmVudDogZmFsc2UsXG4gICAgICBmb2N1c2VkOiBmYWxzZSxcbiAgICAgIHN1cHByZXNzRWRpdHM6IGZhbHNlLCAvLyB1c2VkIHRvIGRpc2FibGUgZWRpdGluZyBkdXJpbmcga2V5IGhhbmRsZXJzIHdoZW4gaW4gcmVhZE9ubHkgbW9kZVxuICAgICAgcGFzdGVJbmNvbWluZzogLTEsIGN1dEluY29taW5nOiAtMSwgLy8gaGVscCByZWNvZ25pemUgcGFzdGUvY3V0IGVkaXRzIGluIGlucHV0LnBvbGxcbiAgICAgIHNlbGVjdGluZ1RleHQ6IGZhbHNlLFxuICAgICAgZHJhZ2dpbmdUZXh0OiBmYWxzZSxcbiAgICAgIGhpZ2hsaWdodDogbmV3IERlbGF5ZWQoKSwgLy8gc3RvcmVzIGhpZ2hsaWdodCB3b3JrZXIgdGltZW91dFxuICAgICAga2V5U2VxOiBudWxsLCAgLy8gVW5maW5pc2hlZCBrZXkgc2VxdWVuY2VcbiAgICAgIHNwZWNpYWxDaGFyczogbnVsbFxuICAgIH07XG5cbiAgICBpZiAob3B0aW9ucy5hdXRvZm9jdXMgJiYgIW1vYmlsZSkgeyBkaXNwbGF5LmlucHV0LmZvY3VzKCk7IH1cblxuICAgIC8vIE92ZXJyaWRlIG1hZ2ljIHRleHRhcmVhIGNvbnRlbnQgcmVzdG9yZSB0aGF0IElFIHNvbWV0aW1lcyBkb2VzXG4gICAgLy8gb24gb3VyIGhpZGRlbiB0ZXh0YXJlYSBvbiByZWxvYWRcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA8IDExKSB7IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcyQxLmRpc3BsYXkuaW5wdXQucmVzZXQodHJ1ZSk7IH0sIDIwKTsgfVxuXG4gICAgcmVnaXN0ZXJFdmVudEhhbmRsZXJzKHRoaXMpO1xuICAgIGVuc3VyZUdsb2JhbEhhbmRsZXJzKCk7XG5cbiAgICBzdGFydE9wZXJhdGlvbih0aGlzKTtcbiAgICB0aGlzLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICBhdHRhY2hEb2ModGhpcywgZG9jKTtcblxuICAgIGlmICgob3B0aW9ucy5hdXRvZm9jdXMgJiYgIW1vYmlsZSkgfHwgdGhpcy5oYXNGb2N1cygpKVxuICAgICAgeyBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMkMS5oYXNGb2N1cygpICYmICF0aGlzJDEuc3RhdGUuZm9jdXNlZCkgeyBvbkZvY3VzKHRoaXMkMSk7IH1cbiAgICAgIH0sIDIwKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgb25CbHVyKHRoaXMpOyB9XG5cbiAgICBmb3IgKHZhciBvcHQgaW4gb3B0aW9uSGFuZGxlcnMpIHsgaWYgKG9wdGlvbkhhbmRsZXJzLmhhc093blByb3BlcnR5KG9wdCkpXG4gICAgICB7IG9wdGlvbkhhbmRsZXJzW29wdF0odGhpcywgb3B0aW9uc1tvcHRdLCBJbml0KTsgfSB9XG4gICAgbWF5YmVVcGRhdGVMaW5lTnVtYmVyV2lkdGgodGhpcyk7XG4gICAgaWYgKG9wdGlvbnMuZmluaXNoSW5pdCkgeyBvcHRpb25zLmZpbmlzaEluaXQodGhpcyk7IH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRIb29rcy5sZW5ndGg7ICsraSkgeyBpbml0SG9va3NbaV0odGhpcyk7IH1cbiAgICBlbmRPcGVyYXRpb24odGhpcyk7XG4gICAgLy8gU3VwcHJlc3Mgb3B0aW1pemVsZWdpYmlsaXR5IGluIFdlYmtpdCwgc2luY2UgaXQgYnJlYWtzIHRleHRcbiAgICAvLyBtZWFzdXJpbmcgb24gbGluZSB3cmFwcGluZyBib3VuZGFyaWVzLlxuICAgIGlmICh3ZWJraXQgJiYgb3B0aW9ucy5saW5lV3JhcHBpbmcgJiZcbiAgICAgICAgZ2V0Q29tcHV0ZWRTdHlsZShkaXNwbGF5LmxpbmVEaXYpLnRleHRSZW5kZXJpbmcgPT0gXCJvcHRpbWl6ZWxlZ2liaWxpdHlcIilcbiAgICAgIHsgZGlzcGxheS5saW5lRGl2LnN0eWxlLnRleHRSZW5kZXJpbmcgPSBcImF1dG9cIjsgfVxuICB9XG5cbiAgLy8gVGhlIGRlZmF1bHQgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICBDb2RlTWlycm9yLmRlZmF1bHRzID0gZGVmYXVsdHM7XG4gIC8vIEZ1bmN0aW9ucyB0byBydW4gd2hlbiBvcHRpb25zIGFyZSBjaGFuZ2VkLlxuICBDb2RlTWlycm9yLm9wdGlvbkhhbmRsZXJzID0gb3B0aW9uSGFuZGxlcnM7XG5cbiAgLy8gQXR0YWNoIHRoZSBuZWNlc3NhcnkgZXZlbnQgaGFuZGxlcnMgd2hlbiBpbml0aWFsaXppbmcgdGhlIGVkaXRvclxuICBmdW5jdGlvbiByZWdpc3RlckV2ZW50SGFuZGxlcnMoY20pIHtcbiAgICB2YXIgZCA9IGNtLmRpc3BsYXk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJtb3VzZWRvd25cIiwgb3BlcmF0aW9uKGNtLCBvbk1vdXNlRG93bikpO1xuICAgIC8vIE9sZGVyIElFJ3Mgd2lsbCBub3QgZmlyZSBhIHNlY29uZCBtb3VzZWRvd24gZm9yIGEgZG91YmxlIGNsaWNrXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCAxMSlcbiAgICAgIHsgb24oZC5zY3JvbGxlciwgXCJkYmxjbGlja1wiLCBvcGVyYXRpb24oY20sIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChzaWduYWxET01FdmVudChjbSwgZSkpIHsgcmV0dXJuIH1cbiAgICAgICAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSk7XG4gICAgICAgIGlmICghcG9zIHx8IGNsaWNrSW5HdXR0ZXIoY20sIGUpIHx8IGV2ZW50SW5XaWRnZXQoY20uZGlzcGxheSwgZSkpIHsgcmV0dXJuIH1cbiAgICAgICAgZV9wcmV2ZW50RGVmYXVsdChlKTtcbiAgICAgICAgdmFyIHdvcmQgPSBjbS5maW5kV29yZEF0KHBvcyk7XG4gICAgICAgIGV4dGVuZFNlbGVjdGlvbihjbS5kb2MsIHdvcmQuYW5jaG9yLCB3b3JkLmhlYWQpO1xuICAgICAgfSkpOyB9XG4gICAgZWxzZVxuICAgICAgeyBvbihkLnNjcm9sbGVyLCBcImRibGNsaWNrXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBzaWduYWxET01FdmVudChjbSwgZSkgfHwgZV9wcmV2ZW50RGVmYXVsdChlKTsgfSk7IH1cbiAgICAvLyBTb21lIGJyb3dzZXJzIGZpcmUgY29udGV4dG1lbnUgKmFmdGVyKiBvcGVuaW5nIHRoZSBtZW51LCBhdFxuICAgIC8vIHdoaWNoIHBvaW50IHdlIGNhbid0IG1lc3Mgd2l0aCBpdCBhbnltb3JlLiBDb250ZXh0IG1lbnUgaXNcbiAgICAvLyBoYW5kbGVkIGluIG9uTW91c2VEb3duIGZvciB0aGVzZSBicm93c2Vycy5cbiAgICBvbihkLnNjcm9sbGVyLCBcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbkNvbnRleHRNZW51KGNtLCBlKTsgfSk7XG4gICAgb24oZC5pbnB1dC5nZXRGaWVsZCgpLCBcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAoIWQuc2Nyb2xsZXIuY29udGFpbnMoZS50YXJnZXQpKSB7IG9uQ29udGV4dE1lbnUoY20sIGUpOyB9XG4gICAgfSk7XG5cbiAgICAvLyBVc2VkIHRvIHN1cHByZXNzIG1vdXNlIGV2ZW50IGhhbmRsaW5nIHdoZW4gYSB0b3VjaCBoYXBwZW5zXG4gICAgdmFyIHRvdWNoRmluaXNoZWQsIHByZXZUb3VjaCA9IHtlbmQ6IDB9O1xuICAgIGZ1bmN0aW9uIGZpbmlzaFRvdWNoKCkge1xuICAgICAgaWYgKGQuYWN0aXZlVG91Y2gpIHtcbiAgICAgICAgdG91Y2hGaW5pc2hlZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gZC5hY3RpdmVUb3VjaCA9IG51bGw7IH0sIDEwMDApO1xuICAgICAgICBwcmV2VG91Y2ggPSBkLmFjdGl2ZVRvdWNoO1xuICAgICAgICBwcmV2VG91Y2guZW5kID0gK25ldyBEYXRlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBpc01vdXNlTGlrZVRvdWNoRXZlbnQoZSkge1xuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT0gMSkgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgdmFyIHRvdWNoID0gZS50b3VjaGVzWzBdO1xuICAgICAgcmV0dXJuIHRvdWNoLnJhZGl1c1ggPD0gMSAmJiB0b3VjaC5yYWRpdXNZIDw9IDFcbiAgICB9XG4gICAgZnVuY3Rpb24gZmFyQXdheSh0b3VjaCwgb3RoZXIpIHtcbiAgICAgIGlmIChvdGhlci5sZWZ0ID09IG51bGwpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgdmFyIGR4ID0gb3RoZXIubGVmdCAtIHRvdWNoLmxlZnQsIGR5ID0gb3RoZXIudG9wIC0gdG91Y2gudG9wO1xuICAgICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5ID4gMjAgKiAyMFxuICAgIH1cbiAgICBvbihkLnNjcm9sbGVyLCBcInRvdWNoc3RhcnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpICYmICFpc01vdXNlTGlrZVRvdWNoRXZlbnQoZSkgJiYgIWNsaWNrSW5HdXR0ZXIoY20sIGUpKSB7XG4gICAgICAgIGQuaW5wdXQuZW5zdXJlUG9sbGVkKCk7XG4gICAgICAgIGNsZWFyVGltZW91dCh0b3VjaEZpbmlzaGVkKTtcbiAgICAgICAgdmFyIG5vdyA9ICtuZXcgRGF0ZTtcbiAgICAgICAgZC5hY3RpdmVUb3VjaCA9IHtzdGFydDogbm93LCBtb3ZlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgcHJldjogbm93IC0gcHJldlRvdWNoLmVuZCA8PSAzMDAgPyBwcmV2VG91Y2ggOiBudWxsfTtcbiAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICAgIGQuYWN0aXZlVG91Y2gubGVmdCA9IGUudG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICBkLmFjdGl2ZVRvdWNoLnRvcCA9IGUudG91Y2hlc1swXS5wYWdlWTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIG9uKGQuc2Nyb2xsZXIsIFwidG91Y2htb3ZlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChkLmFjdGl2ZVRvdWNoKSB7IGQuYWN0aXZlVG91Y2gubW92ZWQgPSB0cnVlOyB9XG4gICAgfSk7XG4gICAgb24oZC5zY3JvbGxlciwgXCJ0b3VjaGVuZFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIHRvdWNoID0gZC5hY3RpdmVUb3VjaDtcbiAgICAgIGlmICh0b3VjaCAmJiAhZXZlbnRJbldpZGdldChkLCBlKSAmJiB0b3VjaC5sZWZ0ICE9IG51bGwgJiZcbiAgICAgICAgICAhdG91Y2gubW92ZWQgJiYgbmV3IERhdGUgLSB0b3VjaC5zdGFydCA8IDMwMCkge1xuICAgICAgICB2YXIgcG9zID0gY20uY29vcmRzQ2hhcihkLmFjdGl2ZVRvdWNoLCBcInBhZ2VcIiksIHJhbmdlO1xuICAgICAgICBpZiAoIXRvdWNoLnByZXYgfHwgZmFyQXdheSh0b3VjaCwgdG91Y2gucHJldikpIC8vIFNpbmdsZSB0YXBcbiAgICAgICAgICB7IHJhbmdlID0gbmV3IFJhbmdlKHBvcywgcG9zKTsgfVxuICAgICAgICBlbHNlIGlmICghdG91Y2gucHJldi5wcmV2IHx8IGZhckF3YXkodG91Y2gsIHRvdWNoLnByZXYucHJldikpIC8vIERvdWJsZSB0YXBcbiAgICAgICAgICB7IHJhbmdlID0gY20uZmluZFdvcmRBdChwb3MpOyB9XG4gICAgICAgIGVsc2UgLy8gVHJpcGxlIHRhcFxuICAgICAgICAgIHsgcmFuZ2UgPSBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCAwKSwgY2xpcFBvcyhjbS5kb2MsIFBvcyhwb3MubGluZSArIDEsIDApKSk7IH1cbiAgICAgICAgY20uc2V0U2VsZWN0aW9uKHJhbmdlLmFuY2hvciwgcmFuZ2UuaGVhZCk7XG4gICAgICAgIGNtLmZvY3VzKCk7XG4gICAgICAgIGVfcHJldmVudERlZmF1bHQoZSk7XG4gICAgICB9XG4gICAgICBmaW5pc2hUb3VjaCgpO1xuICAgIH0pO1xuICAgIG9uKGQuc2Nyb2xsZXIsIFwidG91Y2hjYW5jZWxcIiwgZmluaXNoVG91Y2gpO1xuXG4gICAgLy8gU3luYyBzY3JvbGxpbmcgYmV0d2VlbiBmYWtlIHNjcm9sbGJhcnMgYW5kIHJlYWwgc2Nyb2xsYWJsZVxuICAgIC8vIGFyZWEsIGVuc3VyZSB2aWV3cG9ydCBpcyB1cGRhdGVkIHdoZW4gc2Nyb2xsaW5nLlxuICAgIG9uKGQuc2Nyb2xsZXIsIFwic2Nyb2xsXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChkLnNjcm9sbGVyLmNsaWVudEhlaWdodCkge1xuICAgICAgICB1cGRhdGVTY3JvbGxUb3AoY20sIGQuc2Nyb2xsZXIuc2Nyb2xsVG9wKTtcbiAgICAgICAgc2V0U2Nyb2xsTGVmdChjbSwgZC5zY3JvbGxlci5zY3JvbGxMZWZ0LCB0cnVlKTtcbiAgICAgICAgc2lnbmFsKGNtLCBcInNjcm9sbFwiLCBjbSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBMaXN0ZW4gdG8gd2hlZWwgZXZlbnRzIGluIG9yZGVyIHRvIHRyeSBhbmQgdXBkYXRlIHRoZSB2aWV3cG9ydCBvbiB0aW1lLlxuICAgIG9uKGQuc2Nyb2xsZXIsIFwibW91c2V3aGVlbFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25TY3JvbGxXaGVlbChjbSwgZSk7IH0pO1xuICAgIG9uKGQuc2Nyb2xsZXIsIFwiRE9NTW91c2VTY3JvbGxcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uU2Nyb2xsV2hlZWwoY20sIGUpOyB9KTtcblxuICAgIC8vIFByZXZlbnQgd3JhcHBlciBmcm9tIGV2ZXIgc2Nyb2xsaW5nXG4gICAgb24oZC53cmFwcGVyLCBcInNjcm9sbFwiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBkLndyYXBwZXIuc2Nyb2xsVG9wID0gZC53cmFwcGVyLnNjcm9sbExlZnQgPSAwOyB9KTtcblxuICAgIGQuZHJhZ0Z1bmN0aW9ucyA9IHtcbiAgICAgIGVudGVyOiBmdW5jdGlvbiAoZSkge2lmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IGVfc3RvcChlKTsgfX0sXG4gICAgICBvdmVyOiBmdW5jdGlvbiAoZSkge2lmICghc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IG9uRHJhZ092ZXIoY20sIGUpOyBlX3N0b3AoZSk7IH19LFxuICAgICAgc3RhcnQ6IGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbkRyYWdTdGFydChjbSwgZSk7IH0sXG4gICAgICBkcm9wOiBvcGVyYXRpb24oY20sIG9uRHJvcCksXG4gICAgICBsZWF2ZTogZnVuY3Rpb24gKGUpIHtpZiAoIXNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyBjbGVhckRyYWdDdXJzb3IoY20pOyB9fVxuICAgIH07XG5cbiAgICB2YXIgaW5wID0gZC5pbnB1dC5nZXRGaWVsZCgpO1xuICAgIG9uKGlucCwgXCJrZXl1cFwiLCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gb25LZXlVcC5jYWxsKGNtLCBlKTsgfSk7XG4gICAgb24oaW5wLCBcImtleWRvd25cIiwgb3BlcmF0aW9uKGNtLCBvbktleURvd24pKTtcbiAgICBvbihpbnAsIFwia2V5cHJlc3NcIiwgb3BlcmF0aW9uKGNtLCBvbktleVByZXNzKSk7XG4gICAgb24oaW5wLCBcImZvY3VzXCIsIGZ1bmN0aW9uIChlKSB7IHJldHVybiBvbkZvY3VzKGNtLCBlKTsgfSk7XG4gICAgb24oaW5wLCBcImJsdXJcIiwgZnVuY3Rpb24gKGUpIHsgcmV0dXJuIG9uQmx1cihjbSwgZSk7IH0pO1xuICB9XG5cbiAgdmFyIGluaXRIb29rcyA9IFtdO1xuICBDb2RlTWlycm9yLmRlZmluZUluaXRIb29rID0gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIGluaXRIb29rcy5wdXNoKGYpOyB9O1xuXG4gIC8vIEluZGVudCB0aGUgZ2l2ZW4gbGluZS4gVGhlIGhvdyBwYXJhbWV0ZXIgY2FuIGJlIFwic21hcnRcIixcbiAgLy8gXCJhZGRcIi9udWxsLCBcInN1YnRyYWN0XCIsIG9yIFwicHJldlwiLiBXaGVuIGFnZ3Jlc3NpdmUgaXMgZmFsc2VcbiAgLy8gKHR5cGljYWxseSBzZXQgdG8gdHJ1ZSBmb3IgZm9yY2VkIHNpbmdsZS1saW5lIGluZGVudHMpLCBlbXB0eVxuICAvLyBsaW5lcyBhcmUgbm90IGluZGVudGVkLCBhbmQgcGxhY2VzIHdoZXJlIHRoZSBtb2RlIHJldHVybnMgUGFzc1xuICAvLyBhcmUgbGVmdCBhbG9uZS5cbiAgZnVuY3Rpb24gaW5kZW50TGluZShjbSwgbiwgaG93LCBhZ2dyZXNzaXZlKSB7XG4gICAgdmFyIGRvYyA9IGNtLmRvYywgc3RhdGU7XG4gICAgaWYgKGhvdyA9PSBudWxsKSB7IGhvdyA9IFwiYWRkXCI7IH1cbiAgICBpZiAoaG93ID09IFwic21hcnRcIikge1xuICAgICAgLy8gRmFsbCBiYWNrIHRvIFwicHJldlwiIHdoZW4gdGhlIG1vZGUgZG9lc24ndCBoYXZlIGFuIGluZGVudGF0aW9uXG4gICAgICAvLyBtZXRob2QuXG4gICAgICBpZiAoIWRvYy5tb2RlLmluZGVudCkgeyBob3cgPSBcInByZXZcIjsgfVxuICAgICAgZWxzZSB7IHN0YXRlID0gZ2V0Q29udGV4dEJlZm9yZShjbSwgbikuc3RhdGU7IH1cbiAgICB9XG5cbiAgICB2YXIgdGFiU2l6ZSA9IGNtLm9wdGlvbnMudGFiU2l6ZTtcbiAgICB2YXIgbGluZSA9IGdldExpbmUoZG9jLCBuKSwgY3VyU3BhY2UgPSBjb3VudENvbHVtbihsaW5lLnRleHQsIG51bGwsIHRhYlNpemUpO1xuICAgIGlmIChsaW5lLnN0YXRlQWZ0ZXIpIHsgbGluZS5zdGF0ZUFmdGVyID0gbnVsbDsgfVxuICAgIHZhciBjdXJTcGFjZVN0cmluZyA9IGxpbmUudGV4dC5tYXRjaCgvXlxccyovKVswXSwgaW5kZW50YXRpb247XG4gICAgaWYgKCFhZ2dyZXNzaXZlICYmICEvXFxTLy50ZXN0KGxpbmUudGV4dCkpIHtcbiAgICAgIGluZGVudGF0aW9uID0gMDtcbiAgICAgIGhvdyA9IFwibm90XCI7XG4gICAgfSBlbHNlIGlmIChob3cgPT0gXCJzbWFydFwiKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IGRvYy5tb2RlLmluZGVudChzdGF0ZSwgbGluZS50ZXh0LnNsaWNlKGN1clNwYWNlU3RyaW5nLmxlbmd0aCksIGxpbmUudGV4dCk7XG4gICAgICBpZiAoaW5kZW50YXRpb24gPT0gUGFzcyB8fCBpbmRlbnRhdGlvbiA+IDE1MCkge1xuICAgICAgICBpZiAoIWFnZ3Jlc3NpdmUpIHsgcmV0dXJuIH1cbiAgICAgICAgaG93ID0gXCJwcmV2XCI7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChob3cgPT0gXCJwcmV2XCIpIHtcbiAgICAgIGlmIChuID4gZG9jLmZpcnN0KSB7IGluZGVudGF0aW9uID0gY291bnRDb2x1bW4oZ2V0TGluZShkb2MsIG4tMSkudGV4dCwgbnVsbCwgdGFiU2l6ZSk7IH1cbiAgICAgIGVsc2UgeyBpbmRlbnRhdGlvbiA9IDA7IH1cbiAgICB9IGVsc2UgaWYgKGhvdyA9PSBcImFkZFwiKSB7XG4gICAgICBpbmRlbnRhdGlvbiA9IGN1clNwYWNlICsgY20ub3B0aW9ucy5pbmRlbnRVbml0O1xuICAgIH0gZWxzZSBpZiAoaG93ID09IFwic3VidHJhY3RcIikge1xuICAgICAgaW5kZW50YXRpb24gPSBjdXJTcGFjZSAtIGNtLm9wdGlvbnMuaW5kZW50VW5pdDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBob3cgPT0gXCJudW1iZXJcIikge1xuICAgICAgaW5kZW50YXRpb24gPSBjdXJTcGFjZSArIGhvdztcbiAgICB9XG4gICAgaW5kZW50YXRpb24gPSBNYXRoLm1heCgwLCBpbmRlbnRhdGlvbik7XG5cbiAgICB2YXIgaW5kZW50U3RyaW5nID0gXCJcIiwgcG9zID0gMDtcbiAgICBpZiAoY20ub3B0aW9ucy5pbmRlbnRXaXRoVGFicylcbiAgICAgIHsgZm9yICh2YXIgaSA9IE1hdGguZmxvb3IoaW5kZW50YXRpb24gLyB0YWJTaXplKTsgaTsgLS1pKSB7cG9zICs9IHRhYlNpemU7IGluZGVudFN0cmluZyArPSBcIlxcdFwiO30gfVxuICAgIGlmIChwb3MgPCBpbmRlbnRhdGlvbikgeyBpbmRlbnRTdHJpbmcgKz0gc3BhY2VTdHIoaW5kZW50YXRpb24gLSBwb3MpOyB9XG5cbiAgICBpZiAoaW5kZW50U3RyaW5nICE9IGN1clNwYWNlU3RyaW5nKSB7XG4gICAgICByZXBsYWNlUmFuZ2UoZG9jLCBpbmRlbnRTdHJpbmcsIFBvcyhuLCAwKSwgUG9zKG4sIGN1clNwYWNlU3RyaW5nLmxlbmd0aCksIFwiK2lucHV0XCIpO1xuICAgICAgbGluZS5zdGF0ZUFmdGVyID0gbnVsbDtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0LCBpZiB0aGUgY3Vyc29yIHdhcyBpbiB0aGUgd2hpdGVzcGFjZSBhdCB0aGUgc3RhcnRcbiAgICAgIC8vIG9mIHRoZSBsaW5lLCBpdCBpcyBtb3ZlZCB0byB0aGUgZW5kIG9mIHRoYXQgc3BhY2UuXG4gICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBkb2Muc2VsLnJhbmdlcy5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgIHZhciByYW5nZSA9IGRvYy5zZWwucmFuZ2VzW2kkMV07XG4gICAgICAgIGlmIChyYW5nZS5oZWFkLmxpbmUgPT0gbiAmJiByYW5nZS5oZWFkLmNoIDwgY3VyU3BhY2VTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBvcyQxID0gUG9zKG4sIGN1clNwYWNlU3RyaW5nLmxlbmd0aCk7XG4gICAgICAgICAgcmVwbGFjZU9uZVNlbGVjdGlvbihkb2MsIGkkMSwgbmV3IFJhbmdlKHBvcyQxLCBwb3MkMSkpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUaGlzIHdpbGwgYmUgc2V0IHRvIGEge2xpbmVXaXNlOiBib29sLCB0ZXh0OiBbc3RyaW5nXX0gb2JqZWN0LCBzb1xuICAvLyB0aGF0LCB3aGVuIHBhc3RpbmcsIHdlIGtub3cgd2hhdCBraW5kIG9mIHNlbGVjdGlvbnMgdGhlIGNvcGllZFxuICAvLyB0ZXh0IHdhcyBtYWRlIG91dCBvZi5cbiAgdmFyIGxhc3RDb3BpZWQgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHNldExhc3RDb3BpZWQobmV3TGFzdENvcGllZCkge1xuICAgIGxhc3RDb3BpZWQgPSBuZXdMYXN0Q29waWVkO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHlUZXh0SW5wdXQoY20sIGluc2VydGVkLCBkZWxldGVkLCBzZWwsIG9yaWdpbikge1xuICAgIHZhciBkb2MgPSBjbS5kb2M7XG4gICAgY20uZGlzcGxheS5zaGlmdCA9IGZhbHNlO1xuICAgIGlmICghc2VsKSB7IHNlbCA9IGRvYy5zZWw7IH1cblxuICAgIHZhciByZWNlbnQgPSArbmV3IERhdGUgLSAyMDA7XG4gICAgdmFyIHBhc3RlID0gb3JpZ2luID09IFwicGFzdGVcIiB8fCBjbS5zdGF0ZS5wYXN0ZUluY29taW5nID4gcmVjZW50O1xuICAgIHZhciB0ZXh0TGluZXMgPSBzcGxpdExpbmVzQXV0byhpbnNlcnRlZCksIG11bHRpUGFzdGUgPSBudWxsO1xuICAgIC8vIFdoZW4gcGFzdGluZyBOIGxpbmVzIGludG8gTiBzZWxlY3Rpb25zLCBpbnNlcnQgb25lIGxpbmUgcGVyIHNlbGVjdGlvblxuICAgIGlmIChwYXN0ZSAmJiBzZWwucmFuZ2VzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmIChsYXN0Q29waWVkICYmIGxhc3RDb3BpZWQudGV4dC5qb2luKFwiXFxuXCIpID09IGluc2VydGVkKSB7XG4gICAgICAgIGlmIChzZWwucmFuZ2VzLmxlbmd0aCAlIGxhc3RDb3BpZWQudGV4dC5sZW5ndGggPT0gMCkge1xuICAgICAgICAgIG11bHRpUGFzdGUgPSBbXTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RDb3BpZWQudGV4dC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHsgbXVsdGlQYXN0ZS5wdXNoKGRvYy5zcGxpdExpbmVzKGxhc3RDb3BpZWQudGV4dFtpXSkpOyB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGV4dExpbmVzLmxlbmd0aCA9PSBzZWwucmFuZ2VzLmxlbmd0aCAmJiBjbS5vcHRpb25zLnBhc3RlTGluZXNQZXJTZWxlY3Rpb24pIHtcbiAgICAgICAgbXVsdGlQYXN0ZSA9IG1hcCh0ZXh0TGluZXMsIGZ1bmN0aW9uIChsKSB7IHJldHVybiBbbF07IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1cGRhdGVJbnB1dCA9IGNtLmN1ck9wLnVwZGF0ZUlucHV0O1xuICAgIC8vIE5vcm1hbCBiZWhhdmlvciBpcyB0byBpbnNlcnQgdGhlIG5ldyB0ZXh0IGludG8gZXZlcnkgc2VsZWN0aW9uXG4gICAgZm9yICh2YXIgaSQxID0gc2VsLnJhbmdlcy5sZW5ndGggLSAxOyBpJDEgPj0gMDsgaSQxLS0pIHtcbiAgICAgIHZhciByYW5nZSA9IHNlbC5yYW5nZXNbaSQxXTtcbiAgICAgIHZhciBmcm9tID0gcmFuZ2UuZnJvbSgpLCB0byA9IHJhbmdlLnRvKCk7XG4gICAgICBpZiAocmFuZ2UuZW1wdHkoKSkge1xuICAgICAgICBpZiAoZGVsZXRlZCAmJiBkZWxldGVkID4gMCkgLy8gSGFuZGxlIGRlbGV0aW9uXG4gICAgICAgICAgeyBmcm9tID0gUG9zKGZyb20ubGluZSwgZnJvbS5jaCAtIGRlbGV0ZWQpOyB9XG4gICAgICAgIGVsc2UgaWYgKGNtLnN0YXRlLm92ZXJ3cml0ZSAmJiAhcGFzdGUpIC8vIEhhbmRsZSBvdmVyd3JpdGVcbiAgICAgICAgICB7IHRvID0gUG9zKHRvLmxpbmUsIE1hdGgubWluKGdldExpbmUoZG9jLCB0by5saW5lKS50ZXh0Lmxlbmd0aCwgdG8uY2ggKyBsc3QodGV4dExpbmVzKS5sZW5ndGgpKTsgfVxuICAgICAgICBlbHNlIGlmIChwYXN0ZSAmJiBsYXN0Q29waWVkICYmIGxhc3RDb3BpZWQubGluZVdpc2UgJiYgbGFzdENvcGllZC50ZXh0LmpvaW4oXCJcXG5cIikgPT0gdGV4dExpbmVzLmpvaW4oXCJcXG5cIikpXG4gICAgICAgICAgeyBmcm9tID0gdG8gPSBQb3MoZnJvbS5saW5lLCAwKTsgfVxuICAgICAgfVxuICAgICAgdmFyIGNoYW5nZUV2ZW50ID0ge2Zyb206IGZyb20sIHRvOiB0bywgdGV4dDogbXVsdGlQYXN0ZSA/IG11bHRpUGFzdGVbaSQxICUgbXVsdGlQYXN0ZS5sZW5ndGhdIDogdGV4dExpbmVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogb3JpZ2luIHx8IChwYXN0ZSA/IFwicGFzdGVcIiA6IGNtLnN0YXRlLmN1dEluY29taW5nID4gcmVjZW50ID8gXCJjdXRcIiA6IFwiK2lucHV0XCIpfTtcbiAgICAgIG1ha2VDaGFuZ2UoY20uZG9jLCBjaGFuZ2VFdmVudCk7XG4gICAgICBzaWduYWxMYXRlcihjbSwgXCJpbnB1dFJlYWRcIiwgY20sIGNoYW5nZUV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkICYmICFwYXN0ZSlcbiAgICAgIHsgdHJpZ2dlckVsZWN0cmljKGNtLCBpbnNlcnRlZCk7IH1cblxuICAgIGVuc3VyZUN1cnNvclZpc2libGUoY20pO1xuICAgIGlmIChjbS5jdXJPcC51cGRhdGVJbnB1dCA8IDIpIHsgY20uY3VyT3AudXBkYXRlSW5wdXQgPSB1cGRhdGVJbnB1dDsgfVxuICAgIGNtLmN1ck9wLnR5cGluZyA9IHRydWU7XG4gICAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9IGNtLnN0YXRlLmN1dEluY29taW5nID0gLTE7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVQYXN0ZShlLCBjbSkge1xuICAgIHZhciBwYXN0ZWQgPSBlLmNsaXBib2FyZERhdGEgJiYgZS5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpO1xuICAgIGlmIChwYXN0ZWQpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICghY20uaXNSZWFkT25seSgpICYmICFjbS5vcHRpb25zLmRpc2FibGVJbnB1dClcbiAgICAgICAgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7IHJldHVybiBhcHBseVRleHRJbnB1dChjbSwgcGFzdGVkLCAwLCBudWxsLCBcInBhc3RlXCIpOyB9KTsgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cmlnZ2VyRWxlY3RyaWMoY20sIGluc2VydGVkKSB7XG4gICAgLy8gV2hlbiBhbiAnZWxlY3RyaWMnIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgaW1tZWRpYXRlbHkgdHJpZ2dlciBhIHJlaW5kZW50XG4gICAgaWYgKCFjbS5vcHRpb25zLmVsZWN0cmljQ2hhcnMgfHwgIWNtLm9wdGlvbnMuc21hcnRJbmRlbnQpIHsgcmV0dXJuIH1cbiAgICB2YXIgc2VsID0gY20uZG9jLnNlbDtcblxuICAgIGZvciAodmFyIGkgPSBzZWwucmFuZ2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgcmFuZ2UgPSBzZWwucmFuZ2VzW2ldO1xuICAgICAgaWYgKHJhbmdlLmhlYWQuY2ggPiAxMDAgfHwgKGkgJiYgc2VsLnJhbmdlc1tpIC0gMV0uaGVhZC5saW5lID09IHJhbmdlLmhlYWQubGluZSkpIHsgY29udGludWUgfVxuICAgICAgdmFyIG1vZGUgPSBjbS5nZXRNb2RlQXQocmFuZ2UuaGVhZCk7XG4gICAgICB2YXIgaW5kZW50ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChtb2RlLmVsZWN0cmljQ2hhcnMpIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtb2RlLmVsZWN0cmljQ2hhcnMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgeyBpZiAoaW5zZXJ0ZWQuaW5kZXhPZihtb2RlLmVsZWN0cmljQ2hhcnMuY2hhckF0KGopKSA+IC0xKSB7XG4gICAgICAgICAgICBpbmRlbnRlZCA9IGluZGVudExpbmUoY20sIHJhbmdlLmhlYWQubGluZSwgXCJzbWFydFwiKTtcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfSB9XG4gICAgICB9IGVsc2UgaWYgKG1vZGUuZWxlY3RyaWNJbnB1dCkge1xuICAgICAgICBpZiAobW9kZS5lbGVjdHJpY0lucHV0LnRlc3QoZ2V0TGluZShjbS5kb2MsIHJhbmdlLmhlYWQubGluZSkudGV4dC5zbGljZSgwLCByYW5nZS5oZWFkLmNoKSkpXG4gICAgICAgICAgeyBpbmRlbnRlZCA9IGluZGVudExpbmUoY20sIHJhbmdlLmhlYWQubGluZSwgXCJzbWFydFwiKTsgfVxuICAgICAgfVxuICAgICAgaWYgKGluZGVudGVkKSB7IHNpZ25hbExhdGVyKGNtLCBcImVsZWN0cmljSW5wdXRcIiwgY20sIHJhbmdlLmhlYWQubGluZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3B5YWJsZVJhbmdlcyhjbSkge1xuICAgIHZhciB0ZXh0ID0gW10sIHJhbmdlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaW5lID0gY20uZG9jLnNlbC5yYW5nZXNbaV0uaGVhZC5saW5lO1xuICAgICAgdmFyIGxpbmVSYW5nZSA9IHthbmNob3I6IFBvcyhsaW5lLCAwKSwgaGVhZDogUG9zKGxpbmUgKyAxLCAwKX07XG4gICAgICByYW5nZXMucHVzaChsaW5lUmFuZ2UpO1xuICAgICAgdGV4dC5wdXNoKGNtLmdldFJhbmdlKGxpbmVSYW5nZS5hbmNob3IsIGxpbmVSYW5nZS5oZWFkKSk7XG4gICAgfVxuICAgIHJldHVybiB7dGV4dDogdGV4dCwgcmFuZ2VzOiByYW5nZXN9XG4gIH1cblxuICBmdW5jdGlvbiBkaXNhYmxlQnJvd3Nlck1hZ2ljKGZpZWxkLCBzcGVsbGNoZWNrLCBhdXRvY29ycmVjdCwgYXV0b2NhcGl0YWxpemUpIHtcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXCJhdXRvY29ycmVjdFwiLCBhdXRvY29ycmVjdCA/IFwiXCIgOiBcIm9mZlwiKTtcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXCJhdXRvY2FwaXRhbGl6ZVwiLCBhdXRvY2FwaXRhbGl6ZSA/IFwiXCIgOiBcIm9mZlwiKTtcbiAgICBmaWVsZC5zZXRBdHRyaWJ1dGUoXCJzcGVsbGNoZWNrXCIsICEhc3BlbGxjaGVjayk7XG4gIH1cblxuICBmdW5jdGlvbiBoaWRkZW5UZXh0YXJlYSgpIHtcbiAgICB2YXIgdGUgPSBlbHQoXCJ0ZXh0YXJlYVwiLCBudWxsLCBudWxsLCBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgYm90dG9tOiAtMWVtOyBwYWRkaW5nOiAwOyB3aWR0aDogMXB4OyBoZWlnaHQ6IDFlbTsgb3V0bGluZTogbm9uZVwiKTtcbiAgICB2YXIgZGl2ID0gZWx0KFwiZGl2XCIsIFt0ZV0sIG51bGwsIFwib3ZlcmZsb3c6IGhpZGRlbjsgcG9zaXRpb246IHJlbGF0aXZlOyB3aWR0aDogM3B4OyBoZWlnaHQ6IDBweDtcIik7XG4gICAgLy8gVGhlIHRleHRhcmVhIGlzIGtlcHQgcG9zaXRpb25lZCBuZWFyIHRoZSBjdXJzb3IgdG8gcHJldmVudCB0aGVcbiAgICAvLyBmYWN0IHRoYXQgaXQnbGwgYmUgc2Nyb2xsZWQgaW50byB2aWV3IG9uIGlucHV0IGZyb20gc2Nyb2xsaW5nXG4gICAgLy8gb3VyIGZha2UgY3Vyc29yIG91dCBvZiB2aWV3LiBPbiB3ZWJraXQsIHdoZW4gd3JhcD1vZmYsIHBhc3RlIGlzXG4gICAgLy8gdmVyeSBzbG93LiBTbyBtYWtlIHRoZSBhcmVhIHdpZGUgaW5zdGVhZC5cbiAgICBpZiAod2Via2l0KSB7IHRlLnN0eWxlLndpZHRoID0gXCIxMDAwcHhcIjsgfVxuICAgIGVsc2UgeyB0ZS5zZXRBdHRyaWJ1dGUoXCJ3cmFwXCIsIFwib2ZmXCIpOyB9XG4gICAgLy8gSWYgYm9yZGVyOiAwOyAtLSBpT1MgZmFpbHMgdG8gb3BlbiBrZXlib2FyZCAoaXNzdWUgIzEyODcpXG4gICAgaWYgKGlvcykgeyB0ZS5zdHlsZS5ib3JkZXIgPSBcIjFweCBzb2xpZCBibGFja1wiOyB9XG4gICAgZGlzYWJsZUJyb3dzZXJNYWdpYyh0ZSk7XG4gICAgcmV0dXJuIGRpdlxuICB9XG5cbiAgLy8gVGhlIHB1YmxpY2x5IHZpc2libGUgQVBJLiBOb3RlIHRoYXQgbWV0aG9kT3AoZikgbWVhbnNcbiAgLy8gJ3dyYXAgZiBpbiBhbiBvcGVyYXRpb24sIHBlcmZvcm1lZCBvbiBpdHMgYHRoaXNgIHBhcmFtZXRlcicuXG5cbiAgLy8gVGhpcyBpcyBub3QgdGhlIGNvbXBsZXRlIHNldCBvZiBlZGl0b3IgbWV0aG9kcy4gTW9zdCBvZiB0aGVcbiAgLy8gbWV0aG9kcyBkZWZpbmVkIG9uIHRoZSBEb2MgdHlwZSBhcmUgYWxzbyBpbmplY3RlZCBpbnRvXG4gIC8vIENvZGVNaXJyb3IucHJvdG90eXBlLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgYW5kXG4gIC8vIGNvbnZlbmllbmNlLlxuXG4gIGZ1bmN0aW9uIGFkZEVkaXRvck1ldGhvZHMoQ29kZU1pcnJvcikge1xuICAgIHZhciBvcHRpb25IYW5kbGVycyA9IENvZGVNaXJyb3Iub3B0aW9uSGFuZGxlcnM7XG5cbiAgICB2YXIgaGVscGVycyA9IENvZGVNaXJyb3IuaGVscGVycyA9IHt9O1xuXG4gICAgQ29kZU1pcnJvci5wcm90b3R5cGUgPSB7XG4gICAgICBjb25zdHJ1Y3RvcjogQ29kZU1pcnJvcixcbiAgICAgIGZvY3VzOiBmdW5jdGlvbigpe3dpbmRvdy5mb2N1cygpOyB0aGlzLmRpc3BsYXkuaW5wdXQuZm9jdXMoKTt9LFxuXG4gICAgICBzZXRPcHRpb246IGZ1bmN0aW9uKG9wdGlvbiwgdmFsdWUpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsIG9sZCA9IG9wdGlvbnNbb3B0aW9uXTtcbiAgICAgICAgaWYgKG9wdGlvbnNbb3B0aW9uXSA9PSB2YWx1ZSAmJiBvcHRpb24gIT0gXCJtb2RlXCIpIHsgcmV0dXJuIH1cbiAgICAgICAgb3B0aW9uc1tvcHRpb25dID0gdmFsdWU7XG4gICAgICAgIGlmIChvcHRpb25IYW5kbGVycy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pKVxuICAgICAgICAgIHsgb3BlcmF0aW9uKHRoaXMsIG9wdGlvbkhhbmRsZXJzW29wdGlvbl0pKHRoaXMsIHZhbHVlLCBvbGQpOyB9XG4gICAgICAgIHNpZ25hbCh0aGlzLCBcIm9wdGlvbkNoYW5nZVwiLCB0aGlzLCBvcHRpb24pO1xuICAgICAgfSxcblxuICAgICAgZ2V0T3B0aW9uOiBmdW5jdGlvbihvcHRpb24pIHtyZXR1cm4gdGhpcy5vcHRpb25zW29wdGlvbl19LFxuICAgICAgZ2V0RG9jOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5kb2N9LFxuXG4gICAgICBhZGRLZXlNYXA6IGZ1bmN0aW9uKG1hcCwgYm90dG9tKSB7XG4gICAgICAgIHRoaXMuc3RhdGUua2V5TWFwc1tib3R0b20gPyBcInB1c2hcIiA6IFwidW5zaGlmdFwiXShnZXRLZXlNYXAobWFwKSk7XG4gICAgICB9LFxuICAgICAgcmVtb3ZlS2V5TWFwOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgdmFyIG1hcHMgPSB0aGlzLnN0YXRlLmtleU1hcHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFwcy5sZW5ndGg7ICsraSlcbiAgICAgICAgICB7IGlmIChtYXBzW2ldID09IG1hcCB8fCBtYXBzW2ldLm5hbWUgPT0gbWFwKSB7XG4gICAgICAgICAgICBtYXBzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfSB9XG4gICAgICB9LFxuXG4gICAgICBhZGRPdmVybGF5OiBtZXRob2RPcChmdW5jdGlvbihzcGVjLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBtb2RlID0gc3BlYy50b2tlbiA/IHNwZWMgOiBDb2RlTWlycm9yLmdldE1vZGUodGhpcy5vcHRpb25zLCBzcGVjKTtcbiAgICAgICAgaWYgKG1vZGUuc3RhcnRTdGF0ZSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJPdmVybGF5cyBtYXkgbm90IGJlIHN0YXRlZnVsLlwiKSB9XG4gICAgICAgIGluc2VydFNvcnRlZCh0aGlzLnN0YXRlLm92ZXJsYXlzLFxuICAgICAgICAgICAgICAgICAgICAge21vZGU6IG1vZGUsIG1vZGVTcGVjOiBzcGVjLCBvcGFxdWU6IG9wdGlvbnMgJiYgb3B0aW9ucy5vcGFxdWUsXG4gICAgICAgICAgICAgICAgICAgICAgcHJpb3JpdHk6IChvcHRpb25zICYmIG9wdGlvbnMucHJpb3JpdHkpIHx8IDB9LFxuICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKG92ZXJsYXkpIHsgcmV0dXJuIG92ZXJsYXkucHJpb3JpdHk7IH0pO1xuICAgICAgICB0aGlzLnN0YXRlLm1vZGVHZW4rKztcbiAgICAgICAgcmVnQ2hhbmdlKHRoaXMpO1xuICAgICAgfSksXG4gICAgICByZW1vdmVPdmVybGF5OiBtZXRob2RPcChmdW5jdGlvbihzcGVjKSB7XG4gICAgICAgIHZhciBvdmVybGF5cyA9IHRoaXMuc3RhdGUub3ZlcmxheXM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3ZlcmxheXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB2YXIgY3VyID0gb3ZlcmxheXNbaV0ubW9kZVNwZWM7XG4gICAgICAgICAgaWYgKGN1ciA9PSBzcGVjIHx8IHR5cGVvZiBzcGVjID09IFwic3RyaW5nXCIgJiYgY3VyLm5hbWUgPT0gc3BlYykge1xuICAgICAgICAgICAgb3ZlcmxheXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5tb2RlR2VuKys7XG4gICAgICAgICAgICByZWdDaGFuZ2UodGhpcyk7XG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pLFxuXG4gICAgICBpbmRlbnRMaW5lOiBtZXRob2RPcChmdW5jdGlvbihuLCBkaXIsIGFnZ3Jlc3NpdmUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkaXIgIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2YgZGlyICE9IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBpZiAoZGlyID09IG51bGwpIHsgZGlyID0gdGhpcy5vcHRpb25zLnNtYXJ0SW5kZW50ID8gXCJzbWFydFwiIDogXCJwcmV2XCI7IH1cbiAgICAgICAgICBlbHNlIHsgZGlyID0gZGlyID8gXCJhZGRcIiA6IFwic3VidHJhY3RcIjsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xpbmUodGhpcy5kb2MsIG4pKSB7IGluZGVudExpbmUodGhpcywgbiwgZGlyLCBhZ2dyZXNzaXZlKTsgfVxuICAgICAgfSksXG4gICAgICBpbmRlbnRTZWxlY3Rpb246IG1ldGhvZE9wKGZ1bmN0aW9uKGhvdykge1xuICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5kb2Muc2VsLnJhbmdlcywgZW5kID0gLTE7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmFyIHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICAgIGlmICghcmFuZ2UuZW1wdHkoKSkge1xuICAgICAgICAgICAgdmFyIGZyb20gPSByYW5nZS5mcm9tKCksIHRvID0gcmFuZ2UudG8oKTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IE1hdGgubWF4KGVuZCwgZnJvbS5saW5lKTtcbiAgICAgICAgICAgIGVuZCA9IE1hdGgubWluKHRoaXMubGFzdExpbmUoKSwgdG8ubGluZSAtICh0by5jaCA/IDAgOiAxKSkgKyAxO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0OyBqIDwgZW5kOyArK2opXG4gICAgICAgICAgICAgIHsgaW5kZW50TGluZSh0aGlzLCBqLCBob3cpOyB9XG4gICAgICAgICAgICB2YXIgbmV3UmFuZ2VzID0gdGhpcy5kb2Muc2VsLnJhbmdlcztcbiAgICAgICAgICAgIGlmIChmcm9tLmNoID09IDAgJiYgcmFuZ2VzLmxlbmd0aCA9PSBuZXdSYW5nZXMubGVuZ3RoICYmIG5ld1Jhbmdlc1tpXS5mcm9tKCkuY2ggPiAwKVxuICAgICAgICAgICAgICB7IHJlcGxhY2VPbmVTZWxlY3Rpb24odGhpcy5kb2MsIGksIG5ldyBSYW5nZShmcm9tLCBuZXdSYW5nZXNbaV0udG8oKSksIHNlbF9kb250U2Nyb2xsKTsgfVxuICAgICAgICAgIH0gZWxzZSBpZiAocmFuZ2UuaGVhZC5saW5lID4gZW5kKSB7XG4gICAgICAgICAgICBpbmRlbnRMaW5lKHRoaXMsIHJhbmdlLmhlYWQubGluZSwgaG93LCB0cnVlKTtcbiAgICAgICAgICAgIGVuZCA9IHJhbmdlLmhlYWQubGluZTtcbiAgICAgICAgICAgIGlmIChpID09IHRoaXMuZG9jLnNlbC5wcmltSW5kZXgpIHsgZW5zdXJlQ3Vyc29yVmlzaWJsZSh0aGlzKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSksXG5cbiAgICAgIC8vIEZldGNoIHRoZSBwYXJzZXIgdG9rZW4gZm9yIGEgZ2l2ZW4gY2hhcmFjdGVyLiBVc2VmdWwgZm9yIGhhY2tzXG4gICAgICAvLyB0aGF0IHdhbnQgdG8gaW5zcGVjdCB0aGUgbW9kZSBzdGF0ZSAoc2F5LCBmb3IgY29tcGxldGlvbikuXG4gICAgICBnZXRUb2tlbkF0OiBmdW5jdGlvbihwb3MsIHByZWNpc2UpIHtcbiAgICAgICAgcmV0dXJuIHRha2VUb2tlbih0aGlzLCBwb3MsIHByZWNpc2UpXG4gICAgICB9LFxuXG4gICAgICBnZXRMaW5lVG9rZW5zOiBmdW5jdGlvbihsaW5lLCBwcmVjaXNlKSB7XG4gICAgICAgIHJldHVybiB0YWtlVG9rZW4odGhpcywgUG9zKGxpbmUpLCBwcmVjaXNlLCB0cnVlKVxuICAgICAgfSxcblxuICAgICAgZ2V0VG9rZW5UeXBlQXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICBwb3MgPSBjbGlwUG9zKHRoaXMuZG9jLCBwb3MpO1xuICAgICAgICB2YXIgc3R5bGVzID0gZ2V0TGluZVN0eWxlcyh0aGlzLCBnZXRMaW5lKHRoaXMuZG9jLCBwb3MubGluZSkpO1xuICAgICAgICB2YXIgYmVmb3JlID0gMCwgYWZ0ZXIgPSAoc3R5bGVzLmxlbmd0aCAtIDEpIC8gMiwgY2ggPSBwb3MuY2g7XG4gICAgICAgIHZhciB0eXBlO1xuICAgICAgICBpZiAoY2ggPT0gMCkgeyB0eXBlID0gc3R5bGVzWzJdOyB9XG4gICAgICAgIGVsc2UgeyBmb3IgKDs7KSB7XG4gICAgICAgICAgdmFyIG1pZCA9IChiZWZvcmUgKyBhZnRlcikgPj4gMTtcbiAgICAgICAgICBpZiAoKG1pZCA/IHN0eWxlc1ttaWQgKiAyIC0gMV0gOiAwKSA+PSBjaCkgeyBhZnRlciA9IG1pZDsgfVxuICAgICAgICAgIGVsc2UgaWYgKHN0eWxlc1ttaWQgKiAyICsgMV0gPCBjaCkgeyBiZWZvcmUgPSBtaWQgKyAxOyB9XG4gICAgICAgICAgZWxzZSB7IHR5cGUgPSBzdHlsZXNbbWlkICogMiArIDJdOyBicmVhayB9XG4gICAgICAgIH0gfVxuICAgICAgICB2YXIgY3V0ID0gdHlwZSA/IHR5cGUuaW5kZXhPZihcIm92ZXJsYXkgXCIpIDogLTE7XG4gICAgICAgIHJldHVybiBjdXQgPCAwID8gdHlwZSA6IGN1dCA9PSAwID8gbnVsbCA6IHR5cGUuc2xpY2UoMCwgY3V0IC0gMSlcbiAgICAgIH0sXG5cbiAgICAgIGdldE1vZGVBdDogZnVuY3Rpb24ocG9zKSB7XG4gICAgICAgIHZhciBtb2RlID0gdGhpcy5kb2MubW9kZTtcbiAgICAgICAgaWYgKCFtb2RlLmlubmVyTW9kZSkgeyByZXR1cm4gbW9kZSB9XG4gICAgICAgIHJldHVybiBDb2RlTWlycm9yLmlubmVyTW9kZShtb2RlLCB0aGlzLmdldFRva2VuQXQocG9zKS5zdGF0ZSkubW9kZVxuICAgICAgfSxcblxuICAgICAgZ2V0SGVscGVyOiBmdW5jdGlvbihwb3MsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVscGVycyhwb3MsIHR5cGUpWzBdXG4gICAgICB9LFxuXG4gICAgICBnZXRIZWxwZXJzOiBmdW5jdGlvbihwb3MsIHR5cGUpIHtcbiAgICAgICAgdmFyIGZvdW5kID0gW107XG4gICAgICAgIGlmICghaGVscGVycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgeyByZXR1cm4gZm91bmQgfVxuICAgICAgICB2YXIgaGVscCA9IGhlbHBlcnNbdHlwZV0sIG1vZGUgPSB0aGlzLmdldE1vZGVBdChwb3MpO1xuICAgICAgICBpZiAodHlwZW9mIG1vZGVbdHlwZV0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmIChoZWxwW21vZGVbdHlwZV1dKSB7IGZvdW5kLnB1c2goaGVscFttb2RlW3R5cGVdXSk7IH1cbiAgICAgICAgfSBlbHNlIGlmIChtb2RlW3R5cGVdKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb2RlW3R5cGVdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gaGVscFttb2RlW3R5cGVdW2ldXTtcbiAgICAgICAgICAgIGlmICh2YWwpIHsgZm91bmQucHVzaCh2YWwpOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1vZGUuaGVscGVyVHlwZSAmJiBoZWxwW21vZGUuaGVscGVyVHlwZV0pIHtcbiAgICAgICAgICBmb3VuZC5wdXNoKGhlbHBbbW9kZS5oZWxwZXJUeXBlXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGVscFttb2RlLm5hbWVdKSB7XG4gICAgICAgICAgZm91bmQucHVzaChoZWxwW21vZGUubmFtZV0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkkMSA9IDA7IGkkMSA8IGhlbHAuX2dsb2JhbC5sZW5ndGg7IGkkMSsrKSB7XG4gICAgICAgICAgdmFyIGN1ciA9IGhlbHAuX2dsb2JhbFtpJDFdO1xuICAgICAgICAgIGlmIChjdXIucHJlZChtb2RlLCB0aGlzKSAmJiBpbmRleE9mKGZvdW5kLCBjdXIudmFsKSA9PSAtMSlcbiAgICAgICAgICAgIHsgZm91bmQucHVzaChjdXIudmFsKTsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3VuZFxuICAgICAgfSxcblxuICAgICAgZ2V0U3RhdGVBZnRlcjogZnVuY3Rpb24obGluZSwgcHJlY2lzZSkge1xuICAgICAgICB2YXIgZG9jID0gdGhpcy5kb2M7XG4gICAgICAgIGxpbmUgPSBjbGlwTGluZShkb2MsIGxpbmUgPT0gbnVsbCA/IGRvYy5maXJzdCArIGRvYy5zaXplIC0gMTogbGluZSk7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0QmVmb3JlKHRoaXMsIGxpbmUgKyAxLCBwcmVjaXNlKS5zdGF0ZVxuICAgICAgfSxcblxuICAgICAgY3Vyc29yQ29vcmRzOiBmdW5jdGlvbihzdGFydCwgbW9kZSkge1xuICAgICAgICB2YXIgcG9zLCByYW5nZSA9IHRoaXMuZG9jLnNlbC5wcmltYXJ5KCk7XG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsKSB7IHBvcyA9IHJhbmdlLmhlYWQ7IH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHN0YXJ0ID09IFwib2JqZWN0XCIpIHsgcG9zID0gY2xpcFBvcyh0aGlzLmRvYywgc3RhcnQpOyB9XG4gICAgICAgIGVsc2UgeyBwb3MgPSBzdGFydCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCk7IH1cbiAgICAgICAgcmV0dXJuIGN1cnNvckNvb3Jkcyh0aGlzLCBwb3MsIG1vZGUgfHwgXCJwYWdlXCIpXG4gICAgICB9LFxuXG4gICAgICBjaGFyQ29vcmRzOiBmdW5jdGlvbihwb3MsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJDb29yZHModGhpcywgY2xpcFBvcyh0aGlzLmRvYywgcG9zKSwgbW9kZSB8fCBcInBhZ2VcIilcbiAgICAgIH0sXG5cbiAgICAgIGNvb3Jkc0NoYXI6IGZ1bmN0aW9uKGNvb3JkcywgbW9kZSkge1xuICAgICAgICBjb29yZHMgPSBmcm9tQ29vcmRTeXN0ZW0odGhpcywgY29vcmRzLCBtb2RlIHx8IFwicGFnZVwiKTtcbiAgICAgICAgcmV0dXJuIGNvb3Jkc0NoYXIodGhpcywgY29vcmRzLmxlZnQsIGNvb3Jkcy50b3ApXG4gICAgICB9LFxuXG4gICAgICBsaW5lQXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCwgbW9kZSkge1xuICAgICAgICBoZWlnaHQgPSBmcm9tQ29vcmRTeXN0ZW0odGhpcywge3RvcDogaGVpZ2h0LCBsZWZ0OiAwfSwgbW9kZSB8fCBcInBhZ2VcIikudG9wO1xuICAgICAgICByZXR1cm4gbGluZUF0SGVpZ2h0KHRoaXMuZG9jLCBoZWlnaHQgKyB0aGlzLmRpc3BsYXkudmlld09mZnNldClcbiAgICAgIH0sXG4gICAgICBoZWlnaHRBdExpbmU6IGZ1bmN0aW9uKGxpbmUsIG1vZGUsIGluY2x1ZGVXaWRnZXRzKSB7XG4gICAgICAgIHZhciBlbmQgPSBmYWxzZSwgbGluZU9iajtcbiAgICAgICAgaWYgKHR5cGVvZiBsaW5lID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICB2YXIgbGFzdCA9IHRoaXMuZG9jLmZpcnN0ICsgdGhpcy5kb2Muc2l6ZSAtIDE7XG4gICAgICAgICAgaWYgKGxpbmUgPCB0aGlzLmRvYy5maXJzdCkgeyBsaW5lID0gdGhpcy5kb2MuZmlyc3Q7IH1cbiAgICAgICAgICBlbHNlIGlmIChsaW5lID4gbGFzdCkgeyBsaW5lID0gbGFzdDsgZW5kID0gdHJ1ZTsgfVxuICAgICAgICAgIGxpbmVPYmogPSBnZXRMaW5lKHRoaXMuZG9jLCBsaW5lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsaW5lT2JqID0gbGluZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW50b0Nvb3JkU3lzdGVtKHRoaXMsIGxpbmVPYmosIHt0b3A6IDAsIGxlZnQ6IDB9LCBtb2RlIHx8IFwicGFnZVwiLCBpbmNsdWRlV2lkZ2V0cyB8fCBlbmQpLnRvcCArXG4gICAgICAgICAgKGVuZCA/IHRoaXMuZG9jLmhlaWdodCAtIGhlaWdodEF0TGluZShsaW5lT2JqKSA6IDApXG4gICAgICB9LFxuXG4gICAgICBkZWZhdWx0VGV4dEhlaWdodDogZnVuY3Rpb24oKSB7IHJldHVybiB0ZXh0SGVpZ2h0KHRoaXMuZGlzcGxheSkgfSxcbiAgICAgIGRlZmF1bHRDaGFyV2lkdGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gY2hhcldpZHRoKHRoaXMuZGlzcGxheSkgfSxcblxuICAgICAgZ2V0Vmlld3BvcnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4ge2Zyb206IHRoaXMuZGlzcGxheS52aWV3RnJvbSwgdG86IHRoaXMuZGlzcGxheS52aWV3VG99fSxcblxuICAgICAgYWRkV2lkZ2V0OiBmdW5jdGlvbihwb3MsIG5vZGUsIHNjcm9sbCwgdmVydCwgaG9yaXopIHtcbiAgICAgICAgdmFyIGRpc3BsYXkgPSB0aGlzLmRpc3BsYXk7XG4gICAgICAgIHBvcyA9IGN1cnNvckNvb3Jkcyh0aGlzLCBjbGlwUG9zKHRoaXMuZG9jLCBwb3MpKTtcbiAgICAgICAgdmFyIHRvcCA9IHBvcy5ib3R0b20sIGxlZnQgPSBwb3MubGVmdDtcbiAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoXCJjbS1pZ25vcmUtZXZlbnRzXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgdGhpcy5kaXNwbGF5LmlucHV0LnNldFVuZWRpdGFibGUobm9kZSk7XG4gICAgICAgIGRpc3BsYXkuc2l6ZXIuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIGlmICh2ZXJ0ID09IFwib3ZlclwiKSB7XG4gICAgICAgICAgdG9wID0gcG9zLnRvcDtcbiAgICAgICAgfSBlbHNlIGlmICh2ZXJ0ID09IFwiYWJvdmVcIiB8fCB2ZXJ0ID09IFwibmVhclwiKSB7XG4gICAgICAgICAgdmFyIHZzcGFjZSA9IE1hdGgubWF4KGRpc3BsYXkud3JhcHBlci5jbGllbnRIZWlnaHQsIHRoaXMuZG9jLmhlaWdodCksXG4gICAgICAgICAgaHNwYWNlID0gTWF0aC5tYXgoZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCwgZGlzcGxheS5saW5lU3BhY2UuY2xpZW50V2lkdGgpO1xuICAgICAgICAgIC8vIERlZmF1bHQgdG8gcG9zaXRpb25pbmcgYWJvdmUgKGlmIHNwZWNpZmllZCBhbmQgcG9zc2libGUpOyBvdGhlcndpc2UgZGVmYXVsdCB0byBwb3NpdGlvbmluZyBiZWxvd1xuICAgICAgICAgIGlmICgodmVydCA9PSAnYWJvdmUnIHx8IHBvcy5ib3R0b20gKyBub2RlLm9mZnNldEhlaWdodCA+IHZzcGFjZSkgJiYgcG9zLnRvcCA+IG5vZGUub2Zmc2V0SGVpZ2h0KVxuICAgICAgICAgICAgeyB0b3AgPSBwb3MudG9wIC0gbm9kZS5vZmZzZXRIZWlnaHQ7IH1cbiAgICAgICAgICBlbHNlIGlmIChwb3MuYm90dG9tICsgbm9kZS5vZmZzZXRIZWlnaHQgPD0gdnNwYWNlKVxuICAgICAgICAgICAgeyB0b3AgPSBwb3MuYm90dG9tOyB9XG4gICAgICAgICAgaWYgKGxlZnQgKyBub2RlLm9mZnNldFdpZHRoID4gaHNwYWNlKVxuICAgICAgICAgICAgeyBsZWZ0ID0gaHNwYWNlIC0gbm9kZS5vZmZzZXRXaWR0aDsgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUuc3R5bGUudG9wID0gdG9wICsgXCJweFwiO1xuICAgICAgICBub2RlLnN0eWxlLmxlZnQgPSBub2RlLnN0eWxlLnJpZ2h0ID0gXCJcIjtcbiAgICAgICAgaWYgKGhvcml6ID09IFwicmlnaHRcIikge1xuICAgICAgICAgIGxlZnQgPSBkaXNwbGF5LnNpemVyLmNsaWVudFdpZHRoIC0gbm9kZS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICBub2RlLnN0eWxlLnJpZ2h0ID0gXCIwcHhcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaG9yaXogPT0gXCJsZWZ0XCIpIHsgbGVmdCA9IDA7IH1cbiAgICAgICAgICBlbHNlIGlmIChob3JpeiA9PSBcIm1pZGRsZVwiKSB7IGxlZnQgPSAoZGlzcGxheS5zaXplci5jbGllbnRXaWR0aCAtIG5vZGUub2Zmc2V0V2lkdGgpIC8gMjsgfVxuICAgICAgICAgIG5vZGUuc3R5bGUubGVmdCA9IGxlZnQgKyBcInB4XCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjcm9sbClcbiAgICAgICAgICB7IHNjcm9sbEludG9WaWV3KHRoaXMsIHtsZWZ0OiBsZWZ0LCB0b3A6IHRvcCwgcmlnaHQ6IGxlZnQgKyBub2RlLm9mZnNldFdpZHRoLCBib3R0b206IHRvcCArIG5vZGUub2Zmc2V0SGVpZ2h0fSk7IH1cbiAgICAgIH0sXG5cbiAgICAgIHRyaWdnZXJPbktleURvd246IG1ldGhvZE9wKG9uS2V5RG93biksXG4gICAgICB0cmlnZ2VyT25LZXlQcmVzczogbWV0aG9kT3Aob25LZXlQcmVzcyksXG4gICAgICB0cmlnZ2VyT25LZXlVcDogb25LZXlVcCxcbiAgICAgIHRyaWdnZXJPbk1vdXNlRG93bjogbWV0aG9kT3Aob25Nb3VzZURvd24pLFxuXG4gICAgICBleGVjQ29tbWFuZDogZnVuY3Rpb24oY21kKSB7XG4gICAgICAgIGlmIChjb21tYW5kcy5oYXNPd25Qcm9wZXJ0eShjbWQpKVxuICAgICAgICAgIHsgcmV0dXJuIGNvbW1hbmRzW2NtZF0uY2FsbChudWxsLCB0aGlzKSB9XG4gICAgICB9LFxuXG4gICAgICB0cmlnZ2VyRWxlY3RyaWM6IG1ldGhvZE9wKGZ1bmN0aW9uKHRleHQpIHsgdHJpZ2dlckVsZWN0cmljKHRoaXMsIHRleHQpOyB9KSxcblxuICAgICAgZmluZFBvc0g6IGZ1bmN0aW9uKGZyb20sIGFtb3VudCwgdW5pdCwgdmlzdWFsbHkpIHtcbiAgICAgICAgdmFyIGRpciA9IDE7XG4gICAgICAgIGlmIChhbW91bnQgPCAwKSB7IGRpciA9IC0xOyBhbW91bnQgPSAtYW1vdW50OyB9XG4gICAgICAgIHZhciBjdXIgPSBjbGlwUG9zKHRoaXMuZG9jLCBmcm9tKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7ICsraSkge1xuICAgICAgICAgIGN1ciA9IGZpbmRQb3NIKHRoaXMuZG9jLCBjdXIsIGRpciwgdW5pdCwgdmlzdWFsbHkpO1xuICAgICAgICAgIGlmIChjdXIuaGl0U2lkZSkgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1clxuICAgICAgfSxcblxuICAgICAgbW92ZUg6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICB0aGlzLmV4dGVuZFNlbGVjdGlvbnNCeShmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICBpZiAodGhpcyQxLmRpc3BsYXkuc2hpZnQgfHwgdGhpcyQxLmRvYy5leHRlbmQgfHwgcmFuZ2UuZW1wdHkoKSlcbiAgICAgICAgICAgIHsgcmV0dXJuIGZpbmRQb3NIKHRoaXMkMS5kb2MsIHJhbmdlLmhlYWQsIGRpciwgdW5pdCwgdGhpcyQxLm9wdGlvbnMucnRsTW92ZVZpc3VhbGx5KSB9XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgeyByZXR1cm4gZGlyIDwgMCA/IHJhbmdlLmZyb20oKSA6IHJhbmdlLnRvKCkgfVxuICAgICAgICB9LCBzZWxfbW92ZSk7XG4gICAgICB9KSxcblxuICAgICAgZGVsZXRlSDogbWV0aG9kT3AoZnVuY3Rpb24oZGlyLCB1bml0KSB7XG4gICAgICAgIHZhciBzZWwgPSB0aGlzLmRvYy5zZWwsIGRvYyA9IHRoaXMuZG9jO1xuICAgICAgICBpZiAoc2VsLnNvbWV0aGluZ1NlbGVjdGVkKCkpXG4gICAgICAgICAgeyBkb2MucmVwbGFjZVNlbGVjdGlvbihcIlwiLCBudWxsLCBcIitkZWxldGVcIik7IH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHsgZGVsZXRlTmVhclNlbGVjdGlvbih0aGlzLCBmdW5jdGlvbiAocmFuZ2UpIHtcbiAgICAgICAgICAgIHZhciBvdGhlciA9IGZpbmRQb3NIKGRvYywgcmFuZ2UuaGVhZCwgZGlyLCB1bml0LCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gZGlyIDwgMCA/IHtmcm9tOiBvdGhlciwgdG86IHJhbmdlLmhlYWR9IDoge2Zyb206IHJhbmdlLmhlYWQsIHRvOiBvdGhlcn1cbiAgICAgICAgICB9KTsgfVxuICAgICAgfSksXG5cbiAgICAgIGZpbmRQb3NWOiBmdW5jdGlvbihmcm9tLCBhbW91bnQsIHVuaXQsIGdvYWxDb2x1bW4pIHtcbiAgICAgICAgdmFyIGRpciA9IDEsIHggPSBnb2FsQ29sdW1uO1xuICAgICAgICBpZiAoYW1vdW50IDwgMCkgeyBkaXIgPSAtMTsgYW1vdW50ID0gLWFtb3VudDsgfVxuICAgICAgICB2YXIgY3VyID0gY2xpcFBvcyh0aGlzLmRvYywgZnJvbSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyArK2kpIHtcbiAgICAgICAgICB2YXIgY29vcmRzID0gY3Vyc29yQ29vcmRzKHRoaXMsIGN1ciwgXCJkaXZcIik7XG4gICAgICAgICAgaWYgKHggPT0gbnVsbCkgeyB4ID0gY29vcmRzLmxlZnQ7IH1cbiAgICAgICAgICBlbHNlIHsgY29vcmRzLmxlZnQgPSB4OyB9XG4gICAgICAgICAgY3VyID0gZmluZFBvc1YodGhpcywgY29vcmRzLCBkaXIsIHVuaXQpO1xuICAgICAgICAgIGlmIChjdXIuaGl0U2lkZSkgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1clxuICAgICAgfSxcblxuICAgICAgbW92ZVY6IG1ldGhvZE9wKGZ1bmN0aW9uKGRpciwgdW5pdCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICB2YXIgZG9jID0gdGhpcy5kb2MsIGdvYWxzID0gW107XG4gICAgICAgIHZhciBjb2xsYXBzZSA9ICF0aGlzLmRpc3BsYXkuc2hpZnQgJiYgIWRvYy5leHRlbmQgJiYgZG9jLnNlbC5zb21ldGhpbmdTZWxlY3RlZCgpO1xuICAgICAgICBkb2MuZXh0ZW5kU2VsZWN0aW9uc0J5KGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICAgIGlmIChjb2xsYXBzZSlcbiAgICAgICAgICAgIHsgcmV0dXJuIGRpciA8IDAgPyByYW5nZS5mcm9tKCkgOiByYW5nZS50bygpIH1cbiAgICAgICAgICB2YXIgaGVhZFBvcyA9IGN1cnNvckNvb3Jkcyh0aGlzJDEsIHJhbmdlLmhlYWQsIFwiZGl2XCIpO1xuICAgICAgICAgIGlmIChyYW5nZS5nb2FsQ29sdW1uICE9IG51bGwpIHsgaGVhZFBvcy5sZWZ0ID0gcmFuZ2UuZ29hbENvbHVtbjsgfVxuICAgICAgICAgIGdvYWxzLnB1c2goaGVhZFBvcy5sZWZ0KTtcbiAgICAgICAgICB2YXIgcG9zID0gZmluZFBvc1YodGhpcyQxLCBoZWFkUG9zLCBkaXIsIHVuaXQpO1xuICAgICAgICAgIGlmICh1bml0ID09IFwicGFnZVwiICYmIHJhbmdlID09IGRvYy5zZWwucHJpbWFyeSgpKVxuICAgICAgICAgICAgeyBhZGRUb1Njcm9sbFRvcCh0aGlzJDEsIGNoYXJDb29yZHModGhpcyQxLCBwb3MsIFwiZGl2XCIpLnRvcCAtIGhlYWRQb3MudG9wKTsgfVxuICAgICAgICAgIHJldHVybiBwb3NcbiAgICAgICAgfSwgc2VsX21vdmUpO1xuICAgICAgICBpZiAoZ29hbHMubGVuZ3RoKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgZG9jLnNlbC5yYW5nZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgeyBkb2Muc2VsLnJhbmdlc1tpXS5nb2FsQ29sdW1uID0gZ29hbHNbaV07IH0gfVxuICAgICAgfSksXG5cbiAgICAgIC8vIEZpbmQgdGhlIHdvcmQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIChhcyByZXR1cm5lZCBieSBjb29yZHNDaGFyKS5cbiAgICAgIGZpbmRXb3JkQXQ6IGZ1bmN0aW9uKHBvcykge1xuICAgICAgICB2YXIgZG9jID0gdGhpcy5kb2MsIGxpbmUgPSBnZXRMaW5lKGRvYywgcG9zLmxpbmUpLnRleHQ7XG4gICAgICAgIHZhciBzdGFydCA9IHBvcy5jaCwgZW5kID0gcG9zLmNoO1xuICAgICAgICBpZiAobGluZSkge1xuICAgICAgICAgIHZhciBoZWxwZXIgPSB0aGlzLmdldEhlbHBlcihwb3MsIFwid29yZENoYXJzXCIpO1xuICAgICAgICAgIGlmICgocG9zLnN0aWNreSA9PSBcImJlZm9yZVwiIHx8IGVuZCA9PSBsaW5lLmxlbmd0aCkgJiYgc3RhcnQpIHsgLS1zdGFydDsgfSBlbHNlIHsgKytlbmQ7IH1cbiAgICAgICAgICB2YXIgc3RhcnRDaGFyID0gbGluZS5jaGFyQXQoc3RhcnQpO1xuICAgICAgICAgIHZhciBjaGVjayA9IGlzV29yZENoYXIoc3RhcnRDaGFyLCBoZWxwZXIpXG4gICAgICAgICAgICA/IGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gaXNXb3JkQ2hhcihjaCwgaGVscGVyKTsgfVxuICAgICAgICAgICAgOiAvXFxzLy50ZXN0KHN0YXJ0Q2hhcikgPyBmdW5jdGlvbiAoY2gpIHsgcmV0dXJuIC9cXHMvLnRlc3QoY2gpOyB9XG4gICAgICAgICAgICA6IGZ1bmN0aW9uIChjaCkgeyByZXR1cm4gKCEvXFxzLy50ZXN0KGNoKSAmJiAhaXNXb3JkQ2hhcihjaCkpOyB9O1xuICAgICAgICAgIHdoaWxlIChzdGFydCA+IDAgJiYgY2hlY2sobGluZS5jaGFyQXQoc3RhcnQgLSAxKSkpIHsgLS1zdGFydDsgfVxuICAgICAgICAgIHdoaWxlIChlbmQgPCBsaW5lLmxlbmd0aCAmJiBjaGVjayhsaW5lLmNoYXJBdChlbmQpKSkgeyArK2VuZDsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmFuZ2UoUG9zKHBvcy5saW5lLCBzdGFydCksIFBvcyhwb3MubGluZSwgZW5kKSlcbiAgICAgIH0sXG5cbiAgICAgIHRvZ2dsZU92ZXJ3cml0ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUgPT0gdGhpcy5zdGF0ZS5vdmVyd3JpdGUpIHsgcmV0dXJuIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUub3ZlcndyaXRlID0gIXRoaXMuc3RhdGUub3ZlcndyaXRlKVxuICAgICAgICAgIHsgYWRkQ2xhc3ModGhpcy5kaXNwbGF5LmN1cnNvckRpdiwgXCJDb2RlTWlycm9yLW92ZXJ3cml0ZVwiKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyBybUNsYXNzKHRoaXMuZGlzcGxheS5jdXJzb3JEaXYsIFwiQ29kZU1pcnJvci1vdmVyd3JpdGVcIik7IH1cblxuICAgICAgICBzaWduYWwodGhpcywgXCJvdmVyd3JpdGVUb2dnbGVcIiwgdGhpcywgdGhpcy5zdGF0ZS5vdmVyd3JpdGUpO1xuICAgICAgfSxcbiAgICAgIGhhc0ZvY3VzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpID09IGFjdGl2ZUVsdCgpIH0sXG4gICAgICBpc1JlYWRPbmx5OiBmdW5jdGlvbigpIHsgcmV0dXJuICEhKHRoaXMub3B0aW9ucy5yZWFkT25seSB8fCB0aGlzLmRvYy5jYW50RWRpdCkgfSxcblxuICAgICAgc2Nyb2xsVG86IG1ldGhvZE9wKGZ1bmN0aW9uICh4LCB5KSB7IHNjcm9sbFRvQ29vcmRzKHRoaXMsIHgsIHkpOyB9KSxcbiAgICAgIGdldFNjcm9sbEluZm86IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2Nyb2xsZXIgPSB0aGlzLmRpc3BsYXkuc2Nyb2xsZXI7XG4gICAgICAgIHJldHVybiB7bGVmdDogc2Nyb2xsZXIuc2Nyb2xsTGVmdCwgdG9wOiBzY3JvbGxlci5zY3JvbGxUb3AsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBzY3JvbGxlci5zY3JvbGxIZWlnaHQgLSBzY3JvbGxHYXAodGhpcykgLSB0aGlzLmRpc3BsYXkuYmFySGVpZ2h0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiBzY3JvbGxlci5zY3JvbGxXaWR0aCAtIHNjcm9sbEdhcCh0aGlzKSAtIHRoaXMuZGlzcGxheS5iYXJXaWR0aCxcbiAgICAgICAgICAgICAgICBjbGllbnRIZWlnaHQ6IGRpc3BsYXlIZWlnaHQodGhpcyksIGNsaWVudFdpZHRoOiBkaXNwbGF5V2lkdGgodGhpcyl9XG4gICAgICB9LFxuXG4gICAgICBzY3JvbGxJbnRvVmlldzogbWV0aG9kT3AoZnVuY3Rpb24ocmFuZ2UsIG1hcmdpbikge1xuICAgICAgICBpZiAocmFuZ2UgPT0gbnVsbCkge1xuICAgICAgICAgIHJhbmdlID0ge2Zyb206IHRoaXMuZG9jLnNlbC5wcmltYXJ5KCkuaGVhZCwgdG86IG51bGx9O1xuICAgICAgICAgIGlmIChtYXJnaW4gPT0gbnVsbCkgeyBtYXJnaW4gPSB0aGlzLm9wdGlvbnMuY3Vyc29yU2Nyb2xsTWFyZ2luOyB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHJhbmdlID09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICByYW5nZSA9IHtmcm9tOiBQb3MocmFuZ2UsIDApLCB0bzogbnVsbH07XG4gICAgICAgIH0gZWxzZSBpZiAocmFuZ2UuZnJvbSA9PSBudWxsKSB7XG4gICAgICAgICAgcmFuZ2UgPSB7ZnJvbTogcmFuZ2UsIHRvOiBudWxsfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJhbmdlLnRvKSB7IHJhbmdlLnRvID0gcmFuZ2UuZnJvbTsgfVxuICAgICAgICByYW5nZS5tYXJnaW4gPSBtYXJnaW4gfHwgMDtcblxuICAgICAgICBpZiAocmFuZ2UuZnJvbS5saW5lICE9IG51bGwpIHtcbiAgICAgICAgICBzY3JvbGxUb1JhbmdlKHRoaXMsIHJhbmdlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY3JvbGxUb0Nvb3Jkc1JhbmdlKHRoaXMsIHJhbmdlLmZyb20sIHJhbmdlLnRvLCByYW5nZS5tYXJnaW4pO1xuICAgICAgICB9XG4gICAgICB9KSxcblxuICAgICAgc2V0U2l6ZTogbWV0aG9kT3AoZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgICAgICB2YXIgaW50ZXJwcmV0ID0gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gdHlwZW9mIHZhbCA9PSBcIm51bWJlclwiIHx8IC9eXFxkKyQvLnRlc3QoU3RyaW5nKHZhbCkpID8gdmFsICsgXCJweFwiIDogdmFsOyB9O1xuICAgICAgICBpZiAod2lkdGggIT0gbnVsbCkgeyB0aGlzLmRpc3BsYXkud3JhcHBlci5zdHlsZS53aWR0aCA9IGludGVycHJldCh3aWR0aCk7IH1cbiAgICAgICAgaWYgKGhlaWdodCAhPSBudWxsKSB7IHRoaXMuZGlzcGxheS53cmFwcGVyLnN0eWxlLmhlaWdodCA9IGludGVycHJldChoZWlnaHQpOyB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGluZVdyYXBwaW5nKSB7IGNsZWFyTGluZU1lYXN1cmVtZW50Q2FjaGUodGhpcyk7IH1cbiAgICAgICAgdmFyIGxpbmVObyA9IHRoaXMuZGlzcGxheS52aWV3RnJvbTtcbiAgICAgICAgdGhpcy5kb2MuaXRlcihsaW5lTm8sIHRoaXMuZGlzcGxheS52aWV3VG8sIGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICAgICAgaWYgKGxpbmUud2lkZ2V0cykgeyBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUud2lkZ2V0cy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHsgaWYgKGxpbmUud2lkZ2V0c1tpXS5ub0hTY3JvbGwpIHsgcmVnTGluZUNoYW5nZSh0aGlzJDEsIGxpbmVObywgXCJ3aWRnZXRcIik7IGJyZWFrIH0gfSB9XG4gICAgICAgICAgKytsaW5lTm87XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmN1ck9wLmZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgc2lnbmFsKHRoaXMsIFwicmVmcmVzaFwiLCB0aGlzKTtcbiAgICAgIH0pLFxuXG4gICAgICBvcGVyYXRpb246IGZ1bmN0aW9uKGYpe3JldHVybiBydW5Jbk9wKHRoaXMsIGYpfSxcbiAgICAgIHN0YXJ0T3BlcmF0aW9uOiBmdW5jdGlvbigpe3JldHVybiBzdGFydE9wZXJhdGlvbih0aGlzKX0sXG4gICAgICBlbmRPcGVyYXRpb246IGZ1bmN0aW9uKCl7cmV0dXJuIGVuZE9wZXJhdGlvbih0aGlzKX0sXG5cbiAgICAgIHJlZnJlc2g6IG1ldGhvZE9wKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2xkSGVpZ2h0ID0gdGhpcy5kaXNwbGF5LmNhY2hlZFRleHRIZWlnaHQ7XG4gICAgICAgIHJlZ0NoYW5nZSh0aGlzKTtcbiAgICAgICAgdGhpcy5jdXJPcC5mb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIGNsZWFyQ2FjaGVzKHRoaXMpO1xuICAgICAgICBzY3JvbGxUb0Nvb3Jkcyh0aGlzLCB0aGlzLmRvYy5zY3JvbGxMZWZ0LCB0aGlzLmRvYy5zY3JvbGxUb3ApO1xuICAgICAgICB1cGRhdGVHdXR0ZXJTcGFjZSh0aGlzLmRpc3BsYXkpO1xuICAgICAgICBpZiAob2xkSGVpZ2h0ID09IG51bGwgfHwgTWF0aC5hYnMob2xkSGVpZ2h0IC0gdGV4dEhlaWdodCh0aGlzLmRpc3BsYXkpKSA+IC41IHx8IHRoaXMub3B0aW9ucy5saW5lV3JhcHBpbmcpXG4gICAgICAgICAgeyBlc3RpbWF0ZUxpbmVIZWlnaHRzKHRoaXMpOyB9XG4gICAgICAgIHNpZ25hbCh0aGlzLCBcInJlZnJlc2hcIiwgdGhpcyk7XG4gICAgICB9KSxcblxuICAgICAgc3dhcERvYzogbWV0aG9kT3AoZnVuY3Rpb24oZG9jKSB7XG4gICAgICAgIHZhciBvbGQgPSB0aGlzLmRvYztcbiAgICAgICAgb2xkLmNtID0gbnVsbDtcbiAgICAgICAgLy8gQ2FuY2VsIHRoZSBjdXJyZW50IHRleHQgc2VsZWN0aW9uIGlmIGFueSAoIzU4MjEpXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnNlbGVjdGluZ1RleHQpIHsgdGhpcy5zdGF0ZS5zZWxlY3RpbmdUZXh0KCk7IH1cbiAgICAgICAgYXR0YWNoRG9jKHRoaXMsIGRvYyk7XG4gICAgICAgIGNsZWFyQ2FjaGVzKHRoaXMpO1xuICAgICAgICB0aGlzLmRpc3BsYXkuaW5wdXQucmVzZXQoKTtcbiAgICAgICAgc2Nyb2xsVG9Db29yZHModGhpcywgZG9jLnNjcm9sbExlZnQsIGRvYy5zY3JvbGxUb3ApO1xuICAgICAgICB0aGlzLmN1ck9wLmZvcmNlU2Nyb2xsID0gdHJ1ZTtcbiAgICAgICAgc2lnbmFsTGF0ZXIodGhpcywgXCJzd2FwRG9jXCIsIHRoaXMsIG9sZCk7XG4gICAgICAgIHJldHVybiBvbGRcbiAgICAgIH0pLFxuXG4gICAgICBwaHJhc2U6IGZ1bmN0aW9uKHBocmFzZVRleHQpIHtcbiAgICAgICAgdmFyIHBocmFzZXMgPSB0aGlzLm9wdGlvbnMucGhyYXNlcztcbiAgICAgICAgcmV0dXJuIHBocmFzZXMgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBocmFzZXMsIHBocmFzZVRleHQpID8gcGhyYXNlc1twaHJhc2VUZXh0XSA6IHBocmFzZVRleHRcbiAgICAgIH0sXG5cbiAgICAgIGdldElucHV0RmllbGQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5pbnB1dC5nZXRGaWVsZCgpfSxcbiAgICAgIGdldFdyYXBwZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkud3JhcHBlcn0sXG4gICAgICBnZXRTY3JvbGxlckVsZW1lbnQ6IGZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzcGxheS5zY3JvbGxlcn0sXG4gICAgICBnZXRHdXR0ZXJFbGVtZW50OiBmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc3BsYXkuZ3V0dGVyc31cbiAgICB9O1xuICAgIGV2ZW50TWl4aW4oQ29kZU1pcnJvcik7XG5cbiAgICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyID0gZnVuY3Rpb24odHlwZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGlmICghaGVscGVycy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgeyBoZWxwZXJzW3R5cGVdID0gQ29kZU1pcnJvclt0eXBlXSA9IHtfZ2xvYmFsOiBbXX07IH1cbiAgICAgIGhlbHBlcnNbdHlwZV1bbmFtZV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIENvZGVNaXJyb3IucmVnaXN0ZXJHbG9iYWxIZWxwZXIgPSBmdW5jdGlvbih0eXBlLCBuYW1lLCBwcmVkaWNhdGUsIHZhbHVlKSB7XG4gICAgICBDb2RlTWlycm9yLnJlZ2lzdGVySGVscGVyKHR5cGUsIG5hbWUsIHZhbHVlKTtcbiAgICAgIGhlbHBlcnNbdHlwZV0uX2dsb2JhbC5wdXNoKHtwcmVkOiBwcmVkaWNhdGUsIHZhbDogdmFsdWV9KTtcbiAgICB9O1xuICB9XG5cbiAgLy8gVXNlZCBmb3IgaG9yaXpvbnRhbCByZWxhdGl2ZSBtb3Rpb24uIERpciBpcyAtMSBvciAxIChsZWZ0IG9yXG4gIC8vIHJpZ2h0KSwgdW5pdCBjYW4gYmUgXCJjb2RlcG9pbnRcIiwgXCJjaGFyXCIsIFwiY29sdW1uXCIgKGxpa2UgY2hhciwgYnV0XG4gIC8vIGRvZXNuJ3QgY3Jvc3MgbGluZSBib3VuZGFyaWVzKSwgXCJ3b3JkXCIgKGFjcm9zcyBuZXh0IHdvcmQpLCBvclxuICAvLyBcImdyb3VwXCIgKHRvIHRoZSBzdGFydCBvZiBuZXh0IGdyb3VwIG9mIHdvcmQgb3JcbiAgLy8gbm9uLXdvcmQtbm9uLXdoaXRlc3BhY2UgY2hhcnMpLiBUaGUgdmlzdWFsbHkgcGFyYW0gY29udHJvbHNcbiAgLy8gd2hldGhlciwgaW4gcmlnaHQtdG8tbGVmdCB0ZXh0LCBkaXJlY3Rpb24gMSBtZWFucyB0byBtb3ZlIHRvd2FyZHNcbiAgLy8gdGhlIG5leHQgaW5kZXggaW4gdGhlIHN0cmluZywgb3IgdG93YXJkcyB0aGUgY2hhcmFjdGVyIHRvIHRoZSByaWdodFxuICAvLyBvZiB0aGUgY3VycmVudCBwb3NpdGlvbi4gVGhlIHJlc3VsdGluZyBwb3NpdGlvbiB3aWxsIGhhdmUgYVxuICAvLyBoaXRTaWRlPXRydWUgcHJvcGVydHkgaWYgaXQgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudC5cbiAgZnVuY3Rpb24gZmluZFBvc0goZG9jLCBwb3MsIGRpciwgdW5pdCwgdmlzdWFsbHkpIHtcbiAgICB2YXIgb2xkUG9zID0gcG9zO1xuICAgIHZhciBvcmlnRGlyID0gZGlyO1xuICAgIHZhciBsaW5lT2JqID0gZ2V0TGluZShkb2MsIHBvcy5saW5lKTtcbiAgICB2YXIgbGluZURpciA9IHZpc3VhbGx5ICYmIGRvYy5kaXJlY3Rpb24gPT0gXCJydGxcIiA/IC1kaXIgOiBkaXI7XG4gICAgZnVuY3Rpb24gZmluZE5leHRMaW5lKCkge1xuICAgICAgdmFyIGwgPSBwb3MubGluZSArIGxpbmVEaXI7XG4gICAgICBpZiAobCA8IGRvYy5maXJzdCB8fCBsID49IGRvYy5maXJzdCArIGRvYy5zaXplKSB7IHJldHVybiBmYWxzZSB9XG4gICAgICBwb3MgPSBuZXcgUG9zKGwsIHBvcy5jaCwgcG9zLnN0aWNreSk7XG4gICAgICByZXR1cm4gbGluZU9iaiA9IGdldExpbmUoZG9jLCBsKVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb3ZlT25jZShib3VuZFRvTGluZSkge1xuICAgICAgdmFyIG5leHQ7XG4gICAgICBpZiAodW5pdCA9PSBcImNvZGVwb2ludFwiKSB7XG4gICAgICAgIHZhciBjaCA9IGxpbmVPYmoudGV4dC5jaGFyQ29kZUF0KHBvcy5jaCArIChkaXIgPiAwID8gMCA6IC0xKSk7XG4gICAgICAgIGlmIChpc05hTihjaCkpIHtcbiAgICAgICAgICBuZXh0ID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXN0cmFsID0gZGlyID4gMCA/IGNoID49IDB4RDgwMCAmJiBjaCA8IDB4REMwMCA6IGNoID49IDB4REMwMCAmJiBjaCA8IDB4REZGRjtcbiAgICAgICAgICBuZXh0ID0gbmV3IFBvcyhwb3MubGluZSwgTWF0aC5tYXgoMCwgTWF0aC5taW4obGluZU9iai50ZXh0Lmxlbmd0aCwgcG9zLmNoICsgZGlyICogKGFzdHJhbCA/IDIgOiAxKSkpLCAtZGlyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh2aXN1YWxseSkge1xuICAgICAgICBuZXh0ID0gbW92ZVZpc3VhbGx5KGRvYy5jbSwgbGluZU9iaiwgcG9zLCBkaXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCA9IG1vdmVMb2dpY2FsbHkobGluZU9iaiwgcG9zLCBkaXIpO1xuICAgICAgfVxuICAgICAgaWYgKG5leHQgPT0gbnVsbCkge1xuICAgICAgICBpZiAoIWJvdW5kVG9MaW5lICYmIGZpbmROZXh0TGluZSgpKVxuICAgICAgICAgIHsgcG9zID0gZW5kT2ZMaW5lKHZpc3VhbGx5LCBkb2MuY20sIGxpbmVPYmosIHBvcy5saW5lLCBsaW5lRGlyKTsgfVxuICAgICAgICBlbHNlXG4gICAgICAgICAgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcG9zID0gbmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuXG4gICAgaWYgKHVuaXQgPT0gXCJjaGFyXCIgfHwgdW5pdCA9PSBcImNvZGVwb2ludFwiKSB7XG4gICAgICBtb3ZlT25jZSgpO1xuICAgIH0gZWxzZSBpZiAodW5pdCA9PSBcImNvbHVtblwiKSB7XG4gICAgICBtb3ZlT25jZSh0cnVlKTtcbiAgICB9IGVsc2UgaWYgKHVuaXQgPT0gXCJ3b3JkXCIgfHwgdW5pdCA9PSBcImdyb3VwXCIpIHtcbiAgICAgIHZhciBzYXdUeXBlID0gbnVsbCwgZ3JvdXAgPSB1bml0ID09IFwiZ3JvdXBcIjtcbiAgICAgIHZhciBoZWxwZXIgPSBkb2MuY20gJiYgZG9jLmNtLmdldEhlbHBlcihwb3MsIFwid29yZENoYXJzXCIpO1xuICAgICAgZm9yICh2YXIgZmlyc3QgPSB0cnVlOzsgZmlyc3QgPSBmYWxzZSkge1xuICAgICAgICBpZiAoZGlyIDwgMCAmJiAhbW92ZU9uY2UoIWZpcnN0KSkgeyBicmVhayB9XG4gICAgICAgIHZhciBjdXIgPSBsaW5lT2JqLnRleHQuY2hhckF0KHBvcy5jaCkgfHwgXCJcXG5cIjtcbiAgICAgICAgdmFyIHR5cGUgPSBpc1dvcmRDaGFyKGN1ciwgaGVscGVyKSA/IFwid1wiXG4gICAgICAgICAgOiBncm91cCAmJiBjdXIgPT0gXCJcXG5cIiA/IFwiblwiXG4gICAgICAgICAgOiAhZ3JvdXAgfHwgL1xccy8udGVzdChjdXIpID8gbnVsbFxuICAgICAgICAgIDogXCJwXCI7XG4gICAgICAgIGlmIChncm91cCAmJiAhZmlyc3QgJiYgIXR5cGUpIHsgdHlwZSA9IFwic1wiOyB9XG4gICAgICAgIGlmIChzYXdUeXBlICYmIHNhd1R5cGUgIT0gdHlwZSkge1xuICAgICAgICAgIGlmIChkaXIgPCAwKSB7ZGlyID0gMTsgbW92ZU9uY2UoKTsgcG9zLnN0aWNreSA9IFwiYWZ0ZXJcIjt9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlKSB7IHNhd1R5cGUgPSB0eXBlOyB9XG4gICAgICAgIGlmIChkaXIgPiAwICYmICFtb3ZlT25jZSghZmlyc3QpKSB7IGJyZWFrIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHNraXBBdG9taWMoZG9jLCBwb3MsIG9sZFBvcywgb3JpZ0RpciwgdHJ1ZSk7XG4gICAgaWYgKGVxdWFsQ3Vyc29yUG9zKG9sZFBvcywgcmVzdWx0KSkgeyByZXN1bHQuaGl0U2lkZSA9IHRydWU7IH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICAvLyBGb3IgcmVsYXRpdmUgdmVydGljYWwgbW92ZW1lbnQuIERpciBtYXkgYmUgLTEgb3IgMS4gVW5pdCBjYW4gYmVcbiAgLy8gXCJwYWdlXCIgb3IgXCJsaW5lXCIuIFRoZSByZXN1bHRpbmcgcG9zaXRpb24gd2lsbCBoYXZlIGEgaGl0U2lkZT10cnVlXG4gIC8vIHByb3BlcnR5IGlmIGl0IHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgZG9jdW1lbnQuXG4gIGZ1bmN0aW9uIGZpbmRQb3NWKGNtLCBwb3MsIGRpciwgdW5pdCkge1xuICAgIHZhciBkb2MgPSBjbS5kb2MsIHggPSBwb3MubGVmdCwgeTtcbiAgICBpZiAodW5pdCA9PSBcInBhZ2VcIikge1xuICAgICAgdmFyIHBhZ2VTaXplID0gTWF0aC5taW4oY20uZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCwgd2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpO1xuICAgICAgdmFyIG1vdmVBbW91bnQgPSBNYXRoLm1heChwYWdlU2l6ZSAtIC41ICogdGV4dEhlaWdodChjbS5kaXNwbGF5KSwgMyk7XG4gICAgICB5ID0gKGRpciA+IDAgPyBwb3MuYm90dG9tIDogcG9zLnRvcCkgKyBkaXIgKiBtb3ZlQW1vdW50O1xuXG4gICAgfSBlbHNlIGlmICh1bml0ID09IFwibGluZVwiKSB7XG4gICAgICB5ID0gZGlyID4gMCA/IHBvcy5ib3R0b20gKyAzIDogcG9zLnRvcCAtIDM7XG4gICAgfVxuICAgIHZhciB0YXJnZXQ7XG4gICAgZm9yICg7Oykge1xuICAgICAgdGFyZ2V0ID0gY29vcmRzQ2hhcihjbSwgeCwgeSk7XG4gICAgICBpZiAoIXRhcmdldC5vdXRzaWRlKSB7IGJyZWFrIH1cbiAgICAgIGlmIChkaXIgPCAwID8geSA8PSAwIDogeSA+PSBkb2MuaGVpZ2h0KSB7IHRhcmdldC5oaXRTaWRlID0gdHJ1ZTsgYnJlYWsgfVxuICAgICAgeSArPSBkaXIgKiA1O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0XG4gIH1cblxuICAvLyBDT05URU5URURJVEFCTEUgSU5QVVQgU1RZTEVcblxuICB2YXIgQ29udGVudEVkaXRhYmxlSW5wdXQgPSBmdW5jdGlvbihjbSkge1xuICAgIHRoaXMuY20gPSBjbTtcbiAgICB0aGlzLmxhc3RBbmNob3JOb2RlID0gdGhpcy5sYXN0QW5jaG9yT2Zmc2V0ID0gdGhpcy5sYXN0Rm9jdXNOb2RlID0gdGhpcy5sYXN0Rm9jdXNPZmZzZXQgPSBudWxsO1xuICAgIHRoaXMucG9sbGluZyA9IG5ldyBEZWxheWVkKCk7XG4gICAgdGhpcy5jb21wb3NpbmcgPSBudWxsO1xuICAgIHRoaXMuZ3JhY2VQZXJpb2QgPSBmYWxzZTtcbiAgICB0aGlzLnJlYWRET01UaW1lb3V0ID0gbnVsbDtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChkaXNwbGF5KSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIHZhciBpbnB1dCA9IHRoaXMsIGNtID0gaW5wdXQuY207XG4gICAgdmFyIGRpdiA9IGlucHV0LmRpdiA9IGRpc3BsYXkubGluZURpdjtcbiAgICBkaXNhYmxlQnJvd3Nlck1hZ2ljKGRpdiwgY20ub3B0aW9ucy5zcGVsbGNoZWNrLCBjbS5vcHRpb25zLmF1dG9jb3JyZWN0LCBjbS5vcHRpb25zLmF1dG9jYXBpdGFsaXplKTtcblxuICAgIGZ1bmN0aW9uIGJlbG9uZ3NUb0lucHV0KGUpIHtcbiAgICAgIGZvciAodmFyIHQgPSBlLnRhcmdldDsgdDsgdCA9IHQucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAodCA9PSBkaXYpIHsgcmV0dXJuIHRydWUgfVxuICAgICAgICBpZiAoL1xcYkNvZGVNaXJyb3ItKD86bGluZSk/d2lkZ2V0XFxiLy50ZXN0KHQuY2xhc3NOYW1lKSkgeyBicmVhayB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBvbihkaXYsIFwicGFzdGVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghYmVsb25nc1RvSW5wdXQoZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpIHx8IGhhbmRsZVBhc3RlKGUsIGNtKSkgeyByZXR1cm4gfVxuICAgICAgLy8gSUUgZG9lc24ndCBmaXJlIGlucHV0IGV2ZW50cywgc28gd2Ugc2NoZWR1bGUgYSByZWFkIGZvciB0aGUgcGFzdGVkIGNvbnRlbnQgaW4gdGhpcyB3YXlcbiAgICAgIGlmIChpZV92ZXJzaW9uIDw9IDExKSB7IHNldFRpbWVvdXQob3BlcmF0aW9uKGNtLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzJDEudXBkYXRlRnJvbURPTSgpOyB9KSwgMjApOyB9XG4gICAgfSk7XG5cbiAgICBvbihkaXYsIFwiY29tcG9zaXRpb25zdGFydFwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgdGhpcyQxLmNvbXBvc2luZyA9IHtkYXRhOiBlLmRhdGEsIGRvbmU6IGZhbHNlfTtcbiAgICB9KTtcbiAgICBvbihkaXYsIFwiY29tcG9zaXRpb251cGRhdGVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghdGhpcyQxLmNvbXBvc2luZykgeyB0aGlzJDEuY29tcG9zaW5nID0ge2RhdGE6IGUuZGF0YSwgZG9uZTogZmFsc2V9OyB9XG4gICAgfSk7XG4gICAgb24oZGl2LCBcImNvbXBvc2l0aW9uZW5kXCIsIGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAodGhpcyQxLmNvbXBvc2luZykge1xuICAgICAgICBpZiAoZS5kYXRhICE9IHRoaXMkMS5jb21wb3NpbmcuZGF0YSkgeyB0aGlzJDEucmVhZEZyb21ET01Tb29uKCk7IH1cbiAgICAgICAgdGhpcyQxLmNvbXBvc2luZy5kb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIG9uKGRpdiwgXCJ0b3VjaHN0YXJ0XCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlucHV0LmZvcmNlQ29tcG9zaXRpb25FbmQoKTsgfSk7XG5cbiAgICBvbihkaXYsIFwiaW5wdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCF0aGlzJDEuY29tcG9zaW5nKSB7IHRoaXMkMS5yZWFkRnJvbURPTVNvb24oKTsgfVxuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gb25Db3B5Q3V0KGUpIHtcbiAgICAgIGlmICghYmVsb25nc1RvSW5wdXQoZSkgfHwgc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XG4gICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xuICAgICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogZmFsc2UsIHRleHQ6IGNtLmdldFNlbGVjdGlvbnMoKX0pO1xuICAgICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIHsgY20ucmVwbGFjZVNlbGVjdGlvbihcIlwiLCBudWxsLCBcImN1dFwiKTsgfVxuICAgICAgfSBlbHNlIGlmICghY20ub3B0aW9ucy5saW5lV2lzZUNvcHlDdXQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmFuZ2VzID0gY29weWFibGVSYW5nZXMoY20pO1xuICAgICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogdHJ1ZSwgdGV4dDogcmFuZ2VzLnRleHR9KTtcbiAgICAgICAgaWYgKGUudHlwZSA9PSBcImN1dFwiKSB7XG4gICAgICAgICAgY20ub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNtLnNldFNlbGVjdGlvbnMocmFuZ2VzLnJhbmdlcywgMCwgc2VsX2RvbnRTY3JvbGwpO1xuICAgICAgICAgICAgY20ucmVwbGFjZVNlbGVjdGlvbihcIlwiLCBudWxsLCBcImN1dFwiKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGUuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICBlLmNsaXBib2FyZERhdGEuY2xlYXJEYXRhKCk7XG4gICAgICAgIHZhciBjb250ZW50ID0gbGFzdENvcGllZC50ZXh0LmpvaW4oXCJcXG5cIik7XG4gICAgICAgIC8vIGlPUyBleHBvc2VzIHRoZSBjbGlwYm9hcmQgQVBJLCBidXQgc2VlbXMgdG8gZGlzY2FyZCBjb250ZW50IGluc2VydGVkIGludG8gaXRcbiAgICAgICAgZS5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJUZXh0XCIsIGNvbnRlbnQpO1xuICAgICAgICBpZiAoZS5jbGlwYm9hcmREYXRhLmdldERhdGEoXCJUZXh0XCIpID09IGNvbnRlbnQpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE9sZC1mYXNoaW9uZWQgYnJpZWZseS1mb2N1cy1hLXRleHRhcmVhIGhhY2tcbiAgICAgIHZhciBrbHVkZ2UgPSBoaWRkZW5UZXh0YXJlYSgpLCB0ZSA9IGtsdWRnZS5maXJzdENoaWxkO1xuICAgICAgY20uZGlzcGxheS5saW5lU3BhY2UuaW5zZXJ0QmVmb3JlKGtsdWRnZSwgY20uZGlzcGxheS5saW5lU3BhY2UuZmlyc3RDaGlsZCk7XG4gICAgICB0ZS52YWx1ZSA9IGxhc3RDb3BpZWQudGV4dC5qb2luKFwiXFxuXCIpO1xuICAgICAgdmFyIGhhZEZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIHNlbGVjdElucHV0KHRlKTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBjbS5kaXNwbGF5LmxpbmVTcGFjZS5yZW1vdmVDaGlsZChrbHVkZ2UpO1xuICAgICAgICBoYWRGb2N1cy5mb2N1cygpO1xuICAgICAgICBpZiAoaGFkRm9jdXMgPT0gZGl2KSB7IGlucHV0LnNob3dQcmltYXJ5U2VsZWN0aW9uKCk7IH1cbiAgICAgIH0sIDUwKTtcbiAgICB9XG4gICAgb24oZGl2LCBcImNvcHlcIiwgb25Db3B5Q3V0KTtcbiAgICBvbihkaXYsIFwiY3V0XCIsIG9uQ29weUN1dCk7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNjcmVlblJlYWRlckxhYmVsQ2hhbmdlZCA9IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgIC8vIExhYmVsIGZvciBzY3JlZW5yZWFkZXJzLCBhY2Nlc3NpYmlsaXR5XG4gICAgaWYobGFiZWwpIHtcbiAgICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kaXYucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG4gICAgfVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5wcmVwYXJlU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBwcmVwYXJlU2VsZWN0aW9uKHRoaXMuY20sIGZhbHNlKTtcbiAgICByZXN1bHQuZm9jdXMgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IHRoaXMuZGl2O1xuICAgIHJldHVybiByZXN1bHRcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2hvd1NlbGVjdGlvbiA9IGZ1bmN0aW9uIChpbmZvLCB0YWtlRm9jdXMpIHtcbiAgICBpZiAoIWluZm8gfHwgIXRoaXMuY20uZGlzcGxheS52aWV3Lmxlbmd0aCkgeyByZXR1cm4gfVxuICAgIGlmIChpbmZvLmZvY3VzIHx8IHRha2VGb2N1cykgeyB0aGlzLnNob3dQcmltYXJ5U2VsZWN0aW9uKCk7IH1cbiAgICB0aGlzLnNob3dNdWx0aXBsZVNlbGVjdGlvbnMoaW5mbyk7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmdldFNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbS5kaXNwbGF5LndyYXBwZXIub3duZXJEb2N1bWVudC5nZXRTZWxlY3Rpb24oKVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zaG93UHJpbWFyeVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKSwgY20gPSB0aGlzLmNtLCBwcmltID0gY20uZG9jLnNlbC5wcmltYXJ5KCk7XG4gICAgdmFyIGZyb20gPSBwcmltLmZyb20oKSwgdG8gPSBwcmltLnRvKCk7XG5cbiAgICBpZiAoY20uZGlzcGxheS52aWV3VG8gPT0gY20uZGlzcGxheS52aWV3RnJvbSB8fCBmcm9tLmxpbmUgPj0gY20uZGlzcGxheS52aWV3VG8gfHwgdG8ubGluZSA8IGNtLmRpc3BsYXkudmlld0Zyb20pIHtcbiAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBjdXJBbmNob3IgPSBkb21Ub1BvcyhjbSwgc2VsLmFuY2hvck5vZGUsIHNlbC5hbmNob3JPZmZzZXQpO1xuICAgIHZhciBjdXJGb2N1cyA9IGRvbVRvUG9zKGNtLCBzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIGlmIChjdXJBbmNob3IgJiYgIWN1ckFuY2hvci5iYWQgJiYgY3VyRm9jdXMgJiYgIWN1ckZvY3VzLmJhZCAmJlxuICAgICAgICBjbXAobWluUG9zKGN1ckFuY2hvciwgY3VyRm9jdXMpLCBmcm9tKSA9PSAwICYmXG4gICAgICAgIGNtcChtYXhQb3MoY3VyQW5jaG9yLCBjdXJGb2N1cyksIHRvKSA9PSAwKVxuICAgICAgeyByZXR1cm4gfVxuXG4gICAgdmFyIHZpZXcgPSBjbS5kaXNwbGF5LnZpZXc7XG4gICAgdmFyIHN0YXJ0ID0gKGZyb20ubGluZSA+PSBjbS5kaXNwbGF5LnZpZXdGcm9tICYmIHBvc1RvRE9NKGNtLCBmcm9tKSkgfHxcbiAgICAgICAge25vZGU6IHZpZXdbMF0ubWVhc3VyZS5tYXBbMl0sIG9mZnNldDogMH07XG4gICAgdmFyIGVuZCA9IHRvLmxpbmUgPCBjbS5kaXNwbGF5LnZpZXdUbyAmJiBwb3NUb0RPTShjbSwgdG8pO1xuICAgIGlmICghZW5kKSB7XG4gICAgICB2YXIgbWVhc3VyZSA9IHZpZXdbdmlldy5sZW5ndGggLSAxXS5tZWFzdXJlO1xuICAgICAgdmFyIG1hcCA9IG1lYXN1cmUubWFwcyA/IG1lYXN1cmUubWFwc1ttZWFzdXJlLm1hcHMubGVuZ3RoIC0gMV0gOiBtZWFzdXJlLm1hcDtcbiAgICAgIGVuZCA9IHtub2RlOiBtYXBbbWFwLmxlbmd0aCAtIDFdLCBvZmZzZXQ6IG1hcFttYXAubGVuZ3RoIC0gMl0gLSBtYXBbbWFwLmxlbmd0aCAtIDNdfTtcbiAgICB9XG5cbiAgICBpZiAoIXN0YXJ0IHx8ICFlbmQpIHtcbiAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHZhciBvbGQgPSBzZWwucmFuZ2VDb3VudCAmJiBzZWwuZ2V0UmFuZ2VBdCgwKSwgcm5nO1xuICAgIHRyeSB7IHJuZyA9IHJhbmdlKHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCwgZW5kLm9mZnNldCwgZW5kLm5vZGUpOyB9XG4gICAgY2F0Y2goZSkge30gLy8gT3VyIG1vZGVsIG9mIHRoZSBET00gbWlnaHQgYmUgb3V0ZGF0ZWQsIGluIHdoaWNoIGNhc2UgdGhlIHJhbmdlIHdlIHRyeSB0byBzZXQgY2FuIGJlIGltcG9zc2libGVcbiAgICBpZiAocm5nKSB7XG4gICAgICBpZiAoIWdlY2tvICYmIGNtLnN0YXRlLmZvY3VzZWQpIHtcbiAgICAgICAgc2VsLmNvbGxhcHNlKHN0YXJ0Lm5vZGUsIHN0YXJ0Lm9mZnNldCk7XG4gICAgICAgIGlmICghcm5nLmNvbGxhcHNlZCkge1xuICAgICAgICAgIHNlbC5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICBzZWwuYWRkUmFuZ2Uocm5nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWwuYWRkUmFuZ2Uocm5nKTtcbiAgICAgIH1cbiAgICAgIGlmIChvbGQgJiYgc2VsLmFuY2hvck5vZGUgPT0gbnVsbCkgeyBzZWwuYWRkUmFuZ2Uob2xkKTsgfVxuICAgICAgZWxzZSBpZiAoZ2Vja28pIHsgdGhpcy5zdGFydEdyYWNlUGVyaW9kKCk7IH1cbiAgICB9XG4gICAgdGhpcy5yZW1lbWJlclNlbGVjdGlvbigpO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zdGFydEdyYWNlUGVyaW9kID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBjbGVhclRpbWVvdXQodGhpcy5ncmFjZVBlcmlvZCk7XG4gICAgdGhpcy5ncmFjZVBlcmlvZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLmdyYWNlUGVyaW9kID0gZmFsc2U7XG4gICAgICBpZiAodGhpcyQxLnNlbGVjdGlvbkNoYW5nZWQoKSlcbiAgICAgICAgeyB0aGlzJDEuY20ub3BlcmF0aW9uKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMkMS5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTsgfSk7IH1cbiAgICB9LCAyMCk7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNob3dNdWx0aXBsZVNlbGVjdGlvbnMgPSBmdW5jdGlvbiAoaW5mbykge1xuICAgIHJlbW92ZUNoaWxkcmVuQW5kQWRkKHRoaXMuY20uZGlzcGxheS5jdXJzb3JEaXYsIGluZm8uY3Vyc29ycyk7XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQodGhpcy5jbS5kaXNwbGF5LnNlbGVjdGlvbkRpdiwgaW5mby5zZWxlY3Rpb24pO1xuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5yZW1lbWJlclNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICB0aGlzLmxhc3RBbmNob3JOb2RlID0gc2VsLmFuY2hvck5vZGU7IHRoaXMubGFzdEFuY2hvck9mZnNldCA9IHNlbC5hbmNob3JPZmZzZXQ7XG4gICAgdGhpcy5sYXN0Rm9jdXNOb2RlID0gc2VsLmZvY3VzTm9kZTsgdGhpcy5sYXN0Rm9jdXNPZmZzZXQgPSBzZWwuZm9jdXNPZmZzZXQ7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnNlbGVjdGlvbkluRWRpdG9yID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsLnJhbmdlQ291bnQpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgbm9kZSA9IHNlbC5nZXRSYW5nZUF0KDApLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIHJldHVybiBjb250YWlucyh0aGlzLmRpdiwgbm9kZSlcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuY20ub3B0aW9ucy5yZWFkT25seSAhPSBcIm5vY3Vyc29yXCIpIHtcbiAgICAgIGlmICghdGhpcy5zZWxlY3Rpb25JbkVkaXRvcigpIHx8IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT0gdGhpcy5kaXYpXG4gICAgICAgIHsgdGhpcy5zaG93U2VsZWN0aW9uKHRoaXMucHJlcGFyZVNlbGVjdGlvbigpLCB0cnVlKTsgfVxuICAgICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgICB9XG4gIH07XG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gKCkgeyB0aGlzLmRpdi5ibHVyKCk7IH07XG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5nZXRGaWVsZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuZGl2IH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnN1cHBvcnRzVG91Y2ggPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0cnVlIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlY2VpdmVkRm9jdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGlucHV0ID0gdGhpcztcbiAgICBpZiAodGhpcy5zZWxlY3Rpb25JbkVkaXRvcigpKVxuICAgICAgeyB0aGlzLnBvbGxTZWxlY3Rpb24oKTsgfVxuICAgIGVsc2VcbiAgICAgIHsgcnVuSW5PcCh0aGlzLmNtLCBmdW5jdGlvbiAoKSB7IHJldHVybiBpbnB1dC5jbS5jdXJPcC5zZWxlY3Rpb25DaGFuZ2VkID0gdHJ1ZTsgfSk7IH1cblxuICAgIGZ1bmN0aW9uIHBvbGwoKSB7XG4gICAgICBpZiAoaW5wdXQuY20uc3RhdGUuZm9jdXNlZCkge1xuICAgICAgICBpbnB1dC5wb2xsU2VsZWN0aW9uKCk7XG4gICAgICAgIGlucHV0LnBvbGxpbmcuc2V0KGlucHV0LmNtLm9wdGlvbnMucG9sbEludGVydmFsLCBwb2xsKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5wb2xsaW5nLnNldCh0aGlzLmNtLm9wdGlvbnMucG9sbEludGVydmFsLCBwb2xsKTtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuc2VsZWN0aW9uQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsID0gdGhpcy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4gc2VsLmFuY2hvck5vZGUgIT0gdGhpcy5sYXN0QW5jaG9yTm9kZSB8fCBzZWwuYW5jaG9yT2Zmc2V0ICE9IHRoaXMubGFzdEFuY2hvck9mZnNldCB8fFxuICAgICAgc2VsLmZvY3VzTm9kZSAhPSB0aGlzLmxhc3RGb2N1c05vZGUgfHwgc2VsLmZvY3VzT2Zmc2V0ICE9IHRoaXMubGFzdEZvY3VzT2Zmc2V0XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnBvbGxTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucmVhZERPTVRpbWVvdXQgIT0gbnVsbCB8fCB0aGlzLmdyYWNlUGVyaW9kIHx8ICF0aGlzLnNlbGVjdGlvbkNoYW5nZWQoKSkgeyByZXR1cm4gfVxuICAgIHZhciBzZWwgPSB0aGlzLmdldFNlbGVjdGlvbigpLCBjbSA9IHRoaXMuY207XG4gICAgLy8gT24gQW5kcm9pZCBDaHJvbWUgKHZlcnNpb24gNTYsIGF0IGxlYXN0KSwgYmFja3NwYWNpbmcgaW50byBhblxuICAgIC8vIHVuZWRpdGFibGUgYmxvY2sgZWxlbWVudCB3aWxsIHB1dCB0aGUgY3Vyc29yIGluIHRoYXQgZWxlbWVudCxcbiAgICAvLyBhbmQgdGhlbiwgYmVjYXVzZSBpdCdzIG5vdCBlZGl0YWJsZSwgaGlkZSB0aGUgdmlydHVhbCBrZXlib2FyZC5cbiAgICAvLyBCZWNhdXNlIEFuZHJvaWQgZG9lc24ndCBhbGxvdyB1cyB0byBhY3R1YWxseSBkZXRlY3QgYmFja3NwYWNlXG4gICAgLy8gcHJlc3NlcyBpbiBhIHNhbmUgd2F5LCB0aGlzIGNvZGUgY2hlY2tzIGZvciB3aGVuIHRoYXQgaGFwcGVuc1xuICAgIC8vIGFuZCBzaW11bGF0ZXMgYSBiYWNrc3BhY2UgcHJlc3MgaW4gdGhpcyBjYXNlLlxuICAgIGlmIChhbmRyb2lkICYmIGNocm9tZSAmJiB0aGlzLmNtLmRpc3BsYXkuZ3V0dGVyU3BlY3MubGVuZ3RoICYmIGlzSW5HdXR0ZXIoc2VsLmFuY2hvck5vZGUpKSB7XG4gICAgICB0aGlzLmNtLnRyaWdnZXJPbktleURvd24oe3R5cGU6IFwia2V5ZG93blwiLCBrZXlDb2RlOiA4LCBwcmV2ZW50RGVmYXVsdDogTWF0aC5hYnN9KTtcbiAgICAgIHRoaXMuYmx1cigpO1xuICAgICAgdGhpcy5mb2N1cygpO1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmICh0aGlzLmNvbXBvc2luZykgeyByZXR1cm4gfVxuICAgIHRoaXMucmVtZW1iZXJTZWxlY3Rpb24oKTtcbiAgICB2YXIgYW5jaG9yID0gZG9tVG9Qb3MoY20sIHNlbC5hbmNob3JOb2RlLCBzZWwuYW5jaG9yT2Zmc2V0KTtcbiAgICB2YXIgaGVhZCA9IGRvbVRvUG9zKGNtLCBzZWwuZm9jdXNOb2RlLCBzZWwuZm9jdXNPZmZzZXQpO1xuICAgIGlmIChhbmNob3IgJiYgaGVhZCkgeyBydW5Jbk9wKGNtLCBmdW5jdGlvbiAoKSB7XG4gICAgICBzZXRTZWxlY3Rpb24oY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24oYW5jaG9yLCBoZWFkKSwgc2VsX2RvbnRTY3JvbGwpO1xuICAgICAgaWYgKGFuY2hvci5iYWQgfHwgaGVhZC5iYWQpIHsgY20uY3VyT3Auc2VsZWN0aW9uQ2hhbmdlZCA9IHRydWU7IH1cbiAgICB9KTsgfVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5wb2xsQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5yZWFkRE9NVGltZW91dCAhPSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWFkRE9NVGltZW91dCk7XG4gICAgICB0aGlzLnJlYWRET01UaW1lb3V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgc2VsID0gY20uZG9jLnNlbC5wcmltYXJ5KCk7XG4gICAgdmFyIGZyb20gPSBzZWwuZnJvbSgpLCB0byA9IHNlbC50bygpO1xuICAgIGlmIChmcm9tLmNoID09IDAgJiYgZnJvbS5saW5lID4gY20uZmlyc3RMaW5lKCkpXG4gICAgICB7IGZyb20gPSBQb3MoZnJvbS5saW5lIC0gMSwgZ2V0TGluZShjbS5kb2MsIGZyb20ubGluZSAtIDEpLmxlbmd0aCk7IH1cbiAgICBpZiAodG8uY2ggPT0gZ2V0TGluZShjbS5kb2MsIHRvLmxpbmUpLnRleHQubGVuZ3RoICYmIHRvLmxpbmUgPCBjbS5sYXN0TGluZSgpKVxuICAgICAgeyB0byA9IFBvcyh0by5saW5lICsgMSwgMCk7IH1cbiAgICBpZiAoZnJvbS5saW5lIDwgZGlzcGxheS52aWV3RnJvbSB8fCB0by5saW5lID4gZGlzcGxheS52aWV3VG8gLSAxKSB7IHJldHVybiBmYWxzZSB9XG5cbiAgICB2YXIgZnJvbUluZGV4LCBmcm9tTGluZSwgZnJvbU5vZGU7XG4gICAgaWYgKGZyb20ubGluZSA9PSBkaXNwbGF5LnZpZXdGcm9tIHx8IChmcm9tSW5kZXggPSBmaW5kVmlld0luZGV4KGNtLCBmcm9tLmxpbmUpKSA9PSAwKSB7XG4gICAgICBmcm9tTGluZSA9IGxpbmVObyhkaXNwbGF5LnZpZXdbMF0ubGluZSk7XG4gICAgICBmcm9tTm9kZSA9IGRpc3BsYXkudmlld1swXS5ub2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmcm9tTGluZSA9IGxpbmVObyhkaXNwbGF5LnZpZXdbZnJvbUluZGV4XS5saW5lKTtcbiAgICAgIGZyb21Ob2RlID0gZGlzcGxheS52aWV3W2Zyb21JbmRleCAtIDFdLm5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIHZhciB0b0luZGV4ID0gZmluZFZpZXdJbmRleChjbSwgdG8ubGluZSk7XG4gICAgdmFyIHRvTGluZSwgdG9Ob2RlO1xuICAgIGlmICh0b0luZGV4ID09IGRpc3BsYXkudmlldy5sZW5ndGggLSAxKSB7XG4gICAgICB0b0xpbmUgPSBkaXNwbGF5LnZpZXdUbyAtIDE7XG4gICAgICB0b05vZGUgPSBkaXNwbGF5LmxpbmVEaXYubGFzdENoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICB0b0xpbmUgPSBsaW5lTm8oZGlzcGxheS52aWV3W3RvSW5kZXggKyAxXS5saW5lKSAtIDE7XG4gICAgICB0b05vZGUgPSBkaXNwbGF5LnZpZXdbdG9JbmRleCArIDFdLm5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgIH1cblxuICAgIGlmICghZnJvbU5vZGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICB2YXIgbmV3VGV4dCA9IGNtLmRvYy5zcGxpdExpbmVzKGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tTm9kZSwgdG9Ob2RlLCBmcm9tTGluZSwgdG9MaW5lKSk7XG4gICAgdmFyIG9sZFRleHQgPSBnZXRCZXR3ZWVuKGNtLmRvYywgUG9zKGZyb21MaW5lLCAwKSwgUG9zKHRvTGluZSwgZ2V0TGluZShjbS5kb2MsIHRvTGluZSkudGV4dC5sZW5ndGgpKTtcbiAgICB3aGlsZSAobmV3VGV4dC5sZW5ndGggPiAxICYmIG9sZFRleHQubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKGxzdChuZXdUZXh0KSA9PSBsc3Qob2xkVGV4dCkpIHsgbmV3VGV4dC5wb3AoKTsgb2xkVGV4dC5wb3AoKTsgdG9MaW5lLS07IH1cbiAgICAgIGVsc2UgaWYgKG5ld1RleHRbMF0gPT0gb2xkVGV4dFswXSkgeyBuZXdUZXh0LnNoaWZ0KCk7IG9sZFRleHQuc2hpZnQoKTsgZnJvbUxpbmUrKzsgfVxuICAgICAgZWxzZSB7IGJyZWFrIH1cbiAgICB9XG5cbiAgICB2YXIgY3V0RnJvbnQgPSAwLCBjdXRFbmQgPSAwO1xuICAgIHZhciBuZXdUb3AgPSBuZXdUZXh0WzBdLCBvbGRUb3AgPSBvbGRUZXh0WzBdLCBtYXhDdXRGcm9udCA9IE1hdGgubWluKG5ld1RvcC5sZW5ndGgsIG9sZFRvcC5sZW5ndGgpO1xuICAgIHdoaWxlIChjdXRGcm9udCA8IG1heEN1dEZyb250ICYmIG5ld1RvcC5jaGFyQ29kZUF0KGN1dEZyb250KSA9PSBvbGRUb3AuY2hhckNvZGVBdChjdXRGcm9udCkpXG4gICAgICB7ICsrY3V0RnJvbnQ7IH1cbiAgICB2YXIgbmV3Qm90ID0gbHN0KG5ld1RleHQpLCBvbGRCb3QgPSBsc3Qob2xkVGV4dCk7XG4gICAgdmFyIG1heEN1dEVuZCA9IE1hdGgubWluKG5ld0JvdC5sZW5ndGggLSAobmV3VGV4dC5sZW5ndGggPT0gMSA/IGN1dEZyb250IDogMCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZEJvdC5sZW5ndGggLSAob2xkVGV4dC5sZW5ndGggPT0gMSA/IGN1dEZyb250IDogMCkpO1xuICAgIHdoaWxlIChjdXRFbmQgPCBtYXhDdXRFbmQgJiZcbiAgICAgICAgICAgbmV3Qm90LmNoYXJDb2RlQXQobmV3Qm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpID09IG9sZEJvdC5jaGFyQ29kZUF0KG9sZEJvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSlcbiAgICAgIHsgKytjdXRFbmQ7IH1cbiAgICAvLyBUcnkgdG8gbW92ZSBzdGFydCBvZiBjaGFuZ2UgdG8gc3RhcnQgb2Ygc2VsZWN0aW9uIGlmIGFtYmlndW91c1xuICAgIGlmIChuZXdUZXh0Lmxlbmd0aCA9PSAxICYmIG9sZFRleHQubGVuZ3RoID09IDEgJiYgZnJvbUxpbmUgPT0gZnJvbS5saW5lKSB7XG4gICAgICB3aGlsZSAoY3V0RnJvbnQgJiYgY3V0RnJvbnQgPiBmcm9tLmNoICYmXG4gICAgICAgICAgICAgbmV3Qm90LmNoYXJDb2RlQXQobmV3Qm90Lmxlbmd0aCAtIGN1dEVuZCAtIDEpID09IG9sZEJvdC5jaGFyQ29kZUF0KG9sZEJvdC5sZW5ndGggLSBjdXRFbmQgLSAxKSkge1xuICAgICAgICBjdXRGcm9udC0tO1xuICAgICAgICBjdXRFbmQrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuZXdUZXh0W25ld1RleHQubGVuZ3RoIC0gMV0gPSBuZXdCb3Quc2xpY2UoMCwgbmV3Qm90Lmxlbmd0aCAtIGN1dEVuZCkucmVwbGFjZSgvXlxcdTIwMGIrLywgXCJcIik7XG4gICAgbmV3VGV4dFswXSA9IG5ld1RleHRbMF0uc2xpY2UoY3V0RnJvbnQpLnJlcGxhY2UoL1xcdTIwMGIrJC8sIFwiXCIpO1xuXG4gICAgdmFyIGNoRnJvbSA9IFBvcyhmcm9tTGluZSwgY3V0RnJvbnQpO1xuICAgIHZhciBjaFRvID0gUG9zKHRvTGluZSwgb2xkVGV4dC5sZW5ndGggPyBsc3Qob2xkVGV4dCkubGVuZ3RoIC0gY3V0RW5kIDogMCk7XG4gICAgaWYgKG5ld1RleHQubGVuZ3RoID4gMSB8fCBuZXdUZXh0WzBdIHx8IGNtcChjaEZyb20sIGNoVG8pKSB7XG4gICAgICByZXBsYWNlUmFuZ2UoY20uZG9jLCBuZXdUZXh0LCBjaEZyb20sIGNoVG8sIFwiK2lucHV0XCIpO1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLmVuc3VyZVBvbGxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZvcmNlQ29tcG9zaXRpb25FbmQoKTtcbiAgfTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZm9yY2VDb21wb3NpdGlvbkVuZCgpO1xuICB9O1xuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUuZm9yY2VDb21wb3NpdGlvbkVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMuY29tcG9zaW5nKSB7IHJldHVybiB9XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhZERPTVRpbWVvdXQpO1xuICAgIHRoaXMuY29tcG9zaW5nID0gbnVsbDtcbiAgICB0aGlzLnVwZGF0ZUZyb21ET00oKTtcbiAgICB0aGlzLmRpdi5ibHVyKCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoKTtcbiAgfTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlYWRGcm9tRE9NU29vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgaWYgKHRoaXMucmVhZERPTVRpbWVvdXQgIT0gbnVsbCkgeyByZXR1cm4gfVxuICAgIHRoaXMucmVhZERPTVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRoaXMkMS5yZWFkRE9NVGltZW91dCA9IG51bGw7XG4gICAgICBpZiAodGhpcyQxLmNvbXBvc2luZykge1xuICAgICAgICBpZiAodGhpcyQxLmNvbXBvc2luZy5kb25lKSB7IHRoaXMkMS5jb21wb3NpbmcgPSBudWxsOyB9XG4gICAgICAgIGVsc2UgeyByZXR1cm4gfVxuICAgICAgfVxuICAgICAgdGhpcyQxLnVwZGF0ZUZyb21ET00oKTtcbiAgICB9LCA4MCk7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnVwZGF0ZUZyb21ET00gPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICAgIGlmICh0aGlzLmNtLmlzUmVhZE9ubHkoKSB8fCAhdGhpcy5wb2xsQ29udGVudCgpKVxuICAgICAgeyBydW5Jbk9wKHRoaXMuY20sIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlZ0NoYW5nZSh0aGlzJDEuY20pOyB9KTsgfVxuICB9O1xuXG4gIENvbnRlbnRFZGl0YWJsZUlucHV0LnByb3RvdHlwZS5zZXRVbmVkaXRhYmxlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICBub2RlLmNvbnRlbnRFZGl0YWJsZSA9IFwiZmFsc2VcIjtcbiAgfTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUub25LZXlQcmVzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUuY2hhckNvZGUgPT0gMCB8fCB0aGlzLmNvbXBvc2luZykgeyByZXR1cm4gfVxuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoIXRoaXMuY20uaXNSZWFkT25seSgpKVxuICAgICAgeyBvcGVyYXRpb24odGhpcy5jbSwgYXBwbHlUZXh0SW5wdXQpKHRoaXMuY20sIFN0cmluZy5mcm9tQ2hhckNvZGUoZS5jaGFyQ29kZSA9PSBudWxsID8gZS5rZXlDb2RlIDogZS5jaGFyQ29kZSksIDApOyB9XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlYWRPbmx5Q2hhbmdlZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICB0aGlzLmRpdi5jb250ZW50RWRpdGFibGUgPSBTdHJpbmcodmFsICE9IFwibm9jdXJzb3JcIik7XG4gIH07XG5cbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLm9uQ29udGV4dE1lbnUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgQ29udGVudEVkaXRhYmxlSW5wdXQucHJvdG90eXBlLnJlc2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7fTtcblxuICBDb250ZW50RWRpdGFibGVJbnB1dC5wcm90b3R5cGUubmVlZHNDb250ZW50QXR0cmlidXRlID0gdHJ1ZTtcblxuICBmdW5jdGlvbiBwb3NUb0RPTShjbSwgcG9zKSB7XG4gICAgdmFyIHZpZXcgPSBmaW5kVmlld0ZvckxpbmUoY20sIHBvcy5saW5lKTtcbiAgICBpZiAoIXZpZXcgfHwgdmlldy5oaWRkZW4pIHsgcmV0dXJuIG51bGwgfVxuICAgIHZhciBsaW5lID0gZ2V0TGluZShjbS5kb2MsIHBvcy5saW5lKTtcbiAgICB2YXIgaW5mbyA9IG1hcEZyb21MaW5lVmlldyh2aWV3LCBsaW5lLCBwb3MubGluZSk7XG5cbiAgICB2YXIgb3JkZXIgPSBnZXRPcmRlcihsaW5lLCBjbS5kb2MuZGlyZWN0aW9uKSwgc2lkZSA9IFwibGVmdFwiO1xuICAgIGlmIChvcmRlcikge1xuICAgICAgdmFyIHBhcnRQb3MgPSBnZXRCaWRpUGFydEF0KG9yZGVyLCBwb3MuY2gpO1xuICAgICAgc2lkZSA9IHBhcnRQb3MgJSAyID8gXCJyaWdodFwiIDogXCJsZWZ0XCI7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBub2RlQW5kT2Zmc2V0SW5MaW5lTWFwKGluZm8ubWFwLCBwb3MuY2gsIHNpZGUpO1xuICAgIHJlc3VsdC5vZmZzZXQgPSByZXN1bHQuY29sbGFwc2UgPT0gXCJyaWdodFwiID8gcmVzdWx0LmVuZCA6IHJlc3VsdC5zdGFydDtcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICBmdW5jdGlvbiBpc0luR3V0dGVyKG5vZGUpIHtcbiAgICBmb3IgKHZhciBzY2FuID0gbm9kZTsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50Tm9kZSlcbiAgICAgIHsgaWYgKC9Db2RlTWlycm9yLWd1dHRlci13cmFwcGVyLy50ZXN0KHNjYW4uY2xhc3NOYW1lKSkgeyByZXR1cm4gdHJ1ZSB9IH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhZFBvcyhwb3MsIGJhZCkgeyBpZiAoYmFkKSB7IHBvcy5iYWQgPSB0cnVlOyB9IHJldHVybiBwb3MgfVxuXG4gIGZ1bmN0aW9uIGRvbVRleHRCZXR3ZWVuKGNtLCBmcm9tLCB0bywgZnJvbUxpbmUsIHRvTGluZSkge1xuICAgIHZhciB0ZXh0ID0gXCJcIiwgY2xvc2luZyA9IGZhbHNlLCBsaW5lU2VwID0gY20uZG9jLmxpbmVTZXBhcmF0b3IoKSwgZXh0cmFMaW5lYnJlYWsgPSBmYWxzZTtcbiAgICBmdW5jdGlvbiByZWNvZ25pemVNYXJrZXIoaWQpIHsgcmV0dXJuIGZ1bmN0aW9uIChtYXJrZXIpIHsgcmV0dXJuIG1hcmtlci5pZCA9PSBpZDsgfSB9XG4gICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoY2xvc2luZykge1xuICAgICAgICB0ZXh0ICs9IGxpbmVTZXA7XG4gICAgICAgIGlmIChleHRyYUxpbmVicmVhaykgeyB0ZXh0ICs9IGxpbmVTZXA7IH1cbiAgICAgICAgY2xvc2luZyA9IGV4dHJhTGluZWJyZWFrID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZFRleHQoc3RyKSB7XG4gICAgICBpZiAoc3RyKSB7XG4gICAgICAgIGNsb3NlKCk7XG4gICAgICAgIHRleHQgKz0gc3RyO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB3YWxrKG5vZGUpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09IDEpIHtcbiAgICAgICAgdmFyIGNtVGV4dCA9IG5vZGUuZ2V0QXR0cmlidXRlKFwiY20tdGV4dFwiKTtcbiAgICAgICAgaWYgKGNtVGV4dCkge1xuICAgICAgICAgIGFkZFRleHQoY21UZXh0KTtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya2VySUQgPSBub2RlLmdldEF0dHJpYnV0ZShcImNtLW1hcmtlclwiKSwgcmFuZ2U7XG4gICAgICAgIGlmIChtYXJrZXJJRCkge1xuICAgICAgICAgIHZhciBmb3VuZCA9IGNtLmZpbmRNYXJrcyhQb3MoZnJvbUxpbmUsIDApLCBQb3ModG9MaW5lICsgMSwgMCksIHJlY29nbml6ZU1hcmtlcigrbWFya2VySUQpKTtcbiAgICAgICAgICBpZiAoZm91bmQubGVuZ3RoICYmIChyYW5nZSA9IGZvdW5kWzBdLmZpbmQoMCkpKVxuICAgICAgICAgICAgeyBhZGRUZXh0KGdldEJldHdlZW4oY20uZG9jLCByYW5nZS5mcm9tLCByYW5nZS50bykuam9pbihsaW5lU2VwKSk7IH1cbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoXCJjb250ZW50ZWRpdGFibGVcIikgPT0gXCJmYWxzZVwiKSB7IHJldHVybiB9XG4gICAgICAgIHZhciBpc0Jsb2NrID0gL14ocHJlfGRpdnxwfGxpfHRhYmxlfGJyKSQvaS50ZXN0KG5vZGUubm9kZU5hbWUpO1xuICAgICAgICBpZiAoIS9eYnIkL2kudGVzdChub2RlLm5vZGVOYW1lKSAmJiBub2RlLnRleHRDb250ZW50Lmxlbmd0aCA9PSAwKSB7IHJldHVybiB9XG5cbiAgICAgICAgaWYgKGlzQmxvY2spIHsgY2xvc2UoKTsgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICB7IHdhbGsobm9kZS5jaGlsZE5vZGVzW2ldKTsgfVxuXG4gICAgICAgIGlmICgvXihwcmV8cCkkL2kudGVzdChub2RlLm5vZGVOYW1lKSkgeyBleHRyYUxpbmVicmVhayA9IHRydWU7IH1cbiAgICAgICAgaWYgKGlzQmxvY2spIHsgY2xvc2luZyA9IHRydWU7IH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PSAzKSB7XG4gICAgICAgIGFkZFRleHQobm9kZS5ub2RlVmFsdWUucmVwbGFjZSgvXFx1MjAwYi9nLCBcIlwiKS5yZXBsYWNlKC9cXHUwMGEwL2csIFwiIFwiKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgIHdhbGsoZnJvbSk7XG4gICAgICBpZiAoZnJvbSA9PSB0bykgeyBicmVhayB9XG4gICAgICBmcm9tID0gZnJvbS5uZXh0U2libGluZztcbiAgICAgIGV4dHJhTGluZWJyZWFrID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0XG4gIH1cblxuICBmdW5jdGlvbiBkb21Ub1BvcyhjbSwgbm9kZSwgb2Zmc2V0KSB7XG4gICAgdmFyIGxpbmVOb2RlO1xuICAgIGlmIChub2RlID09IGNtLmRpc3BsYXkubGluZURpdikge1xuICAgICAgbGluZU5vZGUgPSBjbS5kaXNwbGF5LmxpbmVEaXYuY2hpbGROb2Rlc1tvZmZzZXRdO1xuICAgICAgaWYgKCFsaW5lTm9kZSkgeyByZXR1cm4gYmFkUG9zKGNtLmNsaXBQb3MoUG9zKGNtLmRpc3BsYXkudmlld1RvIC0gMSkpLCB0cnVlKSB9XG4gICAgICBub2RlID0gbnVsbDsgb2Zmc2V0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsaW5lTm9kZSA9IG5vZGU7OyBsaW5lTm9kZSA9IGxpbmVOb2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgaWYgKCFsaW5lTm9kZSB8fCBsaW5lTm9kZSA9PSBjbS5kaXNwbGF5LmxpbmVEaXYpIHsgcmV0dXJuIG51bGwgfVxuICAgICAgICBpZiAobGluZU5vZGUucGFyZW50Tm9kZSAmJiBsaW5lTm9kZS5wYXJlbnROb2RlID09IGNtLmRpc3BsYXkubGluZURpdikgeyBicmVhayB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY20uZGlzcGxheS52aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGluZVZpZXcgPSBjbS5kaXNwbGF5LnZpZXdbaV07XG4gICAgICBpZiAobGluZVZpZXcubm9kZSA9PSBsaW5lTm9kZSlcbiAgICAgICAgeyByZXR1cm4gbG9jYXRlTm9kZUluTGluZVZpZXcobGluZVZpZXcsIG5vZGUsIG9mZnNldCkgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGxvY2F0ZU5vZGVJbkxpbmVWaWV3KGxpbmVWaWV3LCBub2RlLCBvZmZzZXQpIHtcbiAgICB2YXIgd3JhcHBlciA9IGxpbmVWaWV3LnRleHQuZmlyc3RDaGlsZCwgYmFkID0gZmFsc2U7XG4gICAgaWYgKCFub2RlIHx8ICFjb250YWlucyh3cmFwcGVyLCBub2RlKSkgeyByZXR1cm4gYmFkUG9zKFBvcyhsaW5lTm8obGluZVZpZXcubGluZSksIDApLCB0cnVlKSB9XG4gICAgaWYgKG5vZGUgPT0gd3JhcHBlcikge1xuICAgICAgYmFkID0gdHJ1ZTtcbiAgICAgIG5vZGUgPSB3cmFwcGVyLmNoaWxkTm9kZXNbb2Zmc2V0XTtcbiAgICAgIG9mZnNldCA9IDA7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBsaW5lVmlldy5yZXN0ID8gbHN0KGxpbmVWaWV3LnJlc3QpIDogbGluZVZpZXcubGluZTtcbiAgICAgICAgcmV0dXJuIGJhZFBvcyhQb3MobGluZU5vKGxpbmUpLCBsaW5lLnRleHQubGVuZ3RoKSwgYmFkKVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUubm9kZVR5cGUgPT0gMyA/IG5vZGUgOiBudWxsLCB0b3BOb2RlID0gbm9kZTtcbiAgICBpZiAoIXRleHROb2RlICYmIG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT0gMSAmJiBub2RlLmZpcnN0Q2hpbGQubm9kZVR5cGUgPT0gMykge1xuICAgICAgdGV4dE5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gICAgICBpZiAob2Zmc2V0KSB7IG9mZnNldCA9IHRleHROb2RlLm5vZGVWYWx1ZS5sZW5ndGg7IH1cbiAgICB9XG4gICAgd2hpbGUgKHRvcE5vZGUucGFyZW50Tm9kZSAhPSB3cmFwcGVyKSB7IHRvcE5vZGUgPSB0b3BOb2RlLnBhcmVudE5vZGU7IH1cbiAgICB2YXIgbWVhc3VyZSA9IGxpbmVWaWV3Lm1lYXN1cmUsIG1hcHMgPSBtZWFzdXJlLm1hcHM7XG5cbiAgICBmdW5jdGlvbiBmaW5kKHRleHROb2RlLCB0b3BOb2RlLCBvZmZzZXQpIHtcbiAgICAgIGZvciAodmFyIGkgPSAtMTsgaSA8IChtYXBzID8gbWFwcy5sZW5ndGggOiAwKTsgaSsrKSB7XG4gICAgICAgIHZhciBtYXAgPSBpIDwgMCA/IG1lYXN1cmUubWFwIDogbWFwc1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXAubGVuZ3RoOyBqICs9IDMpIHtcbiAgICAgICAgICB2YXIgY3VyTm9kZSA9IG1hcFtqICsgMl07XG4gICAgICAgICAgaWYgKGN1ck5vZGUgPT0gdGV4dE5vZGUgfHwgY3VyTm9kZSA9PSB0b3BOb2RlKSB7XG4gICAgICAgICAgICB2YXIgbGluZSA9IGxpbmVObyhpIDwgMCA/IGxpbmVWaWV3LmxpbmUgOiBsaW5lVmlldy5yZXN0W2ldKTtcbiAgICAgICAgICAgIHZhciBjaCA9IG1hcFtqXSArIG9mZnNldDtcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwIHx8IGN1ck5vZGUgIT0gdGV4dE5vZGUpIHsgY2ggPSBtYXBbaiArIChvZmZzZXQgPyAxIDogMCldOyB9XG4gICAgICAgICAgICByZXR1cm4gUG9zKGxpbmUsIGNoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgZm91bmQgPSBmaW5kKHRleHROb2RlLCB0b3BOb2RlLCBvZmZzZXQpO1xuICAgIGlmIChmb3VuZCkgeyByZXR1cm4gYmFkUG9zKGZvdW5kLCBiYWQpIH1cblxuICAgIC8vIEZJWE1FIHRoaXMgaXMgYWxsIHJlYWxseSBzaGFreS4gbWlnaHQgaGFuZGxlIHRoZSBmZXcgY2FzZXMgaXQgbmVlZHMgdG8gaGFuZGxlLCBidXQgbGlrZWx5IHRvIGNhdXNlIHByb2JsZW1zXG4gICAgZm9yICh2YXIgYWZ0ZXIgPSB0b3BOb2RlLm5leHRTaWJsaW5nLCBkaXN0ID0gdGV4dE5vZGUgPyB0ZXh0Tm9kZS5ub2RlVmFsdWUubGVuZ3RoIC0gb2Zmc2V0IDogMDsgYWZ0ZXI7IGFmdGVyID0gYWZ0ZXIubmV4dFNpYmxpbmcpIHtcbiAgICAgIGZvdW5kID0gZmluZChhZnRlciwgYWZ0ZXIuZmlyc3RDaGlsZCwgMCk7XG4gICAgICBpZiAoZm91bmQpXG4gICAgICAgIHsgcmV0dXJuIGJhZFBvcyhQb3MoZm91bmQubGluZSwgZm91bmQuY2ggLSBkaXN0KSwgYmFkKSB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgZGlzdCArPSBhZnRlci50ZXh0Q29udGVudC5sZW5ndGg7IH1cbiAgICB9XG4gICAgZm9yICh2YXIgYmVmb3JlID0gdG9wTm9kZS5wcmV2aW91c1NpYmxpbmcsIGRpc3QkMSA9IG9mZnNldDsgYmVmb3JlOyBiZWZvcmUgPSBiZWZvcmUucHJldmlvdXNTaWJsaW5nKSB7XG4gICAgICBmb3VuZCA9IGZpbmQoYmVmb3JlLCBiZWZvcmUuZmlyc3RDaGlsZCwgLTEpO1xuICAgICAgaWYgKGZvdW5kKVxuICAgICAgICB7IHJldHVybiBiYWRQb3MoUG9zKGZvdW5kLmxpbmUsIGZvdW5kLmNoICsgZGlzdCQxKSwgYmFkKSB9XG4gICAgICBlbHNlXG4gICAgICAgIHsgZGlzdCQxICs9IGJlZm9yZS50ZXh0Q29udGVudC5sZW5ndGg7IH1cbiAgICB9XG4gIH1cblxuICAvLyBURVhUQVJFQSBJTlBVVCBTVFlMRVxuXG4gIHZhciBUZXh0YXJlYUlucHV0ID0gZnVuY3Rpb24oY20pIHtcbiAgICB0aGlzLmNtID0gY207XG4gICAgLy8gU2VlIGlucHV0LnBvbGwgYW5kIGlucHV0LnJlc2V0XG4gICAgdGhpcy5wcmV2SW5wdXQgPSBcIlwiO1xuXG4gICAgLy8gRmxhZyB0aGF0IGluZGljYXRlcyB3aGV0aGVyIHdlIGV4cGVjdCBpbnB1dCB0byBhcHBlYXIgcmVhbCBzb29uXG4gICAgLy8gbm93IChhZnRlciBzb21lIGV2ZW50IGxpa2UgJ2tleXByZXNzJyBvciAnaW5wdXQnKSBhbmQgYXJlXG4gICAgLy8gcG9sbGluZyBpbnRlbnNpdmVseS5cbiAgICB0aGlzLnBvbGxpbmdGYXN0ID0gZmFsc2U7XG4gICAgLy8gU2VsZi1yZXNldHRpbmcgdGltZW91dCBmb3IgdGhlIHBvbGxlclxuICAgIHRoaXMucG9sbGluZyA9IG5ldyBEZWxheWVkKCk7XG4gICAgLy8gVXNlZCB0byB3b3JrIGFyb3VuZCBJRSBpc3N1ZSB3aXRoIHNlbGVjdGlvbiBiZWluZyBmb3Jnb3R0ZW4gd2hlbiBmb2N1cyBtb3ZlcyBhd2F5IGZyb20gdGV4dGFyZWFcbiAgICB0aGlzLmhhc1NlbGVjdGlvbiA9IGZhbHNlO1xuICAgIHRoaXMuY29tcG9zaW5nID0gbnVsbDtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGRpc3BsYXkpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGlucHV0ID0gdGhpcywgY20gPSB0aGlzLmNtO1xuICAgIHRoaXMuY3JlYXRlRmllbGQoZGlzcGxheSk7XG4gICAgdmFyIHRlID0gdGhpcy50ZXh0YXJlYTtcblxuICAgIGRpc3BsYXkud3JhcHBlci5pbnNlcnRCZWZvcmUodGhpcy53cmFwcGVyLCBkaXNwbGF5LndyYXBwZXIuZmlyc3RDaGlsZCk7XG5cbiAgICAvLyBOZWVkZWQgdG8gaGlkZSBiaWcgYmx1ZSBibGlua2luZyBjdXJzb3Igb24gTW9iaWxlIFNhZmFyaSAoZG9lc24ndCBzZWVtIHRvIHdvcmsgaW4gaU9TIDggYW55bW9yZSlcbiAgICBpZiAoaW9zKSB7IHRlLnN0eWxlLndpZHRoID0gXCIwcHhcIjsgfVxuXG4gICAgb24odGUsIFwiaW5wdXRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSAmJiB0aGlzJDEuaGFzU2VsZWN0aW9uKSB7IHRoaXMkMS5oYXNTZWxlY3Rpb24gPSBudWxsOyB9XG4gICAgICBpbnB1dC5wb2xsKCk7XG4gICAgfSk7XG5cbiAgICBvbih0ZSwgXCJwYXN0ZVwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHNpZ25hbERPTUV2ZW50KGNtLCBlKSB8fCBoYW5kbGVQYXN0ZShlLCBjbSkpIHsgcmV0dXJuIH1cblxuICAgICAgY20uc3RhdGUucGFzdGVJbmNvbWluZyA9ICtuZXcgRGF0ZTtcbiAgICAgIGlucHV0LmZhc3RQb2xsKCk7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBwcmVwYXJlQ29weUN1dChlKSB7XG4gICAgICBpZiAoc2lnbmFsRE9NRXZlbnQoY20sIGUpKSB7IHJldHVybiB9XG4gICAgICBpZiAoY20uc29tZXRoaW5nU2VsZWN0ZWQoKSkge1xuICAgICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogZmFsc2UsIHRleHQ6IGNtLmdldFNlbGVjdGlvbnMoKX0pO1xuICAgICAgfSBlbHNlIGlmICghY20ub3B0aW9ucy5saW5lV2lzZUNvcHlDdXQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmFuZ2VzID0gY29weWFibGVSYW5nZXMoY20pO1xuICAgICAgICBzZXRMYXN0Q29waWVkKHtsaW5lV2lzZTogdHJ1ZSwgdGV4dDogcmFuZ2VzLnRleHR9KTtcbiAgICAgICAgaWYgKGUudHlwZSA9PSBcImN1dFwiKSB7XG4gICAgICAgICAgY20uc2V0U2VsZWN0aW9ucyhyYW5nZXMucmFuZ2VzLCBudWxsLCBzZWxfZG9udFNjcm9sbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXQucHJldklucHV0ID0gXCJcIjtcbiAgICAgICAgICB0ZS52YWx1ZSA9IHJhbmdlcy50ZXh0LmpvaW4oXCJcXG5cIik7XG4gICAgICAgICAgc2VsZWN0SW5wdXQodGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZS50eXBlID09IFwiY3V0XCIpIHsgY20uc3RhdGUuY3V0SW5jb21pbmcgPSArbmV3IERhdGU7IH1cbiAgICB9XG4gICAgb24odGUsIFwiY3V0XCIsIHByZXBhcmVDb3B5Q3V0KTtcbiAgICBvbih0ZSwgXCJjb3B5XCIsIHByZXBhcmVDb3B5Q3V0KTtcblxuICAgIG9uKGRpc3BsYXkuc2Nyb2xsZXIsIFwicGFzdGVcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChldmVudEluV2lkZ2V0KGRpc3BsYXksIGUpIHx8IHNpZ25hbERPTUV2ZW50KGNtLCBlKSkgeyByZXR1cm4gfVxuICAgICAgaWYgKCF0ZS5kaXNwYXRjaEV2ZW50KSB7XG4gICAgICAgIGNtLnN0YXRlLnBhc3RlSW5jb21pbmcgPSArbmV3IERhdGU7XG4gICAgICAgIGlucHV0LmZvY3VzKCk7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBQYXNzIHRoZSBgcGFzdGVgIGV2ZW50IHRvIHRoZSB0ZXh0YXJlYSBzbyBpdCdzIGhhbmRsZWQgYnkgaXRzIGV2ZW50IGxpc3RlbmVyLlxuICAgICAgdmFyIGV2ZW50ID0gbmV3IEV2ZW50KFwicGFzdGVcIik7XG4gICAgICBldmVudC5jbGlwYm9hcmREYXRhID0gZS5jbGlwYm9hcmREYXRhO1xuICAgICAgdGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfSk7XG5cbiAgICAvLyBQcmV2ZW50IG5vcm1hbCBzZWxlY3Rpb24gaW4gdGhlIGVkaXRvciAod2UgaGFuZGxlIG91ciBvd24pXG4gICAgb24oZGlzcGxheS5saW5lU3BhY2UsIFwic2VsZWN0c3RhcnRcIiwgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmICghZXZlbnRJbldpZGdldChkaXNwbGF5LCBlKSkgeyBlX3ByZXZlbnREZWZhdWx0KGUpOyB9XG4gICAgfSk7XG5cbiAgICBvbih0ZSwgXCJjb21wb3NpdGlvbnN0YXJ0XCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBzdGFydCA9IGNtLmdldEN1cnNvcihcImZyb21cIik7XG4gICAgICBpZiAoaW5wdXQuY29tcG9zaW5nKSB7IGlucHV0LmNvbXBvc2luZy5yYW5nZS5jbGVhcigpOyB9XG4gICAgICBpbnB1dC5jb21wb3NpbmcgPSB7XG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgcmFuZ2U6IGNtLm1hcmtUZXh0KHN0YXJ0LCBjbS5nZXRDdXJzb3IoXCJ0b1wiKSwge2NsYXNzTmFtZTogXCJDb2RlTWlycm9yLWNvbXBvc2luZ1wifSlcbiAgICAgIH07XG4gICAgfSk7XG4gICAgb24odGUsIFwiY29tcG9zaXRpb25lbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGlucHV0LmNvbXBvc2luZykge1xuICAgICAgICBpbnB1dC5wb2xsKCk7XG4gICAgICAgIGlucHV0LmNvbXBvc2luZy5yYW5nZS5jbGVhcigpO1xuICAgICAgICBpbnB1dC5jb21wb3NpbmcgPSBudWxsO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLmNyZWF0ZUZpZWxkID0gZnVuY3Rpb24gKF9kaXNwbGF5KSB7XG4gICAgLy8gV3JhcHMgYW5kIGhpZGVzIGlucHV0IHRleHRhcmVhXG4gICAgdGhpcy53cmFwcGVyID0gaGlkZGVuVGV4dGFyZWEoKTtcbiAgICAvLyBUaGUgc2VtaWhpZGRlbiB0ZXh0YXJlYSB0aGF0IGlzIGZvY3VzZWQgd2hlbiB0aGUgZWRpdG9yIGlzXG4gICAgLy8gZm9jdXNlZCwgYW5kIHJlY2VpdmVzIGlucHV0LlxuICAgIHRoaXMudGV4dGFyZWEgPSB0aGlzLndyYXBwZXIuZmlyc3RDaGlsZDtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zY3JlZW5SZWFkZXJMYWJlbENoYW5nZWQgPSBmdW5jdGlvbiAobGFiZWwpIHtcbiAgICAvLyBMYWJlbCBmb3Igc2NyZWVucmVhZGVycywgYWNjZXNzaWJpbGl0eVxuICAgIGlmKGxhYmVsKSB7XG4gICAgICB0aGlzLnRleHRhcmVhLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGxhYmVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50ZXh0YXJlYS5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKTtcbiAgICB9XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucHJlcGFyZVNlbGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBSZWRyYXcgdGhlIHNlbGVjdGlvbiBhbmQvb3IgY3Vyc29yXG4gICAgdmFyIGNtID0gdGhpcy5jbSwgZGlzcGxheSA9IGNtLmRpc3BsYXksIGRvYyA9IGNtLmRvYztcbiAgICB2YXIgcmVzdWx0ID0gcHJlcGFyZVNlbGVjdGlvbihjbSk7XG5cbiAgICAvLyBNb3ZlIHRoZSBoaWRkZW4gdGV4dGFyZWEgbmVhciB0aGUgY3Vyc29yIHRvIHByZXZlbnQgc2Nyb2xsaW5nIGFydGlmYWN0c1xuICAgIGlmIChjbS5vcHRpb25zLm1vdmVJbnB1dFdpdGhDdXJzb3IpIHtcbiAgICAgIHZhciBoZWFkUG9zID0gY3Vyc29yQ29vcmRzKGNtLCBkb2Muc2VsLnByaW1hcnkoKS5oZWFkLCBcImRpdlwiKTtcbiAgICAgIHZhciB3cmFwT2ZmID0gZGlzcGxheS53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCBsaW5lT2ZmID0gZGlzcGxheS5saW5lRGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgcmVzdWx0LnRlVG9wID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS53cmFwcGVyLmNsaWVudEhlaWdodCAtIDEwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZFBvcy50b3AgKyBsaW5lT2ZmLnRvcCAtIHdyYXBPZmYudG9wKSk7XG4gICAgICByZXN1bHQudGVMZWZ0ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oZGlzcGxheS53cmFwcGVyLmNsaWVudFdpZHRoIC0gMTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZFBvcy5sZWZ0ICsgbGluZU9mZi5sZWZ0IC0gd3JhcE9mZi5sZWZ0KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnNob3dTZWxlY3Rpb24gPSBmdW5jdGlvbiAoZHJhd24pIHtcbiAgICB2YXIgY20gPSB0aGlzLmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheTtcbiAgICByZW1vdmVDaGlsZHJlbkFuZEFkZChkaXNwbGF5LmN1cnNvckRpdiwgZHJhd24uY3Vyc29ycyk7XG4gICAgcmVtb3ZlQ2hpbGRyZW5BbmRBZGQoZGlzcGxheS5zZWxlY3Rpb25EaXYsIGRyYXduLnNlbGVjdGlvbik7XG4gICAgaWYgKGRyYXduLnRlVG9wICE9IG51bGwpIHtcbiAgICAgIHRoaXMud3JhcHBlci5zdHlsZS50b3AgPSBkcmF3bi50ZVRvcCArIFwicHhcIjtcbiAgICAgIHRoaXMud3JhcHBlci5zdHlsZS5sZWZ0ID0gZHJhd24udGVMZWZ0ICsgXCJweFwiO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXNldCB0aGUgaW5wdXQgdG8gY29ycmVzcG9uZCB0byB0aGUgc2VsZWN0aW9uIChvciB0byBiZSBlbXB0eSxcbiAgLy8gd2hlbiBub3QgdHlwaW5nIGFuZCBub3RoaW5nIGlzIHNlbGVjdGVkKVxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICh0eXBpbmcpIHtcbiAgICBpZiAodGhpcy5jb250ZXh0TWVudVBlbmRpbmcgfHwgdGhpcy5jb21wb3NpbmcpIHsgcmV0dXJuIH1cbiAgICB2YXIgY20gPSB0aGlzLmNtO1xuICAgIGlmIChjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7XG4gICAgICB0aGlzLnByZXZJbnB1dCA9IFwiXCI7XG4gICAgICB2YXIgY29udGVudCA9IGNtLmdldFNlbGVjdGlvbigpO1xuICAgICAgdGhpcy50ZXh0YXJlYS52YWx1ZSA9IGNvbnRlbnQ7XG4gICAgICBpZiAoY20uc3RhdGUuZm9jdXNlZCkgeyBzZWxlY3RJbnB1dCh0aGlzLnRleHRhcmVhKTsgfVxuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSkgeyB0aGlzLmhhc1NlbGVjdGlvbiA9IGNvbnRlbnQ7IH1cbiAgICB9IGVsc2UgaWYgKCF0eXBpbmcpIHtcbiAgICAgIHRoaXMucHJldklucHV0ID0gdGhpcy50ZXh0YXJlYS52YWx1ZSA9IFwiXCI7XG4gICAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7IHRoaXMuaGFzU2VsZWN0aW9uID0gbnVsbDsgfVxuICAgIH1cbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5nZXRGaWVsZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMudGV4dGFyZWEgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5zdXBwb3J0c1RvdWNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZmFsc2UgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5mb2N1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5jbS5vcHRpb25zLnJlYWRPbmx5ICE9IFwibm9jdXJzb3JcIiAmJiAoIW1vYmlsZSB8fCBhY3RpdmVFbHQoKSAhPSB0aGlzLnRleHRhcmVhKSkge1xuICAgICAgdHJ5IHsgdGhpcy50ZXh0YXJlYS5mb2N1cygpOyB9XG4gICAgICBjYXRjaCAoZSkge30gLy8gSUU4IHdpbGwgdGhyb3cgaWYgdGhlIHRleHRhcmVhIGlzIGRpc3BsYXk6IG5vbmUgb3Igbm90IGluIERPTVxuICAgIH1cbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5ibHVyID0gZnVuY3Rpb24gKCkgeyB0aGlzLnRleHRhcmVhLmJsdXIoKTsgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5yZXNldFBvc2l0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMud3JhcHBlci5zdHlsZS50b3AgPSB0aGlzLndyYXBwZXIuc3R5bGUubGVmdCA9IDA7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucmVjZWl2ZWRGb2N1cyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5zbG93UG9sbCgpOyB9O1xuXG4gIC8vIFBvbGwgZm9yIGlucHV0IGNoYW5nZXMsIHVzaW5nIHRoZSBub3JtYWwgcmF0ZSBvZiBwb2xsaW5nLiBUaGlzXG4gIC8vIHJ1bnMgYXMgbG9uZyBhcyB0aGUgZWRpdG9yIGlzIGZvY3VzZWQuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnNsb3dQb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nRmFzdCkgeyByZXR1cm4gfVxuICAgIHRoaXMucG9sbGluZy5zZXQodGhpcy5jbS5vcHRpb25zLnBvbGxJbnRlcnZhbCwgZnVuY3Rpb24gKCkge1xuICAgICAgdGhpcyQxLnBvbGwoKTtcbiAgICAgIGlmICh0aGlzJDEuY20uc3RhdGUuZm9jdXNlZCkgeyB0aGlzJDEuc2xvd1BvbGwoKTsgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIFdoZW4gYW4gZXZlbnQgaGFzIGp1c3QgY29tZSBpbiB0aGF0IGlzIGxpa2VseSB0byBhZGQgb3IgY2hhbmdlXG4gIC8vIHNvbWV0aGluZyBpbiB0aGUgaW5wdXQgdGV4dGFyZWEsIHdlIHBvbGwgZmFzdGVyLCB0byBlbnN1cmUgdGhhdFxuICAvLyB0aGUgY2hhbmdlIGFwcGVhcnMgb24gdGhlIHNjcmVlbiBxdWlja2x5LlxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5mYXN0UG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWlzc2VkID0gZmFsc2UsIGlucHV0ID0gdGhpcztcbiAgICBpbnB1dC5wb2xsaW5nRmFzdCA9IHRydWU7XG4gICAgZnVuY3Rpb24gcCgpIHtcbiAgICAgIHZhciBjaGFuZ2VkID0gaW5wdXQucG9sbCgpO1xuICAgICAgaWYgKCFjaGFuZ2VkICYmICFtaXNzZWQpIHttaXNzZWQgPSB0cnVlOyBpbnB1dC5wb2xsaW5nLnNldCg2MCwgcCk7fVxuICAgICAgZWxzZSB7aW5wdXQucG9sbGluZ0Zhc3QgPSBmYWxzZTsgaW5wdXQuc2xvd1BvbGwoKTt9XG4gICAgfVxuICAgIGlucHV0LnBvbGxpbmcuc2V0KDIwLCBwKTtcbiAgfTtcblxuICAvLyBSZWFkIGlucHV0IGZyb20gdGhlIHRleHRhcmVhLCBhbmQgdXBkYXRlIHRoZSBkb2N1bWVudCB0byBtYXRjaC5cbiAgLy8gV2hlbiBzb21ldGhpbmcgaXMgc2VsZWN0ZWQsIGl0IGlzIHByZXNlbnQgaW4gdGhlIHRleHRhcmVhLCBhbmRcbiAgLy8gc2VsZWN0ZWQgKHVubGVzcyBpdCBpcyBodWdlLCBpbiB3aGljaCBjYXNlIGEgcGxhY2Vob2xkZXIgaXNcbiAgLy8gdXNlZCkuIFdoZW4gbm90aGluZyBpcyBzZWxlY3RlZCwgdGhlIGN1cnNvciBzaXRzIGFmdGVyIHByZXZpb3VzbHlcbiAgLy8gc2VlbiB0ZXh0IChjYW4gYmUgZW1wdHkpLCB3aGljaCBpcyBzdG9yZWQgaW4gcHJldklucHV0ICh3ZSBtdXN0XG4gIC8vIG5vdCByZXNldCB0aGUgdGV4dGFyZWEgd2hlbiB0eXBpbmcsIGJlY2F1c2UgdGhhdCBicmVha3MgSU1FKS5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIGNtID0gdGhpcy5jbSwgaW5wdXQgPSB0aGlzLnRleHRhcmVhLCBwcmV2SW5wdXQgPSB0aGlzLnByZXZJbnB1dDtcbiAgICAvLyBTaW5jZSB0aGlzIGlzIGNhbGxlZCBhICpsb3QqLCB0cnkgdG8gYmFpbCBvdXQgYXMgY2hlYXBseSBhc1xuICAgIC8vIHBvc3NpYmxlIHdoZW4gaXQgaXMgY2xlYXIgdGhhdCBub3RoaW5nIGhhcHBlbmVkLiBoYXNTZWxlY3Rpb25cbiAgICAvLyB3aWxsIGJlIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgYSBsb3Qgb2YgdGV4dCBpbiB0aGUgdGV4dGFyZWEsXG4gICAgLy8gaW4gd2hpY2ggY2FzZSByZWFkaW5nIGl0cyB2YWx1ZSB3b3VsZCBiZSBleHBlbnNpdmUuXG4gICAgaWYgKHRoaXMuY29udGV4dE1lbnVQZW5kaW5nIHx8ICFjbS5zdGF0ZS5mb2N1c2VkIHx8XG4gICAgICAgIChoYXNTZWxlY3Rpb24oaW5wdXQpICYmICFwcmV2SW5wdXQgJiYgIXRoaXMuY29tcG9zaW5nKSB8fFxuICAgICAgICBjbS5pc1JlYWRPbmx5KCkgfHwgY20ub3B0aW9ucy5kaXNhYmxlSW5wdXQgfHwgY20uc3RhdGUua2V5U2VxKVxuICAgICAgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgdmFyIHRleHQgPSBpbnB1dC52YWx1ZTtcbiAgICAvLyBJZiBub3RoaW5nIGNoYW5nZWQsIGJhaWwuXG4gICAgaWYgKHRleHQgPT0gcHJldklucHV0ICYmICFjbS5zb21ldGhpbmdTZWxlY3RlZCgpKSB7IHJldHVybiBmYWxzZSB9XG4gICAgLy8gV29yayBhcm91bmQgbm9uc2Vuc2ljYWwgc2VsZWN0aW9uIHJlc2V0dGluZyBpbiBJRTkvMTAsIGFuZFxuICAgIC8vIGluZXhwbGljYWJsZSBhcHBlYXJhbmNlIG9mIHByaXZhdGUgYXJlYSB1bmljb2RlIGNoYXJhY3RlcnMgb25cbiAgICAvLyBzb21lIGtleSBjb21ib3MgaW4gTWFjICgjMjY4OSkuXG4gICAgaWYgKGllICYmIGllX3ZlcnNpb24gPj0gOSAmJiB0aGlzLmhhc1NlbGVjdGlvbiA9PT0gdGV4dCB8fFxuICAgICAgICBtYWMgJiYgL1tcXHVmNzAwLVxcdWY3ZmZdLy50ZXN0KHRleHQpKSB7XG4gICAgICBjbS5kaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoY20uZG9jLnNlbCA9PSBjbS5kaXNwbGF5LnNlbEZvckNvbnRleHRNZW51KSB7XG4gICAgICB2YXIgZmlyc3QgPSB0ZXh0LmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoZmlyc3QgPT0gMHgyMDBiICYmICFwcmV2SW5wdXQpIHsgcHJldklucHV0ID0gXCJcXHUyMDBiXCI7IH1cbiAgICAgIGlmIChmaXJzdCA9PSAweDIxZGEpIHsgdGhpcy5yZXNldCgpOyByZXR1cm4gdGhpcy5jbS5leGVjQ29tbWFuZChcInVuZG9cIikgfVxuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBwYXJ0IG9mIHRoZSBpbnB1dCB0aGF0IGlzIGFjdHVhbGx5IG5ld1xuICAgIHZhciBzYW1lID0gMCwgbCA9IE1hdGgubWluKHByZXZJbnB1dC5sZW5ndGgsIHRleHQubGVuZ3RoKTtcbiAgICB3aGlsZSAoc2FtZSA8IGwgJiYgcHJldklucHV0LmNoYXJDb2RlQXQoc2FtZSkgPT0gdGV4dC5jaGFyQ29kZUF0KHNhbWUpKSB7ICsrc2FtZTsgfVxuXG4gICAgcnVuSW5PcChjbSwgZnVuY3Rpb24gKCkge1xuICAgICAgYXBwbHlUZXh0SW5wdXQoY20sIHRleHQuc2xpY2Uoc2FtZSksIHByZXZJbnB1dC5sZW5ndGggLSBzYW1lLFxuICAgICAgICAgICAgICAgICAgICAgbnVsbCwgdGhpcyQxLmNvbXBvc2luZyA/IFwiKmNvbXBvc2VcIiA6IG51bGwpO1xuXG4gICAgICAvLyBEb24ndCBsZWF2ZSBsb25nIHRleHQgaW4gdGhlIHRleHRhcmVhLCBzaW5jZSBpdCBtYWtlcyBmdXJ0aGVyIHBvbGxpbmcgc2xvd1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMTAwMCB8fCB0ZXh0LmluZGV4T2YoXCJcXG5cIikgPiAtMSkgeyBpbnB1dC52YWx1ZSA9IHRoaXMkMS5wcmV2SW5wdXQgPSBcIlwiOyB9XG4gICAgICBlbHNlIHsgdGhpcyQxLnByZXZJbnB1dCA9IHRleHQ7IH1cblxuICAgICAgaWYgKHRoaXMkMS5jb21wb3NpbmcpIHtcbiAgICAgICAgdGhpcyQxLmNvbXBvc2luZy5yYW5nZS5jbGVhcigpO1xuICAgICAgICB0aGlzJDEuY29tcG9zaW5nLnJhbmdlID0gY20ubWFya1RleHQodGhpcyQxLmNvbXBvc2luZy5zdGFydCwgY20uZ2V0Q3Vyc29yKFwidG9cIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge2NsYXNzTmFtZTogXCJDb2RlTWlycm9yLWNvbXBvc2luZ1wifSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWVcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5lbnN1cmVQb2xsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucG9sbGluZ0Zhc3QgJiYgdGhpcy5wb2xsKCkpIHsgdGhpcy5wb2xsaW5nRmFzdCA9IGZhbHNlOyB9XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUub25LZXlQcmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7IHRoaXMuaGFzU2VsZWN0aW9uID0gbnVsbDsgfVxuICAgIHRoaXMuZmFzdFBvbGwoKTtcbiAgfTtcblxuICBUZXh0YXJlYUlucHV0LnByb3RvdHlwZS5vbkNvbnRleHRNZW51ID0gZnVuY3Rpb24gKGUpIHtcbiAgICB2YXIgaW5wdXQgPSB0aGlzLCBjbSA9IGlucHV0LmNtLCBkaXNwbGF5ID0gY20uZGlzcGxheSwgdGUgPSBpbnB1dC50ZXh0YXJlYTtcbiAgICBpZiAoaW5wdXQuY29udGV4dE1lbnVQZW5kaW5nKSB7IGlucHV0LmNvbnRleHRNZW51UGVuZGluZygpOyB9XG4gICAgdmFyIHBvcyA9IHBvc0Zyb21Nb3VzZShjbSwgZSksIHNjcm9sbFBvcyA9IGRpc3BsYXkuc2Nyb2xsZXIuc2Nyb2xsVG9wO1xuICAgIGlmICghcG9zIHx8IHByZXN0bykgeyByZXR1cm4gfSAvLyBPcGVyYSBpcyBkaWZmaWN1bHQuXG5cbiAgICAvLyBSZXNldCB0aGUgY3VycmVudCB0ZXh0IHNlbGVjdGlvbiBvbmx5IGlmIHRoZSBjbGljayBpcyBkb25lIG91dHNpZGUgb2YgdGhlIHNlbGVjdGlvblxuICAgIC8vIGFuZCAncmVzZXRTZWxlY3Rpb25PbkNvbnRleHRNZW51JyBvcHRpb24gaXMgdHJ1ZS5cbiAgICB2YXIgcmVzZXQgPSBjbS5vcHRpb25zLnJlc2V0U2VsZWN0aW9uT25Db250ZXh0TWVudTtcbiAgICBpZiAocmVzZXQgJiYgY20uZG9jLnNlbC5jb250YWlucyhwb3MpID09IC0xKVxuICAgICAgeyBvcGVyYXRpb24oY20sIHNldFNlbGVjdGlvbikoY20uZG9jLCBzaW1wbGVTZWxlY3Rpb24ocG9zKSwgc2VsX2RvbnRTY3JvbGwpOyB9XG5cbiAgICB2YXIgb2xkQ1NTID0gdGUuc3R5bGUuY3NzVGV4dCwgb2xkV3JhcHBlckNTUyA9IGlucHV0LndyYXBwZXIuc3R5bGUuY3NzVGV4dDtcbiAgICB2YXIgd3JhcHBlckJveCA9IGlucHV0LndyYXBwZXIub2Zmc2V0UGFyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlucHV0LndyYXBwZXIuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246IHN0YXRpY1wiO1xuICAgIHRlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOiBhYnNvbHV0ZTsgd2lkdGg6IDMwcHg7IGhlaWdodDogMzBweDtcXG4gICAgICB0b3A6IFwiICsgKGUuY2xpZW50WSAtIHdyYXBwZXJCb3gudG9wIC0gNSkgKyBcInB4OyBsZWZ0OiBcIiArIChlLmNsaWVudFggLSB3cmFwcGVyQm94LmxlZnQgLSA1KSArIFwicHg7XFxuICAgICAgei1pbmRleDogMTAwMDsgYmFja2dyb3VuZDogXCIgKyAoaWUgPyBcInJnYmEoMjU1LCAyNTUsIDI1NSwgLjA1KVwiIDogXCJ0cmFuc3BhcmVudFwiKSArIFwiO1xcbiAgICAgIG91dGxpbmU6IG5vbmU7IGJvcmRlci13aWR0aDogMDsgb3V0bGluZTogbm9uZTsgb3ZlcmZsb3c6IGhpZGRlbjsgb3BhY2l0eTogLjA1OyBmaWx0ZXI6IGFscGhhKG9wYWNpdHk9NSk7XCI7XG4gICAgdmFyIG9sZFNjcm9sbFk7XG4gICAgaWYgKHdlYmtpdCkgeyBvbGRTY3JvbGxZID0gd2luZG93LnNjcm9sbFk7IH0gLy8gV29yayBhcm91bmQgQ2hyb21lIGlzc3VlICgjMjcxMilcbiAgICBkaXNwbGF5LmlucHV0LmZvY3VzKCk7XG4gICAgaWYgKHdlYmtpdCkgeyB3aW5kb3cuc2Nyb2xsVG8obnVsbCwgb2xkU2Nyb2xsWSk7IH1cbiAgICBkaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgLy8gQWRkcyBcIlNlbGVjdCBhbGxcIiB0byBjb250ZXh0IG1lbnUgaW4gRkZcbiAgICBpZiAoIWNtLnNvbWV0aGluZ1NlbGVjdGVkKCkpIHsgdGUudmFsdWUgPSBpbnB1dC5wcmV2SW5wdXQgPSBcIiBcIjsgfVxuICAgIGlucHV0LmNvbnRleHRNZW51UGVuZGluZyA9IHJlaGlkZTtcbiAgICBkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID0gY20uZG9jLnNlbDtcbiAgICBjbGVhclRpbWVvdXQoZGlzcGxheS5kZXRlY3RpbmdTZWxlY3RBbGwpO1xuXG4gICAgLy8gU2VsZWN0LWFsbCB3aWxsIGJlIGdyZXllZCBvdXQgaWYgdGhlcmUncyBub3RoaW5nIHRvIHNlbGVjdCwgc29cbiAgICAvLyB0aGlzIGFkZHMgYSB6ZXJvLXdpZHRoIHNwYWNlIHNvIHRoYXQgd2UgY2FuIGxhdGVyIGNoZWNrIHdoZXRoZXJcbiAgICAvLyBpdCBnb3Qgc2VsZWN0ZWQuXG4gICAgZnVuY3Rpb24gcHJlcGFyZVNlbGVjdEFsbEhhY2soKSB7XG4gICAgICBpZiAodGUuc2VsZWN0aW9uU3RhcnQgIT0gbnVsbCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBjbS5zb21ldGhpbmdTZWxlY3RlZCgpO1xuICAgICAgICB2YXIgZXh0dmFsID0gXCJcXHUyMDBiXCIgKyAoc2VsZWN0ZWQgPyB0ZS52YWx1ZSA6IFwiXCIpO1xuICAgICAgICB0ZS52YWx1ZSA9IFwiXFx1MjFkYVwiOyAvLyBVc2VkIHRvIGNhdGNoIGNvbnRleHQtbWVudSB1bmRvXG4gICAgICAgIHRlLnZhbHVlID0gZXh0dmFsO1xuICAgICAgICBpbnB1dC5wcmV2SW5wdXQgPSBzZWxlY3RlZCA/IFwiXCIgOiBcIlxcdTIwMGJcIjtcbiAgICAgICAgdGUuc2VsZWN0aW9uU3RhcnQgPSAxOyB0ZS5zZWxlY3Rpb25FbmQgPSBleHR2YWwubGVuZ3RoO1xuICAgICAgICAvLyBSZS1zZXQgdGhpcywgaW4gY2FzZSBzb21lIG90aGVyIGhhbmRsZXIgdG91Y2hlZCB0aGVcbiAgICAgICAgLy8gc2VsZWN0aW9uIGluIHRoZSBtZWFudGltZS5cbiAgICAgICAgZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IGNtLmRvYy5zZWw7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlaGlkZSgpIHtcbiAgICAgIGlmIChpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcgIT0gcmVoaWRlKSB7IHJldHVybiB9XG4gICAgICBpbnB1dC5jb250ZXh0TWVudVBlbmRpbmcgPSBmYWxzZTtcbiAgICAgIGlucHV0LndyYXBwZXIuc3R5bGUuY3NzVGV4dCA9IG9sZFdyYXBwZXJDU1M7XG4gICAgICB0ZS5zdHlsZS5jc3NUZXh0ID0gb2xkQ1NTO1xuICAgICAgaWYgKGllICYmIGllX3ZlcnNpb24gPCA5KSB7IGRpc3BsYXkuc2Nyb2xsYmFycy5zZXRTY3JvbGxUb3AoZGlzcGxheS5zY3JvbGxlci5zY3JvbGxUb3AgPSBzY3JvbGxQb3MpOyB9XG5cbiAgICAgIC8vIFRyeSB0byBkZXRlY3QgdGhlIHVzZXIgY2hvb3Npbmcgc2VsZWN0LWFsbFxuICAgICAgaWYgKHRlLnNlbGVjdGlvblN0YXJ0ICE9IG51bGwpIHtcbiAgICAgICAgaWYgKCFpZSB8fCAoaWUgJiYgaWVfdmVyc2lvbiA8IDkpKSB7IHByZXBhcmVTZWxlY3RBbGxIYWNrKCk7IH1cbiAgICAgICAgdmFyIGkgPSAwLCBwb2xsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChkaXNwbGF5LnNlbEZvckNvbnRleHRNZW51ID09IGNtLmRvYy5zZWwgJiYgdGUuc2VsZWN0aW9uU3RhcnQgPT0gMCAmJlxuICAgICAgICAgICAgICB0ZS5zZWxlY3Rpb25FbmQgPiAwICYmIGlucHV0LnByZXZJbnB1dCA9PSBcIlxcdTIwMGJcIikge1xuICAgICAgICAgICAgb3BlcmF0aW9uKGNtLCBzZWxlY3RBbGwpKGNtKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkrKyA8IDEwKSB7XG4gICAgICAgICAgICBkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbCA9IHNldFRpbWVvdXQocG9sbCwgNTAwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGlzcGxheS5zZWxGb3JDb250ZXh0TWVudSA9IG51bGw7XG4gICAgICAgICAgICBkaXNwbGF5LmlucHV0LnJlc2V0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBkaXNwbGF5LmRldGVjdGluZ1NlbGVjdEFsbCA9IHNldFRpbWVvdXQocG9sbCwgMjAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaWUgJiYgaWVfdmVyc2lvbiA+PSA5KSB7IHByZXBhcmVTZWxlY3RBbGxIYWNrKCk7IH1cbiAgICBpZiAoY2FwdHVyZVJpZ2h0Q2xpY2spIHtcbiAgICAgIGVfc3RvcChlKTtcbiAgICAgIHZhciBtb3VzZXVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBvZmYod2luZG93LCBcIm1vdXNldXBcIiwgbW91c2V1cCk7XG4gICAgICAgIHNldFRpbWVvdXQocmVoaWRlLCAyMCk7XG4gICAgICB9O1xuICAgICAgb24od2luZG93LCBcIm1vdXNldXBcIiwgbW91c2V1cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFRpbWVvdXQocmVoaWRlLCA1MCk7XG4gICAgfVxuICB9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLnJlYWRPbmx5Q2hhbmdlZCA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICBpZiAoIXZhbCkgeyB0aGlzLnJlc2V0KCk7IH1cbiAgICB0aGlzLnRleHRhcmVhLmRpc2FibGVkID0gdmFsID09IFwibm9jdXJzb3JcIjtcbiAgICB0aGlzLnRleHRhcmVhLnJlYWRPbmx5ID0gISF2YWw7XG4gIH07XG5cbiAgVGV4dGFyZWFJbnB1dC5wcm90b3R5cGUuc2V0VW5lZGl0YWJsZSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gIFRleHRhcmVhSW5wdXQucHJvdG90eXBlLm5lZWRzQ29udGVudEF0dHJpYnV0ZSA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGZyb21UZXh0QXJlYSh0ZXh0YXJlYSwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zID8gY29weU9iaihvcHRpb25zKSA6IHt9O1xuICAgIG9wdGlvbnMudmFsdWUgPSB0ZXh0YXJlYS52YWx1ZTtcbiAgICBpZiAoIW9wdGlvbnMudGFiaW5kZXggJiYgdGV4dGFyZWEudGFiSW5kZXgpXG4gICAgICB7IG9wdGlvbnMudGFiaW5kZXggPSB0ZXh0YXJlYS50YWJJbmRleDsgfVxuICAgIGlmICghb3B0aW9ucy5wbGFjZWhvbGRlciAmJiB0ZXh0YXJlYS5wbGFjZWhvbGRlcilcbiAgICAgIHsgb3B0aW9ucy5wbGFjZWhvbGRlciA9IHRleHRhcmVhLnBsYWNlaG9sZGVyOyB9XG4gICAgLy8gU2V0IGF1dG9mb2N1cyB0byB0cnVlIGlmIHRoaXMgdGV4dGFyZWEgaXMgZm9jdXNlZCwgb3IgaWYgaXQgaGFzXG4gICAgLy8gYXV0b2ZvY3VzIGFuZCBubyBvdGhlciBlbGVtZW50IGlzIGZvY3VzZWQuXG4gICAgaWYgKG9wdGlvbnMuYXV0b2ZvY3VzID09IG51bGwpIHtcbiAgICAgIHZhciBoYXNGb2N1cyA9IGFjdGl2ZUVsdCgpO1xuICAgICAgb3B0aW9ucy5hdXRvZm9jdXMgPSBoYXNGb2N1cyA9PSB0ZXh0YXJlYSB8fFxuICAgICAgICB0ZXh0YXJlYS5nZXRBdHRyaWJ1dGUoXCJhdXRvZm9jdXNcIikgIT0gbnVsbCAmJiBoYXNGb2N1cyA9PSBkb2N1bWVudC5ib2R5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhdmUoKSB7dGV4dGFyZWEudmFsdWUgPSBjbS5nZXRWYWx1ZSgpO31cblxuICAgIHZhciByZWFsU3VibWl0O1xuICAgIGlmICh0ZXh0YXJlYS5mb3JtKSB7XG4gICAgICBvbih0ZXh0YXJlYS5mb3JtLCBcInN1Ym1pdFwiLCBzYXZlKTtcbiAgICAgIC8vIERlcGxvcmFibGUgaGFjayB0byBtYWtlIHRoZSBzdWJtaXQgbWV0aG9kIGRvIHRoZSByaWdodCB0aGluZy5cbiAgICAgIGlmICghb3B0aW9ucy5sZWF2ZVN1Ym1pdE1ldGhvZEFsb25lKSB7XG4gICAgICAgIHZhciBmb3JtID0gdGV4dGFyZWEuZm9ybTtcbiAgICAgICAgcmVhbFN1Ym1pdCA9IGZvcm0uc3VibWl0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciB3cmFwcGVkU3VibWl0ID0gZm9ybS5zdWJtaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzYXZlKCk7XG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCA9IHJlYWxTdWJtaXQ7XG4gICAgICAgICAgICBmb3JtLnN1Ym1pdCgpO1xuICAgICAgICAgICAgZm9ybS5zdWJtaXQgPSB3cmFwcGVkU3VibWl0O1xuICAgICAgICAgIH07XG4gICAgICAgIH0gY2F0Y2goZSkge31cbiAgICAgIH1cbiAgICB9XG5cbiAgICBvcHRpb25zLmZpbmlzaEluaXQgPSBmdW5jdGlvbiAoY20pIHtcbiAgICAgIGNtLnNhdmUgPSBzYXZlO1xuICAgICAgY20uZ2V0VGV4dEFyZWEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0ZXh0YXJlYTsgfTtcbiAgICAgIGNtLnRvVGV4dEFyZWEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNtLnRvVGV4dEFyZWEgPSBpc05hTjsgLy8gUHJldmVudCB0aGlzIGZyb20gYmVpbmcgcmFuIHR3aWNlXG4gICAgICAgIHNhdmUoKTtcbiAgICAgICAgdGV4dGFyZWEucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbS5nZXRXcmFwcGVyRWxlbWVudCgpKTtcbiAgICAgICAgdGV4dGFyZWEuc3R5bGUuZGlzcGxheSA9IFwiXCI7XG4gICAgICAgIGlmICh0ZXh0YXJlYS5mb3JtKSB7XG4gICAgICAgICAgb2ZmKHRleHRhcmVhLmZvcm0sIFwic3VibWl0XCIsIHNhdmUpO1xuICAgICAgICAgIGlmICghb3B0aW9ucy5sZWF2ZVN1Ym1pdE1ldGhvZEFsb25lICYmIHR5cGVvZiB0ZXh0YXJlYS5mb3JtLnN1Ym1pdCA9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICB7IHRleHRhcmVhLmZvcm0uc3VibWl0ID0gcmVhbFN1Ym1pdDsgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH07XG5cbiAgICB0ZXh0YXJlYS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgdmFyIGNtID0gQ29kZU1pcnJvcihmdW5jdGlvbiAobm9kZSkgeyByZXR1cm4gdGV4dGFyZWEucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgdGV4dGFyZWEubmV4dFNpYmxpbmcpOyB9LFxuICAgICAgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNtXG4gIH1cblxuICBmdW5jdGlvbiBhZGRMZWdhY3lQcm9wcyhDb2RlTWlycm9yKSB7XG4gICAgQ29kZU1pcnJvci5vZmYgPSBvZmY7XG4gICAgQ29kZU1pcnJvci5vbiA9IG9uO1xuICAgIENvZGVNaXJyb3Iud2hlZWxFdmVudFBpeGVscyA9IHdoZWVsRXZlbnRQaXhlbHM7XG4gICAgQ29kZU1pcnJvci5Eb2MgPSBEb2M7XG4gICAgQ29kZU1pcnJvci5zcGxpdExpbmVzID0gc3BsaXRMaW5lc0F1dG87XG4gICAgQ29kZU1pcnJvci5jb3VudENvbHVtbiA9IGNvdW50Q29sdW1uO1xuICAgIENvZGVNaXJyb3IuZmluZENvbHVtbiA9IGZpbmRDb2x1bW47XG4gICAgQ29kZU1pcnJvci5pc1dvcmRDaGFyID0gaXNXb3JkQ2hhckJhc2ljO1xuICAgIENvZGVNaXJyb3IuUGFzcyA9IFBhc3M7XG4gICAgQ29kZU1pcnJvci5zaWduYWwgPSBzaWduYWw7XG4gICAgQ29kZU1pcnJvci5MaW5lID0gTGluZTtcbiAgICBDb2RlTWlycm9yLmNoYW5nZUVuZCA9IGNoYW5nZUVuZDtcbiAgICBDb2RlTWlycm9yLnNjcm9sbGJhck1vZGVsID0gc2Nyb2xsYmFyTW9kZWw7XG4gICAgQ29kZU1pcnJvci5Qb3MgPSBQb3M7XG4gICAgQ29kZU1pcnJvci5jbXBQb3MgPSBjbXA7XG4gICAgQ29kZU1pcnJvci5tb2RlcyA9IG1vZGVzO1xuICAgIENvZGVNaXJyb3IubWltZU1vZGVzID0gbWltZU1vZGVzO1xuICAgIENvZGVNaXJyb3IucmVzb2x2ZU1vZGUgPSByZXNvbHZlTW9kZTtcbiAgICBDb2RlTWlycm9yLmdldE1vZGUgPSBnZXRNb2RlO1xuICAgIENvZGVNaXJyb3IubW9kZUV4dGVuc2lvbnMgPSBtb2RlRXh0ZW5zaW9ucztcbiAgICBDb2RlTWlycm9yLmV4dGVuZE1vZGUgPSBleHRlbmRNb2RlO1xuICAgIENvZGVNaXJyb3IuY29weVN0YXRlID0gY29weVN0YXRlO1xuICAgIENvZGVNaXJyb3Iuc3RhcnRTdGF0ZSA9IHN0YXJ0U3RhdGU7XG4gICAgQ29kZU1pcnJvci5pbm5lck1vZGUgPSBpbm5lck1vZGU7XG4gICAgQ29kZU1pcnJvci5jb21tYW5kcyA9IGNvbW1hbmRzO1xuICAgIENvZGVNaXJyb3Iua2V5TWFwID0ga2V5TWFwO1xuICAgIENvZGVNaXJyb3Iua2V5TmFtZSA9IGtleU5hbWU7XG4gICAgQ29kZU1pcnJvci5pc01vZGlmaWVyS2V5ID0gaXNNb2RpZmllcktleTtcbiAgICBDb2RlTWlycm9yLmxvb2t1cEtleSA9IGxvb2t1cEtleTtcbiAgICBDb2RlTWlycm9yLm5vcm1hbGl6ZUtleU1hcCA9IG5vcm1hbGl6ZUtleU1hcDtcbiAgICBDb2RlTWlycm9yLlN0cmluZ1N0cmVhbSA9IFN0cmluZ1N0cmVhbTtcbiAgICBDb2RlTWlycm9yLlNoYXJlZFRleHRNYXJrZXIgPSBTaGFyZWRUZXh0TWFya2VyO1xuICAgIENvZGVNaXJyb3IuVGV4dE1hcmtlciA9IFRleHRNYXJrZXI7XG4gICAgQ29kZU1pcnJvci5MaW5lV2lkZ2V0ID0gTGluZVdpZGdldDtcbiAgICBDb2RlTWlycm9yLmVfcHJldmVudERlZmF1bHQgPSBlX3ByZXZlbnREZWZhdWx0O1xuICAgIENvZGVNaXJyb3IuZV9zdG9wUHJvcGFnYXRpb24gPSBlX3N0b3BQcm9wYWdhdGlvbjtcbiAgICBDb2RlTWlycm9yLmVfc3RvcCA9IGVfc3RvcDtcbiAgICBDb2RlTWlycm9yLmFkZENsYXNzID0gYWRkQ2xhc3M7XG4gICAgQ29kZU1pcnJvci5jb250YWlucyA9IGNvbnRhaW5zO1xuICAgIENvZGVNaXJyb3Iucm1DbGFzcyA9IHJtQ2xhc3M7XG4gICAgQ29kZU1pcnJvci5rZXlOYW1lcyA9IGtleU5hbWVzO1xuICB9XG5cbiAgLy8gRURJVE9SIENPTlNUUlVDVE9SXG5cbiAgZGVmaW5lT3B0aW9ucyhDb2RlTWlycm9yKTtcblxuICBhZGRFZGl0b3JNZXRob2RzKENvZGVNaXJyb3IpO1xuXG4gIC8vIFNldCB1cCBtZXRob2RzIG9uIENvZGVNaXJyb3IncyBwcm90b3R5cGUgdG8gcmVkaXJlY3QgdG8gdGhlIGVkaXRvcidzIGRvY3VtZW50LlxuICB2YXIgZG9udERlbGVnYXRlID0gXCJpdGVyIGluc2VydCByZW1vdmUgY29weSBnZXRFZGl0b3IgY29uc3RydWN0b3JcIi5zcGxpdChcIiBcIik7XG4gIGZvciAodmFyIHByb3AgaW4gRG9jLnByb3RvdHlwZSkgeyBpZiAoRG9jLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBpbmRleE9mKGRvbnREZWxlZ2F0ZSwgcHJvcCkgPCAwKVxuICAgIHsgQ29kZU1pcnJvci5wcm90b3R5cGVbcHJvcF0gPSAoZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7cmV0dXJuIG1ldGhvZC5hcHBseSh0aGlzLmRvYywgYXJndW1lbnRzKX1cbiAgICB9KShEb2MucHJvdG90eXBlW3Byb3BdKTsgfSB9XG5cbiAgZXZlbnRNaXhpbihEb2MpO1xuICBDb2RlTWlycm9yLmlucHV0U3R5bGVzID0ge1widGV4dGFyZWFcIjogVGV4dGFyZWFJbnB1dCwgXCJjb250ZW50ZWRpdGFibGVcIjogQ29udGVudEVkaXRhYmxlSW5wdXR9O1xuXG4gIC8vIEV4dHJhIGFyZ3VtZW50cyBhcmUgc3RvcmVkIGFzIHRoZSBtb2RlJ3MgZGVwZW5kZW5jaWVzLCB3aGljaCBpc1xuICAvLyB1c2VkIGJ5IChsZWdhY3kpIG1lY2hhbmlzbXMgbGlrZSBsb2FkbW9kZS5qcyB0byBhdXRvbWF0aWNhbGx5XG4gIC8vIGxvYWQgYSBtb2RlLiAoUHJlZmVycmVkIG1lY2hhbmlzbSBpcyB0aGUgcmVxdWlyZS9kZWZpbmUgY2FsbHMuKVxuICBDb2RlTWlycm9yLmRlZmluZU1vZGUgPSBmdW5jdGlvbihuYW1lLyosIG1vZGUsIOKApiovKSB7XG4gICAgaWYgKCFDb2RlTWlycm9yLmRlZmF1bHRzLm1vZGUgJiYgbmFtZSAhPSBcIm51bGxcIikgeyBDb2RlTWlycm9yLmRlZmF1bHRzLm1vZGUgPSBuYW1lOyB9XG4gICAgZGVmaW5lTW9kZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xuXG4gIENvZGVNaXJyb3IuZGVmaW5lTUlNRSA9IGRlZmluZU1JTUU7XG5cbiAgLy8gTWluaW1hbCBkZWZhdWx0IG1vZGUuXG4gIENvZGVNaXJyb3IuZGVmaW5lTW9kZShcIm51bGxcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gKHt0b2tlbjogZnVuY3Rpb24gKHN0cmVhbSkgeyByZXR1cm4gc3RyZWFtLnNraXBUb0VuZCgpOyB9fSk7IH0pO1xuICBDb2RlTWlycm9yLmRlZmluZU1JTUUoXCJ0ZXh0L3BsYWluXCIsIFwibnVsbFwiKTtcblxuICAvLyBFWFRFTlNJT05TXG5cbiAgQ29kZU1pcnJvci5kZWZpbmVFeHRlbnNpb24gPSBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xuICAgIENvZGVNaXJyb3IucHJvdG90eXBlW25hbWVdID0gZnVuYztcbiAgfTtcbiAgQ29kZU1pcnJvci5kZWZpbmVEb2NFeHRlbnNpb24gPSBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xuICAgIERvYy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jO1xuICB9O1xuXG4gIENvZGVNaXJyb3IuZnJvbVRleHRBcmVhID0gZnJvbVRleHRBcmVhO1xuXG4gIGFkZExlZ2FjeVByb3BzKENvZGVNaXJyb3IpO1xuXG4gIENvZGVNaXJyb3IudmVyc2lvbiA9IFwiNS41OS4yXCI7XG5cbiAgcmV0dXJuIENvZGVNaXJyb3I7XG5cbn0pKSk7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/js/codemirror.js\n");

/***/ }),

/***/ "./resources/sass/app.scss":
/*!*********************************!*\
  !*** ./resources/sass/app.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcz80OTEwIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSIsImZpbGUiOiIuL3Jlc291cmNlcy9zYXNzL2FwcC5zY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/sass/app.scss\n");

/***/ }),

/***/ "./resources/sass/codemirror.css":
/*!***************************************!*\
  !*** ./resources/sass/codemirror.css ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvc2Fzcy9jb2RlbWlycm9yLmNzcz8wNWM3Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSIsImZpbGUiOiIuL3Jlc291cmNlcy9zYXNzL2NvZGVtaXJyb3IuY3NzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/sass/codemirror.css\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// the startup function
/******/ 	// It's empty as some runtime module handles the default behavior
/******/ 	__webpack_require__.x = x => {};
/************************************************************************/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// Promise = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/codemirror": 0
/******/ 		};
/******/ 		
/******/ 		var deferredModules = [
/******/ 			["./resources/js/codemirror.js"],
/******/ 			["./resources/sass/app.scss"],
/******/ 			["./resources/sass/codemirror.css"]
/******/ 		];
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		var checkDeferredModules = x => {};
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime, executeModules] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0, resolves = [];
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					resolves.push(installedChunks[chunkId][0]);
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			for(moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			while(resolves.length) {
/******/ 				resolves.shift()();
/******/ 			}
/******/ 		
/******/ 			// add entry modules from loaded chunk to deferred list
/******/ 			if(executeModules) deferredModules.push.apply(deferredModules, executeModules);
/******/ 		
/******/ 			// run deferred modules when all chunks ready
/******/ 			return checkDeferredModules();
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 		
/******/ 		function checkDeferredModulesImpl() {
/******/ 			var result;
/******/ 			for(var i = 0; i < deferredModules.length; i++) {
/******/ 				var deferredModule = deferredModules[i];
/******/ 				var fulfilled = true;
/******/ 				for(var j = 1; j < deferredModule.length; j++) {
/******/ 					var depId = deferredModule[j];
/******/ 					if(installedChunks[depId] !== 0) fulfilled = false;
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferredModules.splice(i--, 1);
/******/ 					result = __webpack_require__(__webpack_require__.s = deferredModule[0]);
/******/ 				}
/******/ 			}
/******/ 			if(deferredModules.length === 0) {
/******/ 				__webpack_require__.x();
/******/ 				__webpack_require__.x = x => {};
/******/ 			}
/******/ 			return result;
/******/ 		}
/******/ 		var startup = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			// reset startup function so it can be called again when more startup code is added
/******/ 			__webpack_require__.x = startup || (x => {});
/******/ 			return (checkDeferredModules = checkDeferredModulesImpl)();
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	
/******/ })()
;